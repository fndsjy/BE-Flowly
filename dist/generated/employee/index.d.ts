
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model em_absensi
 * 
 */
export type em_absensi = $Result.DefaultSelection<Prisma.$em_absensiPayload>
/**
 * Model em_apc_academy
 * 
 */
export type em_apc_academy = $Result.DefaultSelection<Prisma.$em_apc_academyPayload>
/**
 * Model em_apc_personal
 * 
 */
export type em_apc_personal = $Result.DefaultSelection<Prisma.$em_apc_personalPayload>
/**
 * Model em_apc_photograph
 * 
 */
export type em_apc_photograph = $Result.DefaultSelection<Prisma.$em_apc_photographPayload>
/**
 * Model em_apc_regulation
 * 
 */
export type em_apc_regulation = $Result.DefaultSelection<Prisma.$em_apc_regulationPayload>
/**
 * Model em_apc_skill_exper
 * 
 */
export type em_apc_skill_exper = $Result.DefaultSelection<Prisma.$em_apc_skill_experPayload>
/**
 * Model em_api_keys
 * 
 */
export type em_api_keys = $Result.DefaultSelection<Prisma.$em_api_keysPayload>
/**
 * Model em_applicant_criteria
 * 
 */
export type em_applicant_criteria = $Result.DefaultSelection<Prisma.$em_applicant_criteriaPayload>
/**
 * Model em_applicant_match
 * 
 */
export type em_applicant_match = $Result.DefaultSelection<Prisma.$em_applicant_matchPayload>
/**
 * Model em_banner
 * 
 */
export type em_banner = $Result.DefaultSelection<Prisma.$em_bannerPayload>
/**
 * Model em_career_contact
 * 
 */
export type em_career_contact = $Result.DefaultSelection<Prisma.$em_career_contactPayload>
/**
 * Model em_certificate_fields
 * 
 */
export type em_certificate_fields = $Result.DefaultSelection<Prisma.$em_certificate_fieldsPayload>
/**
 * Model em_certificate_templates
 * 
 */
export type em_certificate_templates = $Result.DefaultSelection<Prisma.$em_certificate_templatesPayload>
/**
 * Model em_certificates_result
 * 
 */
export type em_certificates_result = $Result.DefaultSelection<Prisma.$em_certificates_resultPayload>
/**
 * Model em_chance
 * 
 */
export type em_chance = $Result.DefaultSelection<Prisma.$em_chancePayload>
/**
 * Model em_contrctype
 * 
 */
export type em_contrctype = $Result.DefaultSelection<Prisma.$em_contrctypePayload>
/**
 * Model em_dept
 * 
 */
export type em_dept = $Result.DefaultSelection<Prisma.$em_deptPayload>
/**
 * Model em_employee
 * 
 */
export type em_employee = $Result.DefaultSelection<Prisma.$em_employeePayload>
/**
 * Model em_event
 * 
 */
export type em_event = $Result.DefaultSelection<Prisma.$em_eventPayload>
/**
 * Model em_event_reg
 * 
 */
export type em_event_reg = $Result.DefaultSelection<Prisma.$em_event_regPayload>
/**
 * Model em_event2
 * 
 */
export type em_event2 = $Result.DefaultSelection<Prisma.$em_event2Payload>
/**
 * Model em_exam_questions
 * 
 */
export type em_exam_questions = $Result.DefaultSelection<Prisma.$em_exam_questionsPayload>
/**
 * Model em_exams
 * 
 */
export type em_exams = $Result.DefaultSelection<Prisma.$em_examsPayload>
/**
 * Model em_exams_monitor
 * 
 */
export type em_exams_monitor = $Result.DefaultSelection<Prisma.$em_exams_monitorPayload>
/**
 * Model em_exams_results
 * 
 */
export type em_exams_results = $Result.DefaultSelection<Prisma.$em_exams_resultsPayload>
/**
 * Model em_faq
 * 
 */
export type em_faq = $Result.DefaultSelection<Prisma.$em_faqPayload>
/**
 * Model em_faq_cat
 * 
 */
export type em_faq_cat = $Result.DefaultSelection<Prisma.$em_faq_catPayload>
/**
 * Model em_galeri_materi
 * 
 */
export type em_galeri_materi = $Result.DefaultSelection<Prisma.$em_galeri_materiPayload>
/**
 * Model em_group
 * 
 */
export type em_group = $Result.DefaultSelection<Prisma.$em_groupPayload>
/**
 * Model em_hero_section
 * 
 */
export type em_hero_section = $Result.DefaultSelection<Prisma.$em_hero_sectionPayload>
/**
 * Model em_jawaban_peserta
 * 
 */
export type em_jawaban_peserta = $Result.DefaultSelection<Prisma.$em_jawaban_pesertaPayload>
/**
 * Model em_jawaban_peserta_apc
 * 
 */
export type em_jawaban_peserta_apc = $Result.DefaultSelection<Prisma.$em_jawaban_peserta_apcPayload>
/**
 * Model em_jobfair
 * 
 */
export type em_jobfair = $Result.DefaultSelection<Prisma.$em_jobfairPayload>
/**
 * Model em_levelposs
 * 
 */
export type em_levelposs = $Result.DefaultSelection<Prisma.$em_levelpossPayload>
/**
 * Model em_logs
 * 
 */
export type em_logs = $Result.DefaultSelection<Prisma.$em_logsPayload>
/**
 * Model em_loker
 * 
 */
export type em_loker = $Result.DefaultSelection<Prisma.$em_lokerPayload>
/**
 * Model em_loktopik
 * 
 */
export type em_loktopik = $Result.DefaultSelection<Prisma.$em_loktopikPayload>
/**
 * Model em_materi_file
 * 
 */
export type em_materi_file = $Result.DefaultSelection<Prisma.$em_materi_filePayload>
/**
 * Model em_materi_kategori
 * 
 */
export type em_materi_kategori = $Result.DefaultSelection<Prisma.$em_materi_kategoriPayload>
/**
 * Model em_materi_type
 * 
 */
export type em_materi_type = $Result.DefaultSelection<Prisma.$em_materi_typePayload>
/**
 * Model em_materi1
 * 
 */
export type em_materi1 = $Result.DefaultSelection<Prisma.$em_materi1Payload>
/**
 * Model em_materi2
 * 
 */
export type em_materi2 = $Result.DefaultSelection<Prisma.$em_materi2Payload>
/**
 * Model em_menu
 * 
 */
export type em_menu = $Result.DefaultSelection<Prisma.$em_menuPayload>
/**
 * Model em_notifikasi
 * 
 */
export type em_notifikasi = $Result.DefaultSelection<Prisma.$em_notifikasiPayload>
/**
 * Model em_notifikasi_read
 * 
 */
export type em_notifikasi_read = $Result.DefaultSelection<Prisma.$em_notifikasi_readPayload>
/**
 * Model em_onboarding
 * 
 */
export type em_onboarding = $Result.DefaultSelection<Prisma.$em_onboardingPayload>
/**
 * Model em_pilar
 * 
 */
export type em_pilar = $Result.DefaultSelection<Prisma.$em_pilarPayload>
/**
 * Model em_profesi
 * 
 */
export type em_profesi = $Result.DefaultSelection<Prisma.$em_profesiPayload>
/**
 * Model em_questions1
 * 
 */
export type em_questions1 = $Result.DefaultSelection<Prisma.$em_questions1Payload>
/**
 * Model em_questions2
 * 
 */
export type em_questions2 = $Result.DefaultSelection<Prisma.$em_questions2Payload>
/**
 * Model em_questtype
 * 
 */
export type em_questtype = $Result.DefaultSelection<Prisma.$em_questtypePayload>
/**
 * Model em_regulations
 * 
 */
export type em_regulations = $Result.DefaultSelection<Prisma.$em_regulationsPayload>
/**
 * Model em_sbu
 * 
 */
export type em_sbu = $Result.DefaultSelection<Prisma.$em_sbuPayload>
/**
 * Model em_sbu_sub
 * 
 */
export type em_sbu_sub = $Result.DefaultSelection<Prisma.$em_sbu_subPayload>
/**
 * Model em_schedule1
 * 
 */
export type em_schedule1 = $Result.DefaultSelection<Prisma.$em_schedule1Payload>
/**
 * Model em_schedule2
 * 
 */
export type em_schedule2 = $Result.DefaultSelection<Prisma.$em_schedule2Payload>
/**
 * Model em_schedule3
 * 
 */
export type em_schedule3 = $Result.DefaultSelection<Prisma.$em_schedule3Payload>
/**
 * Model em_schedule4
 * 
 */
export type em_schedule4 = $Result.DefaultSelection<Prisma.$em_schedule4Payload>
/**
 * Model em_session_exams
 * 
 */
export type em_session_exams = $Result.DefaultSelection<Prisma.$em_session_examsPayload>
/**
 * Model em_session_exams_apc
 * 
 */
export type em_session_exams_apc = $Result.DefaultSelection<Prisma.$em_session_exams_apcPayload>
/**
 * Model em_subscribe
 * 
 */
export type em_subscribe = $Result.DefaultSelection<Prisma.$em_subscribePayload>
/**
 * Model em_subscription
 * 
 */
export type em_subscription = $Result.DefaultSelection<Prisma.$em_subscriptionPayload>
/**
 * Model em_topic_selesai
 * 
 */
export type em_topic_selesai = $Result.DefaultSelection<Prisma.$em_topic_selesaiPayload>
/**
 * Model em_user_answers1
 * 
 */
export type em_user_answers1 = $Result.DefaultSelection<Prisma.$em_user_answers1Payload>
/**
 * Model em_user_dashboard
 * 
 */
export type em_user_dashboard = $Result.DefaultSelection<Prisma.$em_user_dashboardPayload>
/**
 * Model em_user_list
 * 
 */
export type em_user_list = $Result.DefaultSelection<Prisma.$em_user_listPayload>
/**
 * Model em_users
 * 
 */
export type em_users = $Result.DefaultSelection<Prisma.$em_usersPayload>
/**
 * Model em_verify_links
 * 
 */
export type em_verify_links = $Result.DefaultSelection<Prisma.$em_verify_linksPayload>
/**
 * Model em_wa_templates
 * 
 */
export type em_wa_templates = $Result.DefaultSelection<Prisma.$em_wa_templatesPayload>
/**
 * Model em_worktype
 * 
 */
export type em_worktype = $Result.DefaultSelection<Prisma.$em_worktypePayload>
/**
 * Model em_xquetest
 * 
 */
export type em_xquetest = $Result.DefaultSelection<Prisma.$em_xquetestPayload>
/**
 * Model emapp
 * 
 */
export type emapp = $Result.DefaultSelection<Prisma.$emappPayload>
/**
 * Model empassw
 * 
 */
export type empassw = $Result.DefaultSelection<Prisma.$empasswPayload>
/**
 * Model emposs
 * 
 */
export type emposs = $Result.DefaultSelection<Prisma.$empossPayload>
/**
 * Model faceusers
 * 
 */
export type faceusers = $Result.DefaultSelection<Prisma.$faceusersPayload>
/**
 * Model menu
 * 
 */
export type menu = $Result.DefaultSelection<Prisma.$menuPayload>
/**
 * Model scores
 * 
 */
export type scores = $Result.DefaultSelection<Prisma.$scoresPayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Em_absensis
 * const em_absensis = await prisma.em_absensi.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Em_absensis
   * const em_absensis = await prisma.em_absensi.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.em_absensi`: Exposes CRUD operations for the **em_absensi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_absensis
    * const em_absensis = await prisma.em_absensi.findMany()
    * ```
    */
  get em_absensi(): Prisma.em_absensiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_apc_academy`: Exposes CRUD operations for the **em_apc_academy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_apc_academies
    * const em_apc_academies = await prisma.em_apc_academy.findMany()
    * ```
    */
  get em_apc_academy(): Prisma.em_apc_academyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_apc_personal`: Exposes CRUD operations for the **em_apc_personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_apc_personals
    * const em_apc_personals = await prisma.em_apc_personal.findMany()
    * ```
    */
  get em_apc_personal(): Prisma.em_apc_personalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_apc_photograph`: Exposes CRUD operations for the **em_apc_photograph** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_apc_photographs
    * const em_apc_photographs = await prisma.em_apc_photograph.findMany()
    * ```
    */
  get em_apc_photograph(): Prisma.em_apc_photographDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_apc_regulation`: Exposes CRUD operations for the **em_apc_regulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_apc_regulations
    * const em_apc_regulations = await prisma.em_apc_regulation.findMany()
    * ```
    */
  get em_apc_regulation(): Prisma.em_apc_regulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_apc_skill_exper`: Exposes CRUD operations for the **em_apc_skill_exper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_apc_skill_expers
    * const em_apc_skill_expers = await prisma.em_apc_skill_exper.findMany()
    * ```
    */
  get em_apc_skill_exper(): Prisma.em_apc_skill_experDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_api_keys`: Exposes CRUD operations for the **em_api_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_api_keys
    * const em_api_keys = await prisma.em_api_keys.findMany()
    * ```
    */
  get em_api_keys(): Prisma.em_api_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_applicant_criteria`: Exposes CRUD operations for the **em_applicant_criteria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_applicant_criteria
    * const em_applicant_criteria = await prisma.em_applicant_criteria.findMany()
    * ```
    */
  get em_applicant_criteria(): Prisma.em_applicant_criteriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_applicant_match`: Exposes CRUD operations for the **em_applicant_match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_applicant_matches
    * const em_applicant_matches = await prisma.em_applicant_match.findMany()
    * ```
    */
  get em_applicant_match(): Prisma.em_applicant_matchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_banner`: Exposes CRUD operations for the **em_banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_banners
    * const em_banners = await prisma.em_banner.findMany()
    * ```
    */
  get em_banner(): Prisma.em_bannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_career_contact`: Exposes CRUD operations for the **em_career_contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_career_contacts
    * const em_career_contacts = await prisma.em_career_contact.findMany()
    * ```
    */
  get em_career_contact(): Prisma.em_career_contactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_certificate_fields`: Exposes CRUD operations for the **em_certificate_fields** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_certificate_fields
    * const em_certificate_fields = await prisma.em_certificate_fields.findMany()
    * ```
    */
  get em_certificate_fields(): Prisma.em_certificate_fieldsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_certificate_templates`: Exposes CRUD operations for the **em_certificate_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_certificate_templates
    * const em_certificate_templates = await prisma.em_certificate_templates.findMany()
    * ```
    */
  get em_certificate_templates(): Prisma.em_certificate_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_certificates_result`: Exposes CRUD operations for the **em_certificates_result** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_certificates_results
    * const em_certificates_results = await prisma.em_certificates_result.findMany()
    * ```
    */
  get em_certificates_result(): Prisma.em_certificates_resultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_chance`: Exposes CRUD operations for the **em_chance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_chances
    * const em_chances = await prisma.em_chance.findMany()
    * ```
    */
  get em_chance(): Prisma.em_chanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_contrctype`: Exposes CRUD operations for the **em_contrctype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_contrctypes
    * const em_contrctypes = await prisma.em_contrctype.findMany()
    * ```
    */
  get em_contrctype(): Prisma.em_contrctypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_dept`: Exposes CRUD operations for the **em_dept** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_depts
    * const em_depts = await prisma.em_dept.findMany()
    * ```
    */
  get em_dept(): Prisma.em_deptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_employee`: Exposes CRUD operations for the **em_employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_employees
    * const em_employees = await prisma.em_employee.findMany()
    * ```
    */
  get em_employee(): Prisma.em_employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_event`: Exposes CRUD operations for the **em_event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_events
    * const em_events = await prisma.em_event.findMany()
    * ```
    */
  get em_event(): Prisma.em_eventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_event_reg`: Exposes CRUD operations for the **em_event_reg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_event_regs
    * const em_event_regs = await prisma.em_event_reg.findMany()
    * ```
    */
  get em_event_reg(): Prisma.em_event_regDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_event2`: Exposes CRUD operations for the **em_event2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_event2s
    * const em_event2s = await prisma.em_event2.findMany()
    * ```
    */
  get em_event2(): Prisma.em_event2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_exam_questions`: Exposes CRUD operations for the **em_exam_questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_exam_questions
    * const em_exam_questions = await prisma.em_exam_questions.findMany()
    * ```
    */
  get em_exam_questions(): Prisma.em_exam_questionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_exams`: Exposes CRUD operations for the **em_exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_exams
    * const em_exams = await prisma.em_exams.findMany()
    * ```
    */
  get em_exams(): Prisma.em_examsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_exams_monitor`: Exposes CRUD operations for the **em_exams_monitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_exams_monitors
    * const em_exams_monitors = await prisma.em_exams_monitor.findMany()
    * ```
    */
  get em_exams_monitor(): Prisma.em_exams_monitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_exams_results`: Exposes CRUD operations for the **em_exams_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_exams_results
    * const em_exams_results = await prisma.em_exams_results.findMany()
    * ```
    */
  get em_exams_results(): Prisma.em_exams_resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_faq`: Exposes CRUD operations for the **em_faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_faqs
    * const em_faqs = await prisma.em_faq.findMany()
    * ```
    */
  get em_faq(): Prisma.em_faqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_faq_cat`: Exposes CRUD operations for the **em_faq_cat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_faq_cats
    * const em_faq_cats = await prisma.em_faq_cat.findMany()
    * ```
    */
  get em_faq_cat(): Prisma.em_faq_catDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_galeri_materi`: Exposes CRUD operations for the **em_galeri_materi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_galeri_materis
    * const em_galeri_materis = await prisma.em_galeri_materi.findMany()
    * ```
    */
  get em_galeri_materi(): Prisma.em_galeri_materiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_group`: Exposes CRUD operations for the **em_group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_groups
    * const em_groups = await prisma.em_group.findMany()
    * ```
    */
  get em_group(): Prisma.em_groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_hero_section`: Exposes CRUD operations for the **em_hero_section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_hero_sections
    * const em_hero_sections = await prisma.em_hero_section.findMany()
    * ```
    */
  get em_hero_section(): Prisma.em_hero_sectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_jawaban_peserta`: Exposes CRUD operations for the **em_jawaban_peserta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_jawaban_pesertas
    * const em_jawaban_pesertas = await prisma.em_jawaban_peserta.findMany()
    * ```
    */
  get em_jawaban_peserta(): Prisma.em_jawaban_pesertaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_jawaban_peserta_apc`: Exposes CRUD operations for the **em_jawaban_peserta_apc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_jawaban_peserta_apcs
    * const em_jawaban_peserta_apcs = await prisma.em_jawaban_peserta_apc.findMany()
    * ```
    */
  get em_jawaban_peserta_apc(): Prisma.em_jawaban_peserta_apcDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_jobfair`: Exposes CRUD operations for the **em_jobfair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_jobfairs
    * const em_jobfairs = await prisma.em_jobfair.findMany()
    * ```
    */
  get em_jobfair(): Prisma.em_jobfairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_levelposs`: Exposes CRUD operations for the **em_levelposs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_levelposses
    * const em_levelposses = await prisma.em_levelposs.findMany()
    * ```
    */
  get em_levelposs(): Prisma.em_levelpossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_logs`: Exposes CRUD operations for the **em_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_logs
    * const em_logs = await prisma.em_logs.findMany()
    * ```
    */
  get em_logs(): Prisma.em_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_loker`: Exposes CRUD operations for the **em_loker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_lokers
    * const em_lokers = await prisma.em_loker.findMany()
    * ```
    */
  get em_loker(): Prisma.em_lokerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_loktopik`: Exposes CRUD operations for the **em_loktopik** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_loktopiks
    * const em_loktopiks = await prisma.em_loktopik.findMany()
    * ```
    */
  get em_loktopik(): Prisma.em_loktopikDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_materi_file`: Exposes CRUD operations for the **em_materi_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_materi_files
    * const em_materi_files = await prisma.em_materi_file.findMany()
    * ```
    */
  get em_materi_file(): Prisma.em_materi_fileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_materi_kategori`: Exposes CRUD operations for the **em_materi_kategori** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_materi_kategoris
    * const em_materi_kategoris = await prisma.em_materi_kategori.findMany()
    * ```
    */
  get em_materi_kategori(): Prisma.em_materi_kategoriDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_materi_type`: Exposes CRUD operations for the **em_materi_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_materi_types
    * const em_materi_types = await prisma.em_materi_type.findMany()
    * ```
    */
  get em_materi_type(): Prisma.em_materi_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_materi1`: Exposes CRUD operations for the **em_materi1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_materi1s
    * const em_materi1s = await prisma.em_materi1.findMany()
    * ```
    */
  get em_materi1(): Prisma.em_materi1Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_materi2`: Exposes CRUD operations for the **em_materi2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_materi2s
    * const em_materi2s = await prisma.em_materi2.findMany()
    * ```
    */
  get em_materi2(): Prisma.em_materi2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_menu`: Exposes CRUD operations for the **em_menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_menus
    * const em_menus = await prisma.em_menu.findMany()
    * ```
    */
  get em_menu(): Prisma.em_menuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_notifikasi`: Exposes CRUD operations for the **em_notifikasi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_notifikasis
    * const em_notifikasis = await prisma.em_notifikasi.findMany()
    * ```
    */
  get em_notifikasi(): Prisma.em_notifikasiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_notifikasi_read`: Exposes CRUD operations for the **em_notifikasi_read** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_notifikasi_reads
    * const em_notifikasi_reads = await prisma.em_notifikasi_read.findMany()
    * ```
    */
  get em_notifikasi_read(): Prisma.em_notifikasi_readDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_onboarding`: Exposes CRUD operations for the **em_onboarding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_onboardings
    * const em_onboardings = await prisma.em_onboarding.findMany()
    * ```
    */
  get em_onboarding(): Prisma.em_onboardingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_pilar`: Exposes CRUD operations for the **em_pilar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_pilars
    * const em_pilars = await prisma.em_pilar.findMany()
    * ```
    */
  get em_pilar(): Prisma.em_pilarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_profesi`: Exposes CRUD operations for the **em_profesi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_profesis
    * const em_profesis = await prisma.em_profesi.findMany()
    * ```
    */
  get em_profesi(): Prisma.em_profesiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_questions1`: Exposes CRUD operations for the **em_questions1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_questions1s
    * const em_questions1s = await prisma.em_questions1.findMany()
    * ```
    */
  get em_questions1(): Prisma.em_questions1Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_questions2`: Exposes CRUD operations for the **em_questions2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_questions2s
    * const em_questions2s = await prisma.em_questions2.findMany()
    * ```
    */
  get em_questions2(): Prisma.em_questions2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_questtype`: Exposes CRUD operations for the **em_questtype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_questtypes
    * const em_questtypes = await prisma.em_questtype.findMany()
    * ```
    */
  get em_questtype(): Prisma.em_questtypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_regulations`: Exposes CRUD operations for the **em_regulations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_regulations
    * const em_regulations = await prisma.em_regulations.findMany()
    * ```
    */
  get em_regulations(): Prisma.em_regulationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_sbu`: Exposes CRUD operations for the **em_sbu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_sbus
    * const em_sbus = await prisma.em_sbu.findMany()
    * ```
    */
  get em_sbu(): Prisma.em_sbuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_sbu_sub`: Exposes CRUD operations for the **em_sbu_sub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_sbu_subs
    * const em_sbu_subs = await prisma.em_sbu_sub.findMany()
    * ```
    */
  get em_sbu_sub(): Prisma.em_sbu_subDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_schedule1`: Exposes CRUD operations for the **em_schedule1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_schedule1s
    * const em_schedule1s = await prisma.em_schedule1.findMany()
    * ```
    */
  get em_schedule1(): Prisma.em_schedule1Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_schedule2`: Exposes CRUD operations for the **em_schedule2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_schedule2s
    * const em_schedule2s = await prisma.em_schedule2.findMany()
    * ```
    */
  get em_schedule2(): Prisma.em_schedule2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_schedule3`: Exposes CRUD operations for the **em_schedule3** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_schedule3s
    * const em_schedule3s = await prisma.em_schedule3.findMany()
    * ```
    */
  get em_schedule3(): Prisma.em_schedule3Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_schedule4`: Exposes CRUD operations for the **em_schedule4** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_schedule4s
    * const em_schedule4s = await prisma.em_schedule4.findMany()
    * ```
    */
  get em_schedule4(): Prisma.em_schedule4Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_session_exams`: Exposes CRUD operations for the **em_session_exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_session_exams
    * const em_session_exams = await prisma.em_session_exams.findMany()
    * ```
    */
  get em_session_exams(): Prisma.em_session_examsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_session_exams_apc`: Exposes CRUD operations for the **em_session_exams_apc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_session_exams_apcs
    * const em_session_exams_apcs = await prisma.em_session_exams_apc.findMany()
    * ```
    */
  get em_session_exams_apc(): Prisma.em_session_exams_apcDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_subscribe`: Exposes CRUD operations for the **em_subscribe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_subscribes
    * const em_subscribes = await prisma.em_subscribe.findMany()
    * ```
    */
  get em_subscribe(): Prisma.em_subscribeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_subscription`: Exposes CRUD operations for the **em_subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_subscriptions
    * const em_subscriptions = await prisma.em_subscription.findMany()
    * ```
    */
  get em_subscription(): Prisma.em_subscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_topic_selesai`: Exposes CRUD operations for the **em_topic_selesai** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_topic_selesais
    * const em_topic_selesais = await prisma.em_topic_selesai.findMany()
    * ```
    */
  get em_topic_selesai(): Prisma.em_topic_selesaiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_user_answers1`: Exposes CRUD operations for the **em_user_answers1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_user_answers1s
    * const em_user_answers1s = await prisma.em_user_answers1.findMany()
    * ```
    */
  get em_user_answers1(): Prisma.em_user_answers1Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_user_dashboard`: Exposes CRUD operations for the **em_user_dashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_user_dashboards
    * const em_user_dashboards = await prisma.em_user_dashboard.findMany()
    * ```
    */
  get em_user_dashboard(): Prisma.em_user_dashboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_user_list`: Exposes CRUD operations for the **em_user_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_user_lists
    * const em_user_lists = await prisma.em_user_list.findMany()
    * ```
    */
  get em_user_list(): Prisma.em_user_listDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_users`: Exposes CRUD operations for the **em_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_users
    * const em_users = await prisma.em_users.findMany()
    * ```
    */
  get em_users(): Prisma.em_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_verify_links`: Exposes CRUD operations for the **em_verify_links** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_verify_links
    * const em_verify_links = await prisma.em_verify_links.findMany()
    * ```
    */
  get em_verify_links(): Prisma.em_verify_linksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_wa_templates`: Exposes CRUD operations for the **em_wa_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_wa_templates
    * const em_wa_templates = await prisma.em_wa_templates.findMany()
    * ```
    */
  get em_wa_templates(): Prisma.em_wa_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_worktype`: Exposes CRUD operations for the **em_worktype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_worktypes
    * const em_worktypes = await prisma.em_worktype.findMany()
    * ```
    */
  get em_worktype(): Prisma.em_worktypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.em_xquetest`: Exposes CRUD operations for the **em_xquetest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Em_xquetests
    * const em_xquetests = await prisma.em_xquetest.findMany()
    * ```
    */
  get em_xquetest(): Prisma.em_xquetestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emapp`: Exposes CRUD operations for the **emapp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emapps
    * const emapps = await prisma.emapp.findMany()
    * ```
    */
  get emapp(): Prisma.emappDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.empassw`: Exposes CRUD operations for the **empassw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empassws
    * const empassws = await prisma.empassw.findMany()
    * ```
    */
  get empassw(): Prisma.empasswDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emposs`: Exposes CRUD operations for the **emposs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emposses
    * const emposses = await prisma.emposs.findMany()
    * ```
    */
  get emposs(): Prisma.empossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faceusers`: Exposes CRUD operations for the **faceusers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faceusers
    * const faceusers = await prisma.faceusers.findMany()
    * ```
    */
  get faceusers(): Prisma.faceusersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.menuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scores`: Exposes CRUD operations for the **scores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scores
    * const scores = await prisma.scores.findMany()
    * ```
    */
  get scores(): Prisma.scoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    em_absensi: 'em_absensi',
    em_apc_academy: 'em_apc_academy',
    em_apc_personal: 'em_apc_personal',
    em_apc_photograph: 'em_apc_photograph',
    em_apc_regulation: 'em_apc_regulation',
    em_apc_skill_exper: 'em_apc_skill_exper',
    em_api_keys: 'em_api_keys',
    em_applicant_criteria: 'em_applicant_criteria',
    em_applicant_match: 'em_applicant_match',
    em_banner: 'em_banner',
    em_career_contact: 'em_career_contact',
    em_certificate_fields: 'em_certificate_fields',
    em_certificate_templates: 'em_certificate_templates',
    em_certificates_result: 'em_certificates_result',
    em_chance: 'em_chance',
    em_contrctype: 'em_contrctype',
    em_dept: 'em_dept',
    em_employee: 'em_employee',
    em_event: 'em_event',
    em_event_reg: 'em_event_reg',
    em_event2: 'em_event2',
    em_exam_questions: 'em_exam_questions',
    em_exams: 'em_exams',
    em_exams_monitor: 'em_exams_monitor',
    em_exams_results: 'em_exams_results',
    em_faq: 'em_faq',
    em_faq_cat: 'em_faq_cat',
    em_galeri_materi: 'em_galeri_materi',
    em_group: 'em_group',
    em_hero_section: 'em_hero_section',
    em_jawaban_peserta: 'em_jawaban_peserta',
    em_jawaban_peserta_apc: 'em_jawaban_peserta_apc',
    em_jobfair: 'em_jobfair',
    em_levelposs: 'em_levelposs',
    em_logs: 'em_logs',
    em_loker: 'em_loker',
    em_loktopik: 'em_loktopik',
    em_materi_file: 'em_materi_file',
    em_materi_kategori: 'em_materi_kategori',
    em_materi_type: 'em_materi_type',
    em_materi1: 'em_materi1',
    em_materi2: 'em_materi2',
    em_menu: 'em_menu',
    em_notifikasi: 'em_notifikasi',
    em_notifikasi_read: 'em_notifikasi_read',
    em_onboarding: 'em_onboarding',
    em_pilar: 'em_pilar',
    em_profesi: 'em_profesi',
    em_questions1: 'em_questions1',
    em_questions2: 'em_questions2',
    em_questtype: 'em_questtype',
    em_regulations: 'em_regulations',
    em_sbu: 'em_sbu',
    em_sbu_sub: 'em_sbu_sub',
    em_schedule1: 'em_schedule1',
    em_schedule2: 'em_schedule2',
    em_schedule3: 'em_schedule3',
    em_schedule4: 'em_schedule4',
    em_session_exams: 'em_session_exams',
    em_session_exams_apc: 'em_session_exams_apc',
    em_subscribe: 'em_subscribe',
    em_subscription: 'em_subscription',
    em_topic_selesai: 'em_topic_selesai',
    em_user_answers1: 'em_user_answers1',
    em_user_dashboard: 'em_user_dashboard',
    em_user_list: 'em_user_list',
    em_users: 'em_users',
    em_verify_links: 'em_verify_links',
    em_wa_templates: 'em_wa_templates',
    em_worktype: 'em_worktype',
    em_xquetest: 'em_xquetest',
    emapp: 'emapp',
    empassw: 'empassw',
    emposs: 'emposs',
    faceusers: 'faceusers',
    menu: 'menu',
    scores: 'scores',
    sysdiagrams: 'sysdiagrams'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    employee?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "em_absensi" | "em_apc_academy" | "em_apc_personal" | "em_apc_photograph" | "em_apc_regulation" | "em_apc_skill_exper" | "em_api_keys" | "em_applicant_criteria" | "em_applicant_match" | "em_banner" | "em_career_contact" | "em_certificate_fields" | "em_certificate_templates" | "em_certificates_result" | "em_chance" | "em_contrctype" | "em_dept" | "em_employee" | "em_event" | "em_event_reg" | "em_event2" | "em_exam_questions" | "em_exams" | "em_exams_monitor" | "em_exams_results" | "em_faq" | "em_faq_cat" | "em_galeri_materi" | "em_group" | "em_hero_section" | "em_jawaban_peserta" | "em_jawaban_peserta_apc" | "em_jobfair" | "em_levelposs" | "em_logs" | "em_loker" | "em_loktopik" | "em_materi_file" | "em_materi_kategori" | "em_materi_type" | "em_materi1" | "em_materi2" | "em_menu" | "em_notifikasi" | "em_notifikasi_read" | "em_onboarding" | "em_pilar" | "em_profesi" | "em_questions1" | "em_questions2" | "em_questtype" | "em_regulations" | "em_sbu" | "em_sbu_sub" | "em_schedule1" | "em_schedule2" | "em_schedule3" | "em_schedule4" | "em_session_exams" | "em_session_exams_apc" | "em_subscribe" | "em_subscription" | "em_topic_selesai" | "em_user_answers1" | "em_user_dashboard" | "em_user_list" | "em_users" | "em_verify_links" | "em_wa_templates" | "em_worktype" | "em_xquetest" | "emapp" | "empassw" | "emposs" | "faceusers" | "menu" | "scores" | "sysdiagrams"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      em_absensi: {
        payload: Prisma.$em_absensiPayload<ExtArgs>
        fields: Prisma.em_absensiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_absensiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_absensiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>
          }
          findFirst: {
            args: Prisma.em_absensiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_absensiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>
          }
          findMany: {
            args: Prisma.em_absensiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>[]
          }
          create: {
            args: Prisma.em_absensiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>
          }
          createMany: {
            args: Prisma.em_absensiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_absensiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>
          }
          update: {
            args: Prisma.em_absensiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>
          }
          deleteMany: {
            args: Prisma.em_absensiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_absensiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_absensiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_absensiPayload>
          }
          aggregate: {
            args: Prisma.Em_absensiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_absensi>
          }
          groupBy: {
            args: Prisma.em_absensiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_absensiGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_absensiCountArgs<ExtArgs>
            result: $Utils.Optional<Em_absensiCountAggregateOutputType> | number
          }
        }
      }
      em_apc_academy: {
        payload: Prisma.$em_apc_academyPayload<ExtArgs>
        fields: Prisma.em_apc_academyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_apc_academyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_apc_academyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>
          }
          findFirst: {
            args: Prisma.em_apc_academyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_apc_academyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>
          }
          findMany: {
            args: Prisma.em_apc_academyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>[]
          }
          create: {
            args: Prisma.em_apc_academyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>
          }
          createMany: {
            args: Prisma.em_apc_academyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_apc_academyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>
          }
          update: {
            args: Prisma.em_apc_academyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>
          }
          deleteMany: {
            args: Prisma.em_apc_academyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_apc_academyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_apc_academyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_academyPayload>
          }
          aggregate: {
            args: Prisma.Em_apc_academyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_apc_academy>
          }
          groupBy: {
            args: Prisma.em_apc_academyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_academyGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_apc_academyCountArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_academyCountAggregateOutputType> | number
          }
        }
      }
      em_apc_personal: {
        payload: Prisma.$em_apc_personalPayload<ExtArgs>
        fields: Prisma.em_apc_personalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_apc_personalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_apc_personalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>
          }
          findFirst: {
            args: Prisma.em_apc_personalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_apc_personalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>
          }
          findMany: {
            args: Prisma.em_apc_personalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>[]
          }
          create: {
            args: Prisma.em_apc_personalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>
          }
          createMany: {
            args: Prisma.em_apc_personalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_apc_personalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>
          }
          update: {
            args: Prisma.em_apc_personalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>
          }
          deleteMany: {
            args: Prisma.em_apc_personalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_apc_personalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_apc_personalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_personalPayload>
          }
          aggregate: {
            args: Prisma.Em_apc_personalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_apc_personal>
          }
          groupBy: {
            args: Prisma.em_apc_personalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_personalGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_apc_personalCountArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_personalCountAggregateOutputType> | number
          }
        }
      }
      em_apc_photograph: {
        payload: Prisma.$em_apc_photographPayload<ExtArgs>
        fields: Prisma.em_apc_photographFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_apc_photographFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_apc_photographFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>
          }
          findFirst: {
            args: Prisma.em_apc_photographFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_apc_photographFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>
          }
          findMany: {
            args: Prisma.em_apc_photographFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>[]
          }
          create: {
            args: Prisma.em_apc_photographCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>
          }
          createMany: {
            args: Prisma.em_apc_photographCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_apc_photographDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>
          }
          update: {
            args: Prisma.em_apc_photographUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>
          }
          deleteMany: {
            args: Prisma.em_apc_photographDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_apc_photographUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_apc_photographUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_photographPayload>
          }
          aggregate: {
            args: Prisma.Em_apc_photographAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_apc_photograph>
          }
          groupBy: {
            args: Prisma.em_apc_photographGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_photographGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_apc_photographCountArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_photographCountAggregateOutputType> | number
          }
        }
      }
      em_apc_regulation: {
        payload: Prisma.$em_apc_regulationPayload<ExtArgs>
        fields: Prisma.em_apc_regulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_apc_regulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_apc_regulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>
          }
          findFirst: {
            args: Prisma.em_apc_regulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_apc_regulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>
          }
          findMany: {
            args: Prisma.em_apc_regulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>[]
          }
          create: {
            args: Prisma.em_apc_regulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>
          }
          createMany: {
            args: Prisma.em_apc_regulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_apc_regulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>
          }
          update: {
            args: Prisma.em_apc_regulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>
          }
          deleteMany: {
            args: Prisma.em_apc_regulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_apc_regulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_apc_regulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_regulationPayload>
          }
          aggregate: {
            args: Prisma.Em_apc_regulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_apc_regulation>
          }
          groupBy: {
            args: Prisma.em_apc_regulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_regulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_apc_regulationCountArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_regulationCountAggregateOutputType> | number
          }
        }
      }
      em_apc_skill_exper: {
        payload: Prisma.$em_apc_skill_experPayload<ExtArgs>
        fields: Prisma.em_apc_skill_experFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_apc_skill_experFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_apc_skill_experFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>
          }
          findFirst: {
            args: Prisma.em_apc_skill_experFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_apc_skill_experFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>
          }
          findMany: {
            args: Prisma.em_apc_skill_experFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>[]
          }
          create: {
            args: Prisma.em_apc_skill_experCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>
          }
          createMany: {
            args: Prisma.em_apc_skill_experCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_apc_skill_experDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>
          }
          update: {
            args: Prisma.em_apc_skill_experUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>
          }
          deleteMany: {
            args: Prisma.em_apc_skill_experDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_apc_skill_experUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_apc_skill_experUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_apc_skill_experPayload>
          }
          aggregate: {
            args: Prisma.Em_apc_skill_experAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_apc_skill_exper>
          }
          groupBy: {
            args: Prisma.em_apc_skill_experGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_skill_experGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_apc_skill_experCountArgs<ExtArgs>
            result: $Utils.Optional<Em_apc_skill_experCountAggregateOutputType> | number
          }
        }
      }
      em_api_keys: {
        payload: Prisma.$em_api_keysPayload<ExtArgs>
        fields: Prisma.em_api_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_api_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_api_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>
          }
          findFirst: {
            args: Prisma.em_api_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_api_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>
          }
          findMany: {
            args: Prisma.em_api_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>[]
          }
          create: {
            args: Prisma.em_api_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>
          }
          createMany: {
            args: Prisma.em_api_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_api_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>
          }
          update: {
            args: Prisma.em_api_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>
          }
          deleteMany: {
            args: Prisma.em_api_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_api_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_api_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_api_keysPayload>
          }
          aggregate: {
            args: Prisma.Em_api_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_api_keys>
          }
          groupBy: {
            args: Prisma.em_api_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_api_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_api_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Em_api_keysCountAggregateOutputType> | number
          }
        }
      }
      em_applicant_criteria: {
        payload: Prisma.$em_applicant_criteriaPayload<ExtArgs>
        fields: Prisma.em_applicant_criteriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_applicant_criteriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_applicant_criteriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>
          }
          findFirst: {
            args: Prisma.em_applicant_criteriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_applicant_criteriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>
          }
          findMany: {
            args: Prisma.em_applicant_criteriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>[]
          }
          create: {
            args: Prisma.em_applicant_criteriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>
          }
          createMany: {
            args: Prisma.em_applicant_criteriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_applicant_criteriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>
          }
          update: {
            args: Prisma.em_applicant_criteriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>
          }
          deleteMany: {
            args: Prisma.em_applicant_criteriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_applicant_criteriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_applicant_criteriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_criteriaPayload>
          }
          aggregate: {
            args: Prisma.Em_applicant_criteriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_applicant_criteria>
          }
          groupBy: {
            args: Prisma.em_applicant_criteriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_applicant_criteriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_applicant_criteriaCountArgs<ExtArgs>
            result: $Utils.Optional<Em_applicant_criteriaCountAggregateOutputType> | number
          }
        }
      }
      em_applicant_match: {
        payload: Prisma.$em_applicant_matchPayload<ExtArgs>
        fields: Prisma.em_applicant_matchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_applicant_matchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_applicant_matchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>
          }
          findFirst: {
            args: Prisma.em_applicant_matchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_applicant_matchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>
          }
          findMany: {
            args: Prisma.em_applicant_matchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>[]
          }
          create: {
            args: Prisma.em_applicant_matchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>
          }
          createMany: {
            args: Prisma.em_applicant_matchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_applicant_matchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>
          }
          update: {
            args: Prisma.em_applicant_matchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>
          }
          deleteMany: {
            args: Prisma.em_applicant_matchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_applicant_matchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_applicant_matchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_applicant_matchPayload>
          }
          aggregate: {
            args: Prisma.Em_applicant_matchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_applicant_match>
          }
          groupBy: {
            args: Prisma.em_applicant_matchGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_applicant_matchGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_applicant_matchCountArgs<ExtArgs>
            result: $Utils.Optional<Em_applicant_matchCountAggregateOutputType> | number
          }
        }
      }
      em_banner: {
        payload: Prisma.$em_bannerPayload<ExtArgs>
        fields: Prisma.em_bannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_bannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_bannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>
          }
          findFirst: {
            args: Prisma.em_bannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_bannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>
          }
          findMany: {
            args: Prisma.em_bannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>[]
          }
          create: {
            args: Prisma.em_bannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>
          }
          createMany: {
            args: Prisma.em_bannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_bannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>
          }
          update: {
            args: Prisma.em_bannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>
          }
          deleteMany: {
            args: Prisma.em_bannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_bannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_bannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_bannerPayload>
          }
          aggregate: {
            args: Prisma.Em_bannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_banner>
          }
          groupBy: {
            args: Prisma.em_bannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_bannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_bannerCountArgs<ExtArgs>
            result: $Utils.Optional<Em_bannerCountAggregateOutputType> | number
          }
        }
      }
      em_career_contact: {
        payload: Prisma.$em_career_contactPayload<ExtArgs>
        fields: Prisma.em_career_contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_career_contactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_career_contactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>
          }
          findFirst: {
            args: Prisma.em_career_contactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_career_contactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>
          }
          findMany: {
            args: Prisma.em_career_contactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>[]
          }
          create: {
            args: Prisma.em_career_contactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>
          }
          createMany: {
            args: Prisma.em_career_contactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_career_contactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>
          }
          update: {
            args: Prisma.em_career_contactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>
          }
          deleteMany: {
            args: Prisma.em_career_contactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_career_contactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_career_contactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_career_contactPayload>
          }
          aggregate: {
            args: Prisma.Em_career_contactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_career_contact>
          }
          groupBy: {
            args: Prisma.em_career_contactGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_career_contactGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_career_contactCountArgs<ExtArgs>
            result: $Utils.Optional<Em_career_contactCountAggregateOutputType> | number
          }
        }
      }
      em_certificate_fields: {
        payload: Prisma.$em_certificate_fieldsPayload<ExtArgs>
        fields: Prisma.em_certificate_fieldsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_certificate_fieldsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_certificate_fieldsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>
          }
          findFirst: {
            args: Prisma.em_certificate_fieldsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_certificate_fieldsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>
          }
          findMany: {
            args: Prisma.em_certificate_fieldsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>[]
          }
          create: {
            args: Prisma.em_certificate_fieldsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>
          }
          createMany: {
            args: Prisma.em_certificate_fieldsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_certificate_fieldsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>
          }
          update: {
            args: Prisma.em_certificate_fieldsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>
          }
          deleteMany: {
            args: Prisma.em_certificate_fieldsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_certificate_fieldsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_certificate_fieldsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_fieldsPayload>
          }
          aggregate: {
            args: Prisma.Em_certificate_fieldsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_certificate_fields>
          }
          groupBy: {
            args: Prisma.em_certificate_fieldsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_certificate_fieldsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_certificate_fieldsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_certificate_fieldsCountAggregateOutputType> | number
          }
        }
      }
      em_certificate_templates: {
        payload: Prisma.$em_certificate_templatesPayload<ExtArgs>
        fields: Prisma.em_certificate_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_certificate_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_certificate_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>
          }
          findFirst: {
            args: Prisma.em_certificate_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_certificate_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>
          }
          findMany: {
            args: Prisma.em_certificate_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>[]
          }
          create: {
            args: Prisma.em_certificate_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>
          }
          createMany: {
            args: Prisma.em_certificate_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_certificate_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>
          }
          update: {
            args: Prisma.em_certificate_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>
          }
          deleteMany: {
            args: Prisma.em_certificate_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_certificate_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_certificate_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificate_templatesPayload>
          }
          aggregate: {
            args: Prisma.Em_certificate_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_certificate_templates>
          }
          groupBy: {
            args: Prisma.em_certificate_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_certificate_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_certificate_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Em_certificate_templatesCountAggregateOutputType> | number
          }
        }
      }
      em_certificates_result: {
        payload: Prisma.$em_certificates_resultPayload<ExtArgs>
        fields: Prisma.em_certificates_resultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_certificates_resultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_certificates_resultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>
          }
          findFirst: {
            args: Prisma.em_certificates_resultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_certificates_resultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>
          }
          findMany: {
            args: Prisma.em_certificates_resultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>[]
          }
          create: {
            args: Prisma.em_certificates_resultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>
          }
          createMany: {
            args: Prisma.em_certificates_resultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_certificates_resultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>
          }
          update: {
            args: Prisma.em_certificates_resultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>
          }
          deleteMany: {
            args: Prisma.em_certificates_resultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_certificates_resultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_certificates_resultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_certificates_resultPayload>
          }
          aggregate: {
            args: Prisma.Em_certificates_resultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_certificates_result>
          }
          groupBy: {
            args: Prisma.em_certificates_resultGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_certificates_resultGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_certificates_resultCountArgs<ExtArgs>
            result: $Utils.Optional<Em_certificates_resultCountAggregateOutputType> | number
          }
        }
      }
      em_chance: {
        payload: Prisma.$em_chancePayload<ExtArgs>
        fields: Prisma.em_chanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_chanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_chanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>
          }
          findFirst: {
            args: Prisma.em_chanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_chanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>
          }
          findMany: {
            args: Prisma.em_chanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>[]
          }
          create: {
            args: Prisma.em_chanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>
          }
          createMany: {
            args: Prisma.em_chanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_chanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>
          }
          update: {
            args: Prisma.em_chanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>
          }
          deleteMany: {
            args: Prisma.em_chanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_chanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_chanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_chancePayload>
          }
          aggregate: {
            args: Prisma.Em_chanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_chance>
          }
          groupBy: {
            args: Prisma.em_chanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_chanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_chanceCountArgs<ExtArgs>
            result: $Utils.Optional<Em_chanceCountAggregateOutputType> | number
          }
        }
      }
      em_contrctype: {
        payload: Prisma.$em_contrctypePayload<ExtArgs>
        fields: Prisma.em_contrctypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_contrctypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_contrctypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>
          }
          findFirst: {
            args: Prisma.em_contrctypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_contrctypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>
          }
          findMany: {
            args: Prisma.em_contrctypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>[]
          }
          create: {
            args: Prisma.em_contrctypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>
          }
          createMany: {
            args: Prisma.em_contrctypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_contrctypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>
          }
          update: {
            args: Prisma.em_contrctypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>
          }
          deleteMany: {
            args: Prisma.em_contrctypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_contrctypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_contrctypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_contrctypePayload>
          }
          aggregate: {
            args: Prisma.Em_contrctypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_contrctype>
          }
          groupBy: {
            args: Prisma.em_contrctypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_contrctypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_contrctypeCountArgs<ExtArgs>
            result: $Utils.Optional<Em_contrctypeCountAggregateOutputType> | number
          }
        }
      }
      em_dept: {
        payload: Prisma.$em_deptPayload<ExtArgs>
        fields: Prisma.em_deptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_deptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_deptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>
          }
          findFirst: {
            args: Prisma.em_deptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_deptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>
          }
          findMany: {
            args: Prisma.em_deptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>[]
          }
          create: {
            args: Prisma.em_deptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>
          }
          createMany: {
            args: Prisma.em_deptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_deptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>
          }
          update: {
            args: Prisma.em_deptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>
          }
          deleteMany: {
            args: Prisma.em_deptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_deptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_deptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_deptPayload>
          }
          aggregate: {
            args: Prisma.Em_deptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_dept>
          }
          groupBy: {
            args: Prisma.em_deptGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_deptGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_deptCountArgs<ExtArgs>
            result: $Utils.Optional<Em_deptCountAggregateOutputType> | number
          }
        }
      }
      em_employee: {
        payload: Prisma.$em_employeePayload<ExtArgs>
        fields: Prisma.em_employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>
          }
          findFirst: {
            args: Prisma.em_employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>
          }
          findMany: {
            args: Prisma.em_employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>[]
          }
          create: {
            args: Prisma.em_employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>
          }
          createMany: {
            args: Prisma.em_employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>
          }
          update: {
            args: Prisma.em_employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>
          }
          deleteMany: {
            args: Prisma.em_employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_employeePayload>
          }
          aggregate: {
            args: Prisma.Em_employeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_employee>
          }
          groupBy: {
            args: Prisma.em_employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_employeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_employeeCountArgs<ExtArgs>
            result: $Utils.Optional<Em_employeeCountAggregateOutputType> | number
          }
        }
      }
      em_event: {
        payload: Prisma.$em_eventPayload<ExtArgs>
        fields: Prisma.em_eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>
          }
          findFirst: {
            args: Prisma.em_eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>
          }
          findMany: {
            args: Prisma.em_eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>[]
          }
          create: {
            args: Prisma.em_eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>
          }
          createMany: {
            args: Prisma.em_eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>
          }
          update: {
            args: Prisma.em_eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>
          }
          deleteMany: {
            args: Prisma.em_eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_eventPayload>
          }
          aggregate: {
            args: Prisma.Em_eventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_event>
          }
          groupBy: {
            args: Prisma.em_eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_eventGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_eventCountArgs<ExtArgs>
            result: $Utils.Optional<Em_eventCountAggregateOutputType> | number
          }
        }
      }
      em_event_reg: {
        payload: Prisma.$em_event_regPayload<ExtArgs>
        fields: Prisma.em_event_regFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_event_regFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_event_regFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>
          }
          findFirst: {
            args: Prisma.em_event_regFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_event_regFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>
          }
          findMany: {
            args: Prisma.em_event_regFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>[]
          }
          create: {
            args: Prisma.em_event_regCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>
          }
          createMany: {
            args: Prisma.em_event_regCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_event_regDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>
          }
          update: {
            args: Prisma.em_event_regUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>
          }
          deleteMany: {
            args: Prisma.em_event_regDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_event_regUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_event_regUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event_regPayload>
          }
          aggregate: {
            args: Prisma.Em_event_regAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_event_reg>
          }
          groupBy: {
            args: Prisma.em_event_regGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_event_regGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_event_regCountArgs<ExtArgs>
            result: $Utils.Optional<Em_event_regCountAggregateOutputType> | number
          }
        }
      }
      em_event2: {
        payload: Prisma.$em_event2Payload<ExtArgs>
        fields: Prisma.em_event2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_event2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_event2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>
          }
          findFirst: {
            args: Prisma.em_event2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_event2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>
          }
          findMany: {
            args: Prisma.em_event2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>[]
          }
          create: {
            args: Prisma.em_event2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>
          }
          createMany: {
            args: Prisma.em_event2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_event2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>
          }
          update: {
            args: Prisma.em_event2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>
          }
          deleteMany: {
            args: Prisma.em_event2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_event2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_event2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_event2Payload>
          }
          aggregate: {
            args: Prisma.Em_event2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_event2>
          }
          groupBy: {
            args: Prisma.em_event2GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_event2GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_event2CountArgs<ExtArgs>
            result: $Utils.Optional<Em_event2CountAggregateOutputType> | number
          }
        }
      }
      em_exam_questions: {
        payload: Prisma.$em_exam_questionsPayload<ExtArgs>
        fields: Prisma.em_exam_questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_exam_questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_exam_questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>
          }
          findFirst: {
            args: Prisma.em_exam_questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_exam_questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>
          }
          findMany: {
            args: Prisma.em_exam_questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>[]
          }
          create: {
            args: Prisma.em_exam_questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>
          }
          createMany: {
            args: Prisma.em_exam_questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_exam_questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>
          }
          update: {
            args: Prisma.em_exam_questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>
          }
          deleteMany: {
            args: Prisma.em_exam_questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_exam_questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_exam_questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exam_questionsPayload>
          }
          aggregate: {
            args: Prisma.Em_exam_questionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_exam_questions>
          }
          groupBy: {
            args: Prisma.em_exam_questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_exam_questionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_exam_questionsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_exam_questionsCountAggregateOutputType> | number
          }
        }
      }
      em_exams: {
        payload: Prisma.$em_examsPayload<ExtArgs>
        fields: Prisma.em_examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>
          }
          findFirst: {
            args: Prisma.em_examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>
          }
          findMany: {
            args: Prisma.em_examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>[]
          }
          create: {
            args: Prisma.em_examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>
          }
          createMany: {
            args: Prisma.em_examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>
          }
          update: {
            args: Prisma.em_examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>
          }
          deleteMany: {
            args: Prisma.em_examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_examsPayload>
          }
          aggregate: {
            args: Prisma.Em_examsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_exams>
          }
          groupBy: {
            args: Prisma.em_examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_examsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_examsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_examsCountAggregateOutputType> | number
          }
        }
      }
      em_exams_monitor: {
        payload: Prisma.$em_exams_monitorPayload<ExtArgs>
        fields: Prisma.em_exams_monitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_exams_monitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_exams_monitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>
          }
          findFirst: {
            args: Prisma.em_exams_monitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_exams_monitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>
          }
          findMany: {
            args: Prisma.em_exams_monitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>[]
          }
          create: {
            args: Prisma.em_exams_monitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>
          }
          createMany: {
            args: Prisma.em_exams_monitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_exams_monitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>
          }
          update: {
            args: Prisma.em_exams_monitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>
          }
          deleteMany: {
            args: Prisma.em_exams_monitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_exams_monitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_exams_monitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_monitorPayload>
          }
          aggregate: {
            args: Prisma.Em_exams_monitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_exams_monitor>
          }
          groupBy: {
            args: Prisma.em_exams_monitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_exams_monitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_exams_monitorCountArgs<ExtArgs>
            result: $Utils.Optional<Em_exams_monitorCountAggregateOutputType> | number
          }
        }
      }
      em_exams_results: {
        payload: Prisma.$em_exams_resultsPayload<ExtArgs>
        fields: Prisma.em_exams_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_exams_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_exams_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>
          }
          findFirst: {
            args: Prisma.em_exams_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_exams_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>
          }
          findMany: {
            args: Prisma.em_exams_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>[]
          }
          create: {
            args: Prisma.em_exams_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>
          }
          createMany: {
            args: Prisma.em_exams_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_exams_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>
          }
          update: {
            args: Prisma.em_exams_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>
          }
          deleteMany: {
            args: Prisma.em_exams_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_exams_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_exams_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_exams_resultsPayload>
          }
          aggregate: {
            args: Prisma.Em_exams_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_exams_results>
          }
          groupBy: {
            args: Prisma.em_exams_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_exams_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_exams_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_exams_resultsCountAggregateOutputType> | number
          }
        }
      }
      em_faq: {
        payload: Prisma.$em_faqPayload<ExtArgs>
        fields: Prisma.em_faqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_faqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_faqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>
          }
          findFirst: {
            args: Prisma.em_faqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_faqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>
          }
          findMany: {
            args: Prisma.em_faqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>[]
          }
          create: {
            args: Prisma.em_faqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>
          }
          createMany: {
            args: Prisma.em_faqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_faqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>
          }
          update: {
            args: Prisma.em_faqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>
          }
          deleteMany: {
            args: Prisma.em_faqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_faqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_faqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faqPayload>
          }
          aggregate: {
            args: Prisma.Em_faqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_faq>
          }
          groupBy: {
            args: Prisma.em_faqGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_faqGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_faqCountArgs<ExtArgs>
            result: $Utils.Optional<Em_faqCountAggregateOutputType> | number
          }
        }
      }
      em_faq_cat: {
        payload: Prisma.$em_faq_catPayload<ExtArgs>
        fields: Prisma.em_faq_catFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_faq_catFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_faq_catFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>
          }
          findFirst: {
            args: Prisma.em_faq_catFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_faq_catFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>
          }
          findMany: {
            args: Prisma.em_faq_catFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>[]
          }
          create: {
            args: Prisma.em_faq_catCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>
          }
          createMany: {
            args: Prisma.em_faq_catCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_faq_catDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>
          }
          update: {
            args: Prisma.em_faq_catUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>
          }
          deleteMany: {
            args: Prisma.em_faq_catDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_faq_catUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_faq_catUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_faq_catPayload>
          }
          aggregate: {
            args: Prisma.Em_faq_catAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_faq_cat>
          }
          groupBy: {
            args: Prisma.em_faq_catGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_faq_catGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_faq_catCountArgs<ExtArgs>
            result: $Utils.Optional<Em_faq_catCountAggregateOutputType> | number
          }
        }
      }
      em_galeri_materi: {
        payload: Prisma.$em_galeri_materiPayload<ExtArgs>
        fields: Prisma.em_galeri_materiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_galeri_materiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_galeri_materiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>
          }
          findFirst: {
            args: Prisma.em_galeri_materiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_galeri_materiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>
          }
          findMany: {
            args: Prisma.em_galeri_materiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>[]
          }
          create: {
            args: Prisma.em_galeri_materiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>
          }
          createMany: {
            args: Prisma.em_galeri_materiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_galeri_materiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>
          }
          update: {
            args: Prisma.em_galeri_materiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>
          }
          deleteMany: {
            args: Prisma.em_galeri_materiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_galeri_materiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_galeri_materiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_galeri_materiPayload>
          }
          aggregate: {
            args: Prisma.Em_galeri_materiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_galeri_materi>
          }
          groupBy: {
            args: Prisma.em_galeri_materiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_galeri_materiGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_galeri_materiCountArgs<ExtArgs>
            result: $Utils.Optional<Em_galeri_materiCountAggregateOutputType> | number
          }
        }
      }
      em_group: {
        payload: Prisma.$em_groupPayload<ExtArgs>
        fields: Prisma.em_groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>
          }
          findFirst: {
            args: Prisma.em_groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>
          }
          findMany: {
            args: Prisma.em_groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>[]
          }
          create: {
            args: Prisma.em_groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>
          }
          createMany: {
            args: Prisma.em_groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>
          }
          update: {
            args: Prisma.em_groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>
          }
          deleteMany: {
            args: Prisma.em_groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_groupPayload>
          }
          aggregate: {
            args: Prisma.Em_groupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_group>
          }
          groupBy: {
            args: Prisma.em_groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_groupGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_groupCountArgs<ExtArgs>
            result: $Utils.Optional<Em_groupCountAggregateOutputType> | number
          }
        }
      }
      em_hero_section: {
        payload: Prisma.$em_hero_sectionPayload<ExtArgs>
        fields: Prisma.em_hero_sectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_hero_sectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_hero_sectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>
          }
          findFirst: {
            args: Prisma.em_hero_sectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_hero_sectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>
          }
          findMany: {
            args: Prisma.em_hero_sectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>[]
          }
          create: {
            args: Prisma.em_hero_sectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>
          }
          createMany: {
            args: Prisma.em_hero_sectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_hero_sectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>
          }
          update: {
            args: Prisma.em_hero_sectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>
          }
          deleteMany: {
            args: Prisma.em_hero_sectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_hero_sectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_hero_sectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_hero_sectionPayload>
          }
          aggregate: {
            args: Prisma.Em_hero_sectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_hero_section>
          }
          groupBy: {
            args: Prisma.em_hero_sectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_hero_sectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_hero_sectionCountArgs<ExtArgs>
            result: $Utils.Optional<Em_hero_sectionCountAggregateOutputType> | number
          }
        }
      }
      em_jawaban_peserta: {
        payload: Prisma.$em_jawaban_pesertaPayload<ExtArgs>
        fields: Prisma.em_jawaban_pesertaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_jawaban_pesertaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_jawaban_pesertaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>
          }
          findFirst: {
            args: Prisma.em_jawaban_pesertaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_jawaban_pesertaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>
          }
          findMany: {
            args: Prisma.em_jawaban_pesertaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>[]
          }
          create: {
            args: Prisma.em_jawaban_pesertaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>
          }
          createMany: {
            args: Prisma.em_jawaban_pesertaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_jawaban_pesertaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>
          }
          update: {
            args: Prisma.em_jawaban_pesertaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>
          }
          deleteMany: {
            args: Prisma.em_jawaban_pesertaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_jawaban_pesertaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_jawaban_pesertaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_pesertaPayload>
          }
          aggregate: {
            args: Prisma.Em_jawaban_pesertaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_jawaban_peserta>
          }
          groupBy: {
            args: Prisma.em_jawaban_pesertaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_jawaban_pesertaGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_jawaban_pesertaCountArgs<ExtArgs>
            result: $Utils.Optional<Em_jawaban_pesertaCountAggregateOutputType> | number
          }
        }
      }
      em_jawaban_peserta_apc: {
        payload: Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>
        fields: Prisma.em_jawaban_peserta_apcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_jawaban_peserta_apcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_jawaban_peserta_apcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>
          }
          findFirst: {
            args: Prisma.em_jawaban_peserta_apcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_jawaban_peserta_apcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>
          }
          findMany: {
            args: Prisma.em_jawaban_peserta_apcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>[]
          }
          create: {
            args: Prisma.em_jawaban_peserta_apcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>
          }
          createMany: {
            args: Prisma.em_jawaban_peserta_apcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_jawaban_peserta_apcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>
          }
          update: {
            args: Prisma.em_jawaban_peserta_apcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>
          }
          deleteMany: {
            args: Prisma.em_jawaban_peserta_apcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_jawaban_peserta_apcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_jawaban_peserta_apcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jawaban_peserta_apcPayload>
          }
          aggregate: {
            args: Prisma.Em_jawaban_peserta_apcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_jawaban_peserta_apc>
          }
          groupBy: {
            args: Prisma.em_jawaban_peserta_apcGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_jawaban_peserta_apcGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_jawaban_peserta_apcCountArgs<ExtArgs>
            result: $Utils.Optional<Em_jawaban_peserta_apcCountAggregateOutputType> | number
          }
        }
      }
      em_jobfair: {
        payload: Prisma.$em_jobfairPayload<ExtArgs>
        fields: Prisma.em_jobfairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_jobfairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_jobfairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>
          }
          findFirst: {
            args: Prisma.em_jobfairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_jobfairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>
          }
          findMany: {
            args: Prisma.em_jobfairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>[]
          }
          create: {
            args: Prisma.em_jobfairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>
          }
          createMany: {
            args: Prisma.em_jobfairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_jobfairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>
          }
          update: {
            args: Prisma.em_jobfairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>
          }
          deleteMany: {
            args: Prisma.em_jobfairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_jobfairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_jobfairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_jobfairPayload>
          }
          aggregate: {
            args: Prisma.Em_jobfairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_jobfair>
          }
          groupBy: {
            args: Prisma.em_jobfairGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_jobfairGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_jobfairCountArgs<ExtArgs>
            result: $Utils.Optional<Em_jobfairCountAggregateOutputType> | number
          }
        }
      }
      em_levelposs: {
        payload: Prisma.$em_levelpossPayload<ExtArgs>
        fields: Prisma.em_levelpossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_levelpossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_levelpossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>
          }
          findFirst: {
            args: Prisma.em_levelpossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_levelpossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>
          }
          findMany: {
            args: Prisma.em_levelpossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>[]
          }
          create: {
            args: Prisma.em_levelpossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>
          }
          createMany: {
            args: Prisma.em_levelpossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_levelpossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>
          }
          update: {
            args: Prisma.em_levelpossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>
          }
          deleteMany: {
            args: Prisma.em_levelpossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_levelpossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_levelpossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_levelpossPayload>
          }
          aggregate: {
            args: Prisma.Em_levelpossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_levelposs>
          }
          groupBy: {
            args: Prisma.em_levelpossGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_levelpossGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_levelpossCountArgs<ExtArgs>
            result: $Utils.Optional<Em_levelpossCountAggregateOutputType> | number
          }
        }
      }
      em_logs: {
        payload: Prisma.$em_logsPayload<ExtArgs>
        fields: Prisma.em_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>
          }
          findFirst: {
            args: Prisma.em_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>
          }
          findMany: {
            args: Prisma.em_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>[]
          }
          create: {
            args: Prisma.em_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>
          }
          createMany: {
            args: Prisma.em_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>
          }
          update: {
            args: Prisma.em_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>
          }
          deleteMany: {
            args: Prisma.em_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_logsPayload>
          }
          aggregate: {
            args: Prisma.Em_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_logs>
          }
          groupBy: {
            args: Prisma.em_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_logsCountAggregateOutputType> | number
          }
        }
      }
      em_loker: {
        payload: Prisma.$em_lokerPayload<ExtArgs>
        fields: Prisma.em_lokerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_lokerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_lokerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>
          }
          findFirst: {
            args: Prisma.em_lokerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_lokerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>
          }
          findMany: {
            args: Prisma.em_lokerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>[]
          }
          create: {
            args: Prisma.em_lokerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>
          }
          createMany: {
            args: Prisma.em_lokerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_lokerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>
          }
          update: {
            args: Prisma.em_lokerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>
          }
          deleteMany: {
            args: Prisma.em_lokerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_lokerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_lokerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_lokerPayload>
          }
          aggregate: {
            args: Prisma.Em_lokerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_loker>
          }
          groupBy: {
            args: Prisma.em_lokerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_lokerGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_lokerCountArgs<ExtArgs>
            result: $Utils.Optional<Em_lokerCountAggregateOutputType> | number
          }
        }
      }
      em_loktopik: {
        payload: Prisma.$em_loktopikPayload<ExtArgs>
        fields: Prisma.em_loktopikFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_loktopikFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_loktopikFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>
          }
          findFirst: {
            args: Prisma.em_loktopikFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_loktopikFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>
          }
          findMany: {
            args: Prisma.em_loktopikFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>[]
          }
          create: {
            args: Prisma.em_loktopikCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>
          }
          createMany: {
            args: Prisma.em_loktopikCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_loktopikDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>
          }
          update: {
            args: Prisma.em_loktopikUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>
          }
          deleteMany: {
            args: Prisma.em_loktopikDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_loktopikUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_loktopikUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_loktopikPayload>
          }
          aggregate: {
            args: Prisma.Em_loktopikAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_loktopik>
          }
          groupBy: {
            args: Prisma.em_loktopikGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_loktopikGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_loktopikCountArgs<ExtArgs>
            result: $Utils.Optional<Em_loktopikCountAggregateOutputType> | number
          }
        }
      }
      em_materi_file: {
        payload: Prisma.$em_materi_filePayload<ExtArgs>
        fields: Prisma.em_materi_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_materi_fileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_materi_fileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>
          }
          findFirst: {
            args: Prisma.em_materi_fileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_materi_fileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>
          }
          findMany: {
            args: Prisma.em_materi_fileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>[]
          }
          create: {
            args: Prisma.em_materi_fileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>
          }
          createMany: {
            args: Prisma.em_materi_fileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_materi_fileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>
          }
          update: {
            args: Prisma.em_materi_fileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>
          }
          deleteMany: {
            args: Prisma.em_materi_fileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_materi_fileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_materi_fileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_filePayload>
          }
          aggregate: {
            args: Prisma.Em_materi_fileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_materi_file>
          }
          groupBy: {
            args: Prisma.em_materi_fileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_materi_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_materi_fileCountArgs<ExtArgs>
            result: $Utils.Optional<Em_materi_fileCountAggregateOutputType> | number
          }
        }
      }
      em_materi_kategori: {
        payload: Prisma.$em_materi_kategoriPayload<ExtArgs>
        fields: Prisma.em_materi_kategoriFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_materi_kategoriFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_materi_kategoriFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>
          }
          findFirst: {
            args: Prisma.em_materi_kategoriFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_materi_kategoriFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>
          }
          findMany: {
            args: Prisma.em_materi_kategoriFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>[]
          }
          create: {
            args: Prisma.em_materi_kategoriCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>
          }
          createMany: {
            args: Prisma.em_materi_kategoriCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_materi_kategoriDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>
          }
          update: {
            args: Prisma.em_materi_kategoriUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>
          }
          deleteMany: {
            args: Prisma.em_materi_kategoriDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_materi_kategoriUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_materi_kategoriUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_kategoriPayload>
          }
          aggregate: {
            args: Prisma.Em_materi_kategoriAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_materi_kategori>
          }
          groupBy: {
            args: Prisma.em_materi_kategoriGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_materi_kategoriGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_materi_kategoriCountArgs<ExtArgs>
            result: $Utils.Optional<Em_materi_kategoriCountAggregateOutputType> | number
          }
        }
      }
      em_materi_type: {
        payload: Prisma.$em_materi_typePayload<ExtArgs>
        fields: Prisma.em_materi_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_materi_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_materi_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>
          }
          findFirst: {
            args: Prisma.em_materi_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_materi_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>
          }
          findMany: {
            args: Prisma.em_materi_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>[]
          }
          create: {
            args: Prisma.em_materi_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>
          }
          createMany: {
            args: Prisma.em_materi_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_materi_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>
          }
          update: {
            args: Prisma.em_materi_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>
          }
          deleteMany: {
            args: Prisma.em_materi_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_materi_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_materi_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi_typePayload>
          }
          aggregate: {
            args: Prisma.Em_materi_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_materi_type>
          }
          groupBy: {
            args: Prisma.em_materi_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_materi_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_materi_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Em_materi_typeCountAggregateOutputType> | number
          }
        }
      }
      em_materi1: {
        payload: Prisma.$em_materi1Payload<ExtArgs>
        fields: Prisma.em_materi1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_materi1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_materi1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>
          }
          findFirst: {
            args: Prisma.em_materi1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_materi1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>
          }
          findMany: {
            args: Prisma.em_materi1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>[]
          }
          create: {
            args: Prisma.em_materi1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>
          }
          createMany: {
            args: Prisma.em_materi1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_materi1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>
          }
          update: {
            args: Prisma.em_materi1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>
          }
          deleteMany: {
            args: Prisma.em_materi1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_materi1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_materi1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi1Payload>
          }
          aggregate: {
            args: Prisma.Em_materi1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_materi1>
          }
          groupBy: {
            args: Prisma.em_materi1GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_materi1GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_materi1CountArgs<ExtArgs>
            result: $Utils.Optional<Em_materi1CountAggregateOutputType> | number
          }
        }
      }
      em_materi2: {
        payload: Prisma.$em_materi2Payload<ExtArgs>
        fields: Prisma.em_materi2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_materi2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_materi2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>
          }
          findFirst: {
            args: Prisma.em_materi2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_materi2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>
          }
          findMany: {
            args: Prisma.em_materi2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>[]
          }
          create: {
            args: Prisma.em_materi2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>
          }
          createMany: {
            args: Prisma.em_materi2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_materi2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>
          }
          update: {
            args: Prisma.em_materi2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>
          }
          deleteMany: {
            args: Prisma.em_materi2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_materi2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_materi2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_materi2Payload>
          }
          aggregate: {
            args: Prisma.Em_materi2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_materi2>
          }
          groupBy: {
            args: Prisma.em_materi2GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_materi2GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_materi2CountArgs<ExtArgs>
            result: $Utils.Optional<Em_materi2CountAggregateOutputType> | number
          }
        }
      }
      em_menu: {
        payload: Prisma.$em_menuPayload<ExtArgs>
        fields: Prisma.em_menuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_menuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_menuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>
          }
          findFirst: {
            args: Prisma.em_menuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_menuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>
          }
          findMany: {
            args: Prisma.em_menuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>[]
          }
          create: {
            args: Prisma.em_menuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>
          }
          createMany: {
            args: Prisma.em_menuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_menuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>
          }
          update: {
            args: Prisma.em_menuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>
          }
          deleteMany: {
            args: Prisma.em_menuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_menuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_menuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_menuPayload>
          }
          aggregate: {
            args: Prisma.Em_menuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_menu>
          }
          groupBy: {
            args: Prisma.em_menuGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_menuGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_menuCountArgs<ExtArgs>
            result: $Utils.Optional<Em_menuCountAggregateOutputType> | number
          }
        }
      }
      em_notifikasi: {
        payload: Prisma.$em_notifikasiPayload<ExtArgs>
        fields: Prisma.em_notifikasiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_notifikasiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_notifikasiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>
          }
          findFirst: {
            args: Prisma.em_notifikasiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_notifikasiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>
          }
          findMany: {
            args: Prisma.em_notifikasiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>[]
          }
          create: {
            args: Prisma.em_notifikasiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>
          }
          createMany: {
            args: Prisma.em_notifikasiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_notifikasiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>
          }
          update: {
            args: Prisma.em_notifikasiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>
          }
          deleteMany: {
            args: Prisma.em_notifikasiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_notifikasiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_notifikasiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasiPayload>
          }
          aggregate: {
            args: Prisma.Em_notifikasiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_notifikasi>
          }
          groupBy: {
            args: Prisma.em_notifikasiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_notifikasiGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_notifikasiCountArgs<ExtArgs>
            result: $Utils.Optional<Em_notifikasiCountAggregateOutputType> | number
          }
        }
      }
      em_notifikasi_read: {
        payload: Prisma.$em_notifikasi_readPayload<ExtArgs>
        fields: Prisma.em_notifikasi_readFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_notifikasi_readFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_notifikasi_readFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>
          }
          findFirst: {
            args: Prisma.em_notifikasi_readFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_notifikasi_readFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>
          }
          findMany: {
            args: Prisma.em_notifikasi_readFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>[]
          }
          create: {
            args: Prisma.em_notifikasi_readCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>
          }
          createMany: {
            args: Prisma.em_notifikasi_readCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_notifikasi_readDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>
          }
          update: {
            args: Prisma.em_notifikasi_readUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>
          }
          deleteMany: {
            args: Prisma.em_notifikasi_readDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_notifikasi_readUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_notifikasi_readUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_notifikasi_readPayload>
          }
          aggregate: {
            args: Prisma.Em_notifikasi_readAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_notifikasi_read>
          }
          groupBy: {
            args: Prisma.em_notifikasi_readGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_notifikasi_readGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_notifikasi_readCountArgs<ExtArgs>
            result: $Utils.Optional<Em_notifikasi_readCountAggregateOutputType> | number
          }
        }
      }
      em_onboarding: {
        payload: Prisma.$em_onboardingPayload<ExtArgs>
        fields: Prisma.em_onboardingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_onboardingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_onboardingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>
          }
          findFirst: {
            args: Prisma.em_onboardingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_onboardingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>
          }
          findMany: {
            args: Prisma.em_onboardingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>[]
          }
          create: {
            args: Prisma.em_onboardingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>
          }
          createMany: {
            args: Prisma.em_onboardingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_onboardingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>
          }
          update: {
            args: Prisma.em_onboardingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>
          }
          deleteMany: {
            args: Prisma.em_onboardingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_onboardingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_onboardingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_onboardingPayload>
          }
          aggregate: {
            args: Prisma.Em_onboardingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_onboarding>
          }
          groupBy: {
            args: Prisma.em_onboardingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_onboardingGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_onboardingCountArgs<ExtArgs>
            result: $Utils.Optional<Em_onboardingCountAggregateOutputType> | number
          }
        }
      }
      em_pilar: {
        payload: Prisma.$em_pilarPayload<ExtArgs>
        fields: Prisma.em_pilarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_pilarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_pilarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>
          }
          findFirst: {
            args: Prisma.em_pilarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_pilarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>
          }
          findMany: {
            args: Prisma.em_pilarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>[]
          }
          create: {
            args: Prisma.em_pilarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>
          }
          createMany: {
            args: Prisma.em_pilarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_pilarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>
          }
          update: {
            args: Prisma.em_pilarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>
          }
          deleteMany: {
            args: Prisma.em_pilarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_pilarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_pilarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_pilarPayload>
          }
          aggregate: {
            args: Prisma.Em_pilarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_pilar>
          }
          groupBy: {
            args: Prisma.em_pilarGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_pilarGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_pilarCountArgs<ExtArgs>
            result: $Utils.Optional<Em_pilarCountAggregateOutputType> | number
          }
        }
      }
      em_profesi: {
        payload: Prisma.$em_profesiPayload<ExtArgs>
        fields: Prisma.em_profesiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_profesiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_profesiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>
          }
          findFirst: {
            args: Prisma.em_profesiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_profesiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>
          }
          findMany: {
            args: Prisma.em_profesiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>[]
          }
          create: {
            args: Prisma.em_profesiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>
          }
          createMany: {
            args: Prisma.em_profesiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_profesiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>
          }
          update: {
            args: Prisma.em_profesiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>
          }
          deleteMany: {
            args: Prisma.em_profesiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_profesiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_profesiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_profesiPayload>
          }
          aggregate: {
            args: Prisma.Em_profesiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_profesi>
          }
          groupBy: {
            args: Prisma.em_profesiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_profesiGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_profesiCountArgs<ExtArgs>
            result: $Utils.Optional<Em_profesiCountAggregateOutputType> | number
          }
        }
      }
      em_questions1: {
        payload: Prisma.$em_questions1Payload<ExtArgs>
        fields: Prisma.em_questions1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_questions1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_questions1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>
          }
          findFirst: {
            args: Prisma.em_questions1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_questions1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>
          }
          findMany: {
            args: Prisma.em_questions1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>[]
          }
          create: {
            args: Prisma.em_questions1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>
          }
          createMany: {
            args: Prisma.em_questions1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_questions1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>
          }
          update: {
            args: Prisma.em_questions1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>
          }
          deleteMany: {
            args: Prisma.em_questions1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_questions1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_questions1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions1Payload>
          }
          aggregate: {
            args: Prisma.Em_questions1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_questions1>
          }
          groupBy: {
            args: Prisma.em_questions1GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_questions1GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_questions1CountArgs<ExtArgs>
            result: $Utils.Optional<Em_questions1CountAggregateOutputType> | number
          }
        }
      }
      em_questions2: {
        payload: Prisma.$em_questions2Payload<ExtArgs>
        fields: Prisma.em_questions2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_questions2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_questions2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>
          }
          findFirst: {
            args: Prisma.em_questions2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_questions2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>
          }
          findMany: {
            args: Prisma.em_questions2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>[]
          }
          create: {
            args: Prisma.em_questions2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>
          }
          createMany: {
            args: Prisma.em_questions2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_questions2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>
          }
          update: {
            args: Prisma.em_questions2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>
          }
          deleteMany: {
            args: Prisma.em_questions2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_questions2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_questions2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questions2Payload>
          }
          aggregate: {
            args: Prisma.Em_questions2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_questions2>
          }
          groupBy: {
            args: Prisma.em_questions2GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_questions2GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_questions2CountArgs<ExtArgs>
            result: $Utils.Optional<Em_questions2CountAggregateOutputType> | number
          }
        }
      }
      em_questtype: {
        payload: Prisma.$em_questtypePayload<ExtArgs>
        fields: Prisma.em_questtypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_questtypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_questtypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>
          }
          findFirst: {
            args: Prisma.em_questtypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_questtypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>
          }
          findMany: {
            args: Prisma.em_questtypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>[]
          }
          create: {
            args: Prisma.em_questtypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>
          }
          createMany: {
            args: Prisma.em_questtypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_questtypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>
          }
          update: {
            args: Prisma.em_questtypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>
          }
          deleteMany: {
            args: Prisma.em_questtypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_questtypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_questtypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_questtypePayload>
          }
          aggregate: {
            args: Prisma.Em_questtypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_questtype>
          }
          groupBy: {
            args: Prisma.em_questtypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_questtypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_questtypeCountArgs<ExtArgs>
            result: $Utils.Optional<Em_questtypeCountAggregateOutputType> | number
          }
        }
      }
      em_regulations: {
        payload: Prisma.$em_regulationsPayload<ExtArgs>
        fields: Prisma.em_regulationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_regulationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_regulationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>
          }
          findFirst: {
            args: Prisma.em_regulationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_regulationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>
          }
          findMany: {
            args: Prisma.em_regulationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>[]
          }
          create: {
            args: Prisma.em_regulationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>
          }
          createMany: {
            args: Prisma.em_regulationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_regulationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>
          }
          update: {
            args: Prisma.em_regulationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>
          }
          deleteMany: {
            args: Prisma.em_regulationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_regulationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_regulationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_regulationsPayload>
          }
          aggregate: {
            args: Prisma.Em_regulationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_regulations>
          }
          groupBy: {
            args: Prisma.em_regulationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_regulationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_regulationsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_regulationsCountAggregateOutputType> | number
          }
        }
      }
      em_sbu: {
        payload: Prisma.$em_sbuPayload<ExtArgs>
        fields: Prisma.em_sbuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_sbuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_sbuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>
          }
          findFirst: {
            args: Prisma.em_sbuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_sbuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>
          }
          findMany: {
            args: Prisma.em_sbuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>[]
          }
          create: {
            args: Prisma.em_sbuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>
          }
          createMany: {
            args: Prisma.em_sbuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_sbuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>
          }
          update: {
            args: Prisma.em_sbuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>
          }
          deleteMany: {
            args: Prisma.em_sbuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_sbuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_sbuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbuPayload>
          }
          aggregate: {
            args: Prisma.Em_sbuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_sbu>
          }
          groupBy: {
            args: Prisma.em_sbuGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_sbuGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_sbuCountArgs<ExtArgs>
            result: $Utils.Optional<Em_sbuCountAggregateOutputType> | number
          }
        }
      }
      em_sbu_sub: {
        payload: Prisma.$em_sbu_subPayload<ExtArgs>
        fields: Prisma.em_sbu_subFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_sbu_subFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_sbu_subFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>
          }
          findFirst: {
            args: Prisma.em_sbu_subFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_sbu_subFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>
          }
          findMany: {
            args: Prisma.em_sbu_subFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>[]
          }
          create: {
            args: Prisma.em_sbu_subCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>
          }
          createMany: {
            args: Prisma.em_sbu_subCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_sbu_subDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>
          }
          update: {
            args: Prisma.em_sbu_subUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>
          }
          deleteMany: {
            args: Prisma.em_sbu_subDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_sbu_subUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_sbu_subUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_sbu_subPayload>
          }
          aggregate: {
            args: Prisma.Em_sbu_subAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_sbu_sub>
          }
          groupBy: {
            args: Prisma.em_sbu_subGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_sbu_subGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_sbu_subCountArgs<ExtArgs>
            result: $Utils.Optional<Em_sbu_subCountAggregateOutputType> | number
          }
        }
      }
      em_schedule1: {
        payload: Prisma.$em_schedule1Payload<ExtArgs>
        fields: Prisma.em_schedule1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_schedule1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_schedule1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>
          }
          findFirst: {
            args: Prisma.em_schedule1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_schedule1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>
          }
          findMany: {
            args: Prisma.em_schedule1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>[]
          }
          create: {
            args: Prisma.em_schedule1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>
          }
          createMany: {
            args: Prisma.em_schedule1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_schedule1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>
          }
          update: {
            args: Prisma.em_schedule1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>
          }
          deleteMany: {
            args: Prisma.em_schedule1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_schedule1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_schedule1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule1Payload>
          }
          aggregate: {
            args: Prisma.Em_schedule1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_schedule1>
          }
          groupBy: {
            args: Prisma.em_schedule1GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule1GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_schedule1CountArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule1CountAggregateOutputType> | number
          }
        }
      }
      em_schedule2: {
        payload: Prisma.$em_schedule2Payload<ExtArgs>
        fields: Prisma.em_schedule2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_schedule2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_schedule2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>
          }
          findFirst: {
            args: Prisma.em_schedule2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_schedule2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>
          }
          findMany: {
            args: Prisma.em_schedule2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>[]
          }
          create: {
            args: Prisma.em_schedule2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>
          }
          createMany: {
            args: Prisma.em_schedule2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_schedule2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>
          }
          update: {
            args: Prisma.em_schedule2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>
          }
          deleteMany: {
            args: Prisma.em_schedule2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_schedule2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_schedule2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule2Payload>
          }
          aggregate: {
            args: Prisma.Em_schedule2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_schedule2>
          }
          groupBy: {
            args: Prisma.em_schedule2GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule2GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_schedule2CountArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule2CountAggregateOutputType> | number
          }
        }
      }
      em_schedule3: {
        payload: Prisma.$em_schedule3Payload<ExtArgs>
        fields: Prisma.em_schedule3FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_schedule3FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_schedule3FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>
          }
          findFirst: {
            args: Prisma.em_schedule3FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_schedule3FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>
          }
          findMany: {
            args: Prisma.em_schedule3FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>[]
          }
          create: {
            args: Prisma.em_schedule3CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>
          }
          createMany: {
            args: Prisma.em_schedule3CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_schedule3DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>
          }
          update: {
            args: Prisma.em_schedule3UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>
          }
          deleteMany: {
            args: Prisma.em_schedule3DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_schedule3UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_schedule3UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule3Payload>
          }
          aggregate: {
            args: Prisma.Em_schedule3AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_schedule3>
          }
          groupBy: {
            args: Prisma.em_schedule3GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule3GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_schedule3CountArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule3CountAggregateOutputType> | number
          }
        }
      }
      em_schedule4: {
        payload: Prisma.$em_schedule4Payload<ExtArgs>
        fields: Prisma.em_schedule4FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_schedule4FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_schedule4FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>
          }
          findFirst: {
            args: Prisma.em_schedule4FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_schedule4FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>
          }
          findMany: {
            args: Prisma.em_schedule4FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>[]
          }
          create: {
            args: Prisma.em_schedule4CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>
          }
          createMany: {
            args: Prisma.em_schedule4CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_schedule4DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>
          }
          update: {
            args: Prisma.em_schedule4UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>
          }
          deleteMany: {
            args: Prisma.em_schedule4DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_schedule4UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_schedule4UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_schedule4Payload>
          }
          aggregate: {
            args: Prisma.Em_schedule4AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_schedule4>
          }
          groupBy: {
            args: Prisma.em_schedule4GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule4GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_schedule4CountArgs<ExtArgs>
            result: $Utils.Optional<Em_schedule4CountAggregateOutputType> | number
          }
        }
      }
      em_session_exams: {
        payload: Prisma.$em_session_examsPayload<ExtArgs>
        fields: Prisma.em_session_examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_session_examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_session_examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>
          }
          findFirst: {
            args: Prisma.em_session_examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_session_examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>
          }
          findMany: {
            args: Prisma.em_session_examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>[]
          }
          create: {
            args: Prisma.em_session_examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>
          }
          createMany: {
            args: Prisma.em_session_examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_session_examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>
          }
          update: {
            args: Prisma.em_session_examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>
          }
          deleteMany: {
            args: Prisma.em_session_examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_session_examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_session_examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_examsPayload>
          }
          aggregate: {
            args: Prisma.Em_session_examsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_session_exams>
          }
          groupBy: {
            args: Prisma.em_session_examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_session_examsGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_session_examsCountArgs<ExtArgs>
            result: $Utils.Optional<Em_session_examsCountAggregateOutputType> | number
          }
        }
      }
      em_session_exams_apc: {
        payload: Prisma.$em_session_exams_apcPayload<ExtArgs>
        fields: Prisma.em_session_exams_apcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_session_exams_apcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_session_exams_apcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>
          }
          findFirst: {
            args: Prisma.em_session_exams_apcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_session_exams_apcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>
          }
          findMany: {
            args: Prisma.em_session_exams_apcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>[]
          }
          create: {
            args: Prisma.em_session_exams_apcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>
          }
          createMany: {
            args: Prisma.em_session_exams_apcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_session_exams_apcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>
          }
          update: {
            args: Prisma.em_session_exams_apcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>
          }
          deleteMany: {
            args: Prisma.em_session_exams_apcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_session_exams_apcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_session_exams_apcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_session_exams_apcPayload>
          }
          aggregate: {
            args: Prisma.Em_session_exams_apcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_session_exams_apc>
          }
          groupBy: {
            args: Prisma.em_session_exams_apcGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_session_exams_apcGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_session_exams_apcCountArgs<ExtArgs>
            result: $Utils.Optional<Em_session_exams_apcCountAggregateOutputType> | number
          }
        }
      }
      em_subscribe: {
        payload: Prisma.$em_subscribePayload<ExtArgs>
        fields: Prisma.em_subscribeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_subscribeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_subscribeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>
          }
          findFirst: {
            args: Prisma.em_subscribeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_subscribeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>
          }
          findMany: {
            args: Prisma.em_subscribeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>[]
          }
          create: {
            args: Prisma.em_subscribeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>
          }
          createMany: {
            args: Prisma.em_subscribeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_subscribeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>
          }
          update: {
            args: Prisma.em_subscribeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>
          }
          deleteMany: {
            args: Prisma.em_subscribeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_subscribeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_subscribeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscribePayload>
          }
          aggregate: {
            args: Prisma.Em_subscribeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_subscribe>
          }
          groupBy: {
            args: Prisma.em_subscribeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_subscribeGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_subscribeCountArgs<ExtArgs>
            result: $Utils.Optional<Em_subscribeCountAggregateOutputType> | number
          }
        }
      }
      em_subscription: {
        payload: Prisma.$em_subscriptionPayload<ExtArgs>
        fields: Prisma.em_subscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_subscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_subscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>
          }
          findFirst: {
            args: Prisma.em_subscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_subscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>
          }
          findMany: {
            args: Prisma.em_subscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>[]
          }
          create: {
            args: Prisma.em_subscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>
          }
          createMany: {
            args: Prisma.em_subscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_subscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>
          }
          update: {
            args: Prisma.em_subscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>
          }
          deleteMany: {
            args: Prisma.em_subscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_subscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_subscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_subscriptionPayload>
          }
          aggregate: {
            args: Prisma.Em_subscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_subscription>
          }
          groupBy: {
            args: Prisma.em_subscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_subscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_subscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<Em_subscriptionCountAggregateOutputType> | number
          }
        }
      }
      em_topic_selesai: {
        payload: Prisma.$em_topic_selesaiPayload<ExtArgs>
        fields: Prisma.em_topic_selesaiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_topic_selesaiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_topic_selesaiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>
          }
          findFirst: {
            args: Prisma.em_topic_selesaiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_topic_selesaiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>
          }
          findMany: {
            args: Prisma.em_topic_selesaiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>[]
          }
          create: {
            args: Prisma.em_topic_selesaiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>
          }
          createMany: {
            args: Prisma.em_topic_selesaiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_topic_selesaiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>
          }
          update: {
            args: Prisma.em_topic_selesaiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>
          }
          deleteMany: {
            args: Prisma.em_topic_selesaiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_topic_selesaiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_topic_selesaiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_topic_selesaiPayload>
          }
          aggregate: {
            args: Prisma.Em_topic_selesaiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_topic_selesai>
          }
          groupBy: {
            args: Prisma.em_topic_selesaiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_topic_selesaiGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_topic_selesaiCountArgs<ExtArgs>
            result: $Utils.Optional<Em_topic_selesaiCountAggregateOutputType> | number
          }
        }
      }
      em_user_answers1: {
        payload: Prisma.$em_user_answers1Payload<ExtArgs>
        fields: Prisma.em_user_answers1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_user_answers1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_user_answers1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>
          }
          findFirst: {
            args: Prisma.em_user_answers1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_user_answers1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>
          }
          findMany: {
            args: Prisma.em_user_answers1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>[]
          }
          create: {
            args: Prisma.em_user_answers1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>
          }
          createMany: {
            args: Prisma.em_user_answers1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_user_answers1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>
          }
          update: {
            args: Prisma.em_user_answers1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>
          }
          deleteMany: {
            args: Prisma.em_user_answers1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_user_answers1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_user_answers1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_answers1Payload>
          }
          aggregate: {
            args: Prisma.Em_user_answers1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_user_answers1>
          }
          groupBy: {
            args: Prisma.em_user_answers1GroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_user_answers1GroupByOutputType>[]
          }
          count: {
            args: Prisma.em_user_answers1CountArgs<ExtArgs>
            result: $Utils.Optional<Em_user_answers1CountAggregateOutputType> | number
          }
        }
      }
      em_user_dashboard: {
        payload: Prisma.$em_user_dashboardPayload<ExtArgs>
        fields: Prisma.em_user_dashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_user_dashboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_user_dashboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>
          }
          findFirst: {
            args: Prisma.em_user_dashboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_user_dashboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>
          }
          findMany: {
            args: Prisma.em_user_dashboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>[]
          }
          create: {
            args: Prisma.em_user_dashboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>
          }
          createMany: {
            args: Prisma.em_user_dashboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_user_dashboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>
          }
          update: {
            args: Prisma.em_user_dashboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>
          }
          deleteMany: {
            args: Prisma.em_user_dashboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_user_dashboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_user_dashboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_dashboardPayload>
          }
          aggregate: {
            args: Prisma.Em_user_dashboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_user_dashboard>
          }
          groupBy: {
            args: Prisma.em_user_dashboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_user_dashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_user_dashboardCountArgs<ExtArgs>
            result: $Utils.Optional<Em_user_dashboardCountAggregateOutputType> | number
          }
        }
      }
      em_user_list: {
        payload: Prisma.$em_user_listPayload<ExtArgs>
        fields: Prisma.em_user_listFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_user_listFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_user_listFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>
          }
          findFirst: {
            args: Prisma.em_user_listFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_user_listFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>
          }
          findMany: {
            args: Prisma.em_user_listFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>[]
          }
          create: {
            args: Prisma.em_user_listCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>
          }
          createMany: {
            args: Prisma.em_user_listCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_user_listDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>
          }
          update: {
            args: Prisma.em_user_listUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>
          }
          deleteMany: {
            args: Prisma.em_user_listDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_user_listUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_user_listUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_user_listPayload>
          }
          aggregate: {
            args: Prisma.Em_user_listAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_user_list>
          }
          groupBy: {
            args: Prisma.em_user_listGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_user_listGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_user_listCountArgs<ExtArgs>
            result: $Utils.Optional<Em_user_listCountAggregateOutputType> | number
          }
        }
      }
      em_users: {
        payload: Prisma.$em_usersPayload<ExtArgs>
        fields: Prisma.em_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>
          }
          findFirst: {
            args: Prisma.em_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>
          }
          findMany: {
            args: Prisma.em_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>[]
          }
          create: {
            args: Prisma.em_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>
          }
          createMany: {
            args: Prisma.em_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>
          }
          update: {
            args: Prisma.em_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>
          }
          deleteMany: {
            args: Prisma.em_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_usersPayload>
          }
          aggregate: {
            args: Prisma.Em_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_users>
          }
          groupBy: {
            args: Prisma.em_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Em_usersCountAggregateOutputType> | number
          }
        }
      }
      em_verify_links: {
        payload: Prisma.$em_verify_linksPayload<ExtArgs>
        fields: Prisma.em_verify_linksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_verify_linksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_verify_linksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>
          }
          findFirst: {
            args: Prisma.em_verify_linksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_verify_linksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>
          }
          findMany: {
            args: Prisma.em_verify_linksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>[]
          }
          create: {
            args: Prisma.em_verify_linksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>
          }
          createMany: {
            args: Prisma.em_verify_linksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_verify_linksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>
          }
          update: {
            args: Prisma.em_verify_linksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>
          }
          deleteMany: {
            args: Prisma.em_verify_linksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_verify_linksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_verify_linksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_verify_linksPayload>
          }
          aggregate: {
            args: Prisma.Em_verify_linksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_verify_links>
          }
          groupBy: {
            args: Prisma.em_verify_linksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_verify_linksGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_verify_linksCountArgs<ExtArgs>
            result: $Utils.Optional<Em_verify_linksCountAggregateOutputType> | number
          }
        }
      }
      em_wa_templates: {
        payload: Prisma.$em_wa_templatesPayload<ExtArgs>
        fields: Prisma.em_wa_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_wa_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_wa_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>
          }
          findFirst: {
            args: Prisma.em_wa_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_wa_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>
          }
          findMany: {
            args: Prisma.em_wa_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>[]
          }
          create: {
            args: Prisma.em_wa_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>
          }
          createMany: {
            args: Prisma.em_wa_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_wa_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>
          }
          update: {
            args: Prisma.em_wa_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>
          }
          deleteMany: {
            args: Prisma.em_wa_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_wa_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_wa_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_wa_templatesPayload>
          }
          aggregate: {
            args: Prisma.Em_wa_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_wa_templates>
          }
          groupBy: {
            args: Prisma.em_wa_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_wa_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_wa_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Em_wa_templatesCountAggregateOutputType> | number
          }
        }
      }
      em_worktype: {
        payload: Prisma.$em_worktypePayload<ExtArgs>
        fields: Prisma.em_worktypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_worktypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_worktypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>
          }
          findFirst: {
            args: Prisma.em_worktypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_worktypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>
          }
          findMany: {
            args: Prisma.em_worktypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>[]
          }
          create: {
            args: Prisma.em_worktypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>
          }
          createMany: {
            args: Prisma.em_worktypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_worktypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>
          }
          update: {
            args: Prisma.em_worktypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>
          }
          deleteMany: {
            args: Prisma.em_worktypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_worktypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_worktypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_worktypePayload>
          }
          aggregate: {
            args: Prisma.Em_worktypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_worktype>
          }
          groupBy: {
            args: Prisma.em_worktypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_worktypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_worktypeCountArgs<ExtArgs>
            result: $Utils.Optional<Em_worktypeCountAggregateOutputType> | number
          }
        }
      }
      em_xquetest: {
        payload: Prisma.$em_xquetestPayload<ExtArgs>
        fields: Prisma.em_xquetestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.em_xquetestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.em_xquetestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>
          }
          findFirst: {
            args: Prisma.em_xquetestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.em_xquetestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>
          }
          findMany: {
            args: Prisma.em_xquetestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>[]
          }
          create: {
            args: Prisma.em_xquetestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>
          }
          createMany: {
            args: Prisma.em_xquetestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.em_xquetestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>
          }
          update: {
            args: Prisma.em_xquetestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>
          }
          deleteMany: {
            args: Prisma.em_xquetestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.em_xquetestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.em_xquetestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$em_xquetestPayload>
          }
          aggregate: {
            args: Prisma.Em_xquetestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEm_xquetest>
          }
          groupBy: {
            args: Prisma.em_xquetestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Em_xquetestGroupByOutputType>[]
          }
          count: {
            args: Prisma.em_xquetestCountArgs<ExtArgs>
            result: $Utils.Optional<Em_xquetestCountAggregateOutputType> | number
          }
        }
      }
      emapp: {
        payload: Prisma.$emappPayload<ExtArgs>
        fields: Prisma.emappFieldRefs
        operations: {
          findUnique: {
            args: Prisma.emappFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.emappFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>
          }
          findFirst: {
            args: Prisma.emappFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.emappFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>
          }
          findMany: {
            args: Prisma.emappFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>[]
          }
          create: {
            args: Prisma.emappCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>
          }
          createMany: {
            args: Prisma.emappCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.emappDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>
          }
          update: {
            args: Prisma.emappUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>
          }
          deleteMany: {
            args: Prisma.emappDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.emappUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.emappUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emappPayload>
          }
          aggregate: {
            args: Prisma.EmappAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmapp>
          }
          groupBy: {
            args: Prisma.emappGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmappGroupByOutputType>[]
          }
          count: {
            args: Prisma.emappCountArgs<ExtArgs>
            result: $Utils.Optional<EmappCountAggregateOutputType> | number
          }
        }
      }
      empassw: {
        payload: Prisma.$empasswPayload<ExtArgs>
        fields: Prisma.empasswFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empasswFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empasswFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>
          }
          findFirst: {
            args: Prisma.empasswFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empasswFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>
          }
          findMany: {
            args: Prisma.empasswFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>[]
          }
          create: {
            args: Prisma.empasswCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>
          }
          createMany: {
            args: Prisma.empasswCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.empasswDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>
          }
          update: {
            args: Prisma.empasswUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>
          }
          deleteMany: {
            args: Prisma.empasswDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.empasswUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.empasswUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empasswPayload>
          }
          aggregate: {
            args: Prisma.EmpasswAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpassw>
          }
          groupBy: {
            args: Prisma.empasswGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpasswGroupByOutputType>[]
          }
          count: {
            args: Prisma.empasswCountArgs<ExtArgs>
            result: $Utils.Optional<EmpasswCountAggregateOutputType> | number
          }
        }
      }
      emposs: {
        payload: Prisma.$empossPayload<ExtArgs>
        fields: Prisma.empossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>
          }
          findFirst: {
            args: Prisma.empossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>
          }
          findMany: {
            args: Prisma.empossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>[]
          }
          create: {
            args: Prisma.empossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>
          }
          createMany: {
            args: Prisma.empossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.empossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>
          }
          update: {
            args: Prisma.empossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>
          }
          deleteMany: {
            args: Prisma.empossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.empossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.empossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empossPayload>
          }
          aggregate: {
            args: Prisma.EmpossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmposs>
          }
          groupBy: {
            args: Prisma.empossGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpossGroupByOutputType>[]
          }
          count: {
            args: Prisma.empossCountArgs<ExtArgs>
            result: $Utils.Optional<EmpossCountAggregateOutputType> | number
          }
        }
      }
      faceusers: {
        payload: Prisma.$faceusersPayload<ExtArgs>
        fields: Prisma.faceusersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.faceusersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.faceusersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>
          }
          findFirst: {
            args: Prisma.faceusersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.faceusersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>
          }
          findMany: {
            args: Prisma.faceusersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>[]
          }
          create: {
            args: Prisma.faceusersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>
          }
          createMany: {
            args: Prisma.faceusersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.faceusersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>
          }
          update: {
            args: Prisma.faceusersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>
          }
          deleteMany: {
            args: Prisma.faceusersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.faceusersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.faceusersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faceusersPayload>
          }
          aggregate: {
            args: Prisma.FaceusersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaceusers>
          }
          groupBy: {
            args: Prisma.faceusersGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaceusersGroupByOutputType>[]
          }
          count: {
            args: Prisma.faceusersCountArgs<ExtArgs>
            result: $Utils.Optional<FaceusersCountAggregateOutputType> | number
          }
        }
      }
      menu: {
        payload: Prisma.$menuPayload<ExtArgs>
        fields: Prisma.menuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.menuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.menuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          findFirst: {
            args: Prisma.menuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.menuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          findMany: {
            args: Prisma.menuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>[]
          }
          create: {
            args: Prisma.menuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          createMany: {
            args: Prisma.menuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.menuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          update: {
            args: Prisma.menuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          deleteMany: {
            args: Prisma.menuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.menuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.menuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.menuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.menuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      scores: {
        payload: Prisma.$scoresPayload<ExtArgs>
        fields: Prisma.scoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.scoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.scoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>
          }
          findFirst: {
            args: Prisma.scoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.scoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>
          }
          findMany: {
            args: Prisma.scoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>[]
          }
          create: {
            args: Prisma.scoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>
          }
          createMany: {
            args: Prisma.scoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.scoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>
          }
          update: {
            args: Prisma.scoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>
          }
          deleteMany: {
            args: Prisma.scoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.scoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.scoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scoresPayload>
          }
          aggregate: {
            args: Prisma.ScoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScores>
          }
          groupBy: {
            args: Prisma.scoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.scoresCountArgs<ExtArgs>
            result: $Utils.Optional<ScoresCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    em_absensi?: em_absensiOmit
    em_apc_academy?: em_apc_academyOmit
    em_apc_personal?: em_apc_personalOmit
    em_apc_photograph?: em_apc_photographOmit
    em_apc_regulation?: em_apc_regulationOmit
    em_apc_skill_exper?: em_apc_skill_experOmit
    em_api_keys?: em_api_keysOmit
    em_applicant_criteria?: em_applicant_criteriaOmit
    em_applicant_match?: em_applicant_matchOmit
    em_banner?: em_bannerOmit
    em_career_contact?: em_career_contactOmit
    em_certificate_fields?: em_certificate_fieldsOmit
    em_certificate_templates?: em_certificate_templatesOmit
    em_certificates_result?: em_certificates_resultOmit
    em_chance?: em_chanceOmit
    em_contrctype?: em_contrctypeOmit
    em_dept?: em_deptOmit
    em_employee?: em_employeeOmit
    em_event?: em_eventOmit
    em_event_reg?: em_event_regOmit
    em_event2?: em_event2Omit
    em_exam_questions?: em_exam_questionsOmit
    em_exams?: em_examsOmit
    em_exams_monitor?: em_exams_monitorOmit
    em_exams_results?: em_exams_resultsOmit
    em_faq?: em_faqOmit
    em_faq_cat?: em_faq_catOmit
    em_galeri_materi?: em_galeri_materiOmit
    em_group?: em_groupOmit
    em_hero_section?: em_hero_sectionOmit
    em_jawaban_peserta?: em_jawaban_pesertaOmit
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcOmit
    em_jobfair?: em_jobfairOmit
    em_levelposs?: em_levelpossOmit
    em_logs?: em_logsOmit
    em_loker?: em_lokerOmit
    em_loktopik?: em_loktopikOmit
    em_materi_file?: em_materi_fileOmit
    em_materi_kategori?: em_materi_kategoriOmit
    em_materi_type?: em_materi_typeOmit
    em_materi1?: em_materi1Omit
    em_materi2?: em_materi2Omit
    em_menu?: em_menuOmit
    em_notifikasi?: em_notifikasiOmit
    em_notifikasi_read?: em_notifikasi_readOmit
    em_onboarding?: em_onboardingOmit
    em_pilar?: em_pilarOmit
    em_profesi?: em_profesiOmit
    em_questions1?: em_questions1Omit
    em_questions2?: em_questions2Omit
    em_questtype?: em_questtypeOmit
    em_regulations?: em_regulationsOmit
    em_sbu?: em_sbuOmit
    em_sbu_sub?: em_sbu_subOmit
    em_schedule1?: em_schedule1Omit
    em_schedule2?: em_schedule2Omit
    em_schedule3?: em_schedule3Omit
    em_schedule4?: em_schedule4Omit
    em_session_exams?: em_session_examsOmit
    em_session_exams_apc?: em_session_exams_apcOmit
    em_subscribe?: em_subscribeOmit
    em_subscription?: em_subscriptionOmit
    em_topic_selesai?: em_topic_selesaiOmit
    em_user_answers1?: em_user_answers1Omit
    em_user_dashboard?: em_user_dashboardOmit
    em_user_list?: em_user_listOmit
    em_users?: em_usersOmit
    em_verify_links?: em_verify_linksOmit
    em_wa_templates?: em_wa_templatesOmit
    em_worktype?: em_worktypeOmit
    em_xquetest?: em_xquetestOmit
    emapp?: emappOmit
    empassw?: empasswOmit
    emposs?: empossOmit
    faceusers?: faceusersOmit
    menu?: menuOmit
    scores?: scoresOmit
    sysdiagrams?: sysdiagramsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Em_apc_personalCountOutputType
   */

  export type Em_apc_personalCountOutputType = {
    em_apc_academy: number
    em_apc_photograph: number
    em_apc_regulation: number
    em_apc_skill_exper: number
    em_applicant_match: number
  }

  export type Em_apc_personalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_academy?: boolean | Em_apc_personalCountOutputTypeCountEm_apc_academyArgs
    em_apc_photograph?: boolean | Em_apc_personalCountOutputTypeCountEm_apc_photographArgs
    em_apc_regulation?: boolean | Em_apc_personalCountOutputTypeCountEm_apc_regulationArgs
    em_apc_skill_exper?: boolean | Em_apc_personalCountOutputTypeCountEm_apc_skill_experArgs
    em_applicant_match?: boolean | Em_apc_personalCountOutputTypeCountEm_applicant_matchArgs
  }

  // Custom InputTypes
  /**
   * Em_apc_personalCountOutputType without action
   */
  export type Em_apc_personalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_apc_personalCountOutputType
     */
    select?: Em_apc_personalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_apc_personalCountOutputType without action
   */
  export type Em_apc_personalCountOutputTypeCountEm_apc_academyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_academyWhereInput
  }

  /**
   * Em_apc_personalCountOutputType without action
   */
  export type Em_apc_personalCountOutputTypeCountEm_apc_photographArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_photographWhereInput
  }

  /**
   * Em_apc_personalCountOutputType without action
   */
  export type Em_apc_personalCountOutputTypeCountEm_apc_regulationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_regulationWhereInput
  }

  /**
   * Em_apc_personalCountOutputType without action
   */
  export type Em_apc_personalCountOutputTypeCountEm_apc_skill_experArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_skill_experWhereInput
  }

  /**
   * Em_apc_personalCountOutputType without action
   */
  export type Em_apc_personalCountOutputTypeCountEm_applicant_matchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_applicant_matchWhereInput
  }


  /**
   * Count Type Em_certificate_templatesCountOutputType
   */

  export type Em_certificate_templatesCountOutputType = {
    em_certificate_fields: number
  }

  export type Em_certificate_templatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_certificate_fields?: boolean | Em_certificate_templatesCountOutputTypeCountEm_certificate_fieldsArgs
  }

  // Custom InputTypes
  /**
   * Em_certificate_templatesCountOutputType without action
   */
  export type Em_certificate_templatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_certificate_templatesCountOutputType
     */
    select?: Em_certificate_templatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_certificate_templatesCountOutputType without action
   */
  export type Em_certificate_templatesCountOutputTypeCountEm_certificate_fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_certificate_fieldsWhereInput
  }


  /**
   * Count Type Em_eventCountOutputType
   */

  export type Em_eventCountOutputType = {
    em_event2: number
  }

  export type Em_eventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_event2?: boolean | Em_eventCountOutputTypeCountEm_event2Args
  }

  // Custom InputTypes
  /**
   * Em_eventCountOutputType without action
   */
  export type Em_eventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_eventCountOutputType
     */
    select?: Em_eventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_eventCountOutputType without action
   */
  export type Em_eventCountOutputTypeCountEm_event2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_event2WhereInput
  }


  /**
   * Count Type Em_examsCountOutputType
   */

  export type Em_examsCountOutputType = {
    em_loktopik: number
    scores: number
  }

  export type Em_examsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_loktopik?: boolean | Em_examsCountOutputTypeCountEm_loktopikArgs
    scores?: boolean | Em_examsCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * Em_examsCountOutputType without action
   */
  export type Em_examsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_examsCountOutputType
     */
    select?: Em_examsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_examsCountOutputType without action
   */
  export type Em_examsCountOutputTypeCountEm_loktopikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_loktopikWhereInput
  }

  /**
   * Em_examsCountOutputType without action
   */
  export type Em_examsCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scoresWhereInput
  }


  /**
   * Count Type Em_faq_catCountOutputType
   */

  export type Em_faq_catCountOutputType = {
    em_faq: number
  }

  export type Em_faq_catCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_faq?: boolean | Em_faq_catCountOutputTypeCountEm_faqArgs
  }

  // Custom InputTypes
  /**
   * Em_faq_catCountOutputType without action
   */
  export type Em_faq_catCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_faq_catCountOutputType
     */
    select?: Em_faq_catCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_faq_catCountOutputType without action
   */
  export type Em_faq_catCountOutputTypeCountEm_faqArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_faqWhereInput
  }


  /**
   * Count Type Em_lokerCountOutputType
   */

  export type Em_lokerCountOutputType = {
    em_loktopik: number
  }

  export type Em_lokerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_loktopik?: boolean | Em_lokerCountOutputTypeCountEm_loktopikArgs
  }

  // Custom InputTypes
  /**
   * Em_lokerCountOutputType without action
   */
  export type Em_lokerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_lokerCountOutputType
     */
    select?: Em_lokerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_lokerCountOutputType without action
   */
  export type Em_lokerCountOutputTypeCountEm_loktopikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_loktopikWhereInput
  }


  /**
   * Count Type Em_materi_typeCountOutputType
   */

  export type Em_materi_typeCountOutputType = {
    em_materi2: number
  }

  export type Em_materi_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_materi2?: boolean | Em_materi_typeCountOutputTypeCountEm_materi2Args
  }

  // Custom InputTypes
  /**
   * Em_materi_typeCountOutputType without action
   */
  export type Em_materi_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_materi_typeCountOutputType
     */
    select?: Em_materi_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_materi_typeCountOutputType without action
   */
  export type Em_materi_typeCountOutputTypeCountEm_materi2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi2WhereInput
  }


  /**
   * Count Type Em_materi1CountOutputType
   */

  export type Em_materi1CountOutputType = {
    em_materi_file: number
    em_materi2: number
  }

  export type Em_materi1CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_materi_file?: boolean | Em_materi1CountOutputTypeCountEm_materi_fileArgs
    em_materi2?: boolean | Em_materi1CountOutputTypeCountEm_materi2Args
  }

  // Custom InputTypes
  /**
   * Em_materi1CountOutputType without action
   */
  export type Em_materi1CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_materi1CountOutputType
     */
    select?: Em_materi1CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_materi1CountOutputType without action
   */
  export type Em_materi1CountOutputTypeCountEm_materi_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi_fileWhereInput
  }

  /**
   * Em_materi1CountOutputType without action
   */
  export type Em_materi1CountOutputTypeCountEm_materi2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi2WhereInput
  }


  /**
   * Count Type Em_questions1CountOutputType
   */

  export type Em_questions1CountOutputType = {
    em_questions2: number
  }

  export type Em_questions1CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_questions2?: boolean | Em_questions1CountOutputTypeCountEm_questions2Args
  }

  // Custom InputTypes
  /**
   * Em_questions1CountOutputType without action
   */
  export type Em_questions1CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_questions1CountOutputType
     */
    select?: Em_questions1CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_questions1CountOutputType without action
   */
  export type Em_questions1CountOutputTypeCountEm_questions2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_questions2WhereInput
  }


  /**
   * Count Type Em_schedule1CountOutputType
   */

  export type Em_schedule1CountOutputType = {
    em_schedule2: number
    em_schedule3: number
    em_schedule4: number
  }

  export type Em_schedule1CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_schedule2?: boolean | Em_schedule1CountOutputTypeCountEm_schedule2Args
    em_schedule3?: boolean | Em_schedule1CountOutputTypeCountEm_schedule3Args
    em_schedule4?: boolean | Em_schedule1CountOutputTypeCountEm_schedule4Args
  }

  // Custom InputTypes
  /**
   * Em_schedule1CountOutputType without action
   */
  export type Em_schedule1CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_schedule1CountOutputType
     */
    select?: Em_schedule1CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_schedule1CountOutputType without action
   */
  export type Em_schedule1CountOutputTypeCountEm_schedule2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule2WhereInput
  }

  /**
   * Em_schedule1CountOutputType without action
   */
  export type Em_schedule1CountOutputTypeCountEm_schedule3Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule3WhereInput
  }

  /**
   * Em_schedule1CountOutputType without action
   */
  export type Em_schedule1CountOutputTypeCountEm_schedule4Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule4WhereInput
  }


  /**
   * Count Type Em_session_examsCountOutputType
   */

  export type Em_session_examsCountOutputType = {
    em_jawaban_peserta: number
  }

  export type Em_session_examsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_jawaban_peserta?: boolean | Em_session_examsCountOutputTypeCountEm_jawaban_pesertaArgs
  }

  // Custom InputTypes
  /**
   * Em_session_examsCountOutputType without action
   */
  export type Em_session_examsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_session_examsCountOutputType
     */
    select?: Em_session_examsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_session_examsCountOutputType without action
   */
  export type Em_session_examsCountOutputTypeCountEm_jawaban_pesertaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_jawaban_pesertaWhereInput
  }


  /**
   * Count Type Em_session_exams_apcCountOutputType
   */

  export type Em_session_exams_apcCountOutputType = {
    em_jawaban_peserta_apc: number
    em_topic_selesai: number
  }

  export type Em_session_exams_apcCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_jawaban_peserta_apc?: boolean | Em_session_exams_apcCountOutputTypeCountEm_jawaban_peserta_apcArgs
    em_topic_selesai?: boolean | Em_session_exams_apcCountOutputTypeCountEm_topic_selesaiArgs
  }

  // Custom InputTypes
  /**
   * Em_session_exams_apcCountOutputType without action
   */
  export type Em_session_exams_apcCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Em_session_exams_apcCountOutputType
     */
    select?: Em_session_exams_apcCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Em_session_exams_apcCountOutputType without action
   */
  export type Em_session_exams_apcCountOutputTypeCountEm_jawaban_peserta_apcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_jawaban_peserta_apcWhereInput
  }

  /**
   * Em_session_exams_apcCountOutputType without action
   */
  export type Em_session_exams_apcCountOutputTypeCountEm_topic_selesaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_topic_selesaiWhereInput
  }


  /**
   * Count Type EmappCountOutputType
   */

  export type EmappCountOutputType = {
    scores: number
  }

  export type EmappCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scores?: boolean | EmappCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * EmappCountOutputType without action
   */
  export type EmappCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmappCountOutputType
     */
    select?: EmappCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmappCountOutputType without action
   */
  export type EmappCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scoresWhereInput
  }


  /**
   * Count Type EmpossCountOutputType
   */

  export type EmpossCountOutputType = {
    em_applicant_criteria: number
    em_applicant_match: number
  }

  export type EmpossCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_applicant_criteria?: boolean | EmpossCountOutputTypeCountEm_applicant_criteriaArgs
    em_applicant_match?: boolean | EmpossCountOutputTypeCountEm_applicant_matchArgs
  }

  // Custom InputTypes
  /**
   * EmpossCountOutputType without action
   */
  export type EmpossCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpossCountOutputType
     */
    select?: EmpossCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpossCountOutputType without action
   */
  export type EmpossCountOutputTypeCountEm_applicant_criteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_applicant_criteriaWhereInput
  }

  /**
   * EmpossCountOutputType without action
   */
  export type EmpossCountOutputTypeCountEm_applicant_matchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_applicant_matchWhereInput
  }


  /**
   * Models
   */

  /**
   * Model em_absensi
   */

  export type AggregateEm_absensi = {
    _count: Em_absensiCountAggregateOutputType | null
    _avg: Em_absensiAvgAggregateOutputType | null
    _sum: Em_absensiSumAggregateOutputType | null
    _min: Em_absensiMinAggregateOutputType | null
    _max: Em_absensiMaxAggregateOutputType | null
  }

  export type Em_absensiAvgAggregateOutputType = {
    Id: number | null
    faceId: number | null
  }

  export type Em_absensiSumAggregateOutputType = {
    Id: number | null
    faceId: number | null
  }

  export type Em_absensiMinAggregateOutputType = {
    Id: number | null
    faceId: number | null
    inDate: Date | null
    outDate: Date | null
    fileImage: string | null
  }

  export type Em_absensiMaxAggregateOutputType = {
    Id: number | null
    faceId: number | null
    inDate: Date | null
    outDate: Date | null
    fileImage: string | null
  }

  export type Em_absensiCountAggregateOutputType = {
    Id: number
    faceId: number
    inDate: number
    outDate: number
    fileImage: number
    _all: number
  }


  export type Em_absensiAvgAggregateInputType = {
    Id?: true
    faceId?: true
  }

  export type Em_absensiSumAggregateInputType = {
    Id?: true
    faceId?: true
  }

  export type Em_absensiMinAggregateInputType = {
    Id?: true
    faceId?: true
    inDate?: true
    outDate?: true
    fileImage?: true
  }

  export type Em_absensiMaxAggregateInputType = {
    Id?: true
    faceId?: true
    inDate?: true
    outDate?: true
    fileImage?: true
  }

  export type Em_absensiCountAggregateInputType = {
    Id?: true
    faceId?: true
    inDate?: true
    outDate?: true
    fileImage?: true
    _all?: true
  }

  export type Em_absensiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_absensi to aggregate.
     */
    where?: em_absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_absensis to fetch.
     */
    orderBy?: em_absensiOrderByWithRelationInput | em_absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_absensis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_absensis
    **/
    _count?: true | Em_absensiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_absensiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_absensiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_absensiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_absensiMaxAggregateInputType
  }

  export type GetEm_absensiAggregateType<T extends Em_absensiAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_absensi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_absensi[P]>
      : GetScalarType<T[P], AggregateEm_absensi[P]>
  }




  export type em_absensiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_absensiWhereInput
    orderBy?: em_absensiOrderByWithAggregationInput | em_absensiOrderByWithAggregationInput[]
    by: Em_absensiScalarFieldEnum[] | Em_absensiScalarFieldEnum
    having?: em_absensiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_absensiCountAggregateInputType | true
    _avg?: Em_absensiAvgAggregateInputType
    _sum?: Em_absensiSumAggregateInputType
    _min?: Em_absensiMinAggregateInputType
    _max?: Em_absensiMaxAggregateInputType
  }

  export type Em_absensiGroupByOutputType = {
    Id: number
    faceId: number | null
    inDate: Date | null
    outDate: Date | null
    fileImage: string | null
    _count: Em_absensiCountAggregateOutputType | null
    _avg: Em_absensiAvgAggregateOutputType | null
    _sum: Em_absensiSumAggregateOutputType | null
    _min: Em_absensiMinAggregateOutputType | null
    _max: Em_absensiMaxAggregateOutputType | null
  }

  type GetEm_absensiGroupByPayload<T extends em_absensiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_absensiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_absensiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_absensiGroupByOutputType[P]>
            : GetScalarType<T[P], Em_absensiGroupByOutputType[P]>
        }
      >
    >


  export type em_absensiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    faceId?: boolean
    inDate?: boolean
    outDate?: boolean
    fileImage?: boolean
  }, ExtArgs["result"]["em_absensi"]>



  export type em_absensiSelectScalar = {
    Id?: boolean
    faceId?: boolean
    inDate?: boolean
    outDate?: boolean
    fileImage?: boolean
  }

  export type em_absensiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "faceId" | "inDate" | "outDate" | "fileImage", ExtArgs["result"]["em_absensi"]>

  export type $em_absensiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_absensi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      faceId: number | null
      inDate: Date | null
      outDate: Date | null
      fileImage: string | null
    }, ExtArgs["result"]["em_absensi"]>
    composites: {}
  }

  type em_absensiGetPayload<S extends boolean | null | undefined | em_absensiDefaultArgs> = $Result.GetResult<Prisma.$em_absensiPayload, S>

  type em_absensiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_absensiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_absensiCountAggregateInputType | true
    }

  export interface em_absensiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_absensi'], meta: { name: 'em_absensi' } }
    /**
     * Find zero or one Em_absensi that matches the filter.
     * @param {em_absensiFindUniqueArgs} args - Arguments to find a Em_absensi
     * @example
     * // Get one Em_absensi
     * const em_absensi = await prisma.em_absensi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_absensiFindUniqueArgs>(args: SelectSubset<T, em_absensiFindUniqueArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_absensi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_absensiFindUniqueOrThrowArgs} args - Arguments to find a Em_absensi
     * @example
     * // Get one Em_absensi
     * const em_absensi = await prisma.em_absensi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_absensiFindUniqueOrThrowArgs>(args: SelectSubset<T, em_absensiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_absensi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_absensiFindFirstArgs} args - Arguments to find a Em_absensi
     * @example
     * // Get one Em_absensi
     * const em_absensi = await prisma.em_absensi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_absensiFindFirstArgs>(args?: SelectSubset<T, em_absensiFindFirstArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_absensi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_absensiFindFirstOrThrowArgs} args - Arguments to find a Em_absensi
     * @example
     * // Get one Em_absensi
     * const em_absensi = await prisma.em_absensi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_absensiFindFirstOrThrowArgs>(args?: SelectSubset<T, em_absensiFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_absensis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_absensiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_absensis
     * const em_absensis = await prisma.em_absensi.findMany()
     * 
     * // Get first 10 Em_absensis
     * const em_absensis = await prisma.em_absensi.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_absensiWithIdOnly = await prisma.em_absensi.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_absensiFindManyArgs>(args?: SelectSubset<T, em_absensiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_absensi.
     * @param {em_absensiCreateArgs} args - Arguments to create a Em_absensi.
     * @example
     * // Create one Em_absensi
     * const Em_absensi = await prisma.em_absensi.create({
     *   data: {
     *     // ... data to create a Em_absensi
     *   }
     * })
     * 
     */
    create<T extends em_absensiCreateArgs>(args: SelectSubset<T, em_absensiCreateArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_absensis.
     * @param {em_absensiCreateManyArgs} args - Arguments to create many Em_absensis.
     * @example
     * // Create many Em_absensis
     * const em_absensi = await prisma.em_absensi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_absensiCreateManyArgs>(args?: SelectSubset<T, em_absensiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_absensi.
     * @param {em_absensiDeleteArgs} args - Arguments to delete one Em_absensi.
     * @example
     * // Delete one Em_absensi
     * const Em_absensi = await prisma.em_absensi.delete({
     *   where: {
     *     // ... filter to delete one Em_absensi
     *   }
     * })
     * 
     */
    delete<T extends em_absensiDeleteArgs>(args: SelectSubset<T, em_absensiDeleteArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_absensi.
     * @param {em_absensiUpdateArgs} args - Arguments to update one Em_absensi.
     * @example
     * // Update one Em_absensi
     * const em_absensi = await prisma.em_absensi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_absensiUpdateArgs>(args: SelectSubset<T, em_absensiUpdateArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_absensis.
     * @param {em_absensiDeleteManyArgs} args - Arguments to filter Em_absensis to delete.
     * @example
     * // Delete a few Em_absensis
     * const { count } = await prisma.em_absensi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_absensiDeleteManyArgs>(args?: SelectSubset<T, em_absensiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_absensis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_absensiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_absensis
     * const em_absensi = await prisma.em_absensi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_absensiUpdateManyArgs>(args: SelectSubset<T, em_absensiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_absensi.
     * @param {em_absensiUpsertArgs} args - Arguments to update or create a Em_absensi.
     * @example
     * // Update or create a Em_absensi
     * const em_absensi = await prisma.em_absensi.upsert({
     *   create: {
     *     // ... data to create a Em_absensi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_absensi we want to update
     *   }
     * })
     */
    upsert<T extends em_absensiUpsertArgs>(args: SelectSubset<T, em_absensiUpsertArgs<ExtArgs>>): Prisma__em_absensiClient<$Result.GetResult<Prisma.$em_absensiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_absensis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_absensiCountArgs} args - Arguments to filter Em_absensis to count.
     * @example
     * // Count the number of Em_absensis
     * const count = await prisma.em_absensi.count({
     *   where: {
     *     // ... the filter for the Em_absensis we want to count
     *   }
     * })
    **/
    count<T extends em_absensiCountArgs>(
      args?: Subset<T, em_absensiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_absensiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_absensi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_absensiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_absensiAggregateArgs>(args: Subset<T, Em_absensiAggregateArgs>): Prisma.PrismaPromise<GetEm_absensiAggregateType<T>>

    /**
     * Group by Em_absensi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_absensiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_absensiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_absensiGroupByArgs['orderBy'] }
        : { orderBy?: em_absensiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_absensiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_absensiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_absensi model
   */
  readonly fields: em_absensiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_absensi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_absensiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_absensi model
   */
  interface em_absensiFieldRefs {
    readonly Id: FieldRef<"em_absensi", 'Int'>
    readonly faceId: FieldRef<"em_absensi", 'Int'>
    readonly inDate: FieldRef<"em_absensi", 'DateTime'>
    readonly outDate: FieldRef<"em_absensi", 'DateTime'>
    readonly fileImage: FieldRef<"em_absensi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_absensi findUnique
   */
  export type em_absensiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * Filter, which em_absensi to fetch.
     */
    where: em_absensiWhereUniqueInput
  }

  /**
   * em_absensi findUniqueOrThrow
   */
  export type em_absensiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * Filter, which em_absensi to fetch.
     */
    where: em_absensiWhereUniqueInput
  }

  /**
   * em_absensi findFirst
   */
  export type em_absensiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * Filter, which em_absensi to fetch.
     */
    where?: em_absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_absensis to fetch.
     */
    orderBy?: em_absensiOrderByWithRelationInput | em_absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_absensis.
     */
    cursor?: em_absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_absensis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_absensis.
     */
    distinct?: Em_absensiScalarFieldEnum | Em_absensiScalarFieldEnum[]
  }

  /**
   * em_absensi findFirstOrThrow
   */
  export type em_absensiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * Filter, which em_absensi to fetch.
     */
    where?: em_absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_absensis to fetch.
     */
    orderBy?: em_absensiOrderByWithRelationInput | em_absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_absensis.
     */
    cursor?: em_absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_absensis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_absensis.
     */
    distinct?: Em_absensiScalarFieldEnum | Em_absensiScalarFieldEnum[]
  }

  /**
   * em_absensi findMany
   */
  export type em_absensiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * Filter, which em_absensis to fetch.
     */
    where?: em_absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_absensis to fetch.
     */
    orderBy?: em_absensiOrderByWithRelationInput | em_absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_absensis.
     */
    cursor?: em_absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_absensis.
     */
    skip?: number
    distinct?: Em_absensiScalarFieldEnum | Em_absensiScalarFieldEnum[]
  }

  /**
   * em_absensi create
   */
  export type em_absensiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * The data needed to create a em_absensi.
     */
    data?: XOR<em_absensiCreateInput, em_absensiUncheckedCreateInput>
  }

  /**
   * em_absensi createMany
   */
  export type em_absensiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_absensis.
     */
    data: em_absensiCreateManyInput | em_absensiCreateManyInput[]
  }

  /**
   * em_absensi update
   */
  export type em_absensiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * The data needed to update a em_absensi.
     */
    data: XOR<em_absensiUpdateInput, em_absensiUncheckedUpdateInput>
    /**
     * Choose, which em_absensi to update.
     */
    where: em_absensiWhereUniqueInput
  }

  /**
   * em_absensi updateMany
   */
  export type em_absensiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_absensis.
     */
    data: XOR<em_absensiUpdateManyMutationInput, em_absensiUncheckedUpdateManyInput>
    /**
     * Filter which em_absensis to update
     */
    where?: em_absensiWhereInput
    /**
     * Limit how many em_absensis to update.
     */
    limit?: number
  }

  /**
   * em_absensi upsert
   */
  export type em_absensiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * The filter to search for the em_absensi to update in case it exists.
     */
    where: em_absensiWhereUniqueInput
    /**
     * In case the em_absensi found by the `where` argument doesn't exist, create a new em_absensi with this data.
     */
    create: XOR<em_absensiCreateInput, em_absensiUncheckedCreateInput>
    /**
     * In case the em_absensi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_absensiUpdateInput, em_absensiUncheckedUpdateInput>
  }

  /**
   * em_absensi delete
   */
  export type em_absensiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
    /**
     * Filter which em_absensi to delete.
     */
    where: em_absensiWhereUniqueInput
  }

  /**
   * em_absensi deleteMany
   */
  export type em_absensiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_absensis to delete
     */
    where?: em_absensiWhereInput
    /**
     * Limit how many em_absensis to delete.
     */
    limit?: number
  }

  /**
   * em_absensi without action
   */
  export type em_absensiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_absensi
     */
    select?: em_absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_absensi
     */
    omit?: em_absensiOmit<ExtArgs> | null
  }


  /**
   * Model em_apc_academy
   */

  export type AggregateEm_apc_academy = {
    _count: Em_apc_academyCountAggregateOutputType | null
    _avg: Em_apc_academyAvgAggregateOutputType | null
    _sum: Em_apc_academySumAggregateOutputType | null
    _min: Em_apc_academyMinAggregateOutputType | null
    _max: Em_apc_academyMaxAggregateOutputType | null
  }

  export type Em_apc_academyAvgAggregateOutputType = {
    AcademyId: number | null
    ApcId: number | null
    IPK: number | null
  }

  export type Em_apc_academySumAggregateOutputType = {
    AcademyId: number | null
    ApcId: number | null
    IPK: number | null
  }

  export type Em_apc_academyMinAggregateOutputType = {
    AcademyId: number | null
    ApcId: number | null
    SchoolName: string | null
    Province: string | null
    Major: string | null
    Degree: string | null
    EnrollDate: Date | null
    GraduatDate: Date | null
    IPK: number | null
    OrganizeExperience: string | null
    Explain: string | null
    GradeSchool: string | null
    DailySchedule: string | null
    SchoolAddress: string | null
  }

  export type Em_apc_academyMaxAggregateOutputType = {
    AcademyId: number | null
    ApcId: number | null
    SchoolName: string | null
    Province: string | null
    Major: string | null
    Degree: string | null
    EnrollDate: Date | null
    GraduatDate: Date | null
    IPK: number | null
    OrganizeExperience: string | null
    Explain: string | null
    GradeSchool: string | null
    DailySchedule: string | null
    SchoolAddress: string | null
  }

  export type Em_apc_academyCountAggregateOutputType = {
    AcademyId: number
    ApcId: number
    SchoolName: number
    Province: number
    Major: number
    Degree: number
    EnrollDate: number
    GraduatDate: number
    IPK: number
    OrganizeExperience: number
    Explain: number
    GradeSchool: number
    DailySchedule: number
    SchoolAddress: number
    _all: number
  }


  export type Em_apc_academyAvgAggregateInputType = {
    AcademyId?: true
    ApcId?: true
    IPK?: true
  }

  export type Em_apc_academySumAggregateInputType = {
    AcademyId?: true
    ApcId?: true
    IPK?: true
  }

  export type Em_apc_academyMinAggregateInputType = {
    AcademyId?: true
    ApcId?: true
    SchoolName?: true
    Province?: true
    Major?: true
    Degree?: true
    EnrollDate?: true
    GraduatDate?: true
    IPK?: true
    OrganizeExperience?: true
    Explain?: true
    GradeSchool?: true
    DailySchedule?: true
    SchoolAddress?: true
  }

  export type Em_apc_academyMaxAggregateInputType = {
    AcademyId?: true
    ApcId?: true
    SchoolName?: true
    Province?: true
    Major?: true
    Degree?: true
    EnrollDate?: true
    GraduatDate?: true
    IPK?: true
    OrganizeExperience?: true
    Explain?: true
    GradeSchool?: true
    DailySchedule?: true
    SchoolAddress?: true
  }

  export type Em_apc_academyCountAggregateInputType = {
    AcademyId?: true
    ApcId?: true
    SchoolName?: true
    Province?: true
    Major?: true
    Degree?: true
    EnrollDate?: true
    GraduatDate?: true
    IPK?: true
    OrganizeExperience?: true
    Explain?: true
    GradeSchool?: true
    DailySchedule?: true
    SchoolAddress?: true
    _all?: true
  }

  export type Em_apc_academyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_academy to aggregate.
     */
    where?: em_apc_academyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_academies to fetch.
     */
    orderBy?: em_apc_academyOrderByWithRelationInput | em_apc_academyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_apc_academyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_academies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_apc_academies
    **/
    _count?: true | Em_apc_academyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_apc_academyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_apc_academySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_apc_academyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_apc_academyMaxAggregateInputType
  }

  export type GetEm_apc_academyAggregateType<T extends Em_apc_academyAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_apc_academy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_apc_academy[P]>
      : GetScalarType<T[P], AggregateEm_apc_academy[P]>
  }




  export type em_apc_academyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_academyWhereInput
    orderBy?: em_apc_academyOrderByWithAggregationInput | em_apc_academyOrderByWithAggregationInput[]
    by: Em_apc_academyScalarFieldEnum[] | Em_apc_academyScalarFieldEnum
    having?: em_apc_academyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_apc_academyCountAggregateInputType | true
    _avg?: Em_apc_academyAvgAggregateInputType
    _sum?: Em_apc_academySumAggregateInputType
    _min?: Em_apc_academyMinAggregateInputType
    _max?: Em_apc_academyMaxAggregateInputType
  }

  export type Em_apc_academyGroupByOutputType = {
    AcademyId: number
    ApcId: number
    SchoolName: string | null
    Province: string | null
    Major: string | null
    Degree: string | null
    EnrollDate: Date | null
    GraduatDate: Date | null
    IPK: number | null
    OrganizeExperience: string | null
    Explain: string | null
    GradeSchool: string | null
    DailySchedule: string | null
    SchoolAddress: string | null
    _count: Em_apc_academyCountAggregateOutputType | null
    _avg: Em_apc_academyAvgAggregateOutputType | null
    _sum: Em_apc_academySumAggregateOutputType | null
    _min: Em_apc_academyMinAggregateOutputType | null
    _max: Em_apc_academyMaxAggregateOutputType | null
  }

  type GetEm_apc_academyGroupByPayload<T extends em_apc_academyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_apc_academyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_apc_academyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_apc_academyGroupByOutputType[P]>
            : GetScalarType<T[P], Em_apc_academyGroupByOutputType[P]>
        }
      >
    >


  export type em_apc_academySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AcademyId?: boolean
    ApcId?: boolean
    SchoolName?: boolean
    Province?: boolean
    Major?: boolean
    Degree?: boolean
    EnrollDate?: boolean
    GraduatDate?: boolean
    IPK?: boolean
    OrganizeExperience?: boolean
    Explain?: boolean
    GradeSchool?: boolean
    DailySchedule?: boolean
    SchoolAddress?: boolean
    em_apc_personal?: boolean | em_apc_personalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_apc_academy"]>



  export type em_apc_academySelectScalar = {
    AcademyId?: boolean
    ApcId?: boolean
    SchoolName?: boolean
    Province?: boolean
    Major?: boolean
    Degree?: boolean
    EnrollDate?: boolean
    GraduatDate?: boolean
    IPK?: boolean
    OrganizeExperience?: boolean
    Explain?: boolean
    GradeSchool?: boolean
    DailySchedule?: boolean
    SchoolAddress?: boolean
  }

  export type em_apc_academyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AcademyId" | "ApcId" | "SchoolName" | "Province" | "Major" | "Degree" | "EnrollDate" | "GraduatDate" | "IPK" | "OrganizeExperience" | "Explain" | "GradeSchool" | "DailySchedule" | "SchoolAddress", ExtArgs["result"]["em_apc_academy"]>
  export type em_apc_academyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_personal?: boolean | em_apc_personalDefaultArgs<ExtArgs>
  }

  export type $em_apc_academyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_apc_academy"
    objects: {
      em_apc_personal: Prisma.$em_apc_personalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      AcademyId: number
      ApcId: number
      SchoolName: string | null
      Province: string | null
      Major: string | null
      Degree: string | null
      EnrollDate: Date | null
      GraduatDate: Date | null
      IPK: number | null
      OrganizeExperience: string | null
      Explain: string | null
      GradeSchool: string | null
      DailySchedule: string | null
      SchoolAddress: string | null
    }, ExtArgs["result"]["em_apc_academy"]>
    composites: {}
  }

  type em_apc_academyGetPayload<S extends boolean | null | undefined | em_apc_academyDefaultArgs> = $Result.GetResult<Prisma.$em_apc_academyPayload, S>

  type em_apc_academyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_apc_academyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_apc_academyCountAggregateInputType | true
    }

  export interface em_apc_academyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_apc_academy'], meta: { name: 'em_apc_academy' } }
    /**
     * Find zero or one Em_apc_academy that matches the filter.
     * @param {em_apc_academyFindUniqueArgs} args - Arguments to find a Em_apc_academy
     * @example
     * // Get one Em_apc_academy
     * const em_apc_academy = await prisma.em_apc_academy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_apc_academyFindUniqueArgs>(args: SelectSubset<T, em_apc_academyFindUniqueArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_apc_academy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_apc_academyFindUniqueOrThrowArgs} args - Arguments to find a Em_apc_academy
     * @example
     * // Get one Em_apc_academy
     * const em_apc_academy = await prisma.em_apc_academy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_apc_academyFindUniqueOrThrowArgs>(args: SelectSubset<T, em_apc_academyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_academy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_academyFindFirstArgs} args - Arguments to find a Em_apc_academy
     * @example
     * // Get one Em_apc_academy
     * const em_apc_academy = await prisma.em_apc_academy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_apc_academyFindFirstArgs>(args?: SelectSubset<T, em_apc_academyFindFirstArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_academy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_academyFindFirstOrThrowArgs} args - Arguments to find a Em_apc_academy
     * @example
     * // Get one Em_apc_academy
     * const em_apc_academy = await prisma.em_apc_academy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_apc_academyFindFirstOrThrowArgs>(args?: SelectSubset<T, em_apc_academyFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_apc_academies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_academyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_apc_academies
     * const em_apc_academies = await prisma.em_apc_academy.findMany()
     * 
     * // Get first 10 Em_apc_academies
     * const em_apc_academies = await prisma.em_apc_academy.findMany({ take: 10 })
     * 
     * // Only select the `AcademyId`
     * const em_apc_academyWithAcademyIdOnly = await prisma.em_apc_academy.findMany({ select: { AcademyId: true } })
     * 
     */
    findMany<T extends em_apc_academyFindManyArgs>(args?: SelectSubset<T, em_apc_academyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_apc_academy.
     * @param {em_apc_academyCreateArgs} args - Arguments to create a Em_apc_academy.
     * @example
     * // Create one Em_apc_academy
     * const Em_apc_academy = await prisma.em_apc_academy.create({
     *   data: {
     *     // ... data to create a Em_apc_academy
     *   }
     * })
     * 
     */
    create<T extends em_apc_academyCreateArgs>(args: SelectSubset<T, em_apc_academyCreateArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_apc_academies.
     * @param {em_apc_academyCreateManyArgs} args - Arguments to create many Em_apc_academies.
     * @example
     * // Create many Em_apc_academies
     * const em_apc_academy = await prisma.em_apc_academy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_apc_academyCreateManyArgs>(args?: SelectSubset<T, em_apc_academyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_apc_academy.
     * @param {em_apc_academyDeleteArgs} args - Arguments to delete one Em_apc_academy.
     * @example
     * // Delete one Em_apc_academy
     * const Em_apc_academy = await prisma.em_apc_academy.delete({
     *   where: {
     *     // ... filter to delete one Em_apc_academy
     *   }
     * })
     * 
     */
    delete<T extends em_apc_academyDeleteArgs>(args: SelectSubset<T, em_apc_academyDeleteArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_apc_academy.
     * @param {em_apc_academyUpdateArgs} args - Arguments to update one Em_apc_academy.
     * @example
     * // Update one Em_apc_academy
     * const em_apc_academy = await prisma.em_apc_academy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_apc_academyUpdateArgs>(args: SelectSubset<T, em_apc_academyUpdateArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_apc_academies.
     * @param {em_apc_academyDeleteManyArgs} args - Arguments to filter Em_apc_academies to delete.
     * @example
     * // Delete a few Em_apc_academies
     * const { count } = await prisma.em_apc_academy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_apc_academyDeleteManyArgs>(args?: SelectSubset<T, em_apc_academyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_apc_academies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_academyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_apc_academies
     * const em_apc_academy = await prisma.em_apc_academy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_apc_academyUpdateManyArgs>(args: SelectSubset<T, em_apc_academyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_apc_academy.
     * @param {em_apc_academyUpsertArgs} args - Arguments to update or create a Em_apc_academy.
     * @example
     * // Update or create a Em_apc_academy
     * const em_apc_academy = await prisma.em_apc_academy.upsert({
     *   create: {
     *     // ... data to create a Em_apc_academy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_apc_academy we want to update
     *   }
     * })
     */
    upsert<T extends em_apc_academyUpsertArgs>(args: SelectSubset<T, em_apc_academyUpsertArgs<ExtArgs>>): Prisma__em_apc_academyClient<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_apc_academies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_academyCountArgs} args - Arguments to filter Em_apc_academies to count.
     * @example
     * // Count the number of Em_apc_academies
     * const count = await prisma.em_apc_academy.count({
     *   where: {
     *     // ... the filter for the Em_apc_academies we want to count
     *   }
     * })
    **/
    count<T extends em_apc_academyCountArgs>(
      args?: Subset<T, em_apc_academyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_apc_academyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_apc_academy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_apc_academyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_apc_academyAggregateArgs>(args: Subset<T, Em_apc_academyAggregateArgs>): Prisma.PrismaPromise<GetEm_apc_academyAggregateType<T>>

    /**
     * Group by Em_apc_academy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_academyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_apc_academyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_apc_academyGroupByArgs['orderBy'] }
        : { orderBy?: em_apc_academyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_apc_academyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_apc_academyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_apc_academy model
   */
  readonly fields: em_apc_academyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_apc_academy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_apc_academyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_apc_personal<T extends em_apc_personalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personalDefaultArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_apc_academy model
   */
  interface em_apc_academyFieldRefs {
    readonly AcademyId: FieldRef<"em_apc_academy", 'Int'>
    readonly ApcId: FieldRef<"em_apc_academy", 'Int'>
    readonly SchoolName: FieldRef<"em_apc_academy", 'String'>
    readonly Province: FieldRef<"em_apc_academy", 'String'>
    readonly Major: FieldRef<"em_apc_academy", 'String'>
    readonly Degree: FieldRef<"em_apc_academy", 'String'>
    readonly EnrollDate: FieldRef<"em_apc_academy", 'DateTime'>
    readonly GraduatDate: FieldRef<"em_apc_academy", 'DateTime'>
    readonly IPK: FieldRef<"em_apc_academy", 'Float'>
    readonly OrganizeExperience: FieldRef<"em_apc_academy", 'String'>
    readonly Explain: FieldRef<"em_apc_academy", 'String'>
    readonly GradeSchool: FieldRef<"em_apc_academy", 'String'>
    readonly DailySchedule: FieldRef<"em_apc_academy", 'String'>
    readonly SchoolAddress: FieldRef<"em_apc_academy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_apc_academy findUnique
   */
  export type em_apc_academyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_academy to fetch.
     */
    where: em_apc_academyWhereUniqueInput
  }

  /**
   * em_apc_academy findUniqueOrThrow
   */
  export type em_apc_academyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_academy to fetch.
     */
    where: em_apc_academyWhereUniqueInput
  }

  /**
   * em_apc_academy findFirst
   */
  export type em_apc_academyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_academy to fetch.
     */
    where?: em_apc_academyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_academies to fetch.
     */
    orderBy?: em_apc_academyOrderByWithRelationInput | em_apc_academyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_academies.
     */
    cursor?: em_apc_academyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_academies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_academies.
     */
    distinct?: Em_apc_academyScalarFieldEnum | Em_apc_academyScalarFieldEnum[]
  }

  /**
   * em_apc_academy findFirstOrThrow
   */
  export type em_apc_academyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_academy to fetch.
     */
    where?: em_apc_academyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_academies to fetch.
     */
    orderBy?: em_apc_academyOrderByWithRelationInput | em_apc_academyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_academies.
     */
    cursor?: em_apc_academyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_academies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_academies.
     */
    distinct?: Em_apc_academyScalarFieldEnum | Em_apc_academyScalarFieldEnum[]
  }

  /**
   * em_apc_academy findMany
   */
  export type em_apc_academyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_academies to fetch.
     */
    where?: em_apc_academyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_academies to fetch.
     */
    orderBy?: em_apc_academyOrderByWithRelationInput | em_apc_academyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_apc_academies.
     */
    cursor?: em_apc_academyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_academies.
     */
    skip?: number
    distinct?: Em_apc_academyScalarFieldEnum | Em_apc_academyScalarFieldEnum[]
  }

  /**
   * em_apc_academy create
   */
  export type em_apc_academyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * The data needed to create a em_apc_academy.
     */
    data: XOR<em_apc_academyCreateInput, em_apc_academyUncheckedCreateInput>
  }

  /**
   * em_apc_academy createMany
   */
  export type em_apc_academyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_apc_academies.
     */
    data: em_apc_academyCreateManyInput | em_apc_academyCreateManyInput[]
  }

  /**
   * em_apc_academy update
   */
  export type em_apc_academyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * The data needed to update a em_apc_academy.
     */
    data: XOR<em_apc_academyUpdateInput, em_apc_academyUncheckedUpdateInput>
    /**
     * Choose, which em_apc_academy to update.
     */
    where: em_apc_academyWhereUniqueInput
  }

  /**
   * em_apc_academy updateMany
   */
  export type em_apc_academyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_apc_academies.
     */
    data: XOR<em_apc_academyUpdateManyMutationInput, em_apc_academyUncheckedUpdateManyInput>
    /**
     * Filter which em_apc_academies to update
     */
    where?: em_apc_academyWhereInput
    /**
     * Limit how many em_apc_academies to update.
     */
    limit?: number
  }

  /**
   * em_apc_academy upsert
   */
  export type em_apc_academyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * The filter to search for the em_apc_academy to update in case it exists.
     */
    where: em_apc_academyWhereUniqueInput
    /**
     * In case the em_apc_academy found by the `where` argument doesn't exist, create a new em_apc_academy with this data.
     */
    create: XOR<em_apc_academyCreateInput, em_apc_academyUncheckedCreateInput>
    /**
     * In case the em_apc_academy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_apc_academyUpdateInput, em_apc_academyUncheckedUpdateInput>
  }

  /**
   * em_apc_academy delete
   */
  export type em_apc_academyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    /**
     * Filter which em_apc_academy to delete.
     */
    where: em_apc_academyWhereUniqueInput
  }

  /**
   * em_apc_academy deleteMany
   */
  export type em_apc_academyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_academies to delete
     */
    where?: em_apc_academyWhereInput
    /**
     * Limit how many em_apc_academies to delete.
     */
    limit?: number
  }

  /**
   * em_apc_academy without action
   */
  export type em_apc_academyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
  }


  /**
   * Model em_apc_personal
   */

  export type AggregateEm_apc_personal = {
    _count: Em_apc_personalCountAggregateOutputType | null
    _avg: Em_apc_personalAvgAggregateOutputType | null
    _sum: Em_apc_personalSumAggregateOutputType | null
    _min: Em_apc_personalMinAggregateOutputType | null
    _max: Em_apc_personalMaxAggregateOutputType | null
  }

  export type Em_apc_personalAvgAggregateOutputType = {
    ApcId: number | null
    PossId: number | null
    Age: number | null
    Gender: number | null
    Religion: number | null
    MaritalStats: number | null
    Citizenship: number | null
    Province: number | null
    Regency: number | null
    Subdistrict: number | null
    PhoneCode: number | null
    Height: number | null
    Weight: number | null
    NumofSibling: number | null
    LokCat: number | null
    isSosmedId: number | null
    IsCall: number | null
  }

  export type Em_apc_personalSumAggregateOutputType = {
    ApcId: number | null
    PossId: number | null
    Age: number | null
    Gender: number | null
    Religion: number | null
    MaritalStats: number | null
    Citizenship: number | null
    Province: number | null
    Regency: number | null
    Subdistrict: number | null
    PhoneCode: number | null
    Height: number | null
    Weight: number | null
    NumofSibling: number | null
    LokCat: number | null
    isSosmedId: number | null
    IsCall: number | null
  }

  export type Em_apc_personalMinAggregateOutputType = {
    ApcId: number | null
    PossId: number | null
    AboutUs: string | null
    FullName: string | null
    NickName: string | null
    PlaceBirth: string | null
    DateBirth: Date | null
    Age: number | null
    Gender: number | null
    Religion: number | null
    MaritalStats: number | null
    Citizenship: number | null
    Province: number | null
    Regency: number | null
    Subdistrict: number | null
    PostCode: string | null
    Address: string | null
    IdentityType: string | null
    IdentityNumber: string | null
    PhoneCode: number | null
    PhoneNumber: string | null
    EmailAddress: string | null
    Height: number | null
    Weight: number | null
    FatherName: string | null
    FatherOccupa: string | null
    MotherName: string | null
    MotherOccupa: string | null
    NumofSibling: number | null
    SiblingNote: string | null
    NikFileName: string | null
    PhotoFileName: string | null
    CvFileName: string | null
    IsTransferPosst: string | null
    Status: string | null
    CreatedAt: Date | null
    isHobby: string | null
    LokCat: number | null
    isSosmedId: number | null
    isSosmed: string | null
    IsCall: number | null
    DateCall: Date | null
    isLinked: string | null
    PossName: string | null
  }

  export type Em_apc_personalMaxAggregateOutputType = {
    ApcId: number | null
    PossId: number | null
    AboutUs: string | null
    FullName: string | null
    NickName: string | null
    PlaceBirth: string | null
    DateBirth: Date | null
    Age: number | null
    Gender: number | null
    Religion: number | null
    MaritalStats: number | null
    Citizenship: number | null
    Province: number | null
    Regency: number | null
    Subdistrict: number | null
    PostCode: string | null
    Address: string | null
    IdentityType: string | null
    IdentityNumber: string | null
    PhoneCode: number | null
    PhoneNumber: string | null
    EmailAddress: string | null
    Height: number | null
    Weight: number | null
    FatherName: string | null
    FatherOccupa: string | null
    MotherName: string | null
    MotherOccupa: string | null
    NumofSibling: number | null
    SiblingNote: string | null
    NikFileName: string | null
    PhotoFileName: string | null
    CvFileName: string | null
    IsTransferPosst: string | null
    Status: string | null
    CreatedAt: Date | null
    isHobby: string | null
    LokCat: number | null
    isSosmedId: number | null
    isSosmed: string | null
    IsCall: number | null
    DateCall: Date | null
    isLinked: string | null
    PossName: string | null
  }

  export type Em_apc_personalCountAggregateOutputType = {
    ApcId: number
    PossId: number
    AboutUs: number
    FullName: number
    NickName: number
    PlaceBirth: number
    DateBirth: number
    Age: number
    Gender: number
    Religion: number
    MaritalStats: number
    Citizenship: number
    Province: number
    Regency: number
    Subdistrict: number
    PostCode: number
    Address: number
    IdentityType: number
    IdentityNumber: number
    PhoneCode: number
    PhoneNumber: number
    EmailAddress: number
    Height: number
    Weight: number
    FatherName: number
    FatherOccupa: number
    MotherName: number
    MotherOccupa: number
    NumofSibling: number
    SiblingNote: number
    NikFileName: number
    PhotoFileName: number
    CvFileName: number
    IsTransferPosst: number
    Status: number
    CreatedAt: number
    isHobby: number
    LokCat: number
    isSosmedId: number
    isSosmed: number
    IsCall: number
    DateCall: number
    isLinked: number
    PossName: number
    _all: number
  }


  export type Em_apc_personalAvgAggregateInputType = {
    ApcId?: true
    PossId?: true
    Age?: true
    Gender?: true
    Religion?: true
    MaritalStats?: true
    Citizenship?: true
    Province?: true
    Regency?: true
    Subdistrict?: true
    PhoneCode?: true
    Height?: true
    Weight?: true
    NumofSibling?: true
    LokCat?: true
    isSosmedId?: true
    IsCall?: true
  }

  export type Em_apc_personalSumAggregateInputType = {
    ApcId?: true
    PossId?: true
    Age?: true
    Gender?: true
    Religion?: true
    MaritalStats?: true
    Citizenship?: true
    Province?: true
    Regency?: true
    Subdistrict?: true
    PhoneCode?: true
    Height?: true
    Weight?: true
    NumofSibling?: true
    LokCat?: true
    isSosmedId?: true
    IsCall?: true
  }

  export type Em_apc_personalMinAggregateInputType = {
    ApcId?: true
    PossId?: true
    AboutUs?: true
    FullName?: true
    NickName?: true
    PlaceBirth?: true
    DateBirth?: true
    Age?: true
    Gender?: true
    Religion?: true
    MaritalStats?: true
    Citizenship?: true
    Province?: true
    Regency?: true
    Subdistrict?: true
    PostCode?: true
    Address?: true
    IdentityType?: true
    IdentityNumber?: true
    PhoneCode?: true
    PhoneNumber?: true
    EmailAddress?: true
    Height?: true
    Weight?: true
    FatherName?: true
    FatherOccupa?: true
    MotherName?: true
    MotherOccupa?: true
    NumofSibling?: true
    SiblingNote?: true
    NikFileName?: true
    PhotoFileName?: true
    CvFileName?: true
    IsTransferPosst?: true
    Status?: true
    CreatedAt?: true
    isHobby?: true
    LokCat?: true
    isSosmedId?: true
    isSosmed?: true
    IsCall?: true
    DateCall?: true
    isLinked?: true
    PossName?: true
  }

  export type Em_apc_personalMaxAggregateInputType = {
    ApcId?: true
    PossId?: true
    AboutUs?: true
    FullName?: true
    NickName?: true
    PlaceBirth?: true
    DateBirth?: true
    Age?: true
    Gender?: true
    Religion?: true
    MaritalStats?: true
    Citizenship?: true
    Province?: true
    Regency?: true
    Subdistrict?: true
    PostCode?: true
    Address?: true
    IdentityType?: true
    IdentityNumber?: true
    PhoneCode?: true
    PhoneNumber?: true
    EmailAddress?: true
    Height?: true
    Weight?: true
    FatherName?: true
    FatherOccupa?: true
    MotherName?: true
    MotherOccupa?: true
    NumofSibling?: true
    SiblingNote?: true
    NikFileName?: true
    PhotoFileName?: true
    CvFileName?: true
    IsTransferPosst?: true
    Status?: true
    CreatedAt?: true
    isHobby?: true
    LokCat?: true
    isSosmedId?: true
    isSosmed?: true
    IsCall?: true
    DateCall?: true
    isLinked?: true
    PossName?: true
  }

  export type Em_apc_personalCountAggregateInputType = {
    ApcId?: true
    PossId?: true
    AboutUs?: true
    FullName?: true
    NickName?: true
    PlaceBirth?: true
    DateBirth?: true
    Age?: true
    Gender?: true
    Religion?: true
    MaritalStats?: true
    Citizenship?: true
    Province?: true
    Regency?: true
    Subdistrict?: true
    PostCode?: true
    Address?: true
    IdentityType?: true
    IdentityNumber?: true
    PhoneCode?: true
    PhoneNumber?: true
    EmailAddress?: true
    Height?: true
    Weight?: true
    FatherName?: true
    FatherOccupa?: true
    MotherName?: true
    MotherOccupa?: true
    NumofSibling?: true
    SiblingNote?: true
    NikFileName?: true
    PhotoFileName?: true
    CvFileName?: true
    IsTransferPosst?: true
    Status?: true
    CreatedAt?: true
    isHobby?: true
    LokCat?: true
    isSosmedId?: true
    isSosmed?: true
    IsCall?: true
    DateCall?: true
    isLinked?: true
    PossName?: true
    _all?: true
  }

  export type Em_apc_personalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_personal to aggregate.
     */
    where?: em_apc_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_personals to fetch.
     */
    orderBy?: em_apc_personalOrderByWithRelationInput | em_apc_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_apc_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_apc_personals
    **/
    _count?: true | Em_apc_personalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_apc_personalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_apc_personalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_apc_personalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_apc_personalMaxAggregateInputType
  }

  export type GetEm_apc_personalAggregateType<T extends Em_apc_personalAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_apc_personal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_apc_personal[P]>
      : GetScalarType<T[P], AggregateEm_apc_personal[P]>
  }




  export type em_apc_personalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_personalWhereInput
    orderBy?: em_apc_personalOrderByWithAggregationInput | em_apc_personalOrderByWithAggregationInput[]
    by: Em_apc_personalScalarFieldEnum[] | Em_apc_personalScalarFieldEnum
    having?: em_apc_personalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_apc_personalCountAggregateInputType | true
    _avg?: Em_apc_personalAvgAggregateInputType
    _sum?: Em_apc_personalSumAggregateInputType
    _min?: Em_apc_personalMinAggregateInputType
    _max?: Em_apc_personalMaxAggregateInputType
  }

  export type Em_apc_personalGroupByOutputType = {
    ApcId: number
    PossId: number | null
    AboutUs: string | null
    FullName: string | null
    NickName: string | null
    PlaceBirth: string | null
    DateBirth: Date | null
    Age: number | null
    Gender: number | null
    Religion: number | null
    MaritalStats: number | null
    Citizenship: number | null
    Province: number | null
    Regency: number | null
    Subdistrict: number | null
    PostCode: string | null
    Address: string | null
    IdentityType: string | null
    IdentityNumber: string | null
    PhoneCode: number | null
    PhoneNumber: string | null
    EmailAddress: string | null
    Height: number | null
    Weight: number | null
    FatherName: string | null
    FatherOccupa: string | null
    MotherName: string | null
    MotherOccupa: string | null
    NumofSibling: number | null
    SiblingNote: string | null
    NikFileName: string | null
    PhotoFileName: string | null
    CvFileName: string | null
    IsTransferPosst: string | null
    Status: string | null
    CreatedAt: Date | null
    isHobby: string | null
    LokCat: number | null
    isSosmedId: number | null
    isSosmed: string | null
    IsCall: number | null
    DateCall: Date | null
    isLinked: string | null
    PossName: string | null
    _count: Em_apc_personalCountAggregateOutputType | null
    _avg: Em_apc_personalAvgAggregateOutputType | null
    _sum: Em_apc_personalSumAggregateOutputType | null
    _min: Em_apc_personalMinAggregateOutputType | null
    _max: Em_apc_personalMaxAggregateOutputType | null
  }

  type GetEm_apc_personalGroupByPayload<T extends em_apc_personalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_apc_personalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_apc_personalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_apc_personalGroupByOutputType[P]>
            : GetScalarType<T[P], Em_apc_personalGroupByOutputType[P]>
        }
      >
    >


  export type em_apc_personalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ApcId?: boolean
    PossId?: boolean
    AboutUs?: boolean
    FullName?: boolean
    NickName?: boolean
    PlaceBirth?: boolean
    DateBirth?: boolean
    Age?: boolean
    Gender?: boolean
    Religion?: boolean
    MaritalStats?: boolean
    Citizenship?: boolean
    Province?: boolean
    Regency?: boolean
    Subdistrict?: boolean
    PostCode?: boolean
    Address?: boolean
    IdentityType?: boolean
    IdentityNumber?: boolean
    PhoneCode?: boolean
    PhoneNumber?: boolean
    EmailAddress?: boolean
    Height?: boolean
    Weight?: boolean
    FatherName?: boolean
    FatherOccupa?: boolean
    MotherName?: boolean
    MotherOccupa?: boolean
    NumofSibling?: boolean
    SiblingNote?: boolean
    NikFileName?: boolean
    PhotoFileName?: boolean
    CvFileName?: boolean
    IsTransferPosst?: boolean
    Status?: boolean
    CreatedAt?: boolean
    isHobby?: boolean
    LokCat?: boolean
    isSosmedId?: boolean
    isSosmed?: boolean
    IsCall?: boolean
    DateCall?: boolean
    isLinked?: boolean
    PossName?: boolean
    em_apc_academy?: boolean | em_apc_personal$em_apc_academyArgs<ExtArgs>
    em_apc_photograph?: boolean | em_apc_personal$em_apc_photographArgs<ExtArgs>
    em_apc_regulation?: boolean | em_apc_personal$em_apc_regulationArgs<ExtArgs>
    em_apc_skill_exper?: boolean | em_apc_personal$em_apc_skill_experArgs<ExtArgs>
    em_applicant_match?: boolean | em_apc_personal$em_applicant_matchArgs<ExtArgs>
    _count?: boolean | Em_apc_personalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_apc_personal"]>



  export type em_apc_personalSelectScalar = {
    ApcId?: boolean
    PossId?: boolean
    AboutUs?: boolean
    FullName?: boolean
    NickName?: boolean
    PlaceBirth?: boolean
    DateBirth?: boolean
    Age?: boolean
    Gender?: boolean
    Religion?: boolean
    MaritalStats?: boolean
    Citizenship?: boolean
    Province?: boolean
    Regency?: boolean
    Subdistrict?: boolean
    PostCode?: boolean
    Address?: boolean
    IdentityType?: boolean
    IdentityNumber?: boolean
    PhoneCode?: boolean
    PhoneNumber?: boolean
    EmailAddress?: boolean
    Height?: boolean
    Weight?: boolean
    FatherName?: boolean
    FatherOccupa?: boolean
    MotherName?: boolean
    MotherOccupa?: boolean
    NumofSibling?: boolean
    SiblingNote?: boolean
    NikFileName?: boolean
    PhotoFileName?: boolean
    CvFileName?: boolean
    IsTransferPosst?: boolean
    Status?: boolean
    CreatedAt?: boolean
    isHobby?: boolean
    LokCat?: boolean
    isSosmedId?: boolean
    isSosmed?: boolean
    IsCall?: boolean
    DateCall?: boolean
    isLinked?: boolean
    PossName?: boolean
  }

  export type em_apc_personalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ApcId" | "PossId" | "AboutUs" | "FullName" | "NickName" | "PlaceBirth" | "DateBirth" | "Age" | "Gender" | "Religion" | "MaritalStats" | "Citizenship" | "Province" | "Regency" | "Subdistrict" | "PostCode" | "Address" | "IdentityType" | "IdentityNumber" | "PhoneCode" | "PhoneNumber" | "EmailAddress" | "Height" | "Weight" | "FatherName" | "FatherOccupa" | "MotherName" | "MotherOccupa" | "NumofSibling" | "SiblingNote" | "NikFileName" | "PhotoFileName" | "CvFileName" | "IsTransferPosst" | "Status" | "CreatedAt" | "isHobby" | "LokCat" | "isSosmedId" | "isSosmed" | "IsCall" | "DateCall" | "isLinked" | "PossName", ExtArgs["result"]["em_apc_personal"]>
  export type em_apc_personalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_academy?: boolean | em_apc_personal$em_apc_academyArgs<ExtArgs>
    em_apc_photograph?: boolean | em_apc_personal$em_apc_photographArgs<ExtArgs>
    em_apc_regulation?: boolean | em_apc_personal$em_apc_regulationArgs<ExtArgs>
    em_apc_skill_exper?: boolean | em_apc_personal$em_apc_skill_experArgs<ExtArgs>
    em_applicant_match?: boolean | em_apc_personal$em_applicant_matchArgs<ExtArgs>
    _count?: boolean | Em_apc_personalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_apc_personalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_apc_personal"
    objects: {
      em_apc_academy: Prisma.$em_apc_academyPayload<ExtArgs>[]
      em_apc_photograph: Prisma.$em_apc_photographPayload<ExtArgs>[]
      em_apc_regulation: Prisma.$em_apc_regulationPayload<ExtArgs>[]
      em_apc_skill_exper: Prisma.$em_apc_skill_experPayload<ExtArgs>[]
      em_applicant_match: Prisma.$em_applicant_matchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ApcId: number
      PossId: number | null
      AboutUs: string | null
      FullName: string | null
      NickName: string | null
      PlaceBirth: string | null
      DateBirth: Date | null
      Age: number | null
      Gender: number | null
      Religion: number | null
      MaritalStats: number | null
      Citizenship: number | null
      Province: number | null
      Regency: number | null
      Subdistrict: number | null
      PostCode: string | null
      Address: string | null
      IdentityType: string | null
      IdentityNumber: string | null
      PhoneCode: number | null
      PhoneNumber: string | null
      EmailAddress: string | null
      Height: number | null
      Weight: number | null
      FatherName: string | null
      FatherOccupa: string | null
      MotherName: string | null
      MotherOccupa: string | null
      NumofSibling: number | null
      SiblingNote: string | null
      NikFileName: string | null
      PhotoFileName: string | null
      CvFileName: string | null
      IsTransferPosst: string | null
      Status: string | null
      CreatedAt: Date | null
      isHobby: string | null
      LokCat: number | null
      isSosmedId: number | null
      isSosmed: string | null
      IsCall: number | null
      DateCall: Date | null
      isLinked: string | null
      PossName: string | null
    }, ExtArgs["result"]["em_apc_personal"]>
    composites: {}
  }

  type em_apc_personalGetPayload<S extends boolean | null | undefined | em_apc_personalDefaultArgs> = $Result.GetResult<Prisma.$em_apc_personalPayload, S>

  type em_apc_personalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_apc_personalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_apc_personalCountAggregateInputType | true
    }

  export interface em_apc_personalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_apc_personal'], meta: { name: 'em_apc_personal' } }
    /**
     * Find zero or one Em_apc_personal that matches the filter.
     * @param {em_apc_personalFindUniqueArgs} args - Arguments to find a Em_apc_personal
     * @example
     * // Get one Em_apc_personal
     * const em_apc_personal = await prisma.em_apc_personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_apc_personalFindUniqueArgs>(args: SelectSubset<T, em_apc_personalFindUniqueArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_apc_personal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_apc_personalFindUniqueOrThrowArgs} args - Arguments to find a Em_apc_personal
     * @example
     * // Get one Em_apc_personal
     * const em_apc_personal = await prisma.em_apc_personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_apc_personalFindUniqueOrThrowArgs>(args: SelectSubset<T, em_apc_personalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_personalFindFirstArgs} args - Arguments to find a Em_apc_personal
     * @example
     * // Get one Em_apc_personal
     * const em_apc_personal = await prisma.em_apc_personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_apc_personalFindFirstArgs>(args?: SelectSubset<T, em_apc_personalFindFirstArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_personal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_personalFindFirstOrThrowArgs} args - Arguments to find a Em_apc_personal
     * @example
     * // Get one Em_apc_personal
     * const em_apc_personal = await prisma.em_apc_personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_apc_personalFindFirstOrThrowArgs>(args?: SelectSubset<T, em_apc_personalFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_apc_personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_personalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_apc_personals
     * const em_apc_personals = await prisma.em_apc_personal.findMany()
     * 
     * // Get first 10 Em_apc_personals
     * const em_apc_personals = await prisma.em_apc_personal.findMany({ take: 10 })
     * 
     * // Only select the `ApcId`
     * const em_apc_personalWithApcIdOnly = await prisma.em_apc_personal.findMany({ select: { ApcId: true } })
     * 
     */
    findMany<T extends em_apc_personalFindManyArgs>(args?: SelectSubset<T, em_apc_personalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_apc_personal.
     * @param {em_apc_personalCreateArgs} args - Arguments to create a Em_apc_personal.
     * @example
     * // Create one Em_apc_personal
     * const Em_apc_personal = await prisma.em_apc_personal.create({
     *   data: {
     *     // ... data to create a Em_apc_personal
     *   }
     * })
     * 
     */
    create<T extends em_apc_personalCreateArgs>(args: SelectSubset<T, em_apc_personalCreateArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_apc_personals.
     * @param {em_apc_personalCreateManyArgs} args - Arguments to create many Em_apc_personals.
     * @example
     * // Create many Em_apc_personals
     * const em_apc_personal = await prisma.em_apc_personal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_apc_personalCreateManyArgs>(args?: SelectSubset<T, em_apc_personalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_apc_personal.
     * @param {em_apc_personalDeleteArgs} args - Arguments to delete one Em_apc_personal.
     * @example
     * // Delete one Em_apc_personal
     * const Em_apc_personal = await prisma.em_apc_personal.delete({
     *   where: {
     *     // ... filter to delete one Em_apc_personal
     *   }
     * })
     * 
     */
    delete<T extends em_apc_personalDeleteArgs>(args: SelectSubset<T, em_apc_personalDeleteArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_apc_personal.
     * @param {em_apc_personalUpdateArgs} args - Arguments to update one Em_apc_personal.
     * @example
     * // Update one Em_apc_personal
     * const em_apc_personal = await prisma.em_apc_personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_apc_personalUpdateArgs>(args: SelectSubset<T, em_apc_personalUpdateArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_apc_personals.
     * @param {em_apc_personalDeleteManyArgs} args - Arguments to filter Em_apc_personals to delete.
     * @example
     * // Delete a few Em_apc_personals
     * const { count } = await prisma.em_apc_personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_apc_personalDeleteManyArgs>(args?: SelectSubset<T, em_apc_personalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_apc_personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_personalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_apc_personals
     * const em_apc_personal = await prisma.em_apc_personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_apc_personalUpdateManyArgs>(args: SelectSubset<T, em_apc_personalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_apc_personal.
     * @param {em_apc_personalUpsertArgs} args - Arguments to update or create a Em_apc_personal.
     * @example
     * // Update or create a Em_apc_personal
     * const em_apc_personal = await prisma.em_apc_personal.upsert({
     *   create: {
     *     // ... data to create a Em_apc_personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_apc_personal we want to update
     *   }
     * })
     */
    upsert<T extends em_apc_personalUpsertArgs>(args: SelectSubset<T, em_apc_personalUpsertArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_apc_personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_personalCountArgs} args - Arguments to filter Em_apc_personals to count.
     * @example
     * // Count the number of Em_apc_personals
     * const count = await prisma.em_apc_personal.count({
     *   where: {
     *     // ... the filter for the Em_apc_personals we want to count
     *   }
     * })
    **/
    count<T extends em_apc_personalCountArgs>(
      args?: Subset<T, em_apc_personalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_apc_personalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_apc_personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_apc_personalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_apc_personalAggregateArgs>(args: Subset<T, Em_apc_personalAggregateArgs>): Prisma.PrismaPromise<GetEm_apc_personalAggregateType<T>>

    /**
     * Group by Em_apc_personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_personalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_apc_personalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_apc_personalGroupByArgs['orderBy'] }
        : { orderBy?: em_apc_personalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_apc_personalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_apc_personalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_apc_personal model
   */
  readonly fields: em_apc_personalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_apc_personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_apc_personalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_apc_academy<T extends em_apc_personal$em_apc_academyArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personal$em_apc_academyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_academyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_apc_photograph<T extends em_apc_personal$em_apc_photographArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personal$em_apc_photographArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_apc_regulation<T extends em_apc_personal$em_apc_regulationArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personal$em_apc_regulationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_apc_skill_exper<T extends em_apc_personal$em_apc_skill_experArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personal$em_apc_skill_experArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_applicant_match<T extends em_apc_personal$em_applicant_matchArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personal$em_applicant_matchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_apc_personal model
   */
  interface em_apc_personalFieldRefs {
    readonly ApcId: FieldRef<"em_apc_personal", 'Int'>
    readonly PossId: FieldRef<"em_apc_personal", 'Int'>
    readonly AboutUs: FieldRef<"em_apc_personal", 'String'>
    readonly FullName: FieldRef<"em_apc_personal", 'String'>
    readonly NickName: FieldRef<"em_apc_personal", 'String'>
    readonly PlaceBirth: FieldRef<"em_apc_personal", 'String'>
    readonly DateBirth: FieldRef<"em_apc_personal", 'DateTime'>
    readonly Age: FieldRef<"em_apc_personal", 'Int'>
    readonly Gender: FieldRef<"em_apc_personal", 'Int'>
    readonly Religion: FieldRef<"em_apc_personal", 'Int'>
    readonly MaritalStats: FieldRef<"em_apc_personal", 'Int'>
    readonly Citizenship: FieldRef<"em_apc_personal", 'Int'>
    readonly Province: FieldRef<"em_apc_personal", 'Int'>
    readonly Regency: FieldRef<"em_apc_personal", 'Int'>
    readonly Subdistrict: FieldRef<"em_apc_personal", 'Int'>
    readonly PostCode: FieldRef<"em_apc_personal", 'String'>
    readonly Address: FieldRef<"em_apc_personal", 'String'>
    readonly IdentityType: FieldRef<"em_apc_personal", 'String'>
    readonly IdentityNumber: FieldRef<"em_apc_personal", 'String'>
    readonly PhoneCode: FieldRef<"em_apc_personal", 'Int'>
    readonly PhoneNumber: FieldRef<"em_apc_personal", 'String'>
    readonly EmailAddress: FieldRef<"em_apc_personal", 'String'>
    readonly Height: FieldRef<"em_apc_personal", 'Int'>
    readonly Weight: FieldRef<"em_apc_personal", 'Int'>
    readonly FatherName: FieldRef<"em_apc_personal", 'String'>
    readonly FatherOccupa: FieldRef<"em_apc_personal", 'String'>
    readonly MotherName: FieldRef<"em_apc_personal", 'String'>
    readonly MotherOccupa: FieldRef<"em_apc_personal", 'String'>
    readonly NumofSibling: FieldRef<"em_apc_personal", 'Int'>
    readonly SiblingNote: FieldRef<"em_apc_personal", 'String'>
    readonly NikFileName: FieldRef<"em_apc_personal", 'String'>
    readonly PhotoFileName: FieldRef<"em_apc_personal", 'String'>
    readonly CvFileName: FieldRef<"em_apc_personal", 'String'>
    readonly IsTransferPosst: FieldRef<"em_apc_personal", 'String'>
    readonly Status: FieldRef<"em_apc_personal", 'String'>
    readonly CreatedAt: FieldRef<"em_apc_personal", 'DateTime'>
    readonly isHobby: FieldRef<"em_apc_personal", 'String'>
    readonly LokCat: FieldRef<"em_apc_personal", 'Int'>
    readonly isSosmedId: FieldRef<"em_apc_personal", 'Int'>
    readonly isSosmed: FieldRef<"em_apc_personal", 'String'>
    readonly IsCall: FieldRef<"em_apc_personal", 'Int'>
    readonly DateCall: FieldRef<"em_apc_personal", 'DateTime'>
    readonly isLinked: FieldRef<"em_apc_personal", 'String'>
    readonly PossName: FieldRef<"em_apc_personal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_apc_personal findUnique
   */
  export type em_apc_personalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_personal to fetch.
     */
    where: em_apc_personalWhereUniqueInput
  }

  /**
   * em_apc_personal findUniqueOrThrow
   */
  export type em_apc_personalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_personal to fetch.
     */
    where: em_apc_personalWhereUniqueInput
  }

  /**
   * em_apc_personal findFirst
   */
  export type em_apc_personalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_personal to fetch.
     */
    where?: em_apc_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_personals to fetch.
     */
    orderBy?: em_apc_personalOrderByWithRelationInput | em_apc_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_personals.
     */
    cursor?: em_apc_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_personals.
     */
    distinct?: Em_apc_personalScalarFieldEnum | Em_apc_personalScalarFieldEnum[]
  }

  /**
   * em_apc_personal findFirstOrThrow
   */
  export type em_apc_personalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_personal to fetch.
     */
    where?: em_apc_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_personals to fetch.
     */
    orderBy?: em_apc_personalOrderByWithRelationInput | em_apc_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_personals.
     */
    cursor?: em_apc_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_personals.
     */
    distinct?: Em_apc_personalScalarFieldEnum | Em_apc_personalScalarFieldEnum[]
  }

  /**
   * em_apc_personal findMany
   */
  export type em_apc_personalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_personals to fetch.
     */
    where?: em_apc_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_personals to fetch.
     */
    orderBy?: em_apc_personalOrderByWithRelationInput | em_apc_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_apc_personals.
     */
    cursor?: em_apc_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_personals.
     */
    skip?: number
    distinct?: Em_apc_personalScalarFieldEnum | Em_apc_personalScalarFieldEnum[]
  }

  /**
   * em_apc_personal create
   */
  export type em_apc_personalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * The data needed to create a em_apc_personal.
     */
    data?: XOR<em_apc_personalCreateInput, em_apc_personalUncheckedCreateInput>
  }

  /**
   * em_apc_personal createMany
   */
  export type em_apc_personalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_apc_personals.
     */
    data: em_apc_personalCreateManyInput | em_apc_personalCreateManyInput[]
  }

  /**
   * em_apc_personal update
   */
  export type em_apc_personalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * The data needed to update a em_apc_personal.
     */
    data: XOR<em_apc_personalUpdateInput, em_apc_personalUncheckedUpdateInput>
    /**
     * Choose, which em_apc_personal to update.
     */
    where: em_apc_personalWhereUniqueInput
  }

  /**
   * em_apc_personal updateMany
   */
  export type em_apc_personalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_apc_personals.
     */
    data: XOR<em_apc_personalUpdateManyMutationInput, em_apc_personalUncheckedUpdateManyInput>
    /**
     * Filter which em_apc_personals to update
     */
    where?: em_apc_personalWhereInput
    /**
     * Limit how many em_apc_personals to update.
     */
    limit?: number
  }

  /**
   * em_apc_personal upsert
   */
  export type em_apc_personalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * The filter to search for the em_apc_personal to update in case it exists.
     */
    where: em_apc_personalWhereUniqueInput
    /**
     * In case the em_apc_personal found by the `where` argument doesn't exist, create a new em_apc_personal with this data.
     */
    create: XOR<em_apc_personalCreateInput, em_apc_personalUncheckedCreateInput>
    /**
     * In case the em_apc_personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_apc_personalUpdateInput, em_apc_personalUncheckedUpdateInput>
  }

  /**
   * em_apc_personal delete
   */
  export type em_apc_personalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    /**
     * Filter which em_apc_personal to delete.
     */
    where: em_apc_personalWhereUniqueInput
  }

  /**
   * em_apc_personal deleteMany
   */
  export type em_apc_personalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_personals to delete
     */
    where?: em_apc_personalWhereInput
    /**
     * Limit how many em_apc_personals to delete.
     */
    limit?: number
  }

  /**
   * em_apc_personal.em_apc_academy
   */
  export type em_apc_personal$em_apc_academyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_academy
     */
    select?: em_apc_academySelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_academy
     */
    omit?: em_apc_academyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_academyInclude<ExtArgs> | null
    where?: em_apc_academyWhereInput
    orderBy?: em_apc_academyOrderByWithRelationInput | em_apc_academyOrderByWithRelationInput[]
    cursor?: em_apc_academyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_apc_academyScalarFieldEnum | Em_apc_academyScalarFieldEnum[]
  }

  /**
   * em_apc_personal.em_apc_photograph
   */
  export type em_apc_personal$em_apc_photographArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    where?: em_apc_photographWhereInput
    orderBy?: em_apc_photographOrderByWithRelationInput | em_apc_photographOrderByWithRelationInput[]
    cursor?: em_apc_photographWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_apc_photographScalarFieldEnum | Em_apc_photographScalarFieldEnum[]
  }

  /**
   * em_apc_personal.em_apc_regulation
   */
  export type em_apc_personal$em_apc_regulationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    where?: em_apc_regulationWhereInput
    orderBy?: em_apc_regulationOrderByWithRelationInput | em_apc_regulationOrderByWithRelationInput[]
    cursor?: em_apc_regulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_apc_regulationScalarFieldEnum | Em_apc_regulationScalarFieldEnum[]
  }

  /**
   * em_apc_personal.em_apc_skill_exper
   */
  export type em_apc_personal$em_apc_skill_experArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    where?: em_apc_skill_experWhereInput
    orderBy?: em_apc_skill_experOrderByWithRelationInput | em_apc_skill_experOrderByWithRelationInput[]
    cursor?: em_apc_skill_experWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_apc_skill_experScalarFieldEnum | Em_apc_skill_experScalarFieldEnum[]
  }

  /**
   * em_apc_personal.em_applicant_match
   */
  export type em_apc_personal$em_applicant_matchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    where?: em_applicant_matchWhereInput
    orderBy?: em_applicant_matchOrderByWithRelationInput | em_applicant_matchOrderByWithRelationInput[]
    cursor?: em_applicant_matchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_applicant_matchScalarFieldEnum | Em_applicant_matchScalarFieldEnum[]
  }

  /**
   * em_apc_personal without action
   */
  export type em_apc_personalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
  }


  /**
   * Model em_apc_photograph
   */

  export type AggregateEm_apc_photograph = {
    _count: Em_apc_photographCountAggregateOutputType | null
    _avg: Em_apc_photographAvgAggregateOutputType | null
    _sum: Em_apc_photographSumAggregateOutputType | null
    _min: Em_apc_photographMinAggregateOutputType | null
    _max: Em_apc_photographMaxAggregateOutputType | null
  }

  export type Em_apc_photographAvgAggregateOutputType = {
    Id: number | null
    ApcId: number | null
  }

  export type Em_apc_photographSumAggregateOutputType = {
    Id: number | null
    ApcId: number | null
  }

  export type Em_apc_photographMinAggregateOutputType = {
    Id: number | null
    ApcId: number | null
    GenrName: string | null
  }

  export type Em_apc_photographMaxAggregateOutputType = {
    Id: number | null
    ApcId: number | null
    GenrName: string | null
  }

  export type Em_apc_photographCountAggregateOutputType = {
    Id: number
    ApcId: number
    GenrName: number
    _all: number
  }


  export type Em_apc_photographAvgAggregateInputType = {
    Id?: true
    ApcId?: true
  }

  export type Em_apc_photographSumAggregateInputType = {
    Id?: true
    ApcId?: true
  }

  export type Em_apc_photographMinAggregateInputType = {
    Id?: true
    ApcId?: true
    GenrName?: true
  }

  export type Em_apc_photographMaxAggregateInputType = {
    Id?: true
    ApcId?: true
    GenrName?: true
  }

  export type Em_apc_photographCountAggregateInputType = {
    Id?: true
    ApcId?: true
    GenrName?: true
    _all?: true
  }

  export type Em_apc_photographAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_photograph to aggregate.
     */
    where?: em_apc_photographWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_photographs to fetch.
     */
    orderBy?: em_apc_photographOrderByWithRelationInput | em_apc_photographOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_apc_photographWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_photographs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_photographs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_apc_photographs
    **/
    _count?: true | Em_apc_photographCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_apc_photographAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_apc_photographSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_apc_photographMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_apc_photographMaxAggregateInputType
  }

  export type GetEm_apc_photographAggregateType<T extends Em_apc_photographAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_apc_photograph]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_apc_photograph[P]>
      : GetScalarType<T[P], AggregateEm_apc_photograph[P]>
  }




  export type em_apc_photographGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_photographWhereInput
    orderBy?: em_apc_photographOrderByWithAggregationInput | em_apc_photographOrderByWithAggregationInput[]
    by: Em_apc_photographScalarFieldEnum[] | Em_apc_photographScalarFieldEnum
    having?: em_apc_photographScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_apc_photographCountAggregateInputType | true
    _avg?: Em_apc_photographAvgAggregateInputType
    _sum?: Em_apc_photographSumAggregateInputType
    _min?: Em_apc_photographMinAggregateInputType
    _max?: Em_apc_photographMaxAggregateInputType
  }

  export type Em_apc_photographGroupByOutputType = {
    Id: number
    ApcId: number | null
    GenrName: string | null
    _count: Em_apc_photographCountAggregateOutputType | null
    _avg: Em_apc_photographAvgAggregateOutputType | null
    _sum: Em_apc_photographSumAggregateOutputType | null
    _min: Em_apc_photographMinAggregateOutputType | null
    _max: Em_apc_photographMaxAggregateOutputType | null
  }

  type GetEm_apc_photographGroupByPayload<T extends em_apc_photographGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_apc_photographGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_apc_photographGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_apc_photographGroupByOutputType[P]>
            : GetScalarType<T[P], Em_apc_photographGroupByOutputType[P]>
        }
      >
    >


  export type em_apc_photographSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    ApcId?: boolean
    GenrName?: boolean
    em_apc_personal?: boolean | em_apc_photograph$em_apc_personalArgs<ExtArgs>
  }, ExtArgs["result"]["em_apc_photograph"]>



  export type em_apc_photographSelectScalar = {
    Id?: boolean
    ApcId?: boolean
    GenrName?: boolean
  }

  export type em_apc_photographOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "ApcId" | "GenrName", ExtArgs["result"]["em_apc_photograph"]>
  export type em_apc_photographInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_personal?: boolean | em_apc_photograph$em_apc_personalArgs<ExtArgs>
  }

  export type $em_apc_photographPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_apc_photograph"
    objects: {
      em_apc_personal: Prisma.$em_apc_personalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      ApcId: number | null
      GenrName: string | null
    }, ExtArgs["result"]["em_apc_photograph"]>
    composites: {}
  }

  type em_apc_photographGetPayload<S extends boolean | null | undefined | em_apc_photographDefaultArgs> = $Result.GetResult<Prisma.$em_apc_photographPayload, S>

  type em_apc_photographCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_apc_photographFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_apc_photographCountAggregateInputType | true
    }

  export interface em_apc_photographDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_apc_photograph'], meta: { name: 'em_apc_photograph' } }
    /**
     * Find zero or one Em_apc_photograph that matches the filter.
     * @param {em_apc_photographFindUniqueArgs} args - Arguments to find a Em_apc_photograph
     * @example
     * // Get one Em_apc_photograph
     * const em_apc_photograph = await prisma.em_apc_photograph.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_apc_photographFindUniqueArgs>(args: SelectSubset<T, em_apc_photographFindUniqueArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_apc_photograph that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_apc_photographFindUniqueOrThrowArgs} args - Arguments to find a Em_apc_photograph
     * @example
     * // Get one Em_apc_photograph
     * const em_apc_photograph = await prisma.em_apc_photograph.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_apc_photographFindUniqueOrThrowArgs>(args: SelectSubset<T, em_apc_photographFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_photograph that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_photographFindFirstArgs} args - Arguments to find a Em_apc_photograph
     * @example
     * // Get one Em_apc_photograph
     * const em_apc_photograph = await prisma.em_apc_photograph.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_apc_photographFindFirstArgs>(args?: SelectSubset<T, em_apc_photographFindFirstArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_photograph that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_photographFindFirstOrThrowArgs} args - Arguments to find a Em_apc_photograph
     * @example
     * // Get one Em_apc_photograph
     * const em_apc_photograph = await prisma.em_apc_photograph.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_apc_photographFindFirstOrThrowArgs>(args?: SelectSubset<T, em_apc_photographFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_apc_photographs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_photographFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_apc_photographs
     * const em_apc_photographs = await prisma.em_apc_photograph.findMany()
     * 
     * // Get first 10 Em_apc_photographs
     * const em_apc_photographs = await prisma.em_apc_photograph.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_apc_photographWithIdOnly = await prisma.em_apc_photograph.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_apc_photographFindManyArgs>(args?: SelectSubset<T, em_apc_photographFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_apc_photograph.
     * @param {em_apc_photographCreateArgs} args - Arguments to create a Em_apc_photograph.
     * @example
     * // Create one Em_apc_photograph
     * const Em_apc_photograph = await prisma.em_apc_photograph.create({
     *   data: {
     *     // ... data to create a Em_apc_photograph
     *   }
     * })
     * 
     */
    create<T extends em_apc_photographCreateArgs>(args: SelectSubset<T, em_apc_photographCreateArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_apc_photographs.
     * @param {em_apc_photographCreateManyArgs} args - Arguments to create many Em_apc_photographs.
     * @example
     * // Create many Em_apc_photographs
     * const em_apc_photograph = await prisma.em_apc_photograph.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_apc_photographCreateManyArgs>(args?: SelectSubset<T, em_apc_photographCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_apc_photograph.
     * @param {em_apc_photographDeleteArgs} args - Arguments to delete one Em_apc_photograph.
     * @example
     * // Delete one Em_apc_photograph
     * const Em_apc_photograph = await prisma.em_apc_photograph.delete({
     *   where: {
     *     // ... filter to delete one Em_apc_photograph
     *   }
     * })
     * 
     */
    delete<T extends em_apc_photographDeleteArgs>(args: SelectSubset<T, em_apc_photographDeleteArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_apc_photograph.
     * @param {em_apc_photographUpdateArgs} args - Arguments to update one Em_apc_photograph.
     * @example
     * // Update one Em_apc_photograph
     * const em_apc_photograph = await prisma.em_apc_photograph.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_apc_photographUpdateArgs>(args: SelectSubset<T, em_apc_photographUpdateArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_apc_photographs.
     * @param {em_apc_photographDeleteManyArgs} args - Arguments to filter Em_apc_photographs to delete.
     * @example
     * // Delete a few Em_apc_photographs
     * const { count } = await prisma.em_apc_photograph.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_apc_photographDeleteManyArgs>(args?: SelectSubset<T, em_apc_photographDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_apc_photographs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_photographUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_apc_photographs
     * const em_apc_photograph = await prisma.em_apc_photograph.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_apc_photographUpdateManyArgs>(args: SelectSubset<T, em_apc_photographUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_apc_photograph.
     * @param {em_apc_photographUpsertArgs} args - Arguments to update or create a Em_apc_photograph.
     * @example
     * // Update or create a Em_apc_photograph
     * const em_apc_photograph = await prisma.em_apc_photograph.upsert({
     *   create: {
     *     // ... data to create a Em_apc_photograph
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_apc_photograph we want to update
     *   }
     * })
     */
    upsert<T extends em_apc_photographUpsertArgs>(args: SelectSubset<T, em_apc_photographUpsertArgs<ExtArgs>>): Prisma__em_apc_photographClient<$Result.GetResult<Prisma.$em_apc_photographPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_apc_photographs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_photographCountArgs} args - Arguments to filter Em_apc_photographs to count.
     * @example
     * // Count the number of Em_apc_photographs
     * const count = await prisma.em_apc_photograph.count({
     *   where: {
     *     // ... the filter for the Em_apc_photographs we want to count
     *   }
     * })
    **/
    count<T extends em_apc_photographCountArgs>(
      args?: Subset<T, em_apc_photographCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_apc_photographCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_apc_photograph.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_apc_photographAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_apc_photographAggregateArgs>(args: Subset<T, Em_apc_photographAggregateArgs>): Prisma.PrismaPromise<GetEm_apc_photographAggregateType<T>>

    /**
     * Group by Em_apc_photograph.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_photographGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_apc_photographGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_apc_photographGroupByArgs['orderBy'] }
        : { orderBy?: em_apc_photographGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_apc_photographGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_apc_photographGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_apc_photograph model
   */
  readonly fields: em_apc_photographFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_apc_photograph.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_apc_photographClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_apc_personal<T extends em_apc_photograph$em_apc_personalArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_photograph$em_apc_personalArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_apc_photograph model
   */
  interface em_apc_photographFieldRefs {
    readonly Id: FieldRef<"em_apc_photograph", 'Int'>
    readonly ApcId: FieldRef<"em_apc_photograph", 'Int'>
    readonly GenrName: FieldRef<"em_apc_photograph", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_apc_photograph findUnique
   */
  export type em_apc_photographFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_photograph to fetch.
     */
    where: em_apc_photographWhereUniqueInput
  }

  /**
   * em_apc_photograph findUniqueOrThrow
   */
  export type em_apc_photographFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_photograph to fetch.
     */
    where: em_apc_photographWhereUniqueInput
  }

  /**
   * em_apc_photograph findFirst
   */
  export type em_apc_photographFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_photograph to fetch.
     */
    where?: em_apc_photographWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_photographs to fetch.
     */
    orderBy?: em_apc_photographOrderByWithRelationInput | em_apc_photographOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_photographs.
     */
    cursor?: em_apc_photographWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_photographs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_photographs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_photographs.
     */
    distinct?: Em_apc_photographScalarFieldEnum | Em_apc_photographScalarFieldEnum[]
  }

  /**
   * em_apc_photograph findFirstOrThrow
   */
  export type em_apc_photographFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_photograph to fetch.
     */
    where?: em_apc_photographWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_photographs to fetch.
     */
    orderBy?: em_apc_photographOrderByWithRelationInput | em_apc_photographOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_photographs.
     */
    cursor?: em_apc_photographWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_photographs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_photographs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_photographs.
     */
    distinct?: Em_apc_photographScalarFieldEnum | Em_apc_photographScalarFieldEnum[]
  }

  /**
   * em_apc_photograph findMany
   */
  export type em_apc_photographFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_photographs to fetch.
     */
    where?: em_apc_photographWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_photographs to fetch.
     */
    orderBy?: em_apc_photographOrderByWithRelationInput | em_apc_photographOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_apc_photographs.
     */
    cursor?: em_apc_photographWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_photographs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_photographs.
     */
    skip?: number
    distinct?: Em_apc_photographScalarFieldEnum | Em_apc_photographScalarFieldEnum[]
  }

  /**
   * em_apc_photograph create
   */
  export type em_apc_photographCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * The data needed to create a em_apc_photograph.
     */
    data?: XOR<em_apc_photographCreateInput, em_apc_photographUncheckedCreateInput>
  }

  /**
   * em_apc_photograph createMany
   */
  export type em_apc_photographCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_apc_photographs.
     */
    data: em_apc_photographCreateManyInput | em_apc_photographCreateManyInput[]
  }

  /**
   * em_apc_photograph update
   */
  export type em_apc_photographUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * The data needed to update a em_apc_photograph.
     */
    data: XOR<em_apc_photographUpdateInput, em_apc_photographUncheckedUpdateInput>
    /**
     * Choose, which em_apc_photograph to update.
     */
    where: em_apc_photographWhereUniqueInput
  }

  /**
   * em_apc_photograph updateMany
   */
  export type em_apc_photographUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_apc_photographs.
     */
    data: XOR<em_apc_photographUpdateManyMutationInput, em_apc_photographUncheckedUpdateManyInput>
    /**
     * Filter which em_apc_photographs to update
     */
    where?: em_apc_photographWhereInput
    /**
     * Limit how many em_apc_photographs to update.
     */
    limit?: number
  }

  /**
   * em_apc_photograph upsert
   */
  export type em_apc_photographUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * The filter to search for the em_apc_photograph to update in case it exists.
     */
    where: em_apc_photographWhereUniqueInput
    /**
     * In case the em_apc_photograph found by the `where` argument doesn't exist, create a new em_apc_photograph with this data.
     */
    create: XOR<em_apc_photographCreateInput, em_apc_photographUncheckedCreateInput>
    /**
     * In case the em_apc_photograph was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_apc_photographUpdateInput, em_apc_photographUncheckedUpdateInput>
  }

  /**
   * em_apc_photograph delete
   */
  export type em_apc_photographDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
    /**
     * Filter which em_apc_photograph to delete.
     */
    where: em_apc_photographWhereUniqueInput
  }

  /**
   * em_apc_photograph deleteMany
   */
  export type em_apc_photographDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_photographs to delete
     */
    where?: em_apc_photographWhereInput
    /**
     * Limit how many em_apc_photographs to delete.
     */
    limit?: number
  }

  /**
   * em_apc_photograph.em_apc_personal
   */
  export type em_apc_photograph$em_apc_personalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    where?: em_apc_personalWhereInput
  }

  /**
   * em_apc_photograph without action
   */
  export type em_apc_photographDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_photograph
     */
    select?: em_apc_photographSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_photograph
     */
    omit?: em_apc_photographOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_photographInclude<ExtArgs> | null
  }


  /**
   * Model em_apc_regulation
   */

  export type AggregateEm_apc_regulation = {
    _count: Em_apc_regulationCountAggregateOutputType | null
    _avg: Em_apc_regulationAvgAggregateOutputType | null
    _sum: Em_apc_regulationSumAggregateOutputType | null
    _min: Em_apc_regulationMinAggregateOutputType | null
    _max: Em_apc_regulationMaxAggregateOutputType | null
  }

  export type Em_apc_regulationAvgAggregateOutputType = {
    ApcRegId: number | null
    ApcId: number | null
    RegId: number | null
  }

  export type Em_apc_regulationSumAggregateOutputType = {
    ApcRegId: number | null
    ApcId: number | null
    RegId: number | null
  }

  export type Em_apc_regulationMinAggregateOutputType = {
    ApcRegId: number | null
    ApcId: number | null
    RegId: number | null
    RegChoice: boolean | null
  }

  export type Em_apc_regulationMaxAggregateOutputType = {
    ApcRegId: number | null
    ApcId: number | null
    RegId: number | null
    RegChoice: boolean | null
  }

  export type Em_apc_regulationCountAggregateOutputType = {
    ApcRegId: number
    ApcId: number
    RegId: number
    RegChoice: number
    _all: number
  }


  export type Em_apc_regulationAvgAggregateInputType = {
    ApcRegId?: true
    ApcId?: true
    RegId?: true
  }

  export type Em_apc_regulationSumAggregateInputType = {
    ApcRegId?: true
    ApcId?: true
    RegId?: true
  }

  export type Em_apc_regulationMinAggregateInputType = {
    ApcRegId?: true
    ApcId?: true
    RegId?: true
    RegChoice?: true
  }

  export type Em_apc_regulationMaxAggregateInputType = {
    ApcRegId?: true
    ApcId?: true
    RegId?: true
    RegChoice?: true
  }

  export type Em_apc_regulationCountAggregateInputType = {
    ApcRegId?: true
    ApcId?: true
    RegId?: true
    RegChoice?: true
    _all?: true
  }

  export type Em_apc_regulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_regulation to aggregate.
     */
    where?: em_apc_regulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_regulations to fetch.
     */
    orderBy?: em_apc_regulationOrderByWithRelationInput | em_apc_regulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_apc_regulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_apc_regulations
    **/
    _count?: true | Em_apc_regulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_apc_regulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_apc_regulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_apc_regulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_apc_regulationMaxAggregateInputType
  }

  export type GetEm_apc_regulationAggregateType<T extends Em_apc_regulationAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_apc_regulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_apc_regulation[P]>
      : GetScalarType<T[P], AggregateEm_apc_regulation[P]>
  }




  export type em_apc_regulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_regulationWhereInput
    orderBy?: em_apc_regulationOrderByWithAggregationInput | em_apc_regulationOrderByWithAggregationInput[]
    by: Em_apc_regulationScalarFieldEnum[] | Em_apc_regulationScalarFieldEnum
    having?: em_apc_regulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_apc_regulationCountAggregateInputType | true
    _avg?: Em_apc_regulationAvgAggregateInputType
    _sum?: Em_apc_regulationSumAggregateInputType
    _min?: Em_apc_regulationMinAggregateInputType
    _max?: Em_apc_regulationMaxAggregateInputType
  }

  export type Em_apc_regulationGroupByOutputType = {
    ApcRegId: number
    ApcId: number | null
    RegId: number | null
    RegChoice: boolean | null
    _count: Em_apc_regulationCountAggregateOutputType | null
    _avg: Em_apc_regulationAvgAggregateOutputType | null
    _sum: Em_apc_regulationSumAggregateOutputType | null
    _min: Em_apc_regulationMinAggregateOutputType | null
    _max: Em_apc_regulationMaxAggregateOutputType | null
  }

  type GetEm_apc_regulationGroupByPayload<T extends em_apc_regulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_apc_regulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_apc_regulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_apc_regulationGroupByOutputType[P]>
            : GetScalarType<T[P], Em_apc_regulationGroupByOutputType[P]>
        }
      >
    >


  export type em_apc_regulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ApcRegId?: boolean
    ApcId?: boolean
    RegId?: boolean
    RegChoice?: boolean
    em_apc_personal?: boolean | em_apc_regulation$em_apc_personalArgs<ExtArgs>
  }, ExtArgs["result"]["em_apc_regulation"]>



  export type em_apc_regulationSelectScalar = {
    ApcRegId?: boolean
    ApcId?: boolean
    RegId?: boolean
    RegChoice?: boolean
  }

  export type em_apc_regulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ApcRegId" | "ApcId" | "RegId" | "RegChoice", ExtArgs["result"]["em_apc_regulation"]>
  export type em_apc_regulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_personal?: boolean | em_apc_regulation$em_apc_personalArgs<ExtArgs>
  }

  export type $em_apc_regulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_apc_regulation"
    objects: {
      em_apc_personal: Prisma.$em_apc_personalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ApcRegId: number
      ApcId: number | null
      RegId: number | null
      RegChoice: boolean | null
    }, ExtArgs["result"]["em_apc_regulation"]>
    composites: {}
  }

  type em_apc_regulationGetPayload<S extends boolean | null | undefined | em_apc_regulationDefaultArgs> = $Result.GetResult<Prisma.$em_apc_regulationPayload, S>

  type em_apc_regulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_apc_regulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_apc_regulationCountAggregateInputType | true
    }

  export interface em_apc_regulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_apc_regulation'], meta: { name: 'em_apc_regulation' } }
    /**
     * Find zero or one Em_apc_regulation that matches the filter.
     * @param {em_apc_regulationFindUniqueArgs} args - Arguments to find a Em_apc_regulation
     * @example
     * // Get one Em_apc_regulation
     * const em_apc_regulation = await prisma.em_apc_regulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_apc_regulationFindUniqueArgs>(args: SelectSubset<T, em_apc_regulationFindUniqueArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_apc_regulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_apc_regulationFindUniqueOrThrowArgs} args - Arguments to find a Em_apc_regulation
     * @example
     * // Get one Em_apc_regulation
     * const em_apc_regulation = await prisma.em_apc_regulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_apc_regulationFindUniqueOrThrowArgs>(args: SelectSubset<T, em_apc_regulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_regulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_regulationFindFirstArgs} args - Arguments to find a Em_apc_regulation
     * @example
     * // Get one Em_apc_regulation
     * const em_apc_regulation = await prisma.em_apc_regulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_apc_regulationFindFirstArgs>(args?: SelectSubset<T, em_apc_regulationFindFirstArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_regulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_regulationFindFirstOrThrowArgs} args - Arguments to find a Em_apc_regulation
     * @example
     * // Get one Em_apc_regulation
     * const em_apc_regulation = await prisma.em_apc_regulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_apc_regulationFindFirstOrThrowArgs>(args?: SelectSubset<T, em_apc_regulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_apc_regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_regulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_apc_regulations
     * const em_apc_regulations = await prisma.em_apc_regulation.findMany()
     * 
     * // Get first 10 Em_apc_regulations
     * const em_apc_regulations = await prisma.em_apc_regulation.findMany({ take: 10 })
     * 
     * // Only select the `ApcRegId`
     * const em_apc_regulationWithApcRegIdOnly = await prisma.em_apc_regulation.findMany({ select: { ApcRegId: true } })
     * 
     */
    findMany<T extends em_apc_regulationFindManyArgs>(args?: SelectSubset<T, em_apc_regulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_apc_regulation.
     * @param {em_apc_regulationCreateArgs} args - Arguments to create a Em_apc_regulation.
     * @example
     * // Create one Em_apc_regulation
     * const Em_apc_regulation = await prisma.em_apc_regulation.create({
     *   data: {
     *     // ... data to create a Em_apc_regulation
     *   }
     * })
     * 
     */
    create<T extends em_apc_regulationCreateArgs>(args: SelectSubset<T, em_apc_regulationCreateArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_apc_regulations.
     * @param {em_apc_regulationCreateManyArgs} args - Arguments to create many Em_apc_regulations.
     * @example
     * // Create many Em_apc_regulations
     * const em_apc_regulation = await prisma.em_apc_regulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_apc_regulationCreateManyArgs>(args?: SelectSubset<T, em_apc_regulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_apc_regulation.
     * @param {em_apc_regulationDeleteArgs} args - Arguments to delete one Em_apc_regulation.
     * @example
     * // Delete one Em_apc_regulation
     * const Em_apc_regulation = await prisma.em_apc_regulation.delete({
     *   where: {
     *     // ... filter to delete one Em_apc_regulation
     *   }
     * })
     * 
     */
    delete<T extends em_apc_regulationDeleteArgs>(args: SelectSubset<T, em_apc_regulationDeleteArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_apc_regulation.
     * @param {em_apc_regulationUpdateArgs} args - Arguments to update one Em_apc_regulation.
     * @example
     * // Update one Em_apc_regulation
     * const em_apc_regulation = await prisma.em_apc_regulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_apc_regulationUpdateArgs>(args: SelectSubset<T, em_apc_regulationUpdateArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_apc_regulations.
     * @param {em_apc_regulationDeleteManyArgs} args - Arguments to filter Em_apc_regulations to delete.
     * @example
     * // Delete a few Em_apc_regulations
     * const { count } = await prisma.em_apc_regulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_apc_regulationDeleteManyArgs>(args?: SelectSubset<T, em_apc_regulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_apc_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_regulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_apc_regulations
     * const em_apc_regulation = await prisma.em_apc_regulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_apc_regulationUpdateManyArgs>(args: SelectSubset<T, em_apc_regulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_apc_regulation.
     * @param {em_apc_regulationUpsertArgs} args - Arguments to update or create a Em_apc_regulation.
     * @example
     * // Update or create a Em_apc_regulation
     * const em_apc_regulation = await prisma.em_apc_regulation.upsert({
     *   create: {
     *     // ... data to create a Em_apc_regulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_apc_regulation we want to update
     *   }
     * })
     */
    upsert<T extends em_apc_regulationUpsertArgs>(args: SelectSubset<T, em_apc_regulationUpsertArgs<ExtArgs>>): Prisma__em_apc_regulationClient<$Result.GetResult<Prisma.$em_apc_regulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_apc_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_regulationCountArgs} args - Arguments to filter Em_apc_regulations to count.
     * @example
     * // Count the number of Em_apc_regulations
     * const count = await prisma.em_apc_regulation.count({
     *   where: {
     *     // ... the filter for the Em_apc_regulations we want to count
     *   }
     * })
    **/
    count<T extends em_apc_regulationCountArgs>(
      args?: Subset<T, em_apc_regulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_apc_regulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_apc_regulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_apc_regulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_apc_regulationAggregateArgs>(args: Subset<T, Em_apc_regulationAggregateArgs>): Prisma.PrismaPromise<GetEm_apc_regulationAggregateType<T>>

    /**
     * Group by Em_apc_regulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_regulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_apc_regulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_apc_regulationGroupByArgs['orderBy'] }
        : { orderBy?: em_apc_regulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_apc_regulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_apc_regulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_apc_regulation model
   */
  readonly fields: em_apc_regulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_apc_regulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_apc_regulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_apc_personal<T extends em_apc_regulation$em_apc_personalArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_regulation$em_apc_personalArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_apc_regulation model
   */
  interface em_apc_regulationFieldRefs {
    readonly ApcRegId: FieldRef<"em_apc_regulation", 'Int'>
    readonly ApcId: FieldRef<"em_apc_regulation", 'Int'>
    readonly RegId: FieldRef<"em_apc_regulation", 'Int'>
    readonly RegChoice: FieldRef<"em_apc_regulation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * em_apc_regulation findUnique
   */
  export type em_apc_regulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_regulation to fetch.
     */
    where: em_apc_regulationWhereUniqueInput
  }

  /**
   * em_apc_regulation findUniqueOrThrow
   */
  export type em_apc_regulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_regulation to fetch.
     */
    where: em_apc_regulationWhereUniqueInput
  }

  /**
   * em_apc_regulation findFirst
   */
  export type em_apc_regulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_regulation to fetch.
     */
    where?: em_apc_regulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_regulations to fetch.
     */
    orderBy?: em_apc_regulationOrderByWithRelationInput | em_apc_regulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_regulations.
     */
    cursor?: em_apc_regulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_regulations.
     */
    distinct?: Em_apc_regulationScalarFieldEnum | Em_apc_regulationScalarFieldEnum[]
  }

  /**
   * em_apc_regulation findFirstOrThrow
   */
  export type em_apc_regulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_regulation to fetch.
     */
    where?: em_apc_regulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_regulations to fetch.
     */
    orderBy?: em_apc_regulationOrderByWithRelationInput | em_apc_regulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_regulations.
     */
    cursor?: em_apc_regulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_regulations.
     */
    distinct?: Em_apc_regulationScalarFieldEnum | Em_apc_regulationScalarFieldEnum[]
  }

  /**
   * em_apc_regulation findMany
   */
  export type em_apc_regulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_regulations to fetch.
     */
    where?: em_apc_regulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_regulations to fetch.
     */
    orderBy?: em_apc_regulationOrderByWithRelationInput | em_apc_regulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_apc_regulations.
     */
    cursor?: em_apc_regulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_regulations.
     */
    skip?: number
    distinct?: Em_apc_regulationScalarFieldEnum | Em_apc_regulationScalarFieldEnum[]
  }

  /**
   * em_apc_regulation create
   */
  export type em_apc_regulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * The data needed to create a em_apc_regulation.
     */
    data?: XOR<em_apc_regulationCreateInput, em_apc_regulationUncheckedCreateInput>
  }

  /**
   * em_apc_regulation createMany
   */
  export type em_apc_regulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_apc_regulations.
     */
    data: em_apc_regulationCreateManyInput | em_apc_regulationCreateManyInput[]
  }

  /**
   * em_apc_regulation update
   */
  export type em_apc_regulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * The data needed to update a em_apc_regulation.
     */
    data: XOR<em_apc_regulationUpdateInput, em_apc_regulationUncheckedUpdateInput>
    /**
     * Choose, which em_apc_regulation to update.
     */
    where: em_apc_regulationWhereUniqueInput
  }

  /**
   * em_apc_regulation updateMany
   */
  export type em_apc_regulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_apc_regulations.
     */
    data: XOR<em_apc_regulationUpdateManyMutationInput, em_apc_regulationUncheckedUpdateManyInput>
    /**
     * Filter which em_apc_regulations to update
     */
    where?: em_apc_regulationWhereInput
    /**
     * Limit how many em_apc_regulations to update.
     */
    limit?: number
  }

  /**
   * em_apc_regulation upsert
   */
  export type em_apc_regulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * The filter to search for the em_apc_regulation to update in case it exists.
     */
    where: em_apc_regulationWhereUniqueInput
    /**
     * In case the em_apc_regulation found by the `where` argument doesn't exist, create a new em_apc_regulation with this data.
     */
    create: XOR<em_apc_regulationCreateInput, em_apc_regulationUncheckedCreateInput>
    /**
     * In case the em_apc_regulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_apc_regulationUpdateInput, em_apc_regulationUncheckedUpdateInput>
  }

  /**
   * em_apc_regulation delete
   */
  export type em_apc_regulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
    /**
     * Filter which em_apc_regulation to delete.
     */
    where: em_apc_regulationWhereUniqueInput
  }

  /**
   * em_apc_regulation deleteMany
   */
  export type em_apc_regulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_regulations to delete
     */
    where?: em_apc_regulationWhereInput
    /**
     * Limit how many em_apc_regulations to delete.
     */
    limit?: number
  }

  /**
   * em_apc_regulation.em_apc_personal
   */
  export type em_apc_regulation$em_apc_personalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_personal
     */
    select?: em_apc_personalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_personal
     */
    omit?: em_apc_personalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_personalInclude<ExtArgs> | null
    where?: em_apc_personalWhereInput
  }

  /**
   * em_apc_regulation without action
   */
  export type em_apc_regulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_regulation
     */
    select?: em_apc_regulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_regulation
     */
    omit?: em_apc_regulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_regulationInclude<ExtArgs> | null
  }


  /**
   * Model em_apc_skill_exper
   */

  export type AggregateEm_apc_skill_exper = {
    _count: Em_apc_skill_experCountAggregateOutputType | null
    _avg: Em_apc_skill_experAvgAggregateOutputType | null
    _sum: Em_apc_skill_experSumAggregateOutputType | null
    _min: Em_apc_skill_experMinAggregateOutputType | null
    _max: Em_apc_skill_experMaxAggregateOutputType | null
  }

  export type Em_apc_skill_experAvgAggregateOutputType = {
    SkillId: number | null
    ApcId: number | null
    Salary: number | null
    ExpectedSalary: number | null
  }

  export type Em_apc_skill_experSumAggregateOutputType = {
    SkillId: number | null
    ApcId: number | null
    Salary: number | null
    ExpectedSalary: number | null
  }

  export type Em_apc_skill_experMinAggregateOutputType = {
    SkillId: number | null
    ApcId: number | null
    CompanyName: string | null
    Province: string | null
    JobTitle: string | null
    Salary: number | null
    StartDate: Date | null
    EndDate: Date | null
    Responsibilities: string | null
    CareerGoals: string | null
    WhyJoin: string | null
    IsFriend: string | null
    IsMentions: string | null
    IsCompProgram: string | null
    IsIllnes: string | null
    HaveCriminal: string | null
    WhenWork: string | null
    ExpectedSalary: number | null
    isContribution: string | null
    isDuration: string | null
    isAgency: string | null
    isExprn: string | null
    isGenre: string | null
    isRelevan: string | null
    isSpesialSkill: string | null
    isShoot: string | null
    isSchedl: string | null
    isMotivation: string | null
    isStress: string | null
    isLongExpr: string | null
    isPhotTools: string | null
    isChalleng: string | null
    isThreeYears: string | null
    PersonVal: string | null
  }

  export type Em_apc_skill_experMaxAggregateOutputType = {
    SkillId: number | null
    ApcId: number | null
    CompanyName: string | null
    Province: string | null
    JobTitle: string | null
    Salary: number | null
    StartDate: Date | null
    EndDate: Date | null
    Responsibilities: string | null
    CareerGoals: string | null
    WhyJoin: string | null
    IsFriend: string | null
    IsMentions: string | null
    IsCompProgram: string | null
    IsIllnes: string | null
    HaveCriminal: string | null
    WhenWork: string | null
    ExpectedSalary: number | null
    isContribution: string | null
    isDuration: string | null
    isAgency: string | null
    isExprn: string | null
    isGenre: string | null
    isRelevan: string | null
    isSpesialSkill: string | null
    isShoot: string | null
    isSchedl: string | null
    isMotivation: string | null
    isStress: string | null
    isLongExpr: string | null
    isPhotTools: string | null
    isChalleng: string | null
    isThreeYears: string | null
    PersonVal: string | null
  }

  export type Em_apc_skill_experCountAggregateOutputType = {
    SkillId: number
    ApcId: number
    CompanyName: number
    Province: number
    JobTitle: number
    Salary: number
    StartDate: number
    EndDate: number
    Responsibilities: number
    CareerGoals: number
    WhyJoin: number
    IsFriend: number
    IsMentions: number
    IsCompProgram: number
    IsIllnes: number
    HaveCriminal: number
    WhenWork: number
    ExpectedSalary: number
    isContribution: number
    isDuration: number
    isAgency: number
    isExprn: number
    isGenre: number
    isRelevan: number
    isSpesialSkill: number
    isShoot: number
    isSchedl: number
    isMotivation: number
    isStress: number
    isLongExpr: number
    isPhotTools: number
    isChalleng: number
    isThreeYears: number
    PersonVal: number
    _all: number
  }


  export type Em_apc_skill_experAvgAggregateInputType = {
    SkillId?: true
    ApcId?: true
    Salary?: true
    ExpectedSalary?: true
  }

  export type Em_apc_skill_experSumAggregateInputType = {
    SkillId?: true
    ApcId?: true
    Salary?: true
    ExpectedSalary?: true
  }

  export type Em_apc_skill_experMinAggregateInputType = {
    SkillId?: true
    ApcId?: true
    CompanyName?: true
    Province?: true
    JobTitle?: true
    Salary?: true
    StartDate?: true
    EndDate?: true
    Responsibilities?: true
    CareerGoals?: true
    WhyJoin?: true
    IsFriend?: true
    IsMentions?: true
    IsCompProgram?: true
    IsIllnes?: true
    HaveCriminal?: true
    WhenWork?: true
    ExpectedSalary?: true
    isContribution?: true
    isDuration?: true
    isAgency?: true
    isExprn?: true
    isGenre?: true
    isRelevan?: true
    isSpesialSkill?: true
    isShoot?: true
    isSchedl?: true
    isMotivation?: true
    isStress?: true
    isLongExpr?: true
    isPhotTools?: true
    isChalleng?: true
    isThreeYears?: true
    PersonVal?: true
  }

  export type Em_apc_skill_experMaxAggregateInputType = {
    SkillId?: true
    ApcId?: true
    CompanyName?: true
    Province?: true
    JobTitle?: true
    Salary?: true
    StartDate?: true
    EndDate?: true
    Responsibilities?: true
    CareerGoals?: true
    WhyJoin?: true
    IsFriend?: true
    IsMentions?: true
    IsCompProgram?: true
    IsIllnes?: true
    HaveCriminal?: true
    WhenWork?: true
    ExpectedSalary?: true
    isContribution?: true
    isDuration?: true
    isAgency?: true
    isExprn?: true
    isGenre?: true
    isRelevan?: true
    isSpesialSkill?: true
    isShoot?: true
    isSchedl?: true
    isMotivation?: true
    isStress?: true
    isLongExpr?: true
    isPhotTools?: true
    isChalleng?: true
    isThreeYears?: true
    PersonVal?: true
  }

  export type Em_apc_skill_experCountAggregateInputType = {
    SkillId?: true
    ApcId?: true
    CompanyName?: true
    Province?: true
    JobTitle?: true
    Salary?: true
    StartDate?: true
    EndDate?: true
    Responsibilities?: true
    CareerGoals?: true
    WhyJoin?: true
    IsFriend?: true
    IsMentions?: true
    IsCompProgram?: true
    IsIllnes?: true
    HaveCriminal?: true
    WhenWork?: true
    ExpectedSalary?: true
    isContribution?: true
    isDuration?: true
    isAgency?: true
    isExprn?: true
    isGenre?: true
    isRelevan?: true
    isSpesialSkill?: true
    isShoot?: true
    isSchedl?: true
    isMotivation?: true
    isStress?: true
    isLongExpr?: true
    isPhotTools?: true
    isChalleng?: true
    isThreeYears?: true
    PersonVal?: true
    _all?: true
  }

  export type Em_apc_skill_experAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_skill_exper to aggregate.
     */
    where?: em_apc_skill_experWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_skill_expers to fetch.
     */
    orderBy?: em_apc_skill_experOrderByWithRelationInput | em_apc_skill_experOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_apc_skill_experWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_skill_expers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_skill_expers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_apc_skill_expers
    **/
    _count?: true | Em_apc_skill_experCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_apc_skill_experAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_apc_skill_experSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_apc_skill_experMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_apc_skill_experMaxAggregateInputType
  }

  export type GetEm_apc_skill_experAggregateType<T extends Em_apc_skill_experAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_apc_skill_exper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_apc_skill_exper[P]>
      : GetScalarType<T[P], AggregateEm_apc_skill_exper[P]>
  }




  export type em_apc_skill_experGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_apc_skill_experWhereInput
    orderBy?: em_apc_skill_experOrderByWithAggregationInput | em_apc_skill_experOrderByWithAggregationInput[]
    by: Em_apc_skill_experScalarFieldEnum[] | Em_apc_skill_experScalarFieldEnum
    having?: em_apc_skill_experScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_apc_skill_experCountAggregateInputType | true
    _avg?: Em_apc_skill_experAvgAggregateInputType
    _sum?: Em_apc_skill_experSumAggregateInputType
    _min?: Em_apc_skill_experMinAggregateInputType
    _max?: Em_apc_skill_experMaxAggregateInputType
  }

  export type Em_apc_skill_experGroupByOutputType = {
    SkillId: number
    ApcId: number
    CompanyName: string | null
    Province: string | null
    JobTitle: string | null
    Salary: number | null
    StartDate: Date | null
    EndDate: Date | null
    Responsibilities: string | null
    CareerGoals: string | null
    WhyJoin: string | null
    IsFriend: string | null
    IsMentions: string | null
    IsCompProgram: string | null
    IsIllnes: string | null
    HaveCriminal: string | null
    WhenWork: string | null
    ExpectedSalary: number | null
    isContribution: string | null
    isDuration: string | null
    isAgency: string | null
    isExprn: string | null
    isGenre: string | null
    isRelevan: string | null
    isSpesialSkill: string | null
    isShoot: string | null
    isSchedl: string | null
    isMotivation: string | null
    isStress: string | null
    isLongExpr: string | null
    isPhotTools: string | null
    isChalleng: string | null
    isThreeYears: string | null
    PersonVal: string | null
    _count: Em_apc_skill_experCountAggregateOutputType | null
    _avg: Em_apc_skill_experAvgAggregateOutputType | null
    _sum: Em_apc_skill_experSumAggregateOutputType | null
    _min: Em_apc_skill_experMinAggregateOutputType | null
    _max: Em_apc_skill_experMaxAggregateOutputType | null
  }

  type GetEm_apc_skill_experGroupByPayload<T extends em_apc_skill_experGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_apc_skill_experGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_apc_skill_experGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_apc_skill_experGroupByOutputType[P]>
            : GetScalarType<T[P], Em_apc_skill_experGroupByOutputType[P]>
        }
      >
    >


  export type em_apc_skill_experSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SkillId?: boolean
    ApcId?: boolean
    CompanyName?: boolean
    Province?: boolean
    JobTitle?: boolean
    Salary?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Responsibilities?: boolean
    CareerGoals?: boolean
    WhyJoin?: boolean
    IsFriend?: boolean
    IsMentions?: boolean
    IsCompProgram?: boolean
    IsIllnes?: boolean
    HaveCriminal?: boolean
    WhenWork?: boolean
    ExpectedSalary?: boolean
    isContribution?: boolean
    isDuration?: boolean
    isAgency?: boolean
    isExprn?: boolean
    isGenre?: boolean
    isRelevan?: boolean
    isSpesialSkill?: boolean
    isShoot?: boolean
    isSchedl?: boolean
    isMotivation?: boolean
    isStress?: boolean
    isLongExpr?: boolean
    isPhotTools?: boolean
    isChalleng?: boolean
    isThreeYears?: boolean
    PersonVal?: boolean
    em_apc_personal?: boolean | em_apc_personalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_apc_skill_exper"]>



  export type em_apc_skill_experSelectScalar = {
    SkillId?: boolean
    ApcId?: boolean
    CompanyName?: boolean
    Province?: boolean
    JobTitle?: boolean
    Salary?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Responsibilities?: boolean
    CareerGoals?: boolean
    WhyJoin?: boolean
    IsFriend?: boolean
    IsMentions?: boolean
    IsCompProgram?: boolean
    IsIllnes?: boolean
    HaveCriminal?: boolean
    WhenWork?: boolean
    ExpectedSalary?: boolean
    isContribution?: boolean
    isDuration?: boolean
    isAgency?: boolean
    isExprn?: boolean
    isGenre?: boolean
    isRelevan?: boolean
    isSpesialSkill?: boolean
    isShoot?: boolean
    isSchedl?: boolean
    isMotivation?: boolean
    isStress?: boolean
    isLongExpr?: boolean
    isPhotTools?: boolean
    isChalleng?: boolean
    isThreeYears?: boolean
    PersonVal?: boolean
  }

  export type em_apc_skill_experOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SkillId" | "ApcId" | "CompanyName" | "Province" | "JobTitle" | "Salary" | "StartDate" | "EndDate" | "Responsibilities" | "CareerGoals" | "WhyJoin" | "IsFriend" | "IsMentions" | "IsCompProgram" | "IsIllnes" | "HaveCriminal" | "WhenWork" | "ExpectedSalary" | "isContribution" | "isDuration" | "isAgency" | "isExprn" | "isGenre" | "isRelevan" | "isSpesialSkill" | "isShoot" | "isSchedl" | "isMotivation" | "isStress" | "isLongExpr" | "isPhotTools" | "isChalleng" | "isThreeYears" | "PersonVal", ExtArgs["result"]["em_apc_skill_exper"]>
  export type em_apc_skill_experInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_personal?: boolean | em_apc_personalDefaultArgs<ExtArgs>
  }

  export type $em_apc_skill_experPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_apc_skill_exper"
    objects: {
      em_apc_personal: Prisma.$em_apc_personalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SkillId: number
      ApcId: number
      CompanyName: string | null
      Province: string | null
      JobTitle: string | null
      Salary: number | null
      StartDate: Date | null
      EndDate: Date | null
      Responsibilities: string | null
      CareerGoals: string | null
      WhyJoin: string | null
      IsFriend: string | null
      IsMentions: string | null
      IsCompProgram: string | null
      IsIllnes: string | null
      HaveCriminal: string | null
      WhenWork: string | null
      ExpectedSalary: number | null
      isContribution: string | null
      isDuration: string | null
      isAgency: string | null
      isExprn: string | null
      isGenre: string | null
      isRelevan: string | null
      isSpesialSkill: string | null
      isShoot: string | null
      isSchedl: string | null
      isMotivation: string | null
      isStress: string | null
      isLongExpr: string | null
      isPhotTools: string | null
      isChalleng: string | null
      isThreeYears: string | null
      PersonVal: string | null
    }, ExtArgs["result"]["em_apc_skill_exper"]>
    composites: {}
  }

  type em_apc_skill_experGetPayload<S extends boolean | null | undefined | em_apc_skill_experDefaultArgs> = $Result.GetResult<Prisma.$em_apc_skill_experPayload, S>

  type em_apc_skill_experCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_apc_skill_experFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_apc_skill_experCountAggregateInputType | true
    }

  export interface em_apc_skill_experDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_apc_skill_exper'], meta: { name: 'em_apc_skill_exper' } }
    /**
     * Find zero or one Em_apc_skill_exper that matches the filter.
     * @param {em_apc_skill_experFindUniqueArgs} args - Arguments to find a Em_apc_skill_exper
     * @example
     * // Get one Em_apc_skill_exper
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_apc_skill_experFindUniqueArgs>(args: SelectSubset<T, em_apc_skill_experFindUniqueArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_apc_skill_exper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_apc_skill_experFindUniqueOrThrowArgs} args - Arguments to find a Em_apc_skill_exper
     * @example
     * // Get one Em_apc_skill_exper
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_apc_skill_experFindUniqueOrThrowArgs>(args: SelectSubset<T, em_apc_skill_experFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_skill_exper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_skill_experFindFirstArgs} args - Arguments to find a Em_apc_skill_exper
     * @example
     * // Get one Em_apc_skill_exper
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_apc_skill_experFindFirstArgs>(args?: SelectSubset<T, em_apc_skill_experFindFirstArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_apc_skill_exper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_skill_experFindFirstOrThrowArgs} args - Arguments to find a Em_apc_skill_exper
     * @example
     * // Get one Em_apc_skill_exper
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_apc_skill_experFindFirstOrThrowArgs>(args?: SelectSubset<T, em_apc_skill_experFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_apc_skill_expers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_skill_experFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_apc_skill_expers
     * const em_apc_skill_expers = await prisma.em_apc_skill_exper.findMany()
     * 
     * // Get first 10 Em_apc_skill_expers
     * const em_apc_skill_expers = await prisma.em_apc_skill_exper.findMany({ take: 10 })
     * 
     * // Only select the `SkillId`
     * const em_apc_skill_experWithSkillIdOnly = await prisma.em_apc_skill_exper.findMany({ select: { SkillId: true } })
     * 
     */
    findMany<T extends em_apc_skill_experFindManyArgs>(args?: SelectSubset<T, em_apc_skill_experFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_apc_skill_exper.
     * @param {em_apc_skill_experCreateArgs} args - Arguments to create a Em_apc_skill_exper.
     * @example
     * // Create one Em_apc_skill_exper
     * const Em_apc_skill_exper = await prisma.em_apc_skill_exper.create({
     *   data: {
     *     // ... data to create a Em_apc_skill_exper
     *   }
     * })
     * 
     */
    create<T extends em_apc_skill_experCreateArgs>(args: SelectSubset<T, em_apc_skill_experCreateArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_apc_skill_expers.
     * @param {em_apc_skill_experCreateManyArgs} args - Arguments to create many Em_apc_skill_expers.
     * @example
     * // Create many Em_apc_skill_expers
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_apc_skill_experCreateManyArgs>(args?: SelectSubset<T, em_apc_skill_experCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_apc_skill_exper.
     * @param {em_apc_skill_experDeleteArgs} args - Arguments to delete one Em_apc_skill_exper.
     * @example
     * // Delete one Em_apc_skill_exper
     * const Em_apc_skill_exper = await prisma.em_apc_skill_exper.delete({
     *   where: {
     *     // ... filter to delete one Em_apc_skill_exper
     *   }
     * })
     * 
     */
    delete<T extends em_apc_skill_experDeleteArgs>(args: SelectSubset<T, em_apc_skill_experDeleteArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_apc_skill_exper.
     * @param {em_apc_skill_experUpdateArgs} args - Arguments to update one Em_apc_skill_exper.
     * @example
     * // Update one Em_apc_skill_exper
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_apc_skill_experUpdateArgs>(args: SelectSubset<T, em_apc_skill_experUpdateArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_apc_skill_expers.
     * @param {em_apc_skill_experDeleteManyArgs} args - Arguments to filter Em_apc_skill_expers to delete.
     * @example
     * // Delete a few Em_apc_skill_expers
     * const { count } = await prisma.em_apc_skill_exper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_apc_skill_experDeleteManyArgs>(args?: SelectSubset<T, em_apc_skill_experDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_apc_skill_expers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_skill_experUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_apc_skill_expers
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_apc_skill_experUpdateManyArgs>(args: SelectSubset<T, em_apc_skill_experUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_apc_skill_exper.
     * @param {em_apc_skill_experUpsertArgs} args - Arguments to update or create a Em_apc_skill_exper.
     * @example
     * // Update or create a Em_apc_skill_exper
     * const em_apc_skill_exper = await prisma.em_apc_skill_exper.upsert({
     *   create: {
     *     // ... data to create a Em_apc_skill_exper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_apc_skill_exper we want to update
     *   }
     * })
     */
    upsert<T extends em_apc_skill_experUpsertArgs>(args: SelectSubset<T, em_apc_skill_experUpsertArgs<ExtArgs>>): Prisma__em_apc_skill_experClient<$Result.GetResult<Prisma.$em_apc_skill_experPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_apc_skill_expers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_skill_experCountArgs} args - Arguments to filter Em_apc_skill_expers to count.
     * @example
     * // Count the number of Em_apc_skill_expers
     * const count = await prisma.em_apc_skill_exper.count({
     *   where: {
     *     // ... the filter for the Em_apc_skill_expers we want to count
     *   }
     * })
    **/
    count<T extends em_apc_skill_experCountArgs>(
      args?: Subset<T, em_apc_skill_experCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_apc_skill_experCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_apc_skill_exper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_apc_skill_experAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_apc_skill_experAggregateArgs>(args: Subset<T, Em_apc_skill_experAggregateArgs>): Prisma.PrismaPromise<GetEm_apc_skill_experAggregateType<T>>

    /**
     * Group by Em_apc_skill_exper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_apc_skill_experGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_apc_skill_experGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_apc_skill_experGroupByArgs['orderBy'] }
        : { orderBy?: em_apc_skill_experGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_apc_skill_experGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_apc_skill_experGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_apc_skill_exper model
   */
  readonly fields: em_apc_skill_experFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_apc_skill_exper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_apc_skill_experClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_apc_personal<T extends em_apc_personalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personalDefaultArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_apc_skill_exper model
   */
  interface em_apc_skill_experFieldRefs {
    readonly SkillId: FieldRef<"em_apc_skill_exper", 'Int'>
    readonly ApcId: FieldRef<"em_apc_skill_exper", 'Int'>
    readonly CompanyName: FieldRef<"em_apc_skill_exper", 'String'>
    readonly Province: FieldRef<"em_apc_skill_exper", 'String'>
    readonly JobTitle: FieldRef<"em_apc_skill_exper", 'String'>
    readonly Salary: FieldRef<"em_apc_skill_exper", 'Float'>
    readonly StartDate: FieldRef<"em_apc_skill_exper", 'DateTime'>
    readonly EndDate: FieldRef<"em_apc_skill_exper", 'DateTime'>
    readonly Responsibilities: FieldRef<"em_apc_skill_exper", 'String'>
    readonly CareerGoals: FieldRef<"em_apc_skill_exper", 'String'>
    readonly WhyJoin: FieldRef<"em_apc_skill_exper", 'String'>
    readonly IsFriend: FieldRef<"em_apc_skill_exper", 'String'>
    readonly IsMentions: FieldRef<"em_apc_skill_exper", 'String'>
    readonly IsCompProgram: FieldRef<"em_apc_skill_exper", 'String'>
    readonly IsIllnes: FieldRef<"em_apc_skill_exper", 'String'>
    readonly HaveCriminal: FieldRef<"em_apc_skill_exper", 'String'>
    readonly WhenWork: FieldRef<"em_apc_skill_exper", 'String'>
    readonly ExpectedSalary: FieldRef<"em_apc_skill_exper", 'Float'>
    readonly isContribution: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isDuration: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isAgency: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isExprn: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isGenre: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isRelevan: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isSpesialSkill: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isShoot: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isSchedl: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isMotivation: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isStress: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isLongExpr: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isPhotTools: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isChalleng: FieldRef<"em_apc_skill_exper", 'String'>
    readonly isThreeYears: FieldRef<"em_apc_skill_exper", 'String'>
    readonly PersonVal: FieldRef<"em_apc_skill_exper", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_apc_skill_exper findUnique
   */
  export type em_apc_skill_experFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_skill_exper to fetch.
     */
    where: em_apc_skill_experWhereUniqueInput
  }

  /**
   * em_apc_skill_exper findUniqueOrThrow
   */
  export type em_apc_skill_experFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_skill_exper to fetch.
     */
    where: em_apc_skill_experWhereUniqueInput
  }

  /**
   * em_apc_skill_exper findFirst
   */
  export type em_apc_skill_experFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_skill_exper to fetch.
     */
    where?: em_apc_skill_experWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_skill_expers to fetch.
     */
    orderBy?: em_apc_skill_experOrderByWithRelationInput | em_apc_skill_experOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_skill_expers.
     */
    cursor?: em_apc_skill_experWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_skill_expers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_skill_expers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_skill_expers.
     */
    distinct?: Em_apc_skill_experScalarFieldEnum | Em_apc_skill_experScalarFieldEnum[]
  }

  /**
   * em_apc_skill_exper findFirstOrThrow
   */
  export type em_apc_skill_experFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_skill_exper to fetch.
     */
    where?: em_apc_skill_experWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_skill_expers to fetch.
     */
    orderBy?: em_apc_skill_experOrderByWithRelationInput | em_apc_skill_experOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_apc_skill_expers.
     */
    cursor?: em_apc_skill_experWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_skill_expers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_skill_expers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_apc_skill_expers.
     */
    distinct?: Em_apc_skill_experScalarFieldEnum | Em_apc_skill_experScalarFieldEnum[]
  }

  /**
   * em_apc_skill_exper findMany
   */
  export type em_apc_skill_experFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * Filter, which em_apc_skill_expers to fetch.
     */
    where?: em_apc_skill_experWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_apc_skill_expers to fetch.
     */
    orderBy?: em_apc_skill_experOrderByWithRelationInput | em_apc_skill_experOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_apc_skill_expers.
     */
    cursor?: em_apc_skill_experWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_apc_skill_expers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_apc_skill_expers.
     */
    skip?: number
    distinct?: Em_apc_skill_experScalarFieldEnum | Em_apc_skill_experScalarFieldEnum[]
  }

  /**
   * em_apc_skill_exper create
   */
  export type em_apc_skill_experCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * The data needed to create a em_apc_skill_exper.
     */
    data: XOR<em_apc_skill_experCreateInput, em_apc_skill_experUncheckedCreateInput>
  }

  /**
   * em_apc_skill_exper createMany
   */
  export type em_apc_skill_experCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_apc_skill_expers.
     */
    data: em_apc_skill_experCreateManyInput | em_apc_skill_experCreateManyInput[]
  }

  /**
   * em_apc_skill_exper update
   */
  export type em_apc_skill_experUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * The data needed to update a em_apc_skill_exper.
     */
    data: XOR<em_apc_skill_experUpdateInput, em_apc_skill_experUncheckedUpdateInput>
    /**
     * Choose, which em_apc_skill_exper to update.
     */
    where: em_apc_skill_experWhereUniqueInput
  }

  /**
   * em_apc_skill_exper updateMany
   */
  export type em_apc_skill_experUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_apc_skill_expers.
     */
    data: XOR<em_apc_skill_experUpdateManyMutationInput, em_apc_skill_experUncheckedUpdateManyInput>
    /**
     * Filter which em_apc_skill_expers to update
     */
    where?: em_apc_skill_experWhereInput
    /**
     * Limit how many em_apc_skill_expers to update.
     */
    limit?: number
  }

  /**
   * em_apc_skill_exper upsert
   */
  export type em_apc_skill_experUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * The filter to search for the em_apc_skill_exper to update in case it exists.
     */
    where: em_apc_skill_experWhereUniqueInput
    /**
     * In case the em_apc_skill_exper found by the `where` argument doesn't exist, create a new em_apc_skill_exper with this data.
     */
    create: XOR<em_apc_skill_experCreateInput, em_apc_skill_experUncheckedCreateInput>
    /**
     * In case the em_apc_skill_exper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_apc_skill_experUpdateInput, em_apc_skill_experUncheckedUpdateInput>
  }

  /**
   * em_apc_skill_exper delete
   */
  export type em_apc_skill_experDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
    /**
     * Filter which em_apc_skill_exper to delete.
     */
    where: em_apc_skill_experWhereUniqueInput
  }

  /**
   * em_apc_skill_exper deleteMany
   */
  export type em_apc_skill_experDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_apc_skill_expers to delete
     */
    where?: em_apc_skill_experWhereInput
    /**
     * Limit how many em_apc_skill_expers to delete.
     */
    limit?: number
  }

  /**
   * em_apc_skill_exper without action
   */
  export type em_apc_skill_experDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_apc_skill_exper
     */
    select?: em_apc_skill_experSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_apc_skill_exper
     */
    omit?: em_apc_skill_experOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_apc_skill_experInclude<ExtArgs> | null
  }


  /**
   * Model em_api_keys
   */

  export type AggregateEm_api_keys = {
    _count: Em_api_keysCountAggregateOutputType | null
    _avg: Em_api_keysAvgAggregateOutputType | null
    _sum: Em_api_keysSumAggregateOutputType | null
    _min: Em_api_keysMinAggregateOutputType | null
    _max: Em_api_keysMaxAggregateOutputType | null
  }

  export type Em_api_keysAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_api_keysSumAggregateOutputType = {
    id: number | null
  }

  export type Em_api_keysMinAggregateOutputType = {
    id: number | null
    username: string | null
    api_key: string | null
    created_at: Date | null
  }

  export type Em_api_keysMaxAggregateOutputType = {
    id: number | null
    username: string | null
    api_key: string | null
    created_at: Date | null
  }

  export type Em_api_keysCountAggregateOutputType = {
    id: number
    username: number
    api_key: number
    created_at: number
    _all: number
  }


  export type Em_api_keysAvgAggregateInputType = {
    id?: true
  }

  export type Em_api_keysSumAggregateInputType = {
    id?: true
  }

  export type Em_api_keysMinAggregateInputType = {
    id?: true
    username?: true
    api_key?: true
    created_at?: true
  }

  export type Em_api_keysMaxAggregateInputType = {
    id?: true
    username?: true
    api_key?: true
    created_at?: true
  }

  export type Em_api_keysCountAggregateInputType = {
    id?: true
    username?: true
    api_key?: true
    created_at?: true
    _all?: true
  }

  export type Em_api_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_api_keys to aggregate.
     */
    where?: em_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_api_keys to fetch.
     */
    orderBy?: em_api_keysOrderByWithRelationInput | em_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_api_keys
    **/
    _count?: true | Em_api_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_api_keysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_api_keysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_api_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_api_keysMaxAggregateInputType
  }

  export type GetEm_api_keysAggregateType<T extends Em_api_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_api_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_api_keys[P]>
      : GetScalarType<T[P], AggregateEm_api_keys[P]>
  }




  export type em_api_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_api_keysWhereInput
    orderBy?: em_api_keysOrderByWithAggregationInput | em_api_keysOrderByWithAggregationInput[]
    by: Em_api_keysScalarFieldEnum[] | Em_api_keysScalarFieldEnum
    having?: em_api_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_api_keysCountAggregateInputType | true
    _avg?: Em_api_keysAvgAggregateInputType
    _sum?: Em_api_keysSumAggregateInputType
    _min?: Em_api_keysMinAggregateInputType
    _max?: Em_api_keysMaxAggregateInputType
  }

  export type Em_api_keysGroupByOutputType = {
    id: number
    username: string | null
    api_key: string
    created_at: Date
    _count: Em_api_keysCountAggregateOutputType | null
    _avg: Em_api_keysAvgAggregateOutputType | null
    _sum: Em_api_keysSumAggregateOutputType | null
    _min: Em_api_keysMinAggregateOutputType | null
    _max: Em_api_keysMaxAggregateOutputType | null
  }

  type GetEm_api_keysGroupByPayload<T extends em_api_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_api_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_api_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_api_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Em_api_keysGroupByOutputType[P]>
        }
      >
    >


  export type em_api_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    api_key?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["em_api_keys"]>



  export type em_api_keysSelectScalar = {
    id?: boolean
    username?: boolean
    api_key?: boolean
    created_at?: boolean
  }

  export type em_api_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "api_key" | "created_at", ExtArgs["result"]["em_api_keys"]>

  export type $em_api_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_api_keys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      api_key: string
      created_at: Date
    }, ExtArgs["result"]["em_api_keys"]>
    composites: {}
  }

  type em_api_keysGetPayload<S extends boolean | null | undefined | em_api_keysDefaultArgs> = $Result.GetResult<Prisma.$em_api_keysPayload, S>

  type em_api_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_api_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_api_keysCountAggregateInputType | true
    }

  export interface em_api_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_api_keys'], meta: { name: 'em_api_keys' } }
    /**
     * Find zero or one Em_api_keys that matches the filter.
     * @param {em_api_keysFindUniqueArgs} args - Arguments to find a Em_api_keys
     * @example
     * // Get one Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_api_keysFindUniqueArgs>(args: SelectSubset<T, em_api_keysFindUniqueArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_api_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_api_keysFindUniqueOrThrowArgs} args - Arguments to find a Em_api_keys
     * @example
     * // Get one Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_api_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, em_api_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_api_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_api_keysFindFirstArgs} args - Arguments to find a Em_api_keys
     * @example
     * // Get one Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_api_keysFindFirstArgs>(args?: SelectSubset<T, em_api_keysFindFirstArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_api_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_api_keysFindFirstOrThrowArgs} args - Arguments to find a Em_api_keys
     * @example
     * // Get one Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_api_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, em_api_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_api_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_api_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.findMany()
     * 
     * // Get first 10 Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_api_keysWithIdOnly = await prisma.em_api_keys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_api_keysFindManyArgs>(args?: SelectSubset<T, em_api_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_api_keys.
     * @param {em_api_keysCreateArgs} args - Arguments to create a Em_api_keys.
     * @example
     * // Create one Em_api_keys
     * const Em_api_keys = await prisma.em_api_keys.create({
     *   data: {
     *     // ... data to create a Em_api_keys
     *   }
     * })
     * 
     */
    create<T extends em_api_keysCreateArgs>(args: SelectSubset<T, em_api_keysCreateArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_api_keys.
     * @param {em_api_keysCreateManyArgs} args - Arguments to create many Em_api_keys.
     * @example
     * // Create many Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_api_keysCreateManyArgs>(args?: SelectSubset<T, em_api_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_api_keys.
     * @param {em_api_keysDeleteArgs} args - Arguments to delete one Em_api_keys.
     * @example
     * // Delete one Em_api_keys
     * const Em_api_keys = await prisma.em_api_keys.delete({
     *   where: {
     *     // ... filter to delete one Em_api_keys
     *   }
     * })
     * 
     */
    delete<T extends em_api_keysDeleteArgs>(args: SelectSubset<T, em_api_keysDeleteArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_api_keys.
     * @param {em_api_keysUpdateArgs} args - Arguments to update one Em_api_keys.
     * @example
     * // Update one Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_api_keysUpdateArgs>(args: SelectSubset<T, em_api_keysUpdateArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_api_keys.
     * @param {em_api_keysDeleteManyArgs} args - Arguments to filter Em_api_keys to delete.
     * @example
     * // Delete a few Em_api_keys
     * const { count } = await prisma.em_api_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_api_keysDeleteManyArgs>(args?: SelectSubset<T, em_api_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_api_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_api_keysUpdateManyArgs>(args: SelectSubset<T, em_api_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_api_keys.
     * @param {em_api_keysUpsertArgs} args - Arguments to update or create a Em_api_keys.
     * @example
     * // Update or create a Em_api_keys
     * const em_api_keys = await prisma.em_api_keys.upsert({
     *   create: {
     *     // ... data to create a Em_api_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_api_keys we want to update
     *   }
     * })
     */
    upsert<T extends em_api_keysUpsertArgs>(args: SelectSubset<T, em_api_keysUpsertArgs<ExtArgs>>): Prisma__em_api_keysClient<$Result.GetResult<Prisma.$em_api_keysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_api_keysCountArgs} args - Arguments to filter Em_api_keys to count.
     * @example
     * // Count the number of Em_api_keys
     * const count = await prisma.em_api_keys.count({
     *   where: {
     *     // ... the filter for the Em_api_keys we want to count
     *   }
     * })
    **/
    count<T extends em_api_keysCountArgs>(
      args?: Subset<T, em_api_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_api_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_api_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_api_keysAggregateArgs>(args: Subset<T, Em_api_keysAggregateArgs>): Prisma.PrismaPromise<GetEm_api_keysAggregateType<T>>

    /**
     * Group by Em_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_api_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_api_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_api_keysGroupByArgs['orderBy'] }
        : { orderBy?: em_api_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_api_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_api_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_api_keys model
   */
  readonly fields: em_api_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_api_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_api_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_api_keys model
   */
  interface em_api_keysFieldRefs {
    readonly id: FieldRef<"em_api_keys", 'Int'>
    readonly username: FieldRef<"em_api_keys", 'String'>
    readonly api_key: FieldRef<"em_api_keys", 'String'>
    readonly created_at: FieldRef<"em_api_keys", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_api_keys findUnique
   */
  export type em_api_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * Filter, which em_api_keys to fetch.
     */
    where: em_api_keysWhereUniqueInput
  }

  /**
   * em_api_keys findUniqueOrThrow
   */
  export type em_api_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * Filter, which em_api_keys to fetch.
     */
    where: em_api_keysWhereUniqueInput
  }

  /**
   * em_api_keys findFirst
   */
  export type em_api_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * Filter, which em_api_keys to fetch.
     */
    where?: em_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_api_keys to fetch.
     */
    orderBy?: em_api_keysOrderByWithRelationInput | em_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_api_keys.
     */
    cursor?: em_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_api_keys.
     */
    distinct?: Em_api_keysScalarFieldEnum | Em_api_keysScalarFieldEnum[]
  }

  /**
   * em_api_keys findFirstOrThrow
   */
  export type em_api_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * Filter, which em_api_keys to fetch.
     */
    where?: em_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_api_keys to fetch.
     */
    orderBy?: em_api_keysOrderByWithRelationInput | em_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_api_keys.
     */
    cursor?: em_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_api_keys.
     */
    distinct?: Em_api_keysScalarFieldEnum | Em_api_keysScalarFieldEnum[]
  }

  /**
   * em_api_keys findMany
   */
  export type em_api_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * Filter, which em_api_keys to fetch.
     */
    where?: em_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_api_keys to fetch.
     */
    orderBy?: em_api_keysOrderByWithRelationInput | em_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_api_keys.
     */
    cursor?: em_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_api_keys.
     */
    skip?: number
    distinct?: Em_api_keysScalarFieldEnum | Em_api_keysScalarFieldEnum[]
  }

  /**
   * em_api_keys create
   */
  export type em_api_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * The data needed to create a em_api_keys.
     */
    data: XOR<em_api_keysCreateInput, em_api_keysUncheckedCreateInput>
  }

  /**
   * em_api_keys createMany
   */
  export type em_api_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_api_keys.
     */
    data: em_api_keysCreateManyInput | em_api_keysCreateManyInput[]
  }

  /**
   * em_api_keys update
   */
  export type em_api_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * The data needed to update a em_api_keys.
     */
    data: XOR<em_api_keysUpdateInput, em_api_keysUncheckedUpdateInput>
    /**
     * Choose, which em_api_keys to update.
     */
    where: em_api_keysWhereUniqueInput
  }

  /**
   * em_api_keys updateMany
   */
  export type em_api_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_api_keys.
     */
    data: XOR<em_api_keysUpdateManyMutationInput, em_api_keysUncheckedUpdateManyInput>
    /**
     * Filter which em_api_keys to update
     */
    where?: em_api_keysWhereInput
    /**
     * Limit how many em_api_keys to update.
     */
    limit?: number
  }

  /**
   * em_api_keys upsert
   */
  export type em_api_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * The filter to search for the em_api_keys to update in case it exists.
     */
    where: em_api_keysWhereUniqueInput
    /**
     * In case the em_api_keys found by the `where` argument doesn't exist, create a new em_api_keys with this data.
     */
    create: XOR<em_api_keysCreateInput, em_api_keysUncheckedCreateInput>
    /**
     * In case the em_api_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_api_keysUpdateInput, em_api_keysUncheckedUpdateInput>
  }

  /**
   * em_api_keys delete
   */
  export type em_api_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
    /**
     * Filter which em_api_keys to delete.
     */
    where: em_api_keysWhereUniqueInput
  }

  /**
   * em_api_keys deleteMany
   */
  export type em_api_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_api_keys to delete
     */
    where?: em_api_keysWhereInput
    /**
     * Limit how many em_api_keys to delete.
     */
    limit?: number
  }

  /**
   * em_api_keys without action
   */
  export type em_api_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_api_keys
     */
    select?: em_api_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_api_keys
     */
    omit?: em_api_keysOmit<ExtArgs> | null
  }


  /**
   * Model em_applicant_criteria
   */

  export type AggregateEm_applicant_criteria = {
    _count: Em_applicant_criteriaCountAggregateOutputType | null
    _avg: Em_applicant_criteriaAvgAggregateOutputType | null
    _sum: Em_applicant_criteriaSumAggregateOutputType | null
    _min: Em_applicant_criteriaMinAggregateOutputType | null
    _max: Em_applicant_criteriaMaxAggregateOutputType | null
  }

  export type Em_applicant_criteriaAvgAggregateOutputType = {
    id_kriteria: number | null
    id_loker: number | null
    bobot: number | null
  }

  export type Em_applicant_criteriaSumAggregateOutputType = {
    id_kriteria: number | null
    id_loker: number | null
    bobot: number | null
  }

  export type Em_applicant_criteriaMinAggregateOutputType = {
    id_kriteria: number | null
    id_loker: number | null
    jenis_kriteria: string | null
    value: string | null
    value_en: string | null
    bobot: number | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_applicant_criteriaMaxAggregateOutputType = {
    id_kriteria: number | null
    id_loker: number | null
    jenis_kriteria: string | null
    value: string | null
    value_en: string | null
    bobot: number | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_applicant_criteriaCountAggregateOutputType = {
    id_kriteria: number
    id_loker: number
    jenis_kriteria: number
    value: number
    value_en: number
    bobot: number
    created_at: number
    lastupdate: number
    _all: number
  }


  export type Em_applicant_criteriaAvgAggregateInputType = {
    id_kriteria?: true
    id_loker?: true
    bobot?: true
  }

  export type Em_applicant_criteriaSumAggregateInputType = {
    id_kriteria?: true
    id_loker?: true
    bobot?: true
  }

  export type Em_applicant_criteriaMinAggregateInputType = {
    id_kriteria?: true
    id_loker?: true
    jenis_kriteria?: true
    value?: true
    value_en?: true
    bobot?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_applicant_criteriaMaxAggregateInputType = {
    id_kriteria?: true
    id_loker?: true
    jenis_kriteria?: true
    value?: true
    value_en?: true
    bobot?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_applicant_criteriaCountAggregateInputType = {
    id_kriteria?: true
    id_loker?: true
    jenis_kriteria?: true
    value?: true
    value_en?: true
    bobot?: true
    created_at?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_applicant_criteriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_applicant_criteria to aggregate.
     */
    where?: em_applicant_criteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_criteria to fetch.
     */
    orderBy?: em_applicant_criteriaOrderByWithRelationInput | em_applicant_criteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_applicant_criteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_criteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_criteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_applicant_criteria
    **/
    _count?: true | Em_applicant_criteriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_applicant_criteriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_applicant_criteriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_applicant_criteriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_applicant_criteriaMaxAggregateInputType
  }

  export type GetEm_applicant_criteriaAggregateType<T extends Em_applicant_criteriaAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_applicant_criteria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_applicant_criteria[P]>
      : GetScalarType<T[P], AggregateEm_applicant_criteria[P]>
  }




  export type em_applicant_criteriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_applicant_criteriaWhereInput
    orderBy?: em_applicant_criteriaOrderByWithAggregationInput | em_applicant_criteriaOrderByWithAggregationInput[]
    by: Em_applicant_criteriaScalarFieldEnum[] | Em_applicant_criteriaScalarFieldEnum
    having?: em_applicant_criteriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_applicant_criteriaCountAggregateInputType | true
    _avg?: Em_applicant_criteriaAvgAggregateInputType
    _sum?: Em_applicant_criteriaSumAggregateInputType
    _min?: Em_applicant_criteriaMinAggregateInputType
    _max?: Em_applicant_criteriaMaxAggregateInputType
  }

  export type Em_applicant_criteriaGroupByOutputType = {
    id_kriteria: number
    id_loker: number
    jenis_kriteria: string | null
    value: string | null
    value_en: string | null
    bobot: number | null
    created_at: Date | null
    lastupdate: Date | null
    _count: Em_applicant_criteriaCountAggregateOutputType | null
    _avg: Em_applicant_criteriaAvgAggregateOutputType | null
    _sum: Em_applicant_criteriaSumAggregateOutputType | null
    _min: Em_applicant_criteriaMinAggregateOutputType | null
    _max: Em_applicant_criteriaMaxAggregateOutputType | null
  }

  type GetEm_applicant_criteriaGroupByPayload<T extends em_applicant_criteriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_applicant_criteriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_applicant_criteriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_applicant_criteriaGroupByOutputType[P]>
            : GetScalarType<T[P], Em_applicant_criteriaGroupByOutputType[P]>
        }
      >
    >


  export type em_applicant_criteriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kriteria?: boolean
    id_loker?: boolean
    jenis_kriteria?: boolean
    value?: boolean
    value_en?: boolean
    bobot?: boolean
    created_at?: boolean
    lastupdate?: boolean
    emposs?: boolean | empossDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_applicant_criteria"]>



  export type em_applicant_criteriaSelectScalar = {
    id_kriteria?: boolean
    id_loker?: boolean
    jenis_kriteria?: boolean
    value?: boolean
    value_en?: boolean
    bobot?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }

  export type em_applicant_criteriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_kriteria" | "id_loker" | "jenis_kriteria" | "value" | "value_en" | "bobot" | "created_at" | "lastupdate", ExtArgs["result"]["em_applicant_criteria"]>
  export type em_applicant_criteriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emposs?: boolean | empossDefaultArgs<ExtArgs>
  }

  export type $em_applicant_criteriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_applicant_criteria"
    objects: {
      emposs: Prisma.$empossPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_kriteria: number
      id_loker: number
      jenis_kriteria: string | null
      value: string | null
      value_en: string | null
      bobot: number | null
      created_at: Date | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_applicant_criteria"]>
    composites: {}
  }

  type em_applicant_criteriaGetPayload<S extends boolean | null | undefined | em_applicant_criteriaDefaultArgs> = $Result.GetResult<Prisma.$em_applicant_criteriaPayload, S>

  type em_applicant_criteriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_applicant_criteriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_applicant_criteriaCountAggregateInputType | true
    }

  export interface em_applicant_criteriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_applicant_criteria'], meta: { name: 'em_applicant_criteria' } }
    /**
     * Find zero or one Em_applicant_criteria that matches the filter.
     * @param {em_applicant_criteriaFindUniqueArgs} args - Arguments to find a Em_applicant_criteria
     * @example
     * // Get one Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_applicant_criteriaFindUniqueArgs>(args: SelectSubset<T, em_applicant_criteriaFindUniqueArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_applicant_criteria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_applicant_criteriaFindUniqueOrThrowArgs} args - Arguments to find a Em_applicant_criteria
     * @example
     * // Get one Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_applicant_criteriaFindUniqueOrThrowArgs>(args: SelectSubset<T, em_applicant_criteriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_applicant_criteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_criteriaFindFirstArgs} args - Arguments to find a Em_applicant_criteria
     * @example
     * // Get one Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_applicant_criteriaFindFirstArgs>(args?: SelectSubset<T, em_applicant_criteriaFindFirstArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_applicant_criteria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_criteriaFindFirstOrThrowArgs} args - Arguments to find a Em_applicant_criteria
     * @example
     * // Get one Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_applicant_criteriaFindFirstOrThrowArgs>(args?: SelectSubset<T, em_applicant_criteriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_applicant_criteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_criteriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.findMany()
     * 
     * // Get first 10 Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.findMany({ take: 10 })
     * 
     * // Only select the `id_kriteria`
     * const em_applicant_criteriaWithId_kriteriaOnly = await prisma.em_applicant_criteria.findMany({ select: { id_kriteria: true } })
     * 
     */
    findMany<T extends em_applicant_criteriaFindManyArgs>(args?: SelectSubset<T, em_applicant_criteriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_applicant_criteria.
     * @param {em_applicant_criteriaCreateArgs} args - Arguments to create a Em_applicant_criteria.
     * @example
     * // Create one Em_applicant_criteria
     * const Em_applicant_criteria = await prisma.em_applicant_criteria.create({
     *   data: {
     *     // ... data to create a Em_applicant_criteria
     *   }
     * })
     * 
     */
    create<T extends em_applicant_criteriaCreateArgs>(args: SelectSubset<T, em_applicant_criteriaCreateArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_applicant_criteria.
     * @param {em_applicant_criteriaCreateManyArgs} args - Arguments to create many Em_applicant_criteria.
     * @example
     * // Create many Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_applicant_criteriaCreateManyArgs>(args?: SelectSubset<T, em_applicant_criteriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_applicant_criteria.
     * @param {em_applicant_criteriaDeleteArgs} args - Arguments to delete one Em_applicant_criteria.
     * @example
     * // Delete one Em_applicant_criteria
     * const Em_applicant_criteria = await prisma.em_applicant_criteria.delete({
     *   where: {
     *     // ... filter to delete one Em_applicant_criteria
     *   }
     * })
     * 
     */
    delete<T extends em_applicant_criteriaDeleteArgs>(args: SelectSubset<T, em_applicant_criteriaDeleteArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_applicant_criteria.
     * @param {em_applicant_criteriaUpdateArgs} args - Arguments to update one Em_applicant_criteria.
     * @example
     * // Update one Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_applicant_criteriaUpdateArgs>(args: SelectSubset<T, em_applicant_criteriaUpdateArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_applicant_criteria.
     * @param {em_applicant_criteriaDeleteManyArgs} args - Arguments to filter Em_applicant_criteria to delete.
     * @example
     * // Delete a few Em_applicant_criteria
     * const { count } = await prisma.em_applicant_criteria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_applicant_criteriaDeleteManyArgs>(args?: SelectSubset<T, em_applicant_criteriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_applicant_criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_criteriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_applicant_criteriaUpdateManyArgs>(args: SelectSubset<T, em_applicant_criteriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_applicant_criteria.
     * @param {em_applicant_criteriaUpsertArgs} args - Arguments to update or create a Em_applicant_criteria.
     * @example
     * // Update or create a Em_applicant_criteria
     * const em_applicant_criteria = await prisma.em_applicant_criteria.upsert({
     *   create: {
     *     // ... data to create a Em_applicant_criteria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_applicant_criteria we want to update
     *   }
     * })
     */
    upsert<T extends em_applicant_criteriaUpsertArgs>(args: SelectSubset<T, em_applicant_criteriaUpsertArgs<ExtArgs>>): Prisma__em_applicant_criteriaClient<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_applicant_criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_criteriaCountArgs} args - Arguments to filter Em_applicant_criteria to count.
     * @example
     * // Count the number of Em_applicant_criteria
     * const count = await prisma.em_applicant_criteria.count({
     *   where: {
     *     // ... the filter for the Em_applicant_criteria we want to count
     *   }
     * })
    **/
    count<T extends em_applicant_criteriaCountArgs>(
      args?: Subset<T, em_applicant_criteriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_applicant_criteriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_applicant_criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_applicant_criteriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_applicant_criteriaAggregateArgs>(args: Subset<T, Em_applicant_criteriaAggregateArgs>): Prisma.PrismaPromise<GetEm_applicant_criteriaAggregateType<T>>

    /**
     * Group by Em_applicant_criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_criteriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_applicant_criteriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_applicant_criteriaGroupByArgs['orderBy'] }
        : { orderBy?: em_applicant_criteriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_applicant_criteriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_applicant_criteriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_applicant_criteria model
   */
  readonly fields: em_applicant_criteriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_applicant_criteria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_applicant_criteriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emposs<T extends empossDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empossDefaultArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_applicant_criteria model
   */
  interface em_applicant_criteriaFieldRefs {
    readonly id_kriteria: FieldRef<"em_applicant_criteria", 'Int'>
    readonly id_loker: FieldRef<"em_applicant_criteria", 'Int'>
    readonly jenis_kriteria: FieldRef<"em_applicant_criteria", 'String'>
    readonly value: FieldRef<"em_applicant_criteria", 'String'>
    readonly value_en: FieldRef<"em_applicant_criteria", 'String'>
    readonly bobot: FieldRef<"em_applicant_criteria", 'Float'>
    readonly created_at: FieldRef<"em_applicant_criteria", 'DateTime'>
    readonly lastupdate: FieldRef<"em_applicant_criteria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_applicant_criteria findUnique
   */
  export type em_applicant_criteriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_criteria to fetch.
     */
    where: em_applicant_criteriaWhereUniqueInput
  }

  /**
   * em_applicant_criteria findUniqueOrThrow
   */
  export type em_applicant_criteriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_criteria to fetch.
     */
    where: em_applicant_criteriaWhereUniqueInput
  }

  /**
   * em_applicant_criteria findFirst
   */
  export type em_applicant_criteriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_criteria to fetch.
     */
    where?: em_applicant_criteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_criteria to fetch.
     */
    orderBy?: em_applicant_criteriaOrderByWithRelationInput | em_applicant_criteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_applicant_criteria.
     */
    cursor?: em_applicant_criteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_criteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_criteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_applicant_criteria.
     */
    distinct?: Em_applicant_criteriaScalarFieldEnum | Em_applicant_criteriaScalarFieldEnum[]
  }

  /**
   * em_applicant_criteria findFirstOrThrow
   */
  export type em_applicant_criteriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_criteria to fetch.
     */
    where?: em_applicant_criteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_criteria to fetch.
     */
    orderBy?: em_applicant_criteriaOrderByWithRelationInput | em_applicant_criteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_applicant_criteria.
     */
    cursor?: em_applicant_criteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_criteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_criteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_applicant_criteria.
     */
    distinct?: Em_applicant_criteriaScalarFieldEnum | Em_applicant_criteriaScalarFieldEnum[]
  }

  /**
   * em_applicant_criteria findMany
   */
  export type em_applicant_criteriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_criteria to fetch.
     */
    where?: em_applicant_criteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_criteria to fetch.
     */
    orderBy?: em_applicant_criteriaOrderByWithRelationInput | em_applicant_criteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_applicant_criteria.
     */
    cursor?: em_applicant_criteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_criteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_criteria.
     */
    skip?: number
    distinct?: Em_applicant_criteriaScalarFieldEnum | Em_applicant_criteriaScalarFieldEnum[]
  }

  /**
   * em_applicant_criteria create
   */
  export type em_applicant_criteriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * The data needed to create a em_applicant_criteria.
     */
    data: XOR<em_applicant_criteriaCreateInput, em_applicant_criteriaUncheckedCreateInput>
  }

  /**
   * em_applicant_criteria createMany
   */
  export type em_applicant_criteriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_applicant_criteria.
     */
    data: em_applicant_criteriaCreateManyInput | em_applicant_criteriaCreateManyInput[]
  }

  /**
   * em_applicant_criteria update
   */
  export type em_applicant_criteriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * The data needed to update a em_applicant_criteria.
     */
    data: XOR<em_applicant_criteriaUpdateInput, em_applicant_criteriaUncheckedUpdateInput>
    /**
     * Choose, which em_applicant_criteria to update.
     */
    where: em_applicant_criteriaWhereUniqueInput
  }

  /**
   * em_applicant_criteria updateMany
   */
  export type em_applicant_criteriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_applicant_criteria.
     */
    data: XOR<em_applicant_criteriaUpdateManyMutationInput, em_applicant_criteriaUncheckedUpdateManyInput>
    /**
     * Filter which em_applicant_criteria to update
     */
    where?: em_applicant_criteriaWhereInput
    /**
     * Limit how many em_applicant_criteria to update.
     */
    limit?: number
  }

  /**
   * em_applicant_criteria upsert
   */
  export type em_applicant_criteriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * The filter to search for the em_applicant_criteria to update in case it exists.
     */
    where: em_applicant_criteriaWhereUniqueInput
    /**
     * In case the em_applicant_criteria found by the `where` argument doesn't exist, create a new em_applicant_criteria with this data.
     */
    create: XOR<em_applicant_criteriaCreateInput, em_applicant_criteriaUncheckedCreateInput>
    /**
     * In case the em_applicant_criteria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_applicant_criteriaUpdateInput, em_applicant_criteriaUncheckedUpdateInput>
  }

  /**
   * em_applicant_criteria delete
   */
  export type em_applicant_criteriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    /**
     * Filter which em_applicant_criteria to delete.
     */
    where: em_applicant_criteriaWhereUniqueInput
  }

  /**
   * em_applicant_criteria deleteMany
   */
  export type em_applicant_criteriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_applicant_criteria to delete
     */
    where?: em_applicant_criteriaWhereInput
    /**
     * Limit how many em_applicant_criteria to delete.
     */
    limit?: number
  }

  /**
   * em_applicant_criteria without action
   */
  export type em_applicant_criteriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
  }


  /**
   * Model em_applicant_match
   */

  export type AggregateEm_applicant_match = {
    _count: Em_applicant_matchCountAggregateOutputType | null
    _avg: Em_applicant_matchAvgAggregateOutputType | null
    _sum: Em_applicant_matchSumAggregateOutputType | null
    _min: Em_applicant_matchMinAggregateOutputType | null
    _max: Em_applicant_matchMaxAggregateOutputType | null
  }

  export type Em_applicant_matchAvgAggregateOutputType = {
    id_match: number | null
    id_applicant: number | null
    id_loker: number | null
    pendidikan_score: number | null
    jurusan_score: number | null
    pengalaman_score: number | null
    skill_score: number | null
    bahasa_score: number | null
    usia_score: number | null
    total_score: number | null
    total_kriteria: number | null
  }

  export type Em_applicant_matchSumAggregateOutputType = {
    id_match: number | null
    id_applicant: number | null
    id_loker: number | null
    pendidikan_score: number | null
    jurusan_score: number | null
    pengalaman_score: number | null
    skill_score: number | null
    bahasa_score: number | null
    usia_score: number | null
    total_score: number | null
    total_kriteria: number | null
  }

  export type Em_applicant_matchMinAggregateOutputType = {
    id_match: number | null
    id_applicant: number | null
    id_loker: number | null
    pendidikan_score: number | null
    jurusan_score: number | null
    pengalaman_score: number | null
    skill_score: number | null
    bahasa_score: number | null
    usia_score: number | null
    total_score: number | null
    total_kriteria: number | null
    scoring_json: string | null
    created_at: Date | null
  }

  export type Em_applicant_matchMaxAggregateOutputType = {
    id_match: number | null
    id_applicant: number | null
    id_loker: number | null
    pendidikan_score: number | null
    jurusan_score: number | null
    pengalaman_score: number | null
    skill_score: number | null
    bahasa_score: number | null
    usia_score: number | null
    total_score: number | null
    total_kriteria: number | null
    scoring_json: string | null
    created_at: Date | null
  }

  export type Em_applicant_matchCountAggregateOutputType = {
    id_match: number
    id_applicant: number
    id_loker: number
    pendidikan_score: number
    jurusan_score: number
    pengalaman_score: number
    skill_score: number
    bahasa_score: number
    usia_score: number
    total_score: number
    total_kriteria: number
    scoring_json: number
    created_at: number
    _all: number
  }


  export type Em_applicant_matchAvgAggregateInputType = {
    id_match?: true
    id_applicant?: true
    id_loker?: true
    pendidikan_score?: true
    jurusan_score?: true
    pengalaman_score?: true
    skill_score?: true
    bahasa_score?: true
    usia_score?: true
    total_score?: true
    total_kriteria?: true
  }

  export type Em_applicant_matchSumAggregateInputType = {
    id_match?: true
    id_applicant?: true
    id_loker?: true
    pendidikan_score?: true
    jurusan_score?: true
    pengalaman_score?: true
    skill_score?: true
    bahasa_score?: true
    usia_score?: true
    total_score?: true
    total_kriteria?: true
  }

  export type Em_applicant_matchMinAggregateInputType = {
    id_match?: true
    id_applicant?: true
    id_loker?: true
    pendidikan_score?: true
    jurusan_score?: true
    pengalaman_score?: true
    skill_score?: true
    bahasa_score?: true
    usia_score?: true
    total_score?: true
    total_kriteria?: true
    scoring_json?: true
    created_at?: true
  }

  export type Em_applicant_matchMaxAggregateInputType = {
    id_match?: true
    id_applicant?: true
    id_loker?: true
    pendidikan_score?: true
    jurusan_score?: true
    pengalaman_score?: true
    skill_score?: true
    bahasa_score?: true
    usia_score?: true
    total_score?: true
    total_kriteria?: true
    scoring_json?: true
    created_at?: true
  }

  export type Em_applicant_matchCountAggregateInputType = {
    id_match?: true
    id_applicant?: true
    id_loker?: true
    pendidikan_score?: true
    jurusan_score?: true
    pengalaman_score?: true
    skill_score?: true
    bahasa_score?: true
    usia_score?: true
    total_score?: true
    total_kriteria?: true
    scoring_json?: true
    created_at?: true
    _all?: true
  }

  export type Em_applicant_matchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_applicant_match to aggregate.
     */
    where?: em_applicant_matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_matches to fetch.
     */
    orderBy?: em_applicant_matchOrderByWithRelationInput | em_applicant_matchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_applicant_matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_applicant_matches
    **/
    _count?: true | Em_applicant_matchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_applicant_matchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_applicant_matchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_applicant_matchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_applicant_matchMaxAggregateInputType
  }

  export type GetEm_applicant_matchAggregateType<T extends Em_applicant_matchAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_applicant_match]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_applicant_match[P]>
      : GetScalarType<T[P], AggregateEm_applicant_match[P]>
  }




  export type em_applicant_matchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_applicant_matchWhereInput
    orderBy?: em_applicant_matchOrderByWithAggregationInput | em_applicant_matchOrderByWithAggregationInput[]
    by: Em_applicant_matchScalarFieldEnum[] | Em_applicant_matchScalarFieldEnum
    having?: em_applicant_matchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_applicant_matchCountAggregateInputType | true
    _avg?: Em_applicant_matchAvgAggregateInputType
    _sum?: Em_applicant_matchSumAggregateInputType
    _min?: Em_applicant_matchMinAggregateInputType
    _max?: Em_applicant_matchMaxAggregateInputType
  }

  export type Em_applicant_matchGroupByOutputType = {
    id_match: number
    id_applicant: number
    id_loker: number
    pendidikan_score: number | null
    jurusan_score: number | null
    pengalaman_score: number | null
    skill_score: number | null
    bahasa_score: number | null
    usia_score: number | null
    total_score: number | null
    total_kriteria: number | null
    scoring_json: string | null
    created_at: Date | null
    _count: Em_applicant_matchCountAggregateOutputType | null
    _avg: Em_applicant_matchAvgAggregateOutputType | null
    _sum: Em_applicant_matchSumAggregateOutputType | null
    _min: Em_applicant_matchMinAggregateOutputType | null
    _max: Em_applicant_matchMaxAggregateOutputType | null
  }

  type GetEm_applicant_matchGroupByPayload<T extends em_applicant_matchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_applicant_matchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_applicant_matchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_applicant_matchGroupByOutputType[P]>
            : GetScalarType<T[P], Em_applicant_matchGroupByOutputType[P]>
        }
      >
    >


  export type em_applicant_matchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_match?: boolean
    id_applicant?: boolean
    id_loker?: boolean
    pendidikan_score?: boolean
    jurusan_score?: boolean
    pengalaman_score?: boolean
    skill_score?: boolean
    bahasa_score?: boolean
    usia_score?: boolean
    total_score?: boolean
    total_kriteria?: boolean
    scoring_json?: boolean
    created_at?: boolean
    em_apc_personal?: boolean | em_apc_personalDefaultArgs<ExtArgs>
    emposs?: boolean | empossDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_applicant_match"]>



  export type em_applicant_matchSelectScalar = {
    id_match?: boolean
    id_applicant?: boolean
    id_loker?: boolean
    pendidikan_score?: boolean
    jurusan_score?: boolean
    pengalaman_score?: boolean
    skill_score?: boolean
    bahasa_score?: boolean
    usia_score?: boolean
    total_score?: boolean
    total_kriteria?: boolean
    scoring_json?: boolean
    created_at?: boolean
  }

  export type em_applicant_matchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_match" | "id_applicant" | "id_loker" | "pendidikan_score" | "jurusan_score" | "pengalaman_score" | "skill_score" | "bahasa_score" | "usia_score" | "total_score" | "total_kriteria" | "scoring_json" | "created_at", ExtArgs["result"]["em_applicant_match"]>
  export type em_applicant_matchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_apc_personal?: boolean | em_apc_personalDefaultArgs<ExtArgs>
    emposs?: boolean | empossDefaultArgs<ExtArgs>
  }

  export type $em_applicant_matchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_applicant_match"
    objects: {
      em_apc_personal: Prisma.$em_apc_personalPayload<ExtArgs>
      emposs: Prisma.$empossPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_match: number
      id_applicant: number
      id_loker: number
      pendidikan_score: number | null
      jurusan_score: number | null
      pengalaman_score: number | null
      skill_score: number | null
      bahasa_score: number | null
      usia_score: number | null
      total_score: number | null
      total_kriteria: number | null
      scoring_json: string | null
      created_at: Date | null
    }, ExtArgs["result"]["em_applicant_match"]>
    composites: {}
  }

  type em_applicant_matchGetPayload<S extends boolean | null | undefined | em_applicant_matchDefaultArgs> = $Result.GetResult<Prisma.$em_applicant_matchPayload, S>

  type em_applicant_matchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_applicant_matchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_applicant_matchCountAggregateInputType | true
    }

  export interface em_applicant_matchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_applicant_match'], meta: { name: 'em_applicant_match' } }
    /**
     * Find zero or one Em_applicant_match that matches the filter.
     * @param {em_applicant_matchFindUniqueArgs} args - Arguments to find a Em_applicant_match
     * @example
     * // Get one Em_applicant_match
     * const em_applicant_match = await prisma.em_applicant_match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_applicant_matchFindUniqueArgs>(args: SelectSubset<T, em_applicant_matchFindUniqueArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_applicant_match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_applicant_matchFindUniqueOrThrowArgs} args - Arguments to find a Em_applicant_match
     * @example
     * // Get one Em_applicant_match
     * const em_applicant_match = await prisma.em_applicant_match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_applicant_matchFindUniqueOrThrowArgs>(args: SelectSubset<T, em_applicant_matchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_applicant_match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_matchFindFirstArgs} args - Arguments to find a Em_applicant_match
     * @example
     * // Get one Em_applicant_match
     * const em_applicant_match = await prisma.em_applicant_match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_applicant_matchFindFirstArgs>(args?: SelectSubset<T, em_applicant_matchFindFirstArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_applicant_match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_matchFindFirstOrThrowArgs} args - Arguments to find a Em_applicant_match
     * @example
     * // Get one Em_applicant_match
     * const em_applicant_match = await prisma.em_applicant_match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_applicant_matchFindFirstOrThrowArgs>(args?: SelectSubset<T, em_applicant_matchFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_applicant_matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_matchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_applicant_matches
     * const em_applicant_matches = await prisma.em_applicant_match.findMany()
     * 
     * // Get first 10 Em_applicant_matches
     * const em_applicant_matches = await prisma.em_applicant_match.findMany({ take: 10 })
     * 
     * // Only select the `id_match`
     * const em_applicant_matchWithId_matchOnly = await prisma.em_applicant_match.findMany({ select: { id_match: true } })
     * 
     */
    findMany<T extends em_applicant_matchFindManyArgs>(args?: SelectSubset<T, em_applicant_matchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_applicant_match.
     * @param {em_applicant_matchCreateArgs} args - Arguments to create a Em_applicant_match.
     * @example
     * // Create one Em_applicant_match
     * const Em_applicant_match = await prisma.em_applicant_match.create({
     *   data: {
     *     // ... data to create a Em_applicant_match
     *   }
     * })
     * 
     */
    create<T extends em_applicant_matchCreateArgs>(args: SelectSubset<T, em_applicant_matchCreateArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_applicant_matches.
     * @param {em_applicant_matchCreateManyArgs} args - Arguments to create many Em_applicant_matches.
     * @example
     * // Create many Em_applicant_matches
     * const em_applicant_match = await prisma.em_applicant_match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_applicant_matchCreateManyArgs>(args?: SelectSubset<T, em_applicant_matchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_applicant_match.
     * @param {em_applicant_matchDeleteArgs} args - Arguments to delete one Em_applicant_match.
     * @example
     * // Delete one Em_applicant_match
     * const Em_applicant_match = await prisma.em_applicant_match.delete({
     *   where: {
     *     // ... filter to delete one Em_applicant_match
     *   }
     * })
     * 
     */
    delete<T extends em_applicant_matchDeleteArgs>(args: SelectSubset<T, em_applicant_matchDeleteArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_applicant_match.
     * @param {em_applicant_matchUpdateArgs} args - Arguments to update one Em_applicant_match.
     * @example
     * // Update one Em_applicant_match
     * const em_applicant_match = await prisma.em_applicant_match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_applicant_matchUpdateArgs>(args: SelectSubset<T, em_applicant_matchUpdateArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_applicant_matches.
     * @param {em_applicant_matchDeleteManyArgs} args - Arguments to filter Em_applicant_matches to delete.
     * @example
     * // Delete a few Em_applicant_matches
     * const { count } = await prisma.em_applicant_match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_applicant_matchDeleteManyArgs>(args?: SelectSubset<T, em_applicant_matchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_applicant_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_matchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_applicant_matches
     * const em_applicant_match = await prisma.em_applicant_match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_applicant_matchUpdateManyArgs>(args: SelectSubset<T, em_applicant_matchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_applicant_match.
     * @param {em_applicant_matchUpsertArgs} args - Arguments to update or create a Em_applicant_match.
     * @example
     * // Update or create a Em_applicant_match
     * const em_applicant_match = await prisma.em_applicant_match.upsert({
     *   create: {
     *     // ... data to create a Em_applicant_match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_applicant_match we want to update
     *   }
     * })
     */
    upsert<T extends em_applicant_matchUpsertArgs>(args: SelectSubset<T, em_applicant_matchUpsertArgs<ExtArgs>>): Prisma__em_applicant_matchClient<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_applicant_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_matchCountArgs} args - Arguments to filter Em_applicant_matches to count.
     * @example
     * // Count the number of Em_applicant_matches
     * const count = await prisma.em_applicant_match.count({
     *   where: {
     *     // ... the filter for the Em_applicant_matches we want to count
     *   }
     * })
    **/
    count<T extends em_applicant_matchCountArgs>(
      args?: Subset<T, em_applicant_matchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_applicant_matchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_applicant_match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_applicant_matchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_applicant_matchAggregateArgs>(args: Subset<T, Em_applicant_matchAggregateArgs>): Prisma.PrismaPromise<GetEm_applicant_matchAggregateType<T>>

    /**
     * Group by Em_applicant_match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_applicant_matchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_applicant_matchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_applicant_matchGroupByArgs['orderBy'] }
        : { orderBy?: em_applicant_matchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_applicant_matchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_applicant_matchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_applicant_match model
   */
  readonly fields: em_applicant_matchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_applicant_match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_applicant_matchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_apc_personal<T extends em_apc_personalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_apc_personalDefaultArgs<ExtArgs>>): Prisma__em_apc_personalClient<$Result.GetResult<Prisma.$em_apc_personalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emposs<T extends empossDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empossDefaultArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_applicant_match model
   */
  interface em_applicant_matchFieldRefs {
    readonly id_match: FieldRef<"em_applicant_match", 'Int'>
    readonly id_applicant: FieldRef<"em_applicant_match", 'Int'>
    readonly id_loker: FieldRef<"em_applicant_match", 'Int'>
    readonly pendidikan_score: FieldRef<"em_applicant_match", 'Float'>
    readonly jurusan_score: FieldRef<"em_applicant_match", 'Float'>
    readonly pengalaman_score: FieldRef<"em_applicant_match", 'Float'>
    readonly skill_score: FieldRef<"em_applicant_match", 'Float'>
    readonly bahasa_score: FieldRef<"em_applicant_match", 'Float'>
    readonly usia_score: FieldRef<"em_applicant_match", 'Float'>
    readonly total_score: FieldRef<"em_applicant_match", 'Float'>
    readonly total_kriteria: FieldRef<"em_applicant_match", 'Int'>
    readonly scoring_json: FieldRef<"em_applicant_match", 'String'>
    readonly created_at: FieldRef<"em_applicant_match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_applicant_match findUnique
   */
  export type em_applicant_matchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_match to fetch.
     */
    where: em_applicant_matchWhereUniqueInput
  }

  /**
   * em_applicant_match findUniqueOrThrow
   */
  export type em_applicant_matchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_match to fetch.
     */
    where: em_applicant_matchWhereUniqueInput
  }

  /**
   * em_applicant_match findFirst
   */
  export type em_applicant_matchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_match to fetch.
     */
    where?: em_applicant_matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_matches to fetch.
     */
    orderBy?: em_applicant_matchOrderByWithRelationInput | em_applicant_matchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_applicant_matches.
     */
    cursor?: em_applicant_matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_applicant_matches.
     */
    distinct?: Em_applicant_matchScalarFieldEnum | Em_applicant_matchScalarFieldEnum[]
  }

  /**
   * em_applicant_match findFirstOrThrow
   */
  export type em_applicant_matchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_match to fetch.
     */
    where?: em_applicant_matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_matches to fetch.
     */
    orderBy?: em_applicant_matchOrderByWithRelationInput | em_applicant_matchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_applicant_matches.
     */
    cursor?: em_applicant_matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_applicant_matches.
     */
    distinct?: Em_applicant_matchScalarFieldEnum | Em_applicant_matchScalarFieldEnum[]
  }

  /**
   * em_applicant_match findMany
   */
  export type em_applicant_matchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * Filter, which em_applicant_matches to fetch.
     */
    where?: em_applicant_matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_applicant_matches to fetch.
     */
    orderBy?: em_applicant_matchOrderByWithRelationInput | em_applicant_matchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_applicant_matches.
     */
    cursor?: em_applicant_matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_applicant_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_applicant_matches.
     */
    skip?: number
    distinct?: Em_applicant_matchScalarFieldEnum | Em_applicant_matchScalarFieldEnum[]
  }

  /**
   * em_applicant_match create
   */
  export type em_applicant_matchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * The data needed to create a em_applicant_match.
     */
    data: XOR<em_applicant_matchCreateInput, em_applicant_matchUncheckedCreateInput>
  }

  /**
   * em_applicant_match createMany
   */
  export type em_applicant_matchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_applicant_matches.
     */
    data: em_applicant_matchCreateManyInput | em_applicant_matchCreateManyInput[]
  }

  /**
   * em_applicant_match update
   */
  export type em_applicant_matchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * The data needed to update a em_applicant_match.
     */
    data: XOR<em_applicant_matchUpdateInput, em_applicant_matchUncheckedUpdateInput>
    /**
     * Choose, which em_applicant_match to update.
     */
    where: em_applicant_matchWhereUniqueInput
  }

  /**
   * em_applicant_match updateMany
   */
  export type em_applicant_matchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_applicant_matches.
     */
    data: XOR<em_applicant_matchUpdateManyMutationInput, em_applicant_matchUncheckedUpdateManyInput>
    /**
     * Filter which em_applicant_matches to update
     */
    where?: em_applicant_matchWhereInput
    /**
     * Limit how many em_applicant_matches to update.
     */
    limit?: number
  }

  /**
   * em_applicant_match upsert
   */
  export type em_applicant_matchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * The filter to search for the em_applicant_match to update in case it exists.
     */
    where: em_applicant_matchWhereUniqueInput
    /**
     * In case the em_applicant_match found by the `where` argument doesn't exist, create a new em_applicant_match with this data.
     */
    create: XOR<em_applicant_matchCreateInput, em_applicant_matchUncheckedCreateInput>
    /**
     * In case the em_applicant_match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_applicant_matchUpdateInput, em_applicant_matchUncheckedUpdateInput>
  }

  /**
   * em_applicant_match delete
   */
  export type em_applicant_matchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    /**
     * Filter which em_applicant_match to delete.
     */
    where: em_applicant_matchWhereUniqueInput
  }

  /**
   * em_applicant_match deleteMany
   */
  export type em_applicant_matchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_applicant_matches to delete
     */
    where?: em_applicant_matchWhereInput
    /**
     * Limit how many em_applicant_matches to delete.
     */
    limit?: number
  }

  /**
   * em_applicant_match without action
   */
  export type em_applicant_matchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
  }


  /**
   * Model em_banner
   */

  export type AggregateEm_banner = {
    _count: Em_bannerCountAggregateOutputType | null
    _avg: Em_bannerAvgAggregateOutputType | null
    _sum: Em_bannerSumAggregateOutputType | null
    _min: Em_bannerMinAggregateOutputType | null
    _max: Em_bannerMaxAggregateOutputType | null
  }

  export type Em_bannerAvgAggregateOutputType = {
    Id: number | null
    noUrut: number | null
  }

  export type Em_bannerSumAggregateOutputType = {
    Id: number | null
    noUrut: number | null
  }

  export type Em_bannerMinAggregateOutputType = {
    Id: number | null
    bannerName: string | null
    fileName: string | null
    menuName: string | null
    noUrut: number | null
    Status: string | null
    created_at: Date | null
    last_update: Date | null
    userid: string | null
  }

  export type Em_bannerMaxAggregateOutputType = {
    Id: number | null
    bannerName: string | null
    fileName: string | null
    menuName: string | null
    noUrut: number | null
    Status: string | null
    created_at: Date | null
    last_update: Date | null
    userid: string | null
  }

  export type Em_bannerCountAggregateOutputType = {
    Id: number
    bannerName: number
    fileName: number
    menuName: number
    noUrut: number
    Status: number
    created_at: number
    last_update: number
    userid: number
    _all: number
  }


  export type Em_bannerAvgAggregateInputType = {
    Id?: true
    noUrut?: true
  }

  export type Em_bannerSumAggregateInputType = {
    Id?: true
    noUrut?: true
  }

  export type Em_bannerMinAggregateInputType = {
    Id?: true
    bannerName?: true
    fileName?: true
    menuName?: true
    noUrut?: true
    Status?: true
    created_at?: true
    last_update?: true
    userid?: true
  }

  export type Em_bannerMaxAggregateInputType = {
    Id?: true
    bannerName?: true
    fileName?: true
    menuName?: true
    noUrut?: true
    Status?: true
    created_at?: true
    last_update?: true
    userid?: true
  }

  export type Em_bannerCountAggregateInputType = {
    Id?: true
    bannerName?: true
    fileName?: true
    menuName?: true
    noUrut?: true
    Status?: true
    created_at?: true
    last_update?: true
    userid?: true
    _all?: true
  }

  export type Em_bannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_banner to aggregate.
     */
    where?: em_bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_banners to fetch.
     */
    orderBy?: em_bannerOrderByWithRelationInput | em_bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_banners
    **/
    _count?: true | Em_bannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_bannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_bannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_bannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_bannerMaxAggregateInputType
  }

  export type GetEm_bannerAggregateType<T extends Em_bannerAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_banner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_banner[P]>
      : GetScalarType<T[P], AggregateEm_banner[P]>
  }




  export type em_bannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_bannerWhereInput
    orderBy?: em_bannerOrderByWithAggregationInput | em_bannerOrderByWithAggregationInput[]
    by: Em_bannerScalarFieldEnum[] | Em_bannerScalarFieldEnum
    having?: em_bannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_bannerCountAggregateInputType | true
    _avg?: Em_bannerAvgAggregateInputType
    _sum?: Em_bannerSumAggregateInputType
    _min?: Em_bannerMinAggregateInputType
    _max?: Em_bannerMaxAggregateInputType
  }

  export type Em_bannerGroupByOutputType = {
    Id: number
    bannerName: string | null
    fileName: string | null
    menuName: string | null
    noUrut: number | null
    Status: string | null
    created_at: Date | null
    last_update: Date | null
    userid: string | null
    _count: Em_bannerCountAggregateOutputType | null
    _avg: Em_bannerAvgAggregateOutputType | null
    _sum: Em_bannerSumAggregateOutputType | null
    _min: Em_bannerMinAggregateOutputType | null
    _max: Em_bannerMaxAggregateOutputType | null
  }

  type GetEm_bannerGroupByPayload<T extends em_bannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_bannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_bannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_bannerGroupByOutputType[P]>
            : GetScalarType<T[P], Em_bannerGroupByOutputType[P]>
        }
      >
    >


  export type em_bannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    bannerName?: boolean
    fileName?: boolean
    menuName?: boolean
    noUrut?: boolean
    Status?: boolean
    created_at?: boolean
    last_update?: boolean
    userid?: boolean
  }, ExtArgs["result"]["em_banner"]>



  export type em_bannerSelectScalar = {
    Id?: boolean
    bannerName?: boolean
    fileName?: boolean
    menuName?: boolean
    noUrut?: boolean
    Status?: boolean
    created_at?: boolean
    last_update?: boolean
    userid?: boolean
  }

  export type em_bannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "bannerName" | "fileName" | "menuName" | "noUrut" | "Status" | "created_at" | "last_update" | "userid", ExtArgs["result"]["em_banner"]>

  export type $em_bannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      bannerName: string | null
      fileName: string | null
      menuName: string | null
      noUrut: number | null
      Status: string | null
      created_at: Date | null
      last_update: Date | null
      userid: string | null
    }, ExtArgs["result"]["em_banner"]>
    composites: {}
  }

  type em_bannerGetPayload<S extends boolean | null | undefined | em_bannerDefaultArgs> = $Result.GetResult<Prisma.$em_bannerPayload, S>

  type em_bannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_bannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_bannerCountAggregateInputType | true
    }

  export interface em_bannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_banner'], meta: { name: 'em_banner' } }
    /**
     * Find zero or one Em_banner that matches the filter.
     * @param {em_bannerFindUniqueArgs} args - Arguments to find a Em_banner
     * @example
     * // Get one Em_banner
     * const em_banner = await prisma.em_banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_bannerFindUniqueArgs>(args: SelectSubset<T, em_bannerFindUniqueArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_bannerFindUniqueOrThrowArgs} args - Arguments to find a Em_banner
     * @example
     * // Get one Em_banner
     * const em_banner = await prisma.em_banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_bannerFindUniqueOrThrowArgs>(args: SelectSubset<T, em_bannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_bannerFindFirstArgs} args - Arguments to find a Em_banner
     * @example
     * // Get one Em_banner
     * const em_banner = await prisma.em_banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_bannerFindFirstArgs>(args?: SelectSubset<T, em_bannerFindFirstArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_bannerFindFirstOrThrowArgs} args - Arguments to find a Em_banner
     * @example
     * // Get one Em_banner
     * const em_banner = await prisma.em_banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_bannerFindFirstOrThrowArgs>(args?: SelectSubset<T, em_bannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_bannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_banners
     * const em_banners = await prisma.em_banner.findMany()
     * 
     * // Get first 10 Em_banners
     * const em_banners = await prisma.em_banner.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_bannerWithIdOnly = await prisma.em_banner.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_bannerFindManyArgs>(args?: SelectSubset<T, em_bannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_banner.
     * @param {em_bannerCreateArgs} args - Arguments to create a Em_banner.
     * @example
     * // Create one Em_banner
     * const Em_banner = await prisma.em_banner.create({
     *   data: {
     *     // ... data to create a Em_banner
     *   }
     * })
     * 
     */
    create<T extends em_bannerCreateArgs>(args: SelectSubset<T, em_bannerCreateArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_banners.
     * @param {em_bannerCreateManyArgs} args - Arguments to create many Em_banners.
     * @example
     * // Create many Em_banners
     * const em_banner = await prisma.em_banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_bannerCreateManyArgs>(args?: SelectSubset<T, em_bannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_banner.
     * @param {em_bannerDeleteArgs} args - Arguments to delete one Em_banner.
     * @example
     * // Delete one Em_banner
     * const Em_banner = await prisma.em_banner.delete({
     *   where: {
     *     // ... filter to delete one Em_banner
     *   }
     * })
     * 
     */
    delete<T extends em_bannerDeleteArgs>(args: SelectSubset<T, em_bannerDeleteArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_banner.
     * @param {em_bannerUpdateArgs} args - Arguments to update one Em_banner.
     * @example
     * // Update one Em_banner
     * const em_banner = await prisma.em_banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_bannerUpdateArgs>(args: SelectSubset<T, em_bannerUpdateArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_banners.
     * @param {em_bannerDeleteManyArgs} args - Arguments to filter Em_banners to delete.
     * @example
     * // Delete a few Em_banners
     * const { count } = await prisma.em_banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_bannerDeleteManyArgs>(args?: SelectSubset<T, em_bannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_bannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_banners
     * const em_banner = await prisma.em_banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_bannerUpdateManyArgs>(args: SelectSubset<T, em_bannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_banner.
     * @param {em_bannerUpsertArgs} args - Arguments to update or create a Em_banner.
     * @example
     * // Update or create a Em_banner
     * const em_banner = await prisma.em_banner.upsert({
     *   create: {
     *     // ... data to create a Em_banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_banner we want to update
     *   }
     * })
     */
    upsert<T extends em_bannerUpsertArgs>(args: SelectSubset<T, em_bannerUpsertArgs<ExtArgs>>): Prisma__em_bannerClient<$Result.GetResult<Prisma.$em_bannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_bannerCountArgs} args - Arguments to filter Em_banners to count.
     * @example
     * // Count the number of Em_banners
     * const count = await prisma.em_banner.count({
     *   where: {
     *     // ... the filter for the Em_banners we want to count
     *   }
     * })
    **/
    count<T extends em_bannerCountArgs>(
      args?: Subset<T, em_bannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_bannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_bannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_bannerAggregateArgs>(args: Subset<T, Em_bannerAggregateArgs>): Prisma.PrismaPromise<GetEm_bannerAggregateType<T>>

    /**
     * Group by Em_banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_bannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_bannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_bannerGroupByArgs['orderBy'] }
        : { orderBy?: em_bannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_bannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_bannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_banner model
   */
  readonly fields: em_bannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_bannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_banner model
   */
  interface em_bannerFieldRefs {
    readonly Id: FieldRef<"em_banner", 'Int'>
    readonly bannerName: FieldRef<"em_banner", 'String'>
    readonly fileName: FieldRef<"em_banner", 'String'>
    readonly menuName: FieldRef<"em_banner", 'String'>
    readonly noUrut: FieldRef<"em_banner", 'Int'>
    readonly Status: FieldRef<"em_banner", 'String'>
    readonly created_at: FieldRef<"em_banner", 'DateTime'>
    readonly last_update: FieldRef<"em_banner", 'DateTime'>
    readonly userid: FieldRef<"em_banner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_banner findUnique
   */
  export type em_bannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * Filter, which em_banner to fetch.
     */
    where: em_bannerWhereUniqueInput
  }

  /**
   * em_banner findUniqueOrThrow
   */
  export type em_bannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * Filter, which em_banner to fetch.
     */
    where: em_bannerWhereUniqueInput
  }

  /**
   * em_banner findFirst
   */
  export type em_bannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * Filter, which em_banner to fetch.
     */
    where?: em_bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_banners to fetch.
     */
    orderBy?: em_bannerOrderByWithRelationInput | em_bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_banners.
     */
    cursor?: em_bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_banners.
     */
    distinct?: Em_bannerScalarFieldEnum | Em_bannerScalarFieldEnum[]
  }

  /**
   * em_banner findFirstOrThrow
   */
  export type em_bannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * Filter, which em_banner to fetch.
     */
    where?: em_bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_banners to fetch.
     */
    orderBy?: em_bannerOrderByWithRelationInput | em_bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_banners.
     */
    cursor?: em_bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_banners.
     */
    distinct?: Em_bannerScalarFieldEnum | Em_bannerScalarFieldEnum[]
  }

  /**
   * em_banner findMany
   */
  export type em_bannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * Filter, which em_banners to fetch.
     */
    where?: em_bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_banners to fetch.
     */
    orderBy?: em_bannerOrderByWithRelationInput | em_bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_banners.
     */
    cursor?: em_bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_banners.
     */
    skip?: number
    distinct?: Em_bannerScalarFieldEnum | Em_bannerScalarFieldEnum[]
  }

  /**
   * em_banner create
   */
  export type em_bannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * The data needed to create a em_banner.
     */
    data?: XOR<em_bannerCreateInput, em_bannerUncheckedCreateInput>
  }

  /**
   * em_banner createMany
   */
  export type em_bannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_banners.
     */
    data: em_bannerCreateManyInput | em_bannerCreateManyInput[]
  }

  /**
   * em_banner update
   */
  export type em_bannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * The data needed to update a em_banner.
     */
    data: XOR<em_bannerUpdateInput, em_bannerUncheckedUpdateInput>
    /**
     * Choose, which em_banner to update.
     */
    where: em_bannerWhereUniqueInput
  }

  /**
   * em_banner updateMany
   */
  export type em_bannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_banners.
     */
    data: XOR<em_bannerUpdateManyMutationInput, em_bannerUncheckedUpdateManyInput>
    /**
     * Filter which em_banners to update
     */
    where?: em_bannerWhereInput
    /**
     * Limit how many em_banners to update.
     */
    limit?: number
  }

  /**
   * em_banner upsert
   */
  export type em_bannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * The filter to search for the em_banner to update in case it exists.
     */
    where: em_bannerWhereUniqueInput
    /**
     * In case the em_banner found by the `where` argument doesn't exist, create a new em_banner with this data.
     */
    create: XOR<em_bannerCreateInput, em_bannerUncheckedCreateInput>
    /**
     * In case the em_banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_bannerUpdateInput, em_bannerUncheckedUpdateInput>
  }

  /**
   * em_banner delete
   */
  export type em_bannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
    /**
     * Filter which em_banner to delete.
     */
    where: em_bannerWhereUniqueInput
  }

  /**
   * em_banner deleteMany
   */
  export type em_bannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_banners to delete
     */
    where?: em_bannerWhereInput
    /**
     * Limit how many em_banners to delete.
     */
    limit?: number
  }

  /**
   * em_banner without action
   */
  export type em_bannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_banner
     */
    select?: em_bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_banner
     */
    omit?: em_bannerOmit<ExtArgs> | null
  }


  /**
   * Model em_career_contact
   */

  export type AggregateEm_career_contact = {
    _count: Em_career_contactCountAggregateOutputType | null
    _avg: Em_career_contactAvgAggregateOutputType | null
    _sum: Em_career_contactSumAggregateOutputType | null
    _min: Em_career_contactMinAggregateOutputType | null
    _max: Em_career_contactMaxAggregateOutputType | null
  }

  export type Em_career_contactAvgAggregateOutputType = {
    cpId: number | null
  }

  export type Em_career_contactSumAggregateOutputType = {
    cpId: number | null
  }

  export type Em_career_contactMinAggregateOutputType = {
    cpId: number | null
    companyName: string | null
    email: string | null
    waNumber: string | null
    fileImage: string | null
    created_at: Date | null
    lastupdate: Date | null
    userid: string | null
  }

  export type Em_career_contactMaxAggregateOutputType = {
    cpId: number | null
    companyName: string | null
    email: string | null
    waNumber: string | null
    fileImage: string | null
    created_at: Date | null
    lastupdate: Date | null
    userid: string | null
  }

  export type Em_career_contactCountAggregateOutputType = {
    cpId: number
    companyName: number
    email: number
    waNumber: number
    fileImage: number
    created_at: number
    lastupdate: number
    userid: number
    _all: number
  }


  export type Em_career_contactAvgAggregateInputType = {
    cpId?: true
  }

  export type Em_career_contactSumAggregateInputType = {
    cpId?: true
  }

  export type Em_career_contactMinAggregateInputType = {
    cpId?: true
    companyName?: true
    email?: true
    waNumber?: true
    fileImage?: true
    created_at?: true
    lastupdate?: true
    userid?: true
  }

  export type Em_career_contactMaxAggregateInputType = {
    cpId?: true
    companyName?: true
    email?: true
    waNumber?: true
    fileImage?: true
    created_at?: true
    lastupdate?: true
    userid?: true
  }

  export type Em_career_contactCountAggregateInputType = {
    cpId?: true
    companyName?: true
    email?: true
    waNumber?: true
    fileImage?: true
    created_at?: true
    lastupdate?: true
    userid?: true
    _all?: true
  }

  export type Em_career_contactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_career_contact to aggregate.
     */
    where?: em_career_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_career_contacts to fetch.
     */
    orderBy?: em_career_contactOrderByWithRelationInput | em_career_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_career_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_career_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_career_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_career_contacts
    **/
    _count?: true | Em_career_contactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_career_contactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_career_contactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_career_contactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_career_contactMaxAggregateInputType
  }

  export type GetEm_career_contactAggregateType<T extends Em_career_contactAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_career_contact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_career_contact[P]>
      : GetScalarType<T[P], AggregateEm_career_contact[P]>
  }




  export type em_career_contactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_career_contactWhereInput
    orderBy?: em_career_contactOrderByWithAggregationInput | em_career_contactOrderByWithAggregationInput[]
    by: Em_career_contactScalarFieldEnum[] | Em_career_contactScalarFieldEnum
    having?: em_career_contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_career_contactCountAggregateInputType | true
    _avg?: Em_career_contactAvgAggregateInputType
    _sum?: Em_career_contactSumAggregateInputType
    _min?: Em_career_contactMinAggregateInputType
    _max?: Em_career_contactMaxAggregateInputType
  }

  export type Em_career_contactGroupByOutputType = {
    cpId: number
    companyName: string | null
    email: string | null
    waNumber: string | null
    fileImage: string | null
    created_at: Date | null
    lastupdate: Date | null
    userid: string | null
    _count: Em_career_contactCountAggregateOutputType | null
    _avg: Em_career_contactAvgAggregateOutputType | null
    _sum: Em_career_contactSumAggregateOutputType | null
    _min: Em_career_contactMinAggregateOutputType | null
    _max: Em_career_contactMaxAggregateOutputType | null
  }

  type GetEm_career_contactGroupByPayload<T extends em_career_contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_career_contactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_career_contactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_career_contactGroupByOutputType[P]>
            : GetScalarType<T[P], Em_career_contactGroupByOutputType[P]>
        }
      >
    >


  export type em_career_contactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpId?: boolean
    companyName?: boolean
    email?: boolean
    waNumber?: boolean
    fileImage?: boolean
    created_at?: boolean
    lastupdate?: boolean
    userid?: boolean
  }, ExtArgs["result"]["em_career_contact"]>



  export type em_career_contactSelectScalar = {
    cpId?: boolean
    companyName?: boolean
    email?: boolean
    waNumber?: boolean
    fileImage?: boolean
    created_at?: boolean
    lastupdate?: boolean
    userid?: boolean
  }

  export type em_career_contactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cpId" | "companyName" | "email" | "waNumber" | "fileImage" | "created_at" | "lastupdate" | "userid", ExtArgs["result"]["em_career_contact"]>

  export type $em_career_contactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_career_contact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cpId: number
      companyName: string | null
      email: string | null
      waNumber: string | null
      fileImage: string | null
      created_at: Date | null
      lastupdate: Date | null
      userid: string | null
    }, ExtArgs["result"]["em_career_contact"]>
    composites: {}
  }

  type em_career_contactGetPayload<S extends boolean | null | undefined | em_career_contactDefaultArgs> = $Result.GetResult<Prisma.$em_career_contactPayload, S>

  type em_career_contactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_career_contactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_career_contactCountAggregateInputType | true
    }

  export interface em_career_contactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_career_contact'], meta: { name: 'em_career_contact' } }
    /**
     * Find zero or one Em_career_contact that matches the filter.
     * @param {em_career_contactFindUniqueArgs} args - Arguments to find a Em_career_contact
     * @example
     * // Get one Em_career_contact
     * const em_career_contact = await prisma.em_career_contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_career_contactFindUniqueArgs>(args: SelectSubset<T, em_career_contactFindUniqueArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_career_contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_career_contactFindUniqueOrThrowArgs} args - Arguments to find a Em_career_contact
     * @example
     * // Get one Em_career_contact
     * const em_career_contact = await prisma.em_career_contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_career_contactFindUniqueOrThrowArgs>(args: SelectSubset<T, em_career_contactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_career_contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_career_contactFindFirstArgs} args - Arguments to find a Em_career_contact
     * @example
     * // Get one Em_career_contact
     * const em_career_contact = await prisma.em_career_contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_career_contactFindFirstArgs>(args?: SelectSubset<T, em_career_contactFindFirstArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_career_contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_career_contactFindFirstOrThrowArgs} args - Arguments to find a Em_career_contact
     * @example
     * // Get one Em_career_contact
     * const em_career_contact = await prisma.em_career_contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_career_contactFindFirstOrThrowArgs>(args?: SelectSubset<T, em_career_contactFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_career_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_career_contactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_career_contacts
     * const em_career_contacts = await prisma.em_career_contact.findMany()
     * 
     * // Get first 10 Em_career_contacts
     * const em_career_contacts = await prisma.em_career_contact.findMany({ take: 10 })
     * 
     * // Only select the `cpId`
     * const em_career_contactWithCpIdOnly = await prisma.em_career_contact.findMany({ select: { cpId: true } })
     * 
     */
    findMany<T extends em_career_contactFindManyArgs>(args?: SelectSubset<T, em_career_contactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_career_contact.
     * @param {em_career_contactCreateArgs} args - Arguments to create a Em_career_contact.
     * @example
     * // Create one Em_career_contact
     * const Em_career_contact = await prisma.em_career_contact.create({
     *   data: {
     *     // ... data to create a Em_career_contact
     *   }
     * })
     * 
     */
    create<T extends em_career_contactCreateArgs>(args: SelectSubset<T, em_career_contactCreateArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_career_contacts.
     * @param {em_career_contactCreateManyArgs} args - Arguments to create many Em_career_contacts.
     * @example
     * // Create many Em_career_contacts
     * const em_career_contact = await prisma.em_career_contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_career_contactCreateManyArgs>(args?: SelectSubset<T, em_career_contactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_career_contact.
     * @param {em_career_contactDeleteArgs} args - Arguments to delete one Em_career_contact.
     * @example
     * // Delete one Em_career_contact
     * const Em_career_contact = await prisma.em_career_contact.delete({
     *   where: {
     *     // ... filter to delete one Em_career_contact
     *   }
     * })
     * 
     */
    delete<T extends em_career_contactDeleteArgs>(args: SelectSubset<T, em_career_contactDeleteArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_career_contact.
     * @param {em_career_contactUpdateArgs} args - Arguments to update one Em_career_contact.
     * @example
     * // Update one Em_career_contact
     * const em_career_contact = await prisma.em_career_contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_career_contactUpdateArgs>(args: SelectSubset<T, em_career_contactUpdateArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_career_contacts.
     * @param {em_career_contactDeleteManyArgs} args - Arguments to filter Em_career_contacts to delete.
     * @example
     * // Delete a few Em_career_contacts
     * const { count } = await prisma.em_career_contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_career_contactDeleteManyArgs>(args?: SelectSubset<T, em_career_contactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_career_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_career_contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_career_contacts
     * const em_career_contact = await prisma.em_career_contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_career_contactUpdateManyArgs>(args: SelectSubset<T, em_career_contactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_career_contact.
     * @param {em_career_contactUpsertArgs} args - Arguments to update or create a Em_career_contact.
     * @example
     * // Update or create a Em_career_contact
     * const em_career_contact = await prisma.em_career_contact.upsert({
     *   create: {
     *     // ... data to create a Em_career_contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_career_contact we want to update
     *   }
     * })
     */
    upsert<T extends em_career_contactUpsertArgs>(args: SelectSubset<T, em_career_contactUpsertArgs<ExtArgs>>): Prisma__em_career_contactClient<$Result.GetResult<Prisma.$em_career_contactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_career_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_career_contactCountArgs} args - Arguments to filter Em_career_contacts to count.
     * @example
     * // Count the number of Em_career_contacts
     * const count = await prisma.em_career_contact.count({
     *   where: {
     *     // ... the filter for the Em_career_contacts we want to count
     *   }
     * })
    **/
    count<T extends em_career_contactCountArgs>(
      args?: Subset<T, em_career_contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_career_contactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_career_contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_career_contactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_career_contactAggregateArgs>(args: Subset<T, Em_career_contactAggregateArgs>): Prisma.PrismaPromise<GetEm_career_contactAggregateType<T>>

    /**
     * Group by Em_career_contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_career_contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_career_contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_career_contactGroupByArgs['orderBy'] }
        : { orderBy?: em_career_contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_career_contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_career_contactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_career_contact model
   */
  readonly fields: em_career_contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_career_contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_career_contactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_career_contact model
   */
  interface em_career_contactFieldRefs {
    readonly cpId: FieldRef<"em_career_contact", 'Int'>
    readonly companyName: FieldRef<"em_career_contact", 'String'>
    readonly email: FieldRef<"em_career_contact", 'String'>
    readonly waNumber: FieldRef<"em_career_contact", 'String'>
    readonly fileImage: FieldRef<"em_career_contact", 'String'>
    readonly created_at: FieldRef<"em_career_contact", 'DateTime'>
    readonly lastupdate: FieldRef<"em_career_contact", 'DateTime'>
    readonly userid: FieldRef<"em_career_contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_career_contact findUnique
   */
  export type em_career_contactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * Filter, which em_career_contact to fetch.
     */
    where: em_career_contactWhereUniqueInput
  }

  /**
   * em_career_contact findUniqueOrThrow
   */
  export type em_career_contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * Filter, which em_career_contact to fetch.
     */
    where: em_career_contactWhereUniqueInput
  }

  /**
   * em_career_contact findFirst
   */
  export type em_career_contactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * Filter, which em_career_contact to fetch.
     */
    where?: em_career_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_career_contacts to fetch.
     */
    orderBy?: em_career_contactOrderByWithRelationInput | em_career_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_career_contacts.
     */
    cursor?: em_career_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_career_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_career_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_career_contacts.
     */
    distinct?: Em_career_contactScalarFieldEnum | Em_career_contactScalarFieldEnum[]
  }

  /**
   * em_career_contact findFirstOrThrow
   */
  export type em_career_contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * Filter, which em_career_contact to fetch.
     */
    where?: em_career_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_career_contacts to fetch.
     */
    orderBy?: em_career_contactOrderByWithRelationInput | em_career_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_career_contacts.
     */
    cursor?: em_career_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_career_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_career_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_career_contacts.
     */
    distinct?: Em_career_contactScalarFieldEnum | Em_career_contactScalarFieldEnum[]
  }

  /**
   * em_career_contact findMany
   */
  export type em_career_contactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * Filter, which em_career_contacts to fetch.
     */
    where?: em_career_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_career_contacts to fetch.
     */
    orderBy?: em_career_contactOrderByWithRelationInput | em_career_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_career_contacts.
     */
    cursor?: em_career_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_career_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_career_contacts.
     */
    skip?: number
    distinct?: Em_career_contactScalarFieldEnum | Em_career_contactScalarFieldEnum[]
  }

  /**
   * em_career_contact create
   */
  export type em_career_contactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * The data needed to create a em_career_contact.
     */
    data?: XOR<em_career_contactCreateInput, em_career_contactUncheckedCreateInput>
  }

  /**
   * em_career_contact createMany
   */
  export type em_career_contactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_career_contacts.
     */
    data: em_career_contactCreateManyInput | em_career_contactCreateManyInput[]
  }

  /**
   * em_career_contact update
   */
  export type em_career_contactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * The data needed to update a em_career_contact.
     */
    data: XOR<em_career_contactUpdateInput, em_career_contactUncheckedUpdateInput>
    /**
     * Choose, which em_career_contact to update.
     */
    where: em_career_contactWhereUniqueInput
  }

  /**
   * em_career_contact updateMany
   */
  export type em_career_contactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_career_contacts.
     */
    data: XOR<em_career_contactUpdateManyMutationInput, em_career_contactUncheckedUpdateManyInput>
    /**
     * Filter which em_career_contacts to update
     */
    where?: em_career_contactWhereInput
    /**
     * Limit how many em_career_contacts to update.
     */
    limit?: number
  }

  /**
   * em_career_contact upsert
   */
  export type em_career_contactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * The filter to search for the em_career_contact to update in case it exists.
     */
    where: em_career_contactWhereUniqueInput
    /**
     * In case the em_career_contact found by the `where` argument doesn't exist, create a new em_career_contact with this data.
     */
    create: XOR<em_career_contactCreateInput, em_career_contactUncheckedCreateInput>
    /**
     * In case the em_career_contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_career_contactUpdateInput, em_career_contactUncheckedUpdateInput>
  }

  /**
   * em_career_contact delete
   */
  export type em_career_contactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
    /**
     * Filter which em_career_contact to delete.
     */
    where: em_career_contactWhereUniqueInput
  }

  /**
   * em_career_contact deleteMany
   */
  export type em_career_contactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_career_contacts to delete
     */
    where?: em_career_contactWhereInput
    /**
     * Limit how many em_career_contacts to delete.
     */
    limit?: number
  }

  /**
   * em_career_contact without action
   */
  export type em_career_contactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_career_contact
     */
    select?: em_career_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_career_contact
     */
    omit?: em_career_contactOmit<ExtArgs> | null
  }


  /**
   * Model em_certificate_fields
   */

  export type AggregateEm_certificate_fields = {
    _count: Em_certificate_fieldsCountAggregateOutputType | null
    _avg: Em_certificate_fieldsAvgAggregateOutputType | null
    _sum: Em_certificate_fieldsSumAggregateOutputType | null
    _min: Em_certificate_fieldsMinAggregateOutputType | null
    _max: Em_certificate_fieldsMaxAggregateOutputType | null
  }

  export type Em_certificate_fieldsAvgAggregateOutputType = {
    id: number | null
    certificate_id: number | null
    is_left: number | null
    is_top: number | null
    text_width: number | null
    text_height: number | null
    font_size: number | null
  }

  export type Em_certificate_fieldsSumAggregateOutputType = {
    id: number | null
    certificate_id: number | null
    is_left: number | null
    is_top: number | null
    text_width: number | null
    text_height: number | null
    font_size: number | null
  }

  export type Em_certificate_fieldsMinAggregateOutputType = {
    id: number | null
    certificate_id: number | null
    is_text: string | null
    is_left: number | null
    is_top: number | null
    text_width: number | null
    text_height: number | null
    font_size: number | null
    align: string | null
    font_family: string | null
    font_style: string | null
    font_weight: string | null
    font_color: string | null
    created_date: Date | null
    lastupdate: Date | null
  }

  export type Em_certificate_fieldsMaxAggregateOutputType = {
    id: number | null
    certificate_id: number | null
    is_text: string | null
    is_left: number | null
    is_top: number | null
    text_width: number | null
    text_height: number | null
    font_size: number | null
    align: string | null
    font_family: string | null
    font_style: string | null
    font_weight: string | null
    font_color: string | null
    created_date: Date | null
    lastupdate: Date | null
  }

  export type Em_certificate_fieldsCountAggregateOutputType = {
    id: number
    certificate_id: number
    is_text: number
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: number
    font_family: number
    font_style: number
    font_weight: number
    font_color: number
    created_date: number
    lastupdate: number
    _all: number
  }


  export type Em_certificate_fieldsAvgAggregateInputType = {
    id?: true
    certificate_id?: true
    is_left?: true
    is_top?: true
    text_width?: true
    text_height?: true
    font_size?: true
  }

  export type Em_certificate_fieldsSumAggregateInputType = {
    id?: true
    certificate_id?: true
    is_left?: true
    is_top?: true
    text_width?: true
    text_height?: true
    font_size?: true
  }

  export type Em_certificate_fieldsMinAggregateInputType = {
    id?: true
    certificate_id?: true
    is_text?: true
    is_left?: true
    is_top?: true
    text_width?: true
    text_height?: true
    font_size?: true
    align?: true
    font_family?: true
    font_style?: true
    font_weight?: true
    font_color?: true
    created_date?: true
    lastupdate?: true
  }

  export type Em_certificate_fieldsMaxAggregateInputType = {
    id?: true
    certificate_id?: true
    is_text?: true
    is_left?: true
    is_top?: true
    text_width?: true
    text_height?: true
    font_size?: true
    align?: true
    font_family?: true
    font_style?: true
    font_weight?: true
    font_color?: true
    created_date?: true
    lastupdate?: true
  }

  export type Em_certificate_fieldsCountAggregateInputType = {
    id?: true
    certificate_id?: true
    is_text?: true
    is_left?: true
    is_top?: true
    text_width?: true
    text_height?: true
    font_size?: true
    align?: true
    font_family?: true
    font_style?: true
    font_weight?: true
    font_color?: true
    created_date?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_certificate_fieldsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_certificate_fields to aggregate.
     */
    where?: em_certificate_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_fields to fetch.
     */
    orderBy?: em_certificate_fieldsOrderByWithRelationInput | em_certificate_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_certificate_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_certificate_fields
    **/
    _count?: true | Em_certificate_fieldsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_certificate_fieldsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_certificate_fieldsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_certificate_fieldsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_certificate_fieldsMaxAggregateInputType
  }

  export type GetEm_certificate_fieldsAggregateType<T extends Em_certificate_fieldsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_certificate_fields]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_certificate_fields[P]>
      : GetScalarType<T[P], AggregateEm_certificate_fields[P]>
  }




  export type em_certificate_fieldsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_certificate_fieldsWhereInput
    orderBy?: em_certificate_fieldsOrderByWithAggregationInput | em_certificate_fieldsOrderByWithAggregationInput[]
    by: Em_certificate_fieldsScalarFieldEnum[] | Em_certificate_fieldsScalarFieldEnum
    having?: em_certificate_fieldsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_certificate_fieldsCountAggregateInputType | true
    _avg?: Em_certificate_fieldsAvgAggregateInputType
    _sum?: Em_certificate_fieldsSumAggregateInputType
    _min?: Em_certificate_fieldsMinAggregateInputType
    _max?: Em_certificate_fieldsMaxAggregateInputType
  }

  export type Em_certificate_fieldsGroupByOutputType = {
    id: number
    certificate_id: number
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style: string | null
    font_weight: string | null
    font_color: string | null
    created_date: Date | null
    lastupdate: Date | null
    _count: Em_certificate_fieldsCountAggregateOutputType | null
    _avg: Em_certificate_fieldsAvgAggregateOutputType | null
    _sum: Em_certificate_fieldsSumAggregateOutputType | null
    _min: Em_certificate_fieldsMinAggregateOutputType | null
    _max: Em_certificate_fieldsMaxAggregateOutputType | null
  }

  type GetEm_certificate_fieldsGroupByPayload<T extends em_certificate_fieldsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_certificate_fieldsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_certificate_fieldsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_certificate_fieldsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_certificate_fieldsGroupByOutputType[P]>
        }
      >
    >


  export type em_certificate_fieldsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    certificate_id?: boolean
    is_text?: boolean
    is_left?: boolean
    is_top?: boolean
    text_width?: boolean
    text_height?: boolean
    font_size?: boolean
    align?: boolean
    font_family?: boolean
    font_style?: boolean
    font_weight?: boolean
    font_color?: boolean
    created_date?: boolean
    lastupdate?: boolean
    em_certificate_templates?: boolean | em_certificate_templatesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_certificate_fields"]>



  export type em_certificate_fieldsSelectScalar = {
    id?: boolean
    certificate_id?: boolean
    is_text?: boolean
    is_left?: boolean
    is_top?: boolean
    text_width?: boolean
    text_height?: boolean
    font_size?: boolean
    align?: boolean
    font_family?: boolean
    font_style?: boolean
    font_weight?: boolean
    font_color?: boolean
    created_date?: boolean
    lastupdate?: boolean
  }

  export type em_certificate_fieldsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "certificate_id" | "is_text" | "is_left" | "is_top" | "text_width" | "text_height" | "font_size" | "align" | "font_family" | "font_style" | "font_weight" | "font_color" | "created_date" | "lastupdate", ExtArgs["result"]["em_certificate_fields"]>
  export type em_certificate_fieldsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_certificate_templates?: boolean | em_certificate_templatesDefaultArgs<ExtArgs>
  }

  export type $em_certificate_fieldsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_certificate_fields"
    objects: {
      em_certificate_templates: Prisma.$em_certificate_templatesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      certificate_id: number
      is_text: string
      is_left: number
      is_top: number
      text_width: number
      text_height: number
      font_size: number
      align: string
      font_family: string
      font_style: string | null
      font_weight: string | null
      font_color: string | null
      created_date: Date | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_certificate_fields"]>
    composites: {}
  }

  type em_certificate_fieldsGetPayload<S extends boolean | null | undefined | em_certificate_fieldsDefaultArgs> = $Result.GetResult<Prisma.$em_certificate_fieldsPayload, S>

  type em_certificate_fieldsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_certificate_fieldsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_certificate_fieldsCountAggregateInputType | true
    }

  export interface em_certificate_fieldsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_certificate_fields'], meta: { name: 'em_certificate_fields' } }
    /**
     * Find zero or one Em_certificate_fields that matches the filter.
     * @param {em_certificate_fieldsFindUniqueArgs} args - Arguments to find a Em_certificate_fields
     * @example
     * // Get one Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_certificate_fieldsFindUniqueArgs>(args: SelectSubset<T, em_certificate_fieldsFindUniqueArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_certificate_fields that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_certificate_fieldsFindUniqueOrThrowArgs} args - Arguments to find a Em_certificate_fields
     * @example
     * // Get one Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_certificate_fieldsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_certificate_fieldsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_certificate_fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_fieldsFindFirstArgs} args - Arguments to find a Em_certificate_fields
     * @example
     * // Get one Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_certificate_fieldsFindFirstArgs>(args?: SelectSubset<T, em_certificate_fieldsFindFirstArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_certificate_fields that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_fieldsFindFirstOrThrowArgs} args - Arguments to find a Em_certificate_fields
     * @example
     * // Get one Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_certificate_fieldsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_certificate_fieldsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_certificate_fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_fieldsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.findMany()
     * 
     * // Get first 10 Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_certificate_fieldsWithIdOnly = await prisma.em_certificate_fields.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_certificate_fieldsFindManyArgs>(args?: SelectSubset<T, em_certificate_fieldsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_certificate_fields.
     * @param {em_certificate_fieldsCreateArgs} args - Arguments to create a Em_certificate_fields.
     * @example
     * // Create one Em_certificate_fields
     * const Em_certificate_fields = await prisma.em_certificate_fields.create({
     *   data: {
     *     // ... data to create a Em_certificate_fields
     *   }
     * })
     * 
     */
    create<T extends em_certificate_fieldsCreateArgs>(args: SelectSubset<T, em_certificate_fieldsCreateArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_certificate_fields.
     * @param {em_certificate_fieldsCreateManyArgs} args - Arguments to create many Em_certificate_fields.
     * @example
     * // Create many Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_certificate_fieldsCreateManyArgs>(args?: SelectSubset<T, em_certificate_fieldsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_certificate_fields.
     * @param {em_certificate_fieldsDeleteArgs} args - Arguments to delete one Em_certificate_fields.
     * @example
     * // Delete one Em_certificate_fields
     * const Em_certificate_fields = await prisma.em_certificate_fields.delete({
     *   where: {
     *     // ... filter to delete one Em_certificate_fields
     *   }
     * })
     * 
     */
    delete<T extends em_certificate_fieldsDeleteArgs>(args: SelectSubset<T, em_certificate_fieldsDeleteArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_certificate_fields.
     * @param {em_certificate_fieldsUpdateArgs} args - Arguments to update one Em_certificate_fields.
     * @example
     * // Update one Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_certificate_fieldsUpdateArgs>(args: SelectSubset<T, em_certificate_fieldsUpdateArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_certificate_fields.
     * @param {em_certificate_fieldsDeleteManyArgs} args - Arguments to filter Em_certificate_fields to delete.
     * @example
     * // Delete a few Em_certificate_fields
     * const { count } = await prisma.em_certificate_fields.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_certificate_fieldsDeleteManyArgs>(args?: SelectSubset<T, em_certificate_fieldsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_certificate_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_fieldsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_certificate_fieldsUpdateManyArgs>(args: SelectSubset<T, em_certificate_fieldsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_certificate_fields.
     * @param {em_certificate_fieldsUpsertArgs} args - Arguments to update or create a Em_certificate_fields.
     * @example
     * // Update or create a Em_certificate_fields
     * const em_certificate_fields = await prisma.em_certificate_fields.upsert({
     *   create: {
     *     // ... data to create a Em_certificate_fields
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_certificate_fields we want to update
     *   }
     * })
     */
    upsert<T extends em_certificate_fieldsUpsertArgs>(args: SelectSubset<T, em_certificate_fieldsUpsertArgs<ExtArgs>>): Prisma__em_certificate_fieldsClient<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_certificate_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_fieldsCountArgs} args - Arguments to filter Em_certificate_fields to count.
     * @example
     * // Count the number of Em_certificate_fields
     * const count = await prisma.em_certificate_fields.count({
     *   where: {
     *     // ... the filter for the Em_certificate_fields we want to count
     *   }
     * })
    **/
    count<T extends em_certificate_fieldsCountArgs>(
      args?: Subset<T, em_certificate_fieldsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_certificate_fieldsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_certificate_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_certificate_fieldsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_certificate_fieldsAggregateArgs>(args: Subset<T, Em_certificate_fieldsAggregateArgs>): Prisma.PrismaPromise<GetEm_certificate_fieldsAggregateType<T>>

    /**
     * Group by Em_certificate_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_fieldsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_certificate_fieldsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_certificate_fieldsGroupByArgs['orderBy'] }
        : { orderBy?: em_certificate_fieldsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_certificate_fieldsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_certificate_fieldsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_certificate_fields model
   */
  readonly fields: em_certificate_fieldsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_certificate_fields.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_certificate_fieldsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_certificate_templates<T extends em_certificate_templatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_certificate_templatesDefaultArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_certificate_fields model
   */
  interface em_certificate_fieldsFieldRefs {
    readonly id: FieldRef<"em_certificate_fields", 'Int'>
    readonly certificate_id: FieldRef<"em_certificate_fields", 'Int'>
    readonly is_text: FieldRef<"em_certificate_fields", 'String'>
    readonly is_left: FieldRef<"em_certificate_fields", 'Float'>
    readonly is_top: FieldRef<"em_certificate_fields", 'Float'>
    readonly text_width: FieldRef<"em_certificate_fields", 'Float'>
    readonly text_height: FieldRef<"em_certificate_fields", 'Float'>
    readonly font_size: FieldRef<"em_certificate_fields", 'Int'>
    readonly align: FieldRef<"em_certificate_fields", 'String'>
    readonly font_family: FieldRef<"em_certificate_fields", 'String'>
    readonly font_style: FieldRef<"em_certificate_fields", 'String'>
    readonly font_weight: FieldRef<"em_certificate_fields", 'String'>
    readonly font_color: FieldRef<"em_certificate_fields", 'String'>
    readonly created_date: FieldRef<"em_certificate_fields", 'DateTime'>
    readonly lastupdate: FieldRef<"em_certificate_fields", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_certificate_fields findUnique
   */
  export type em_certificate_fieldsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_fields to fetch.
     */
    where: em_certificate_fieldsWhereUniqueInput
  }

  /**
   * em_certificate_fields findUniqueOrThrow
   */
  export type em_certificate_fieldsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_fields to fetch.
     */
    where: em_certificate_fieldsWhereUniqueInput
  }

  /**
   * em_certificate_fields findFirst
   */
  export type em_certificate_fieldsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_fields to fetch.
     */
    where?: em_certificate_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_fields to fetch.
     */
    orderBy?: em_certificate_fieldsOrderByWithRelationInput | em_certificate_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_certificate_fields.
     */
    cursor?: em_certificate_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_certificate_fields.
     */
    distinct?: Em_certificate_fieldsScalarFieldEnum | Em_certificate_fieldsScalarFieldEnum[]
  }

  /**
   * em_certificate_fields findFirstOrThrow
   */
  export type em_certificate_fieldsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_fields to fetch.
     */
    where?: em_certificate_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_fields to fetch.
     */
    orderBy?: em_certificate_fieldsOrderByWithRelationInput | em_certificate_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_certificate_fields.
     */
    cursor?: em_certificate_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_certificate_fields.
     */
    distinct?: Em_certificate_fieldsScalarFieldEnum | Em_certificate_fieldsScalarFieldEnum[]
  }

  /**
   * em_certificate_fields findMany
   */
  export type em_certificate_fieldsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_fields to fetch.
     */
    where?: em_certificate_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_fields to fetch.
     */
    orderBy?: em_certificate_fieldsOrderByWithRelationInput | em_certificate_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_certificate_fields.
     */
    cursor?: em_certificate_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_fields.
     */
    skip?: number
    distinct?: Em_certificate_fieldsScalarFieldEnum | Em_certificate_fieldsScalarFieldEnum[]
  }

  /**
   * em_certificate_fields create
   */
  export type em_certificate_fieldsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * The data needed to create a em_certificate_fields.
     */
    data: XOR<em_certificate_fieldsCreateInput, em_certificate_fieldsUncheckedCreateInput>
  }

  /**
   * em_certificate_fields createMany
   */
  export type em_certificate_fieldsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_certificate_fields.
     */
    data: em_certificate_fieldsCreateManyInput | em_certificate_fieldsCreateManyInput[]
  }

  /**
   * em_certificate_fields update
   */
  export type em_certificate_fieldsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * The data needed to update a em_certificate_fields.
     */
    data: XOR<em_certificate_fieldsUpdateInput, em_certificate_fieldsUncheckedUpdateInput>
    /**
     * Choose, which em_certificate_fields to update.
     */
    where: em_certificate_fieldsWhereUniqueInput
  }

  /**
   * em_certificate_fields updateMany
   */
  export type em_certificate_fieldsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_certificate_fields.
     */
    data: XOR<em_certificate_fieldsUpdateManyMutationInput, em_certificate_fieldsUncheckedUpdateManyInput>
    /**
     * Filter which em_certificate_fields to update
     */
    where?: em_certificate_fieldsWhereInput
    /**
     * Limit how many em_certificate_fields to update.
     */
    limit?: number
  }

  /**
   * em_certificate_fields upsert
   */
  export type em_certificate_fieldsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * The filter to search for the em_certificate_fields to update in case it exists.
     */
    where: em_certificate_fieldsWhereUniqueInput
    /**
     * In case the em_certificate_fields found by the `where` argument doesn't exist, create a new em_certificate_fields with this data.
     */
    create: XOR<em_certificate_fieldsCreateInput, em_certificate_fieldsUncheckedCreateInput>
    /**
     * In case the em_certificate_fields was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_certificate_fieldsUpdateInput, em_certificate_fieldsUncheckedUpdateInput>
  }

  /**
   * em_certificate_fields delete
   */
  export type em_certificate_fieldsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    /**
     * Filter which em_certificate_fields to delete.
     */
    where: em_certificate_fieldsWhereUniqueInput
  }

  /**
   * em_certificate_fields deleteMany
   */
  export type em_certificate_fieldsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_certificate_fields to delete
     */
    where?: em_certificate_fieldsWhereInput
    /**
     * Limit how many em_certificate_fields to delete.
     */
    limit?: number
  }

  /**
   * em_certificate_fields without action
   */
  export type em_certificate_fieldsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
  }


  /**
   * Model em_certificate_templates
   */

  export type AggregateEm_certificate_templates = {
    _count: Em_certificate_templatesCountAggregateOutputType | null
    _avg: Em_certificate_templatesAvgAggregateOutputType | null
    _sum: Em_certificate_templatesSumAggregateOutputType | null
    _min: Em_certificate_templatesMinAggregateOutputType | null
    _max: Em_certificate_templatesMaxAggregateOutputType | null
  }

  export type Em_certificate_templatesAvgAggregateOutputType = {
    certificate_id: number | null
  }

  export type Em_certificate_templatesSumAggregateOutputType = {
    certificate_id: number | null
  }

  export type Em_certificate_templatesMinAggregateOutputType = {
    certificate_id: number | null
    name: string | null
    background_image: string | null
    created_at: Date | null
    certificate_name: string | null
    lastupdate: Date | null
  }

  export type Em_certificate_templatesMaxAggregateOutputType = {
    certificate_id: number | null
    name: string | null
    background_image: string | null
    created_at: Date | null
    certificate_name: string | null
    lastupdate: Date | null
  }

  export type Em_certificate_templatesCountAggregateOutputType = {
    certificate_id: number
    name: number
    background_image: number
    created_at: number
    certificate_name: number
    lastupdate: number
    _all: number
  }


  export type Em_certificate_templatesAvgAggregateInputType = {
    certificate_id?: true
  }

  export type Em_certificate_templatesSumAggregateInputType = {
    certificate_id?: true
  }

  export type Em_certificate_templatesMinAggregateInputType = {
    certificate_id?: true
    name?: true
    background_image?: true
    created_at?: true
    certificate_name?: true
    lastupdate?: true
  }

  export type Em_certificate_templatesMaxAggregateInputType = {
    certificate_id?: true
    name?: true
    background_image?: true
    created_at?: true
    certificate_name?: true
    lastupdate?: true
  }

  export type Em_certificate_templatesCountAggregateInputType = {
    certificate_id?: true
    name?: true
    background_image?: true
    created_at?: true
    certificate_name?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_certificate_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_certificate_templates to aggregate.
     */
    where?: em_certificate_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_templates to fetch.
     */
    orderBy?: em_certificate_templatesOrderByWithRelationInput | em_certificate_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_certificate_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_certificate_templates
    **/
    _count?: true | Em_certificate_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_certificate_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_certificate_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_certificate_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_certificate_templatesMaxAggregateInputType
  }

  export type GetEm_certificate_templatesAggregateType<T extends Em_certificate_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_certificate_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_certificate_templates[P]>
      : GetScalarType<T[P], AggregateEm_certificate_templates[P]>
  }




  export type em_certificate_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_certificate_templatesWhereInput
    orderBy?: em_certificate_templatesOrderByWithAggregationInput | em_certificate_templatesOrderByWithAggregationInput[]
    by: Em_certificate_templatesScalarFieldEnum[] | Em_certificate_templatesScalarFieldEnum
    having?: em_certificate_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_certificate_templatesCountAggregateInputType | true
    _avg?: Em_certificate_templatesAvgAggregateInputType
    _sum?: Em_certificate_templatesSumAggregateInputType
    _min?: Em_certificate_templatesMinAggregateInputType
    _max?: Em_certificate_templatesMaxAggregateInputType
  }

  export type Em_certificate_templatesGroupByOutputType = {
    certificate_id: number
    name: string | null
    background_image: string | null
    created_at: Date | null
    certificate_name: string | null
    lastupdate: Date | null
    _count: Em_certificate_templatesCountAggregateOutputType | null
    _avg: Em_certificate_templatesAvgAggregateOutputType | null
    _sum: Em_certificate_templatesSumAggregateOutputType | null
    _min: Em_certificate_templatesMinAggregateOutputType | null
    _max: Em_certificate_templatesMaxAggregateOutputType | null
  }

  type GetEm_certificate_templatesGroupByPayload<T extends em_certificate_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_certificate_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_certificate_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_certificate_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Em_certificate_templatesGroupByOutputType[P]>
        }
      >
    >


  export type em_certificate_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    certificate_id?: boolean
    name?: boolean
    background_image?: boolean
    created_at?: boolean
    certificate_name?: boolean
    lastupdate?: boolean
    em_certificate_fields?: boolean | em_certificate_templates$em_certificate_fieldsArgs<ExtArgs>
    _count?: boolean | Em_certificate_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_certificate_templates"]>



  export type em_certificate_templatesSelectScalar = {
    certificate_id?: boolean
    name?: boolean
    background_image?: boolean
    created_at?: boolean
    certificate_name?: boolean
    lastupdate?: boolean
  }

  export type em_certificate_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"certificate_id" | "name" | "background_image" | "created_at" | "certificate_name" | "lastupdate", ExtArgs["result"]["em_certificate_templates"]>
  export type em_certificate_templatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_certificate_fields?: boolean | em_certificate_templates$em_certificate_fieldsArgs<ExtArgs>
    _count?: boolean | Em_certificate_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_certificate_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_certificate_templates"
    objects: {
      em_certificate_fields: Prisma.$em_certificate_fieldsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      certificate_id: number
      name: string | null
      background_image: string | null
      created_at: Date | null
      certificate_name: string | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_certificate_templates"]>
    composites: {}
  }

  type em_certificate_templatesGetPayload<S extends boolean | null | undefined | em_certificate_templatesDefaultArgs> = $Result.GetResult<Prisma.$em_certificate_templatesPayload, S>

  type em_certificate_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_certificate_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_certificate_templatesCountAggregateInputType | true
    }

  export interface em_certificate_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_certificate_templates'], meta: { name: 'em_certificate_templates' } }
    /**
     * Find zero or one Em_certificate_templates that matches the filter.
     * @param {em_certificate_templatesFindUniqueArgs} args - Arguments to find a Em_certificate_templates
     * @example
     * // Get one Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_certificate_templatesFindUniqueArgs>(args: SelectSubset<T, em_certificate_templatesFindUniqueArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_certificate_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_certificate_templatesFindUniqueOrThrowArgs} args - Arguments to find a Em_certificate_templates
     * @example
     * // Get one Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_certificate_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, em_certificate_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_certificate_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_templatesFindFirstArgs} args - Arguments to find a Em_certificate_templates
     * @example
     * // Get one Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_certificate_templatesFindFirstArgs>(args?: SelectSubset<T, em_certificate_templatesFindFirstArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_certificate_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_templatesFindFirstOrThrowArgs} args - Arguments to find a Em_certificate_templates
     * @example
     * // Get one Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_certificate_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, em_certificate_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_certificate_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.findMany()
     * 
     * // Get first 10 Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.findMany({ take: 10 })
     * 
     * // Only select the `certificate_id`
     * const em_certificate_templatesWithCertificate_idOnly = await prisma.em_certificate_templates.findMany({ select: { certificate_id: true } })
     * 
     */
    findMany<T extends em_certificate_templatesFindManyArgs>(args?: SelectSubset<T, em_certificate_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_certificate_templates.
     * @param {em_certificate_templatesCreateArgs} args - Arguments to create a Em_certificate_templates.
     * @example
     * // Create one Em_certificate_templates
     * const Em_certificate_templates = await prisma.em_certificate_templates.create({
     *   data: {
     *     // ... data to create a Em_certificate_templates
     *   }
     * })
     * 
     */
    create<T extends em_certificate_templatesCreateArgs>(args: SelectSubset<T, em_certificate_templatesCreateArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_certificate_templates.
     * @param {em_certificate_templatesCreateManyArgs} args - Arguments to create many Em_certificate_templates.
     * @example
     * // Create many Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_certificate_templatesCreateManyArgs>(args?: SelectSubset<T, em_certificate_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_certificate_templates.
     * @param {em_certificate_templatesDeleteArgs} args - Arguments to delete one Em_certificate_templates.
     * @example
     * // Delete one Em_certificate_templates
     * const Em_certificate_templates = await prisma.em_certificate_templates.delete({
     *   where: {
     *     // ... filter to delete one Em_certificate_templates
     *   }
     * })
     * 
     */
    delete<T extends em_certificate_templatesDeleteArgs>(args: SelectSubset<T, em_certificate_templatesDeleteArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_certificate_templates.
     * @param {em_certificate_templatesUpdateArgs} args - Arguments to update one Em_certificate_templates.
     * @example
     * // Update one Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_certificate_templatesUpdateArgs>(args: SelectSubset<T, em_certificate_templatesUpdateArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_certificate_templates.
     * @param {em_certificate_templatesDeleteManyArgs} args - Arguments to filter Em_certificate_templates to delete.
     * @example
     * // Delete a few Em_certificate_templates
     * const { count } = await prisma.em_certificate_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_certificate_templatesDeleteManyArgs>(args?: SelectSubset<T, em_certificate_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_certificate_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_certificate_templatesUpdateManyArgs>(args: SelectSubset<T, em_certificate_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_certificate_templates.
     * @param {em_certificate_templatesUpsertArgs} args - Arguments to update or create a Em_certificate_templates.
     * @example
     * // Update or create a Em_certificate_templates
     * const em_certificate_templates = await prisma.em_certificate_templates.upsert({
     *   create: {
     *     // ... data to create a Em_certificate_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_certificate_templates we want to update
     *   }
     * })
     */
    upsert<T extends em_certificate_templatesUpsertArgs>(args: SelectSubset<T, em_certificate_templatesUpsertArgs<ExtArgs>>): Prisma__em_certificate_templatesClient<$Result.GetResult<Prisma.$em_certificate_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_certificate_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_templatesCountArgs} args - Arguments to filter Em_certificate_templates to count.
     * @example
     * // Count the number of Em_certificate_templates
     * const count = await prisma.em_certificate_templates.count({
     *   where: {
     *     // ... the filter for the Em_certificate_templates we want to count
     *   }
     * })
    **/
    count<T extends em_certificate_templatesCountArgs>(
      args?: Subset<T, em_certificate_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_certificate_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_certificate_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_certificate_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_certificate_templatesAggregateArgs>(args: Subset<T, Em_certificate_templatesAggregateArgs>): Prisma.PrismaPromise<GetEm_certificate_templatesAggregateType<T>>

    /**
     * Group by Em_certificate_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificate_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_certificate_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_certificate_templatesGroupByArgs['orderBy'] }
        : { orderBy?: em_certificate_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_certificate_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_certificate_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_certificate_templates model
   */
  readonly fields: em_certificate_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_certificate_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_certificate_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_certificate_fields<T extends em_certificate_templates$em_certificate_fieldsArgs<ExtArgs> = {}>(args?: Subset<T, em_certificate_templates$em_certificate_fieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_certificate_fieldsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_certificate_templates model
   */
  interface em_certificate_templatesFieldRefs {
    readonly certificate_id: FieldRef<"em_certificate_templates", 'Int'>
    readonly name: FieldRef<"em_certificate_templates", 'String'>
    readonly background_image: FieldRef<"em_certificate_templates", 'String'>
    readonly created_at: FieldRef<"em_certificate_templates", 'DateTime'>
    readonly certificate_name: FieldRef<"em_certificate_templates", 'String'>
    readonly lastupdate: FieldRef<"em_certificate_templates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_certificate_templates findUnique
   */
  export type em_certificate_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_templates to fetch.
     */
    where: em_certificate_templatesWhereUniqueInput
  }

  /**
   * em_certificate_templates findUniqueOrThrow
   */
  export type em_certificate_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_templates to fetch.
     */
    where: em_certificate_templatesWhereUniqueInput
  }

  /**
   * em_certificate_templates findFirst
   */
  export type em_certificate_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_templates to fetch.
     */
    where?: em_certificate_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_templates to fetch.
     */
    orderBy?: em_certificate_templatesOrderByWithRelationInput | em_certificate_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_certificate_templates.
     */
    cursor?: em_certificate_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_certificate_templates.
     */
    distinct?: Em_certificate_templatesScalarFieldEnum | Em_certificate_templatesScalarFieldEnum[]
  }

  /**
   * em_certificate_templates findFirstOrThrow
   */
  export type em_certificate_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_templates to fetch.
     */
    where?: em_certificate_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_templates to fetch.
     */
    orderBy?: em_certificate_templatesOrderByWithRelationInput | em_certificate_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_certificate_templates.
     */
    cursor?: em_certificate_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_certificate_templates.
     */
    distinct?: Em_certificate_templatesScalarFieldEnum | Em_certificate_templatesScalarFieldEnum[]
  }

  /**
   * em_certificate_templates findMany
   */
  export type em_certificate_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * Filter, which em_certificate_templates to fetch.
     */
    where?: em_certificate_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificate_templates to fetch.
     */
    orderBy?: em_certificate_templatesOrderByWithRelationInput | em_certificate_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_certificate_templates.
     */
    cursor?: em_certificate_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificate_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificate_templates.
     */
    skip?: number
    distinct?: Em_certificate_templatesScalarFieldEnum | Em_certificate_templatesScalarFieldEnum[]
  }

  /**
   * em_certificate_templates create
   */
  export type em_certificate_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * The data needed to create a em_certificate_templates.
     */
    data?: XOR<em_certificate_templatesCreateInput, em_certificate_templatesUncheckedCreateInput>
  }

  /**
   * em_certificate_templates createMany
   */
  export type em_certificate_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_certificate_templates.
     */
    data: em_certificate_templatesCreateManyInput | em_certificate_templatesCreateManyInput[]
  }

  /**
   * em_certificate_templates update
   */
  export type em_certificate_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * The data needed to update a em_certificate_templates.
     */
    data: XOR<em_certificate_templatesUpdateInput, em_certificate_templatesUncheckedUpdateInput>
    /**
     * Choose, which em_certificate_templates to update.
     */
    where: em_certificate_templatesWhereUniqueInput
  }

  /**
   * em_certificate_templates updateMany
   */
  export type em_certificate_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_certificate_templates.
     */
    data: XOR<em_certificate_templatesUpdateManyMutationInput, em_certificate_templatesUncheckedUpdateManyInput>
    /**
     * Filter which em_certificate_templates to update
     */
    where?: em_certificate_templatesWhereInput
    /**
     * Limit how many em_certificate_templates to update.
     */
    limit?: number
  }

  /**
   * em_certificate_templates upsert
   */
  export type em_certificate_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * The filter to search for the em_certificate_templates to update in case it exists.
     */
    where: em_certificate_templatesWhereUniqueInput
    /**
     * In case the em_certificate_templates found by the `where` argument doesn't exist, create a new em_certificate_templates with this data.
     */
    create: XOR<em_certificate_templatesCreateInput, em_certificate_templatesUncheckedCreateInput>
    /**
     * In case the em_certificate_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_certificate_templatesUpdateInput, em_certificate_templatesUncheckedUpdateInput>
  }

  /**
   * em_certificate_templates delete
   */
  export type em_certificate_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
    /**
     * Filter which em_certificate_templates to delete.
     */
    where: em_certificate_templatesWhereUniqueInput
  }

  /**
   * em_certificate_templates deleteMany
   */
  export type em_certificate_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_certificate_templates to delete
     */
    where?: em_certificate_templatesWhereInput
    /**
     * Limit how many em_certificate_templates to delete.
     */
    limit?: number
  }

  /**
   * em_certificate_templates.em_certificate_fields
   */
  export type em_certificate_templates$em_certificate_fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_fields
     */
    select?: em_certificate_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_fields
     */
    omit?: em_certificate_fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_fieldsInclude<ExtArgs> | null
    where?: em_certificate_fieldsWhereInput
    orderBy?: em_certificate_fieldsOrderByWithRelationInput | em_certificate_fieldsOrderByWithRelationInput[]
    cursor?: em_certificate_fieldsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_certificate_fieldsScalarFieldEnum | Em_certificate_fieldsScalarFieldEnum[]
  }

  /**
   * em_certificate_templates without action
   */
  export type em_certificate_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificate_templates
     */
    select?: em_certificate_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificate_templates
     */
    omit?: em_certificate_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_certificate_templatesInclude<ExtArgs> | null
  }


  /**
   * Model em_certificates_result
   */

  export type AggregateEm_certificates_result = {
    _count: Em_certificates_resultCountAggregateOutputType | null
    _avg: Em_certificates_resultAvgAggregateOutputType | null
    _sum: Em_certificates_resultSumAggregateOutputType | null
    _min: Em_certificates_resultMinAggregateOutputType | null
    _max: Em_certificates_resultMaxAggregateOutputType | null
  }

  export type Em_certificates_resultAvgAggregateOutputType = {
    cert_templ_id: number | null
    empl_id: number | null
    schedule_id: number | null
  }

  export type Em_certificates_resultSumAggregateOutputType = {
    cert_templ_id: number | null
    empl_id: number | null
    schedule_id: number | null
  }

  export type Em_certificates_resultMinAggregateOutputType = {
    cert_number: string | null
    cert_templ_id: number | null
    empl_id: number | null
    cert_name: string | null
    created_date: Date | null
    status: string | null
    generated_by: string | null
    schedule_id: number | null
  }

  export type Em_certificates_resultMaxAggregateOutputType = {
    cert_number: string | null
    cert_templ_id: number | null
    empl_id: number | null
    cert_name: string | null
    created_date: Date | null
    status: string | null
    generated_by: string | null
    schedule_id: number | null
  }

  export type Em_certificates_resultCountAggregateOutputType = {
    cert_number: number
    cert_templ_id: number
    empl_id: number
    cert_name: number
    created_date: number
    status: number
    generated_by: number
    schedule_id: number
    _all: number
  }


  export type Em_certificates_resultAvgAggregateInputType = {
    cert_templ_id?: true
    empl_id?: true
    schedule_id?: true
  }

  export type Em_certificates_resultSumAggregateInputType = {
    cert_templ_id?: true
    empl_id?: true
    schedule_id?: true
  }

  export type Em_certificates_resultMinAggregateInputType = {
    cert_number?: true
    cert_templ_id?: true
    empl_id?: true
    cert_name?: true
    created_date?: true
    status?: true
    generated_by?: true
    schedule_id?: true
  }

  export type Em_certificates_resultMaxAggregateInputType = {
    cert_number?: true
    cert_templ_id?: true
    empl_id?: true
    cert_name?: true
    created_date?: true
    status?: true
    generated_by?: true
    schedule_id?: true
  }

  export type Em_certificates_resultCountAggregateInputType = {
    cert_number?: true
    cert_templ_id?: true
    empl_id?: true
    cert_name?: true
    created_date?: true
    status?: true
    generated_by?: true
    schedule_id?: true
    _all?: true
  }

  export type Em_certificates_resultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_certificates_result to aggregate.
     */
    where?: em_certificates_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificates_results to fetch.
     */
    orderBy?: em_certificates_resultOrderByWithRelationInput | em_certificates_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_certificates_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificates_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificates_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_certificates_results
    **/
    _count?: true | Em_certificates_resultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_certificates_resultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_certificates_resultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_certificates_resultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_certificates_resultMaxAggregateInputType
  }

  export type GetEm_certificates_resultAggregateType<T extends Em_certificates_resultAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_certificates_result]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_certificates_result[P]>
      : GetScalarType<T[P], AggregateEm_certificates_result[P]>
  }




  export type em_certificates_resultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_certificates_resultWhereInput
    orderBy?: em_certificates_resultOrderByWithAggregationInput | em_certificates_resultOrderByWithAggregationInput[]
    by: Em_certificates_resultScalarFieldEnum[] | Em_certificates_resultScalarFieldEnum
    having?: em_certificates_resultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_certificates_resultCountAggregateInputType | true
    _avg?: Em_certificates_resultAvgAggregateInputType
    _sum?: Em_certificates_resultSumAggregateInputType
    _min?: Em_certificates_resultMinAggregateInputType
    _max?: Em_certificates_resultMaxAggregateInputType
  }

  export type Em_certificates_resultGroupByOutputType = {
    cert_number: string
    cert_templ_id: number
    empl_id: number
    cert_name: string
    created_date: Date | null
    status: string | null
    generated_by: string | null
    schedule_id: number | null
    _count: Em_certificates_resultCountAggregateOutputType | null
    _avg: Em_certificates_resultAvgAggregateOutputType | null
    _sum: Em_certificates_resultSumAggregateOutputType | null
    _min: Em_certificates_resultMinAggregateOutputType | null
    _max: Em_certificates_resultMaxAggregateOutputType | null
  }

  type GetEm_certificates_resultGroupByPayload<T extends em_certificates_resultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_certificates_resultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_certificates_resultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_certificates_resultGroupByOutputType[P]>
            : GetScalarType<T[P], Em_certificates_resultGroupByOutputType[P]>
        }
      >
    >


  export type em_certificates_resultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cert_number?: boolean
    cert_templ_id?: boolean
    empl_id?: boolean
    cert_name?: boolean
    created_date?: boolean
    status?: boolean
    generated_by?: boolean
    schedule_id?: boolean
  }, ExtArgs["result"]["em_certificates_result"]>



  export type em_certificates_resultSelectScalar = {
    cert_number?: boolean
    cert_templ_id?: boolean
    empl_id?: boolean
    cert_name?: boolean
    created_date?: boolean
    status?: boolean
    generated_by?: boolean
    schedule_id?: boolean
  }

  export type em_certificates_resultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cert_number" | "cert_templ_id" | "empl_id" | "cert_name" | "created_date" | "status" | "generated_by" | "schedule_id", ExtArgs["result"]["em_certificates_result"]>

  export type $em_certificates_resultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_certificates_result"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cert_number: string
      cert_templ_id: number
      empl_id: number
      cert_name: string
      created_date: Date | null
      status: string | null
      generated_by: string | null
      schedule_id: number | null
    }, ExtArgs["result"]["em_certificates_result"]>
    composites: {}
  }

  type em_certificates_resultGetPayload<S extends boolean | null | undefined | em_certificates_resultDefaultArgs> = $Result.GetResult<Prisma.$em_certificates_resultPayload, S>

  type em_certificates_resultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_certificates_resultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_certificates_resultCountAggregateInputType | true
    }

  export interface em_certificates_resultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_certificates_result'], meta: { name: 'em_certificates_result' } }
    /**
     * Find zero or one Em_certificates_result that matches the filter.
     * @param {em_certificates_resultFindUniqueArgs} args - Arguments to find a Em_certificates_result
     * @example
     * // Get one Em_certificates_result
     * const em_certificates_result = await prisma.em_certificates_result.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_certificates_resultFindUniqueArgs>(args: SelectSubset<T, em_certificates_resultFindUniqueArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_certificates_result that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_certificates_resultFindUniqueOrThrowArgs} args - Arguments to find a Em_certificates_result
     * @example
     * // Get one Em_certificates_result
     * const em_certificates_result = await prisma.em_certificates_result.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_certificates_resultFindUniqueOrThrowArgs>(args: SelectSubset<T, em_certificates_resultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_certificates_result that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificates_resultFindFirstArgs} args - Arguments to find a Em_certificates_result
     * @example
     * // Get one Em_certificates_result
     * const em_certificates_result = await prisma.em_certificates_result.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_certificates_resultFindFirstArgs>(args?: SelectSubset<T, em_certificates_resultFindFirstArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_certificates_result that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificates_resultFindFirstOrThrowArgs} args - Arguments to find a Em_certificates_result
     * @example
     * // Get one Em_certificates_result
     * const em_certificates_result = await prisma.em_certificates_result.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_certificates_resultFindFirstOrThrowArgs>(args?: SelectSubset<T, em_certificates_resultFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_certificates_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificates_resultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_certificates_results
     * const em_certificates_results = await prisma.em_certificates_result.findMany()
     * 
     * // Get first 10 Em_certificates_results
     * const em_certificates_results = await prisma.em_certificates_result.findMany({ take: 10 })
     * 
     * // Only select the `cert_number`
     * const em_certificates_resultWithCert_numberOnly = await prisma.em_certificates_result.findMany({ select: { cert_number: true } })
     * 
     */
    findMany<T extends em_certificates_resultFindManyArgs>(args?: SelectSubset<T, em_certificates_resultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_certificates_result.
     * @param {em_certificates_resultCreateArgs} args - Arguments to create a Em_certificates_result.
     * @example
     * // Create one Em_certificates_result
     * const Em_certificates_result = await prisma.em_certificates_result.create({
     *   data: {
     *     // ... data to create a Em_certificates_result
     *   }
     * })
     * 
     */
    create<T extends em_certificates_resultCreateArgs>(args: SelectSubset<T, em_certificates_resultCreateArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_certificates_results.
     * @param {em_certificates_resultCreateManyArgs} args - Arguments to create many Em_certificates_results.
     * @example
     * // Create many Em_certificates_results
     * const em_certificates_result = await prisma.em_certificates_result.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_certificates_resultCreateManyArgs>(args?: SelectSubset<T, em_certificates_resultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_certificates_result.
     * @param {em_certificates_resultDeleteArgs} args - Arguments to delete one Em_certificates_result.
     * @example
     * // Delete one Em_certificates_result
     * const Em_certificates_result = await prisma.em_certificates_result.delete({
     *   where: {
     *     // ... filter to delete one Em_certificates_result
     *   }
     * })
     * 
     */
    delete<T extends em_certificates_resultDeleteArgs>(args: SelectSubset<T, em_certificates_resultDeleteArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_certificates_result.
     * @param {em_certificates_resultUpdateArgs} args - Arguments to update one Em_certificates_result.
     * @example
     * // Update one Em_certificates_result
     * const em_certificates_result = await prisma.em_certificates_result.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_certificates_resultUpdateArgs>(args: SelectSubset<T, em_certificates_resultUpdateArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_certificates_results.
     * @param {em_certificates_resultDeleteManyArgs} args - Arguments to filter Em_certificates_results to delete.
     * @example
     * // Delete a few Em_certificates_results
     * const { count } = await prisma.em_certificates_result.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_certificates_resultDeleteManyArgs>(args?: SelectSubset<T, em_certificates_resultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_certificates_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificates_resultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_certificates_results
     * const em_certificates_result = await prisma.em_certificates_result.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_certificates_resultUpdateManyArgs>(args: SelectSubset<T, em_certificates_resultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_certificates_result.
     * @param {em_certificates_resultUpsertArgs} args - Arguments to update or create a Em_certificates_result.
     * @example
     * // Update or create a Em_certificates_result
     * const em_certificates_result = await prisma.em_certificates_result.upsert({
     *   create: {
     *     // ... data to create a Em_certificates_result
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_certificates_result we want to update
     *   }
     * })
     */
    upsert<T extends em_certificates_resultUpsertArgs>(args: SelectSubset<T, em_certificates_resultUpsertArgs<ExtArgs>>): Prisma__em_certificates_resultClient<$Result.GetResult<Prisma.$em_certificates_resultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_certificates_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificates_resultCountArgs} args - Arguments to filter Em_certificates_results to count.
     * @example
     * // Count the number of Em_certificates_results
     * const count = await prisma.em_certificates_result.count({
     *   where: {
     *     // ... the filter for the Em_certificates_results we want to count
     *   }
     * })
    **/
    count<T extends em_certificates_resultCountArgs>(
      args?: Subset<T, em_certificates_resultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_certificates_resultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_certificates_result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_certificates_resultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_certificates_resultAggregateArgs>(args: Subset<T, Em_certificates_resultAggregateArgs>): Prisma.PrismaPromise<GetEm_certificates_resultAggregateType<T>>

    /**
     * Group by Em_certificates_result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_certificates_resultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_certificates_resultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_certificates_resultGroupByArgs['orderBy'] }
        : { orderBy?: em_certificates_resultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_certificates_resultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_certificates_resultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_certificates_result model
   */
  readonly fields: em_certificates_resultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_certificates_result.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_certificates_resultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_certificates_result model
   */
  interface em_certificates_resultFieldRefs {
    readonly cert_number: FieldRef<"em_certificates_result", 'String'>
    readonly cert_templ_id: FieldRef<"em_certificates_result", 'Int'>
    readonly empl_id: FieldRef<"em_certificates_result", 'Int'>
    readonly cert_name: FieldRef<"em_certificates_result", 'String'>
    readonly created_date: FieldRef<"em_certificates_result", 'DateTime'>
    readonly status: FieldRef<"em_certificates_result", 'String'>
    readonly generated_by: FieldRef<"em_certificates_result", 'String'>
    readonly schedule_id: FieldRef<"em_certificates_result", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_certificates_result findUnique
   */
  export type em_certificates_resultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * Filter, which em_certificates_result to fetch.
     */
    where: em_certificates_resultWhereUniqueInput
  }

  /**
   * em_certificates_result findUniqueOrThrow
   */
  export type em_certificates_resultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * Filter, which em_certificates_result to fetch.
     */
    where: em_certificates_resultWhereUniqueInput
  }

  /**
   * em_certificates_result findFirst
   */
  export type em_certificates_resultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * Filter, which em_certificates_result to fetch.
     */
    where?: em_certificates_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificates_results to fetch.
     */
    orderBy?: em_certificates_resultOrderByWithRelationInput | em_certificates_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_certificates_results.
     */
    cursor?: em_certificates_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificates_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificates_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_certificates_results.
     */
    distinct?: Em_certificates_resultScalarFieldEnum | Em_certificates_resultScalarFieldEnum[]
  }

  /**
   * em_certificates_result findFirstOrThrow
   */
  export type em_certificates_resultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * Filter, which em_certificates_result to fetch.
     */
    where?: em_certificates_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificates_results to fetch.
     */
    orderBy?: em_certificates_resultOrderByWithRelationInput | em_certificates_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_certificates_results.
     */
    cursor?: em_certificates_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificates_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificates_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_certificates_results.
     */
    distinct?: Em_certificates_resultScalarFieldEnum | Em_certificates_resultScalarFieldEnum[]
  }

  /**
   * em_certificates_result findMany
   */
  export type em_certificates_resultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * Filter, which em_certificates_results to fetch.
     */
    where?: em_certificates_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_certificates_results to fetch.
     */
    orderBy?: em_certificates_resultOrderByWithRelationInput | em_certificates_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_certificates_results.
     */
    cursor?: em_certificates_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_certificates_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_certificates_results.
     */
    skip?: number
    distinct?: Em_certificates_resultScalarFieldEnum | Em_certificates_resultScalarFieldEnum[]
  }

  /**
   * em_certificates_result create
   */
  export type em_certificates_resultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * The data needed to create a em_certificates_result.
     */
    data: XOR<em_certificates_resultCreateInput, em_certificates_resultUncheckedCreateInput>
  }

  /**
   * em_certificates_result createMany
   */
  export type em_certificates_resultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_certificates_results.
     */
    data: em_certificates_resultCreateManyInput | em_certificates_resultCreateManyInput[]
  }

  /**
   * em_certificates_result update
   */
  export type em_certificates_resultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * The data needed to update a em_certificates_result.
     */
    data: XOR<em_certificates_resultUpdateInput, em_certificates_resultUncheckedUpdateInput>
    /**
     * Choose, which em_certificates_result to update.
     */
    where: em_certificates_resultWhereUniqueInput
  }

  /**
   * em_certificates_result updateMany
   */
  export type em_certificates_resultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_certificates_results.
     */
    data: XOR<em_certificates_resultUpdateManyMutationInput, em_certificates_resultUncheckedUpdateManyInput>
    /**
     * Filter which em_certificates_results to update
     */
    where?: em_certificates_resultWhereInput
    /**
     * Limit how many em_certificates_results to update.
     */
    limit?: number
  }

  /**
   * em_certificates_result upsert
   */
  export type em_certificates_resultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * The filter to search for the em_certificates_result to update in case it exists.
     */
    where: em_certificates_resultWhereUniqueInput
    /**
     * In case the em_certificates_result found by the `where` argument doesn't exist, create a new em_certificates_result with this data.
     */
    create: XOR<em_certificates_resultCreateInput, em_certificates_resultUncheckedCreateInput>
    /**
     * In case the em_certificates_result was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_certificates_resultUpdateInput, em_certificates_resultUncheckedUpdateInput>
  }

  /**
   * em_certificates_result delete
   */
  export type em_certificates_resultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
    /**
     * Filter which em_certificates_result to delete.
     */
    where: em_certificates_resultWhereUniqueInput
  }

  /**
   * em_certificates_result deleteMany
   */
  export type em_certificates_resultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_certificates_results to delete
     */
    where?: em_certificates_resultWhereInput
    /**
     * Limit how many em_certificates_results to delete.
     */
    limit?: number
  }

  /**
   * em_certificates_result without action
   */
  export type em_certificates_resultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_certificates_result
     */
    select?: em_certificates_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_certificates_result
     */
    omit?: em_certificates_resultOmit<ExtArgs> | null
  }


  /**
   * Model em_chance
   */

  export type AggregateEm_chance = {
    _count: Em_chanceCountAggregateOutputType | null
    _avg: Em_chanceAvgAggregateOutputType | null
    _sum: Em_chanceSumAggregateOutputType | null
    _min: Em_chanceMinAggregateOutputType | null
    _max: Em_chanceMaxAggregateOutputType | null
  }

  export type Em_chanceAvgAggregateOutputType = {
    chId: number | null
  }

  export type Em_chanceSumAggregateOutputType = {
    chId: number | null
  }

  export type Em_chanceMinAggregateOutputType = {
    chId: number | null
    chName: string | null
    chDesc: string | null
    chStats: string | null
    chFileImage: string | null
    chLink: string | null
    chUserid: string | null
    chDate: Date | null
    chLastupdate: Date | null
  }

  export type Em_chanceMaxAggregateOutputType = {
    chId: number | null
    chName: string | null
    chDesc: string | null
    chStats: string | null
    chFileImage: string | null
    chLink: string | null
    chUserid: string | null
    chDate: Date | null
    chLastupdate: Date | null
  }

  export type Em_chanceCountAggregateOutputType = {
    chId: number
    chName: number
    chDesc: number
    chStats: number
    chFileImage: number
    chLink: number
    chUserid: number
    chDate: number
    chLastupdate: number
    _all: number
  }


  export type Em_chanceAvgAggregateInputType = {
    chId?: true
  }

  export type Em_chanceSumAggregateInputType = {
    chId?: true
  }

  export type Em_chanceMinAggregateInputType = {
    chId?: true
    chName?: true
    chDesc?: true
    chStats?: true
    chFileImage?: true
    chLink?: true
    chUserid?: true
    chDate?: true
    chLastupdate?: true
  }

  export type Em_chanceMaxAggregateInputType = {
    chId?: true
    chName?: true
    chDesc?: true
    chStats?: true
    chFileImage?: true
    chLink?: true
    chUserid?: true
    chDate?: true
    chLastupdate?: true
  }

  export type Em_chanceCountAggregateInputType = {
    chId?: true
    chName?: true
    chDesc?: true
    chStats?: true
    chFileImage?: true
    chLink?: true
    chUserid?: true
    chDate?: true
    chLastupdate?: true
    _all?: true
  }

  export type Em_chanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_chance to aggregate.
     */
    where?: em_chanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_chances to fetch.
     */
    orderBy?: em_chanceOrderByWithRelationInput | em_chanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_chanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_chances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_chances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_chances
    **/
    _count?: true | Em_chanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_chanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_chanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_chanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_chanceMaxAggregateInputType
  }

  export type GetEm_chanceAggregateType<T extends Em_chanceAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_chance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_chance[P]>
      : GetScalarType<T[P], AggregateEm_chance[P]>
  }




  export type em_chanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_chanceWhereInput
    orderBy?: em_chanceOrderByWithAggregationInput | em_chanceOrderByWithAggregationInput[]
    by: Em_chanceScalarFieldEnum[] | Em_chanceScalarFieldEnum
    having?: em_chanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_chanceCountAggregateInputType | true
    _avg?: Em_chanceAvgAggregateInputType
    _sum?: Em_chanceSumAggregateInputType
    _min?: Em_chanceMinAggregateInputType
    _max?: Em_chanceMaxAggregateInputType
  }

  export type Em_chanceGroupByOutputType = {
    chId: number
    chName: string | null
    chDesc: string | null
    chStats: string | null
    chFileImage: string | null
    chLink: string | null
    chUserid: string | null
    chDate: Date | null
    chLastupdate: Date | null
    _count: Em_chanceCountAggregateOutputType | null
    _avg: Em_chanceAvgAggregateOutputType | null
    _sum: Em_chanceSumAggregateOutputType | null
    _min: Em_chanceMinAggregateOutputType | null
    _max: Em_chanceMaxAggregateOutputType | null
  }

  type GetEm_chanceGroupByPayload<T extends em_chanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_chanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_chanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_chanceGroupByOutputType[P]>
            : GetScalarType<T[P], Em_chanceGroupByOutputType[P]>
        }
      >
    >


  export type em_chanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chId?: boolean
    chName?: boolean
    chDesc?: boolean
    chStats?: boolean
    chFileImage?: boolean
    chLink?: boolean
    chUserid?: boolean
    chDate?: boolean
    chLastupdate?: boolean
  }, ExtArgs["result"]["em_chance"]>



  export type em_chanceSelectScalar = {
    chId?: boolean
    chName?: boolean
    chDesc?: boolean
    chStats?: boolean
    chFileImage?: boolean
    chLink?: boolean
    chUserid?: boolean
    chDate?: boolean
    chLastupdate?: boolean
  }

  export type em_chanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chId" | "chName" | "chDesc" | "chStats" | "chFileImage" | "chLink" | "chUserid" | "chDate" | "chLastupdate", ExtArgs["result"]["em_chance"]>

  export type $em_chancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_chance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chId: number
      chName: string | null
      chDesc: string | null
      chStats: string | null
      chFileImage: string | null
      chLink: string | null
      chUserid: string | null
      chDate: Date | null
      chLastupdate: Date | null
    }, ExtArgs["result"]["em_chance"]>
    composites: {}
  }

  type em_chanceGetPayload<S extends boolean | null | undefined | em_chanceDefaultArgs> = $Result.GetResult<Prisma.$em_chancePayload, S>

  type em_chanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_chanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_chanceCountAggregateInputType | true
    }

  export interface em_chanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_chance'], meta: { name: 'em_chance' } }
    /**
     * Find zero or one Em_chance that matches the filter.
     * @param {em_chanceFindUniqueArgs} args - Arguments to find a Em_chance
     * @example
     * // Get one Em_chance
     * const em_chance = await prisma.em_chance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_chanceFindUniqueArgs>(args: SelectSubset<T, em_chanceFindUniqueArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_chance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_chanceFindUniqueOrThrowArgs} args - Arguments to find a Em_chance
     * @example
     * // Get one Em_chance
     * const em_chance = await prisma.em_chance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_chanceFindUniqueOrThrowArgs>(args: SelectSubset<T, em_chanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_chance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_chanceFindFirstArgs} args - Arguments to find a Em_chance
     * @example
     * // Get one Em_chance
     * const em_chance = await prisma.em_chance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_chanceFindFirstArgs>(args?: SelectSubset<T, em_chanceFindFirstArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_chance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_chanceFindFirstOrThrowArgs} args - Arguments to find a Em_chance
     * @example
     * // Get one Em_chance
     * const em_chance = await prisma.em_chance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_chanceFindFirstOrThrowArgs>(args?: SelectSubset<T, em_chanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_chances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_chanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_chances
     * const em_chances = await prisma.em_chance.findMany()
     * 
     * // Get first 10 Em_chances
     * const em_chances = await prisma.em_chance.findMany({ take: 10 })
     * 
     * // Only select the `chId`
     * const em_chanceWithChIdOnly = await prisma.em_chance.findMany({ select: { chId: true } })
     * 
     */
    findMany<T extends em_chanceFindManyArgs>(args?: SelectSubset<T, em_chanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_chance.
     * @param {em_chanceCreateArgs} args - Arguments to create a Em_chance.
     * @example
     * // Create one Em_chance
     * const Em_chance = await prisma.em_chance.create({
     *   data: {
     *     // ... data to create a Em_chance
     *   }
     * })
     * 
     */
    create<T extends em_chanceCreateArgs>(args: SelectSubset<T, em_chanceCreateArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_chances.
     * @param {em_chanceCreateManyArgs} args - Arguments to create many Em_chances.
     * @example
     * // Create many Em_chances
     * const em_chance = await prisma.em_chance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_chanceCreateManyArgs>(args?: SelectSubset<T, em_chanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_chance.
     * @param {em_chanceDeleteArgs} args - Arguments to delete one Em_chance.
     * @example
     * // Delete one Em_chance
     * const Em_chance = await prisma.em_chance.delete({
     *   where: {
     *     // ... filter to delete one Em_chance
     *   }
     * })
     * 
     */
    delete<T extends em_chanceDeleteArgs>(args: SelectSubset<T, em_chanceDeleteArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_chance.
     * @param {em_chanceUpdateArgs} args - Arguments to update one Em_chance.
     * @example
     * // Update one Em_chance
     * const em_chance = await prisma.em_chance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_chanceUpdateArgs>(args: SelectSubset<T, em_chanceUpdateArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_chances.
     * @param {em_chanceDeleteManyArgs} args - Arguments to filter Em_chances to delete.
     * @example
     * // Delete a few Em_chances
     * const { count } = await prisma.em_chance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_chanceDeleteManyArgs>(args?: SelectSubset<T, em_chanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_chances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_chanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_chances
     * const em_chance = await prisma.em_chance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_chanceUpdateManyArgs>(args: SelectSubset<T, em_chanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_chance.
     * @param {em_chanceUpsertArgs} args - Arguments to update or create a Em_chance.
     * @example
     * // Update or create a Em_chance
     * const em_chance = await prisma.em_chance.upsert({
     *   create: {
     *     // ... data to create a Em_chance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_chance we want to update
     *   }
     * })
     */
    upsert<T extends em_chanceUpsertArgs>(args: SelectSubset<T, em_chanceUpsertArgs<ExtArgs>>): Prisma__em_chanceClient<$Result.GetResult<Prisma.$em_chancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_chances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_chanceCountArgs} args - Arguments to filter Em_chances to count.
     * @example
     * // Count the number of Em_chances
     * const count = await prisma.em_chance.count({
     *   where: {
     *     // ... the filter for the Em_chances we want to count
     *   }
     * })
    **/
    count<T extends em_chanceCountArgs>(
      args?: Subset<T, em_chanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_chanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_chance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_chanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_chanceAggregateArgs>(args: Subset<T, Em_chanceAggregateArgs>): Prisma.PrismaPromise<GetEm_chanceAggregateType<T>>

    /**
     * Group by Em_chance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_chanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_chanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_chanceGroupByArgs['orderBy'] }
        : { orderBy?: em_chanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_chanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_chanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_chance model
   */
  readonly fields: em_chanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_chance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_chanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_chance model
   */
  interface em_chanceFieldRefs {
    readonly chId: FieldRef<"em_chance", 'Int'>
    readonly chName: FieldRef<"em_chance", 'String'>
    readonly chDesc: FieldRef<"em_chance", 'String'>
    readonly chStats: FieldRef<"em_chance", 'String'>
    readonly chFileImage: FieldRef<"em_chance", 'String'>
    readonly chLink: FieldRef<"em_chance", 'String'>
    readonly chUserid: FieldRef<"em_chance", 'String'>
    readonly chDate: FieldRef<"em_chance", 'DateTime'>
    readonly chLastupdate: FieldRef<"em_chance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_chance findUnique
   */
  export type em_chanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * Filter, which em_chance to fetch.
     */
    where: em_chanceWhereUniqueInput
  }

  /**
   * em_chance findUniqueOrThrow
   */
  export type em_chanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * Filter, which em_chance to fetch.
     */
    where: em_chanceWhereUniqueInput
  }

  /**
   * em_chance findFirst
   */
  export type em_chanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * Filter, which em_chance to fetch.
     */
    where?: em_chanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_chances to fetch.
     */
    orderBy?: em_chanceOrderByWithRelationInput | em_chanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_chances.
     */
    cursor?: em_chanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_chances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_chances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_chances.
     */
    distinct?: Em_chanceScalarFieldEnum | Em_chanceScalarFieldEnum[]
  }

  /**
   * em_chance findFirstOrThrow
   */
  export type em_chanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * Filter, which em_chance to fetch.
     */
    where?: em_chanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_chances to fetch.
     */
    orderBy?: em_chanceOrderByWithRelationInput | em_chanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_chances.
     */
    cursor?: em_chanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_chances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_chances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_chances.
     */
    distinct?: Em_chanceScalarFieldEnum | Em_chanceScalarFieldEnum[]
  }

  /**
   * em_chance findMany
   */
  export type em_chanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * Filter, which em_chances to fetch.
     */
    where?: em_chanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_chances to fetch.
     */
    orderBy?: em_chanceOrderByWithRelationInput | em_chanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_chances.
     */
    cursor?: em_chanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_chances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_chances.
     */
    skip?: number
    distinct?: Em_chanceScalarFieldEnum | Em_chanceScalarFieldEnum[]
  }

  /**
   * em_chance create
   */
  export type em_chanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * The data needed to create a em_chance.
     */
    data?: XOR<em_chanceCreateInput, em_chanceUncheckedCreateInput>
  }

  /**
   * em_chance createMany
   */
  export type em_chanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_chances.
     */
    data: em_chanceCreateManyInput | em_chanceCreateManyInput[]
  }

  /**
   * em_chance update
   */
  export type em_chanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * The data needed to update a em_chance.
     */
    data: XOR<em_chanceUpdateInput, em_chanceUncheckedUpdateInput>
    /**
     * Choose, which em_chance to update.
     */
    where: em_chanceWhereUniqueInput
  }

  /**
   * em_chance updateMany
   */
  export type em_chanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_chances.
     */
    data: XOR<em_chanceUpdateManyMutationInput, em_chanceUncheckedUpdateManyInput>
    /**
     * Filter which em_chances to update
     */
    where?: em_chanceWhereInput
    /**
     * Limit how many em_chances to update.
     */
    limit?: number
  }

  /**
   * em_chance upsert
   */
  export type em_chanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * The filter to search for the em_chance to update in case it exists.
     */
    where: em_chanceWhereUniqueInput
    /**
     * In case the em_chance found by the `where` argument doesn't exist, create a new em_chance with this data.
     */
    create: XOR<em_chanceCreateInput, em_chanceUncheckedCreateInput>
    /**
     * In case the em_chance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_chanceUpdateInput, em_chanceUncheckedUpdateInput>
  }

  /**
   * em_chance delete
   */
  export type em_chanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
    /**
     * Filter which em_chance to delete.
     */
    where: em_chanceWhereUniqueInput
  }

  /**
   * em_chance deleteMany
   */
  export type em_chanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_chances to delete
     */
    where?: em_chanceWhereInput
    /**
     * Limit how many em_chances to delete.
     */
    limit?: number
  }

  /**
   * em_chance without action
   */
  export type em_chanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_chance
     */
    select?: em_chanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_chance
     */
    omit?: em_chanceOmit<ExtArgs> | null
  }


  /**
   * Model em_contrctype
   */

  export type AggregateEm_contrctype = {
    _count: Em_contrctypeCountAggregateOutputType | null
    _avg: Em_contrctypeAvgAggregateOutputType | null
    _sum: Em_contrctypeSumAggregateOutputType | null
    _min: Em_contrctypeMinAggregateOutputType | null
    _max: Em_contrctypeMaxAggregateOutputType | null
  }

  export type Em_contrctypeAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_contrctypeSumAggregateOutputType = {
    id: number | null
  }

  export type Em_contrctypeMinAggregateOutputType = {
    id: number | null
    contract_text: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_contrctypeMaxAggregateOutputType = {
    id: number | null
    contract_text: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_contrctypeCountAggregateOutputType = {
    id: number
    contract_text: number
    status: number
    lastupdate: number
    _all: number
  }


  export type Em_contrctypeAvgAggregateInputType = {
    id?: true
  }

  export type Em_contrctypeSumAggregateInputType = {
    id?: true
  }

  export type Em_contrctypeMinAggregateInputType = {
    id?: true
    contract_text?: true
    status?: true
    lastupdate?: true
  }

  export type Em_contrctypeMaxAggregateInputType = {
    id?: true
    contract_text?: true
    status?: true
    lastupdate?: true
  }

  export type Em_contrctypeCountAggregateInputType = {
    id?: true
    contract_text?: true
    status?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_contrctypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_contrctype to aggregate.
     */
    where?: em_contrctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_contrctypes to fetch.
     */
    orderBy?: em_contrctypeOrderByWithRelationInput | em_contrctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_contrctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_contrctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_contrctypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_contrctypes
    **/
    _count?: true | Em_contrctypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_contrctypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_contrctypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_contrctypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_contrctypeMaxAggregateInputType
  }

  export type GetEm_contrctypeAggregateType<T extends Em_contrctypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_contrctype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_contrctype[P]>
      : GetScalarType<T[P], AggregateEm_contrctype[P]>
  }




  export type em_contrctypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_contrctypeWhereInput
    orderBy?: em_contrctypeOrderByWithAggregationInput | em_contrctypeOrderByWithAggregationInput[]
    by: Em_contrctypeScalarFieldEnum[] | Em_contrctypeScalarFieldEnum
    having?: em_contrctypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_contrctypeCountAggregateInputType | true
    _avg?: Em_contrctypeAvgAggregateInputType
    _sum?: Em_contrctypeSumAggregateInputType
    _min?: Em_contrctypeMinAggregateInputType
    _max?: Em_contrctypeMaxAggregateInputType
  }

  export type Em_contrctypeGroupByOutputType = {
    id: number
    contract_text: string
    status: string | null
    lastupdate: Date | null
    _count: Em_contrctypeCountAggregateOutputType | null
    _avg: Em_contrctypeAvgAggregateOutputType | null
    _sum: Em_contrctypeSumAggregateOutputType | null
    _min: Em_contrctypeMinAggregateOutputType | null
    _max: Em_contrctypeMaxAggregateOutputType | null
  }

  type GetEm_contrctypeGroupByPayload<T extends em_contrctypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_contrctypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_contrctypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_contrctypeGroupByOutputType[P]>
            : GetScalarType<T[P], Em_contrctypeGroupByOutputType[P]>
        }
      >
    >


  export type em_contrctypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract_text?: boolean
    status?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["em_contrctype"]>



  export type em_contrctypeSelectScalar = {
    id?: boolean
    contract_text?: boolean
    status?: boolean
    lastupdate?: boolean
  }

  export type em_contrctypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contract_text" | "status" | "lastupdate", ExtArgs["result"]["em_contrctype"]>

  export type $em_contrctypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_contrctype"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contract_text: string
      status: string | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_contrctype"]>
    composites: {}
  }

  type em_contrctypeGetPayload<S extends boolean | null | undefined | em_contrctypeDefaultArgs> = $Result.GetResult<Prisma.$em_contrctypePayload, S>

  type em_contrctypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_contrctypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_contrctypeCountAggregateInputType | true
    }

  export interface em_contrctypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_contrctype'], meta: { name: 'em_contrctype' } }
    /**
     * Find zero or one Em_contrctype that matches the filter.
     * @param {em_contrctypeFindUniqueArgs} args - Arguments to find a Em_contrctype
     * @example
     * // Get one Em_contrctype
     * const em_contrctype = await prisma.em_contrctype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_contrctypeFindUniqueArgs>(args: SelectSubset<T, em_contrctypeFindUniqueArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_contrctype that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_contrctypeFindUniqueOrThrowArgs} args - Arguments to find a Em_contrctype
     * @example
     * // Get one Em_contrctype
     * const em_contrctype = await prisma.em_contrctype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_contrctypeFindUniqueOrThrowArgs>(args: SelectSubset<T, em_contrctypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_contrctype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_contrctypeFindFirstArgs} args - Arguments to find a Em_contrctype
     * @example
     * // Get one Em_contrctype
     * const em_contrctype = await prisma.em_contrctype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_contrctypeFindFirstArgs>(args?: SelectSubset<T, em_contrctypeFindFirstArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_contrctype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_contrctypeFindFirstOrThrowArgs} args - Arguments to find a Em_contrctype
     * @example
     * // Get one Em_contrctype
     * const em_contrctype = await prisma.em_contrctype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_contrctypeFindFirstOrThrowArgs>(args?: SelectSubset<T, em_contrctypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_contrctypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_contrctypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_contrctypes
     * const em_contrctypes = await prisma.em_contrctype.findMany()
     * 
     * // Get first 10 Em_contrctypes
     * const em_contrctypes = await prisma.em_contrctype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_contrctypeWithIdOnly = await prisma.em_contrctype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_contrctypeFindManyArgs>(args?: SelectSubset<T, em_contrctypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_contrctype.
     * @param {em_contrctypeCreateArgs} args - Arguments to create a Em_contrctype.
     * @example
     * // Create one Em_contrctype
     * const Em_contrctype = await prisma.em_contrctype.create({
     *   data: {
     *     // ... data to create a Em_contrctype
     *   }
     * })
     * 
     */
    create<T extends em_contrctypeCreateArgs>(args: SelectSubset<T, em_contrctypeCreateArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_contrctypes.
     * @param {em_contrctypeCreateManyArgs} args - Arguments to create many Em_contrctypes.
     * @example
     * // Create many Em_contrctypes
     * const em_contrctype = await prisma.em_contrctype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_contrctypeCreateManyArgs>(args?: SelectSubset<T, em_contrctypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_contrctype.
     * @param {em_contrctypeDeleteArgs} args - Arguments to delete one Em_contrctype.
     * @example
     * // Delete one Em_contrctype
     * const Em_contrctype = await prisma.em_contrctype.delete({
     *   where: {
     *     // ... filter to delete one Em_contrctype
     *   }
     * })
     * 
     */
    delete<T extends em_contrctypeDeleteArgs>(args: SelectSubset<T, em_contrctypeDeleteArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_contrctype.
     * @param {em_contrctypeUpdateArgs} args - Arguments to update one Em_contrctype.
     * @example
     * // Update one Em_contrctype
     * const em_contrctype = await prisma.em_contrctype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_contrctypeUpdateArgs>(args: SelectSubset<T, em_contrctypeUpdateArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_contrctypes.
     * @param {em_contrctypeDeleteManyArgs} args - Arguments to filter Em_contrctypes to delete.
     * @example
     * // Delete a few Em_contrctypes
     * const { count } = await prisma.em_contrctype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_contrctypeDeleteManyArgs>(args?: SelectSubset<T, em_contrctypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_contrctypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_contrctypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_contrctypes
     * const em_contrctype = await prisma.em_contrctype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_contrctypeUpdateManyArgs>(args: SelectSubset<T, em_contrctypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_contrctype.
     * @param {em_contrctypeUpsertArgs} args - Arguments to update or create a Em_contrctype.
     * @example
     * // Update or create a Em_contrctype
     * const em_contrctype = await prisma.em_contrctype.upsert({
     *   create: {
     *     // ... data to create a Em_contrctype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_contrctype we want to update
     *   }
     * })
     */
    upsert<T extends em_contrctypeUpsertArgs>(args: SelectSubset<T, em_contrctypeUpsertArgs<ExtArgs>>): Prisma__em_contrctypeClient<$Result.GetResult<Prisma.$em_contrctypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_contrctypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_contrctypeCountArgs} args - Arguments to filter Em_contrctypes to count.
     * @example
     * // Count the number of Em_contrctypes
     * const count = await prisma.em_contrctype.count({
     *   where: {
     *     // ... the filter for the Em_contrctypes we want to count
     *   }
     * })
    **/
    count<T extends em_contrctypeCountArgs>(
      args?: Subset<T, em_contrctypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_contrctypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_contrctype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_contrctypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_contrctypeAggregateArgs>(args: Subset<T, Em_contrctypeAggregateArgs>): Prisma.PrismaPromise<GetEm_contrctypeAggregateType<T>>

    /**
     * Group by Em_contrctype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_contrctypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_contrctypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_contrctypeGroupByArgs['orderBy'] }
        : { orderBy?: em_contrctypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_contrctypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_contrctypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_contrctype model
   */
  readonly fields: em_contrctypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_contrctype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_contrctypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_contrctype model
   */
  interface em_contrctypeFieldRefs {
    readonly id: FieldRef<"em_contrctype", 'Int'>
    readonly contract_text: FieldRef<"em_contrctype", 'String'>
    readonly status: FieldRef<"em_contrctype", 'String'>
    readonly lastupdate: FieldRef<"em_contrctype", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_contrctype findUnique
   */
  export type em_contrctypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * Filter, which em_contrctype to fetch.
     */
    where: em_contrctypeWhereUniqueInput
  }

  /**
   * em_contrctype findUniqueOrThrow
   */
  export type em_contrctypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * Filter, which em_contrctype to fetch.
     */
    where: em_contrctypeWhereUniqueInput
  }

  /**
   * em_contrctype findFirst
   */
  export type em_contrctypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * Filter, which em_contrctype to fetch.
     */
    where?: em_contrctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_contrctypes to fetch.
     */
    orderBy?: em_contrctypeOrderByWithRelationInput | em_contrctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_contrctypes.
     */
    cursor?: em_contrctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_contrctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_contrctypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_contrctypes.
     */
    distinct?: Em_contrctypeScalarFieldEnum | Em_contrctypeScalarFieldEnum[]
  }

  /**
   * em_contrctype findFirstOrThrow
   */
  export type em_contrctypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * Filter, which em_contrctype to fetch.
     */
    where?: em_contrctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_contrctypes to fetch.
     */
    orderBy?: em_contrctypeOrderByWithRelationInput | em_contrctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_contrctypes.
     */
    cursor?: em_contrctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_contrctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_contrctypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_contrctypes.
     */
    distinct?: Em_contrctypeScalarFieldEnum | Em_contrctypeScalarFieldEnum[]
  }

  /**
   * em_contrctype findMany
   */
  export type em_contrctypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * Filter, which em_contrctypes to fetch.
     */
    where?: em_contrctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_contrctypes to fetch.
     */
    orderBy?: em_contrctypeOrderByWithRelationInput | em_contrctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_contrctypes.
     */
    cursor?: em_contrctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_contrctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_contrctypes.
     */
    skip?: number
    distinct?: Em_contrctypeScalarFieldEnum | Em_contrctypeScalarFieldEnum[]
  }

  /**
   * em_contrctype create
   */
  export type em_contrctypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * The data needed to create a em_contrctype.
     */
    data: XOR<em_contrctypeCreateInput, em_contrctypeUncheckedCreateInput>
  }

  /**
   * em_contrctype createMany
   */
  export type em_contrctypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_contrctypes.
     */
    data: em_contrctypeCreateManyInput | em_contrctypeCreateManyInput[]
  }

  /**
   * em_contrctype update
   */
  export type em_contrctypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * The data needed to update a em_contrctype.
     */
    data: XOR<em_contrctypeUpdateInput, em_contrctypeUncheckedUpdateInput>
    /**
     * Choose, which em_contrctype to update.
     */
    where: em_contrctypeWhereUniqueInput
  }

  /**
   * em_contrctype updateMany
   */
  export type em_contrctypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_contrctypes.
     */
    data: XOR<em_contrctypeUpdateManyMutationInput, em_contrctypeUncheckedUpdateManyInput>
    /**
     * Filter which em_contrctypes to update
     */
    where?: em_contrctypeWhereInput
    /**
     * Limit how many em_contrctypes to update.
     */
    limit?: number
  }

  /**
   * em_contrctype upsert
   */
  export type em_contrctypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * The filter to search for the em_contrctype to update in case it exists.
     */
    where: em_contrctypeWhereUniqueInput
    /**
     * In case the em_contrctype found by the `where` argument doesn't exist, create a new em_contrctype with this data.
     */
    create: XOR<em_contrctypeCreateInput, em_contrctypeUncheckedCreateInput>
    /**
     * In case the em_contrctype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_contrctypeUpdateInput, em_contrctypeUncheckedUpdateInput>
  }

  /**
   * em_contrctype delete
   */
  export type em_contrctypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
    /**
     * Filter which em_contrctype to delete.
     */
    where: em_contrctypeWhereUniqueInput
  }

  /**
   * em_contrctype deleteMany
   */
  export type em_contrctypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_contrctypes to delete
     */
    where?: em_contrctypeWhereInput
    /**
     * Limit how many em_contrctypes to delete.
     */
    limit?: number
  }

  /**
   * em_contrctype without action
   */
  export type em_contrctypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_contrctype
     */
    select?: em_contrctypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_contrctype
     */
    omit?: em_contrctypeOmit<ExtArgs> | null
  }


  /**
   * Model em_dept
   */

  export type AggregateEm_dept = {
    _count: Em_deptCountAggregateOutputType | null
    _avg: Em_deptAvgAggregateOutputType | null
    _sum: Em_deptSumAggregateOutputType | null
    _min: Em_deptMinAggregateOutputType | null
    _max: Em_deptMaxAggregateOutputType | null
  }

  export type Em_deptAvgAggregateOutputType = {
    DEPTID: number | null
    sbu_sub: number | null
  }

  export type Em_deptSumAggregateOutputType = {
    DEPTID: number | null
    sbu_sub: number | null
  }

  export type Em_deptMinAggregateOutputType = {
    DEPTID: number | null
    DEPTNAME: string | null
    sbu_sub: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_deptMaxAggregateOutputType = {
    DEPTID: number | null
    DEPTNAME: string | null
    sbu_sub: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_deptCountAggregateOutputType = {
    DEPTID: number
    DEPTNAME: number
    sbu_sub: number
    status: number
    add_by: number
    created_at: number
    lastupdate: number
    _all: number
  }


  export type Em_deptAvgAggregateInputType = {
    DEPTID?: true
    sbu_sub?: true
  }

  export type Em_deptSumAggregateInputType = {
    DEPTID?: true
    sbu_sub?: true
  }

  export type Em_deptMinAggregateInputType = {
    DEPTID?: true
    DEPTNAME?: true
    sbu_sub?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_deptMaxAggregateInputType = {
    DEPTID?: true
    DEPTNAME?: true
    sbu_sub?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_deptCountAggregateInputType = {
    DEPTID?: true
    DEPTNAME?: true
    sbu_sub?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_deptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_dept to aggregate.
     */
    where?: em_deptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_depts to fetch.
     */
    orderBy?: em_deptOrderByWithRelationInput | em_deptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_deptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_depts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_depts
    **/
    _count?: true | Em_deptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_deptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_deptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_deptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_deptMaxAggregateInputType
  }

  export type GetEm_deptAggregateType<T extends Em_deptAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_dept]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_dept[P]>
      : GetScalarType<T[P], AggregateEm_dept[P]>
  }




  export type em_deptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_deptWhereInput
    orderBy?: em_deptOrderByWithAggregationInput | em_deptOrderByWithAggregationInput[]
    by: Em_deptScalarFieldEnum[] | Em_deptScalarFieldEnum
    having?: em_deptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_deptCountAggregateInputType | true
    _avg?: Em_deptAvgAggregateInputType
    _sum?: Em_deptSumAggregateInputType
    _min?: Em_deptMinAggregateInputType
    _max?: Em_deptMaxAggregateInputType
  }

  export type Em_deptGroupByOutputType = {
    DEPTID: number
    DEPTNAME: string | null
    sbu_sub: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    _count: Em_deptCountAggregateOutputType | null
    _avg: Em_deptAvgAggregateOutputType | null
    _sum: Em_deptSumAggregateOutputType | null
    _min: Em_deptMinAggregateOutputType | null
    _max: Em_deptMaxAggregateOutputType | null
  }

  type GetEm_deptGroupByPayload<T extends em_deptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_deptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_deptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_deptGroupByOutputType[P]>
            : GetScalarType<T[P], Em_deptGroupByOutputType[P]>
        }
      >
    >


  export type em_deptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DEPTID?: boolean
    DEPTNAME?: boolean
    sbu_sub?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["em_dept"]>



  export type em_deptSelectScalar = {
    DEPTID?: boolean
    DEPTNAME?: boolean
    sbu_sub?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }

  export type em_deptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"DEPTID" | "DEPTNAME" | "sbu_sub" | "status" | "add_by" | "created_at" | "lastupdate", ExtArgs["result"]["em_dept"]>

  export type $em_deptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_dept"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      DEPTID: number
      DEPTNAME: string | null
      sbu_sub: number | null
      status: string | null
      add_by: string | null
      created_at: Date | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_dept"]>
    composites: {}
  }

  type em_deptGetPayload<S extends boolean | null | undefined | em_deptDefaultArgs> = $Result.GetResult<Prisma.$em_deptPayload, S>

  type em_deptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_deptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_deptCountAggregateInputType | true
    }

  export interface em_deptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_dept'], meta: { name: 'em_dept' } }
    /**
     * Find zero or one Em_dept that matches the filter.
     * @param {em_deptFindUniqueArgs} args - Arguments to find a Em_dept
     * @example
     * // Get one Em_dept
     * const em_dept = await prisma.em_dept.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_deptFindUniqueArgs>(args: SelectSubset<T, em_deptFindUniqueArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_dept that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_deptFindUniqueOrThrowArgs} args - Arguments to find a Em_dept
     * @example
     * // Get one Em_dept
     * const em_dept = await prisma.em_dept.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_deptFindUniqueOrThrowArgs>(args: SelectSubset<T, em_deptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_dept that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_deptFindFirstArgs} args - Arguments to find a Em_dept
     * @example
     * // Get one Em_dept
     * const em_dept = await prisma.em_dept.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_deptFindFirstArgs>(args?: SelectSubset<T, em_deptFindFirstArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_dept that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_deptFindFirstOrThrowArgs} args - Arguments to find a Em_dept
     * @example
     * // Get one Em_dept
     * const em_dept = await prisma.em_dept.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_deptFindFirstOrThrowArgs>(args?: SelectSubset<T, em_deptFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_depts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_deptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_depts
     * const em_depts = await prisma.em_dept.findMany()
     * 
     * // Get first 10 Em_depts
     * const em_depts = await prisma.em_dept.findMany({ take: 10 })
     * 
     * // Only select the `DEPTID`
     * const em_deptWithDEPTIDOnly = await prisma.em_dept.findMany({ select: { DEPTID: true } })
     * 
     */
    findMany<T extends em_deptFindManyArgs>(args?: SelectSubset<T, em_deptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_dept.
     * @param {em_deptCreateArgs} args - Arguments to create a Em_dept.
     * @example
     * // Create one Em_dept
     * const Em_dept = await prisma.em_dept.create({
     *   data: {
     *     // ... data to create a Em_dept
     *   }
     * })
     * 
     */
    create<T extends em_deptCreateArgs>(args: SelectSubset<T, em_deptCreateArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_depts.
     * @param {em_deptCreateManyArgs} args - Arguments to create many Em_depts.
     * @example
     * // Create many Em_depts
     * const em_dept = await prisma.em_dept.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_deptCreateManyArgs>(args?: SelectSubset<T, em_deptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_dept.
     * @param {em_deptDeleteArgs} args - Arguments to delete one Em_dept.
     * @example
     * // Delete one Em_dept
     * const Em_dept = await prisma.em_dept.delete({
     *   where: {
     *     // ... filter to delete one Em_dept
     *   }
     * })
     * 
     */
    delete<T extends em_deptDeleteArgs>(args: SelectSubset<T, em_deptDeleteArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_dept.
     * @param {em_deptUpdateArgs} args - Arguments to update one Em_dept.
     * @example
     * // Update one Em_dept
     * const em_dept = await prisma.em_dept.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_deptUpdateArgs>(args: SelectSubset<T, em_deptUpdateArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_depts.
     * @param {em_deptDeleteManyArgs} args - Arguments to filter Em_depts to delete.
     * @example
     * // Delete a few Em_depts
     * const { count } = await prisma.em_dept.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_deptDeleteManyArgs>(args?: SelectSubset<T, em_deptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_depts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_deptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_depts
     * const em_dept = await prisma.em_dept.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_deptUpdateManyArgs>(args: SelectSubset<T, em_deptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_dept.
     * @param {em_deptUpsertArgs} args - Arguments to update or create a Em_dept.
     * @example
     * // Update or create a Em_dept
     * const em_dept = await prisma.em_dept.upsert({
     *   create: {
     *     // ... data to create a Em_dept
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_dept we want to update
     *   }
     * })
     */
    upsert<T extends em_deptUpsertArgs>(args: SelectSubset<T, em_deptUpsertArgs<ExtArgs>>): Prisma__em_deptClient<$Result.GetResult<Prisma.$em_deptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_depts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_deptCountArgs} args - Arguments to filter Em_depts to count.
     * @example
     * // Count the number of Em_depts
     * const count = await prisma.em_dept.count({
     *   where: {
     *     // ... the filter for the Em_depts we want to count
     *   }
     * })
    **/
    count<T extends em_deptCountArgs>(
      args?: Subset<T, em_deptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_deptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_dept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_deptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_deptAggregateArgs>(args: Subset<T, Em_deptAggregateArgs>): Prisma.PrismaPromise<GetEm_deptAggregateType<T>>

    /**
     * Group by Em_dept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_deptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_deptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_deptGroupByArgs['orderBy'] }
        : { orderBy?: em_deptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_deptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_deptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_dept model
   */
  readonly fields: em_deptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_dept.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_deptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_dept model
   */
  interface em_deptFieldRefs {
    readonly DEPTID: FieldRef<"em_dept", 'Int'>
    readonly DEPTNAME: FieldRef<"em_dept", 'String'>
    readonly sbu_sub: FieldRef<"em_dept", 'Int'>
    readonly status: FieldRef<"em_dept", 'String'>
    readonly add_by: FieldRef<"em_dept", 'String'>
    readonly created_at: FieldRef<"em_dept", 'DateTime'>
    readonly lastupdate: FieldRef<"em_dept", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_dept findUnique
   */
  export type em_deptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * Filter, which em_dept to fetch.
     */
    where: em_deptWhereUniqueInput
  }

  /**
   * em_dept findUniqueOrThrow
   */
  export type em_deptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * Filter, which em_dept to fetch.
     */
    where: em_deptWhereUniqueInput
  }

  /**
   * em_dept findFirst
   */
  export type em_deptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * Filter, which em_dept to fetch.
     */
    where?: em_deptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_depts to fetch.
     */
    orderBy?: em_deptOrderByWithRelationInput | em_deptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_depts.
     */
    cursor?: em_deptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_depts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_depts.
     */
    distinct?: Em_deptScalarFieldEnum | Em_deptScalarFieldEnum[]
  }

  /**
   * em_dept findFirstOrThrow
   */
  export type em_deptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * Filter, which em_dept to fetch.
     */
    where?: em_deptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_depts to fetch.
     */
    orderBy?: em_deptOrderByWithRelationInput | em_deptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_depts.
     */
    cursor?: em_deptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_depts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_depts.
     */
    distinct?: Em_deptScalarFieldEnum | Em_deptScalarFieldEnum[]
  }

  /**
   * em_dept findMany
   */
  export type em_deptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * Filter, which em_depts to fetch.
     */
    where?: em_deptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_depts to fetch.
     */
    orderBy?: em_deptOrderByWithRelationInput | em_deptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_depts.
     */
    cursor?: em_deptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_depts.
     */
    skip?: number
    distinct?: Em_deptScalarFieldEnum | Em_deptScalarFieldEnum[]
  }

  /**
   * em_dept create
   */
  export type em_deptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * The data needed to create a em_dept.
     */
    data?: XOR<em_deptCreateInput, em_deptUncheckedCreateInput>
  }

  /**
   * em_dept createMany
   */
  export type em_deptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_depts.
     */
    data: em_deptCreateManyInput | em_deptCreateManyInput[]
  }

  /**
   * em_dept update
   */
  export type em_deptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * The data needed to update a em_dept.
     */
    data: XOR<em_deptUpdateInput, em_deptUncheckedUpdateInput>
    /**
     * Choose, which em_dept to update.
     */
    where: em_deptWhereUniqueInput
  }

  /**
   * em_dept updateMany
   */
  export type em_deptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_depts.
     */
    data: XOR<em_deptUpdateManyMutationInput, em_deptUncheckedUpdateManyInput>
    /**
     * Filter which em_depts to update
     */
    where?: em_deptWhereInput
    /**
     * Limit how many em_depts to update.
     */
    limit?: number
  }

  /**
   * em_dept upsert
   */
  export type em_deptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * The filter to search for the em_dept to update in case it exists.
     */
    where: em_deptWhereUniqueInput
    /**
     * In case the em_dept found by the `where` argument doesn't exist, create a new em_dept with this data.
     */
    create: XOR<em_deptCreateInput, em_deptUncheckedCreateInput>
    /**
     * In case the em_dept was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_deptUpdateInput, em_deptUncheckedUpdateInput>
  }

  /**
   * em_dept delete
   */
  export type em_deptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
    /**
     * Filter which em_dept to delete.
     */
    where: em_deptWhereUniqueInput
  }

  /**
   * em_dept deleteMany
   */
  export type em_deptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_depts to delete
     */
    where?: em_deptWhereInput
    /**
     * Limit how many em_depts to delete.
     */
    limit?: number
  }

  /**
   * em_dept without action
   */
  export type em_deptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_dept
     */
    select?: em_deptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_dept
     */
    omit?: em_deptOmit<ExtArgs> | null
  }


  /**
   * Model em_employee
   */

  export type AggregateEm_employee = {
    _count: Em_employeeCountAggregateOutputType | null
    _avg: Em_employeeAvgAggregateOutputType | null
    _sum: Em_employeeSumAggregateOutputType | null
    _min: Em_employeeMinAggregateOutputType | null
    _max: Em_employeeMaxAggregateOutputType | null
  }

  export type Em_employeeAvgAggregateOutputType = {
    UserId: number | null
    DeptId: number | null
    Shift: number | null
    isFirstLogin: number | null
    SbuSub: number | null
  }

  export type Em_employeeSumAggregateOutputType = {
    UserId: number | null
    DeptId: number | null
    Shift: number | null
    isFirstLogin: number | null
    SbuSub: number | null
  }

  export type Em_employeeMinAggregateOutputType = {
    UserId: number | null
    BadgeNum: string | null
    Name: string | null
    Gender: string | null
    BirthDay: Date | null
    HireDay: Date | null
    Street: string | null
    Religion: string | null
    Tipe: string | null
    isLokasi: string | null
    Phone: string | null
    DeptId: number | null
    Password: string | null
    CardNo: string | null
    Shift: number | null
    isMem: boolean | null
    AddBy: string | null
    Created_at: Date | null
    Lastupdate: Date | null
    isMemDate: Date | null
    isFirstLogin: number | null
    ImgName: string | null
    SbuSub: number | null
    Nik: string | null
    ResignDate: Date | null
    status: string | null
  }

  export type Em_employeeMaxAggregateOutputType = {
    UserId: number | null
    BadgeNum: string | null
    Name: string | null
    Gender: string | null
    BirthDay: Date | null
    HireDay: Date | null
    Street: string | null
    Religion: string | null
    Tipe: string | null
    isLokasi: string | null
    Phone: string | null
    DeptId: number | null
    Password: string | null
    CardNo: string | null
    Shift: number | null
    isMem: boolean | null
    AddBy: string | null
    Created_at: Date | null
    Lastupdate: Date | null
    isMemDate: Date | null
    isFirstLogin: number | null
    ImgName: string | null
    SbuSub: number | null
    Nik: string | null
    ResignDate: Date | null
    status: string | null
  }

  export type Em_employeeCountAggregateOutputType = {
    UserId: number
    BadgeNum: number
    Name: number
    Gender: number
    BirthDay: number
    HireDay: number
    Street: number
    Religion: number
    Tipe: number
    isLokasi: number
    Phone: number
    DeptId: number
    Password: number
    CardNo: number
    Shift: number
    isMem: number
    AddBy: number
    Created_at: number
    Lastupdate: number
    isMemDate: number
    isFirstLogin: number
    ImgName: number
    SbuSub: number
    Nik: number
    ResignDate: number
    status: number
    _all: number
  }


  export type Em_employeeAvgAggregateInputType = {
    UserId?: true
    DeptId?: true
    Shift?: true
    isFirstLogin?: true
    SbuSub?: true
  }

  export type Em_employeeSumAggregateInputType = {
    UserId?: true
    DeptId?: true
    Shift?: true
    isFirstLogin?: true
    SbuSub?: true
  }

  export type Em_employeeMinAggregateInputType = {
    UserId?: true
    BadgeNum?: true
    Name?: true
    Gender?: true
    BirthDay?: true
    HireDay?: true
    Street?: true
    Religion?: true
    Tipe?: true
    isLokasi?: true
    Phone?: true
    DeptId?: true
    Password?: true
    CardNo?: true
    Shift?: true
    isMem?: true
    AddBy?: true
    Created_at?: true
    Lastupdate?: true
    isMemDate?: true
    isFirstLogin?: true
    ImgName?: true
    SbuSub?: true
    Nik?: true
    ResignDate?: true
    status?: true
  }

  export type Em_employeeMaxAggregateInputType = {
    UserId?: true
    BadgeNum?: true
    Name?: true
    Gender?: true
    BirthDay?: true
    HireDay?: true
    Street?: true
    Religion?: true
    Tipe?: true
    isLokasi?: true
    Phone?: true
    DeptId?: true
    Password?: true
    CardNo?: true
    Shift?: true
    isMem?: true
    AddBy?: true
    Created_at?: true
    Lastupdate?: true
    isMemDate?: true
    isFirstLogin?: true
    ImgName?: true
    SbuSub?: true
    Nik?: true
    ResignDate?: true
    status?: true
  }

  export type Em_employeeCountAggregateInputType = {
    UserId?: true
    BadgeNum?: true
    Name?: true
    Gender?: true
    BirthDay?: true
    HireDay?: true
    Street?: true
    Religion?: true
    Tipe?: true
    isLokasi?: true
    Phone?: true
    DeptId?: true
    Password?: true
    CardNo?: true
    Shift?: true
    isMem?: true
    AddBy?: true
    Created_at?: true
    Lastupdate?: true
    isMemDate?: true
    isFirstLogin?: true
    ImgName?: true
    SbuSub?: true
    Nik?: true
    ResignDate?: true
    status?: true
    _all?: true
  }

  export type Em_employeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_employee to aggregate.
     */
    where?: em_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_employees to fetch.
     */
    orderBy?: em_employeeOrderByWithRelationInput | em_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_employees
    **/
    _count?: true | Em_employeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_employeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_employeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_employeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_employeeMaxAggregateInputType
  }

  export type GetEm_employeeAggregateType<T extends Em_employeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_employee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_employee[P]>
      : GetScalarType<T[P], AggregateEm_employee[P]>
  }




  export type em_employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_employeeWhereInput
    orderBy?: em_employeeOrderByWithAggregationInput | em_employeeOrderByWithAggregationInput[]
    by: Em_employeeScalarFieldEnum[] | Em_employeeScalarFieldEnum
    having?: em_employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_employeeCountAggregateInputType | true
    _avg?: Em_employeeAvgAggregateInputType
    _sum?: Em_employeeSumAggregateInputType
    _min?: Em_employeeMinAggregateInputType
    _max?: Em_employeeMaxAggregateInputType
  }

  export type Em_employeeGroupByOutputType = {
    UserId: number
    BadgeNum: string
    Name: string | null
    Gender: string | null
    BirthDay: Date | null
    HireDay: Date | null
    Street: string | null
    Religion: string | null
    Tipe: string | null
    isLokasi: string | null
    Phone: string | null
    DeptId: number | null
    Password: string | null
    CardNo: string | null
    Shift: number | null
    isMem: boolean | null
    AddBy: string | null
    Created_at: Date | null
    Lastupdate: Date | null
    isMemDate: Date | null
    isFirstLogin: number | null
    ImgName: string | null
    SbuSub: number | null
    Nik: string | null
    ResignDate: Date | null
    status: string | null
    _count: Em_employeeCountAggregateOutputType | null
    _avg: Em_employeeAvgAggregateOutputType | null
    _sum: Em_employeeSumAggregateOutputType | null
    _min: Em_employeeMinAggregateOutputType | null
    _max: Em_employeeMaxAggregateOutputType | null
  }

  type GetEm_employeeGroupByPayload<T extends em_employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_employeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_employeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_employeeGroupByOutputType[P]>
            : GetScalarType<T[P], Em_employeeGroupByOutputType[P]>
        }
      >
    >


  export type em_employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    BadgeNum?: boolean
    Name?: boolean
    Gender?: boolean
    BirthDay?: boolean
    HireDay?: boolean
    Street?: boolean
    Religion?: boolean
    Tipe?: boolean
    isLokasi?: boolean
    Phone?: boolean
    DeptId?: boolean
    Password?: boolean
    CardNo?: boolean
    Shift?: boolean
    isMem?: boolean
    AddBy?: boolean
    Created_at?: boolean
    Lastupdate?: boolean
    isMemDate?: boolean
    isFirstLogin?: boolean
    ImgName?: boolean
    SbuSub?: boolean
    Nik?: boolean
    ResignDate?: boolean
    status?: boolean
  }, ExtArgs["result"]["em_employee"]>



  export type em_employeeSelectScalar = {
    UserId?: boolean
    BadgeNum?: boolean
    Name?: boolean
    Gender?: boolean
    BirthDay?: boolean
    HireDay?: boolean
    Street?: boolean
    Religion?: boolean
    Tipe?: boolean
    isLokasi?: boolean
    Phone?: boolean
    DeptId?: boolean
    Password?: boolean
    CardNo?: boolean
    Shift?: boolean
    isMem?: boolean
    AddBy?: boolean
    Created_at?: boolean
    Lastupdate?: boolean
    isMemDate?: boolean
    isFirstLogin?: boolean
    ImgName?: boolean
    SbuSub?: boolean
    Nik?: boolean
    ResignDate?: boolean
    status?: boolean
  }

  export type em_employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserId" | "BadgeNum" | "Name" | "Gender" | "BirthDay" | "HireDay" | "Street" | "Religion" | "Tipe" | "isLokasi" | "Phone" | "DeptId" | "Password" | "CardNo" | "Shift" | "isMem" | "AddBy" | "Created_at" | "Lastupdate" | "isMemDate" | "isFirstLogin" | "ImgName" | "SbuSub" | "Nik" | "ResignDate" | "status", ExtArgs["result"]["em_employee"]>

  export type $em_employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_employee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      UserId: number
      BadgeNum: string
      Name: string | null
      Gender: string | null
      BirthDay: Date | null
      HireDay: Date | null
      Street: string | null
      Religion: string | null
      Tipe: string | null
      isLokasi: string | null
      Phone: string | null
      DeptId: number | null
      Password: string | null
      CardNo: string | null
      Shift: number | null
      isMem: boolean | null
      AddBy: string | null
      Created_at: Date | null
      Lastupdate: Date | null
      isMemDate: Date | null
      isFirstLogin: number | null
      ImgName: string | null
      SbuSub: number | null
      Nik: string | null
      ResignDate: Date | null
      status: string | null
    }, ExtArgs["result"]["em_employee"]>
    composites: {}
  }

  type em_employeeGetPayload<S extends boolean | null | undefined | em_employeeDefaultArgs> = $Result.GetResult<Prisma.$em_employeePayload, S>

  type em_employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_employeeCountAggregateInputType | true
    }

  export interface em_employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_employee'], meta: { name: 'em_employee' } }
    /**
     * Find zero or one Em_employee that matches the filter.
     * @param {em_employeeFindUniqueArgs} args - Arguments to find a Em_employee
     * @example
     * // Get one Em_employee
     * const em_employee = await prisma.em_employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_employeeFindUniqueArgs>(args: SelectSubset<T, em_employeeFindUniqueArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_employeeFindUniqueOrThrowArgs} args - Arguments to find a Em_employee
     * @example
     * // Get one Em_employee
     * const em_employee = await prisma.em_employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, em_employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_employeeFindFirstArgs} args - Arguments to find a Em_employee
     * @example
     * // Get one Em_employee
     * const em_employee = await prisma.em_employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_employeeFindFirstArgs>(args?: SelectSubset<T, em_employeeFindFirstArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_employeeFindFirstOrThrowArgs} args - Arguments to find a Em_employee
     * @example
     * // Get one Em_employee
     * const em_employee = await prisma.em_employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, em_employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_employees
     * const em_employees = await prisma.em_employee.findMany()
     * 
     * // Get first 10 Em_employees
     * const em_employees = await prisma.em_employee.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const em_employeeWithUserIdOnly = await prisma.em_employee.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends em_employeeFindManyArgs>(args?: SelectSubset<T, em_employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_employee.
     * @param {em_employeeCreateArgs} args - Arguments to create a Em_employee.
     * @example
     * // Create one Em_employee
     * const Em_employee = await prisma.em_employee.create({
     *   data: {
     *     // ... data to create a Em_employee
     *   }
     * })
     * 
     */
    create<T extends em_employeeCreateArgs>(args: SelectSubset<T, em_employeeCreateArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_employees.
     * @param {em_employeeCreateManyArgs} args - Arguments to create many Em_employees.
     * @example
     * // Create many Em_employees
     * const em_employee = await prisma.em_employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_employeeCreateManyArgs>(args?: SelectSubset<T, em_employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_employee.
     * @param {em_employeeDeleteArgs} args - Arguments to delete one Em_employee.
     * @example
     * // Delete one Em_employee
     * const Em_employee = await prisma.em_employee.delete({
     *   where: {
     *     // ... filter to delete one Em_employee
     *   }
     * })
     * 
     */
    delete<T extends em_employeeDeleteArgs>(args: SelectSubset<T, em_employeeDeleteArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_employee.
     * @param {em_employeeUpdateArgs} args - Arguments to update one Em_employee.
     * @example
     * // Update one Em_employee
     * const em_employee = await prisma.em_employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_employeeUpdateArgs>(args: SelectSubset<T, em_employeeUpdateArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_employees.
     * @param {em_employeeDeleteManyArgs} args - Arguments to filter Em_employees to delete.
     * @example
     * // Delete a few Em_employees
     * const { count } = await prisma.em_employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_employeeDeleteManyArgs>(args?: SelectSubset<T, em_employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_employees
     * const em_employee = await prisma.em_employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_employeeUpdateManyArgs>(args: SelectSubset<T, em_employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_employee.
     * @param {em_employeeUpsertArgs} args - Arguments to update or create a Em_employee.
     * @example
     * // Update or create a Em_employee
     * const em_employee = await prisma.em_employee.upsert({
     *   create: {
     *     // ... data to create a Em_employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_employee we want to update
     *   }
     * })
     */
    upsert<T extends em_employeeUpsertArgs>(args: SelectSubset<T, em_employeeUpsertArgs<ExtArgs>>): Prisma__em_employeeClient<$Result.GetResult<Prisma.$em_employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_employeeCountArgs} args - Arguments to filter Em_employees to count.
     * @example
     * // Count the number of Em_employees
     * const count = await prisma.em_employee.count({
     *   where: {
     *     // ... the filter for the Em_employees we want to count
     *   }
     * })
    **/
    count<T extends em_employeeCountArgs>(
      args?: Subset<T, em_employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_employeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_employeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_employeeAggregateArgs>(args: Subset<T, Em_employeeAggregateArgs>): Prisma.PrismaPromise<GetEm_employeeAggregateType<T>>

    /**
     * Group by Em_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_employeeGroupByArgs['orderBy'] }
        : { orderBy?: em_employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_employeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_employee model
   */
  readonly fields: em_employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_employee model
   */
  interface em_employeeFieldRefs {
    readonly UserId: FieldRef<"em_employee", 'Int'>
    readonly BadgeNum: FieldRef<"em_employee", 'String'>
    readonly Name: FieldRef<"em_employee", 'String'>
    readonly Gender: FieldRef<"em_employee", 'String'>
    readonly BirthDay: FieldRef<"em_employee", 'DateTime'>
    readonly HireDay: FieldRef<"em_employee", 'DateTime'>
    readonly Street: FieldRef<"em_employee", 'String'>
    readonly Religion: FieldRef<"em_employee", 'String'>
    readonly Tipe: FieldRef<"em_employee", 'String'>
    readonly isLokasi: FieldRef<"em_employee", 'String'>
    readonly Phone: FieldRef<"em_employee", 'String'>
    readonly DeptId: FieldRef<"em_employee", 'Int'>
    readonly Password: FieldRef<"em_employee", 'String'>
    readonly CardNo: FieldRef<"em_employee", 'String'>
    readonly Shift: FieldRef<"em_employee", 'Int'>
    readonly isMem: FieldRef<"em_employee", 'Boolean'>
    readonly AddBy: FieldRef<"em_employee", 'String'>
    readonly Created_at: FieldRef<"em_employee", 'DateTime'>
    readonly Lastupdate: FieldRef<"em_employee", 'DateTime'>
    readonly isMemDate: FieldRef<"em_employee", 'DateTime'>
    readonly isFirstLogin: FieldRef<"em_employee", 'Int'>
    readonly ImgName: FieldRef<"em_employee", 'String'>
    readonly SbuSub: FieldRef<"em_employee", 'Int'>
    readonly Nik: FieldRef<"em_employee", 'String'>
    readonly ResignDate: FieldRef<"em_employee", 'DateTime'>
    readonly status: FieldRef<"em_employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_employee findUnique
   */
  export type em_employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * Filter, which em_employee to fetch.
     */
    where: em_employeeWhereUniqueInput
  }

  /**
   * em_employee findUniqueOrThrow
   */
  export type em_employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * Filter, which em_employee to fetch.
     */
    where: em_employeeWhereUniqueInput
  }

  /**
   * em_employee findFirst
   */
  export type em_employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * Filter, which em_employee to fetch.
     */
    where?: em_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_employees to fetch.
     */
    orderBy?: em_employeeOrderByWithRelationInput | em_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_employees.
     */
    cursor?: em_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_employees.
     */
    distinct?: Em_employeeScalarFieldEnum | Em_employeeScalarFieldEnum[]
  }

  /**
   * em_employee findFirstOrThrow
   */
  export type em_employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * Filter, which em_employee to fetch.
     */
    where?: em_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_employees to fetch.
     */
    orderBy?: em_employeeOrderByWithRelationInput | em_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_employees.
     */
    cursor?: em_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_employees.
     */
    distinct?: Em_employeeScalarFieldEnum | Em_employeeScalarFieldEnum[]
  }

  /**
   * em_employee findMany
   */
  export type em_employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * Filter, which em_employees to fetch.
     */
    where?: em_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_employees to fetch.
     */
    orderBy?: em_employeeOrderByWithRelationInput | em_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_employees.
     */
    cursor?: em_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_employees.
     */
    skip?: number
    distinct?: Em_employeeScalarFieldEnum | Em_employeeScalarFieldEnum[]
  }

  /**
   * em_employee create
   */
  export type em_employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * The data needed to create a em_employee.
     */
    data: XOR<em_employeeCreateInput, em_employeeUncheckedCreateInput>
  }

  /**
   * em_employee createMany
   */
  export type em_employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_employees.
     */
    data: em_employeeCreateManyInput | em_employeeCreateManyInput[]
  }

  /**
   * em_employee update
   */
  export type em_employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * The data needed to update a em_employee.
     */
    data: XOR<em_employeeUpdateInput, em_employeeUncheckedUpdateInput>
    /**
     * Choose, which em_employee to update.
     */
    where: em_employeeWhereUniqueInput
  }

  /**
   * em_employee updateMany
   */
  export type em_employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_employees.
     */
    data: XOR<em_employeeUpdateManyMutationInput, em_employeeUncheckedUpdateManyInput>
    /**
     * Filter which em_employees to update
     */
    where?: em_employeeWhereInput
    /**
     * Limit how many em_employees to update.
     */
    limit?: number
  }

  /**
   * em_employee upsert
   */
  export type em_employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * The filter to search for the em_employee to update in case it exists.
     */
    where: em_employeeWhereUniqueInput
    /**
     * In case the em_employee found by the `where` argument doesn't exist, create a new em_employee with this data.
     */
    create: XOR<em_employeeCreateInput, em_employeeUncheckedCreateInput>
    /**
     * In case the em_employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_employeeUpdateInput, em_employeeUncheckedUpdateInput>
  }

  /**
   * em_employee delete
   */
  export type em_employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
    /**
     * Filter which em_employee to delete.
     */
    where: em_employeeWhereUniqueInput
  }

  /**
   * em_employee deleteMany
   */
  export type em_employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_employees to delete
     */
    where?: em_employeeWhereInput
    /**
     * Limit how many em_employees to delete.
     */
    limit?: number
  }

  /**
   * em_employee without action
   */
  export type em_employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_employee
     */
    select?: em_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_employee
     */
    omit?: em_employeeOmit<ExtArgs> | null
  }


  /**
   * Model em_event
   */

  export type AggregateEm_event = {
    _count: Em_eventCountAggregateOutputType | null
    _avg: Em_eventAvgAggregateOutputType | null
    _sum: Em_eventSumAggregateOutputType | null
    _min: Em_eventMinAggregateOutputType | null
    _max: Em_eventMaxAggregateOutputType | null
  }

  export type Em_eventAvgAggregateOutputType = {
    event_id: number | null
  }

  export type Em_eventSumAggregateOutputType = {
    event_id: number | null
  }

  export type Em_eventMinAggregateOutputType = {
    event_id: number | null
    event_name: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    lokasi: string | null
    created_date: Date | null
    last_update: Date | null
  }

  export type Em_eventMaxAggregateOutputType = {
    event_id: number | null
    event_name: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    lokasi: string | null
    created_date: Date | null
    last_update: Date | null
  }

  export type Em_eventCountAggregateOutputType = {
    event_id: number
    event_name: number
    start_date: number
    end_date: number
    status: number
    lokasi: number
    created_date: number
    last_update: number
    _all: number
  }


  export type Em_eventAvgAggregateInputType = {
    event_id?: true
  }

  export type Em_eventSumAggregateInputType = {
    event_id?: true
  }

  export type Em_eventMinAggregateInputType = {
    event_id?: true
    event_name?: true
    start_date?: true
    end_date?: true
    status?: true
    lokasi?: true
    created_date?: true
    last_update?: true
  }

  export type Em_eventMaxAggregateInputType = {
    event_id?: true
    event_name?: true
    start_date?: true
    end_date?: true
    status?: true
    lokasi?: true
    created_date?: true
    last_update?: true
  }

  export type Em_eventCountAggregateInputType = {
    event_id?: true
    event_name?: true
    start_date?: true
    end_date?: true
    status?: true
    lokasi?: true
    created_date?: true
    last_update?: true
    _all?: true
  }

  export type Em_eventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_event to aggregate.
     */
    where?: em_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_events to fetch.
     */
    orderBy?: em_eventOrderByWithRelationInput | em_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_events
    **/
    _count?: true | Em_eventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_eventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_eventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_eventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_eventMaxAggregateInputType
  }

  export type GetEm_eventAggregateType<T extends Em_eventAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_event]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_event[P]>
      : GetScalarType<T[P], AggregateEm_event[P]>
  }




  export type em_eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_eventWhereInput
    orderBy?: em_eventOrderByWithAggregationInput | em_eventOrderByWithAggregationInput[]
    by: Em_eventScalarFieldEnum[] | Em_eventScalarFieldEnum
    having?: em_eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_eventCountAggregateInputType | true
    _avg?: Em_eventAvgAggregateInputType
    _sum?: Em_eventSumAggregateInputType
    _min?: Em_eventMinAggregateInputType
    _max?: Em_eventMaxAggregateInputType
  }

  export type Em_eventGroupByOutputType = {
    event_id: number
    event_name: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    lokasi: string | null
    created_date: Date | null
    last_update: Date | null
    _count: Em_eventCountAggregateOutputType | null
    _avg: Em_eventAvgAggregateOutputType | null
    _sum: Em_eventSumAggregateOutputType | null
    _min: Em_eventMinAggregateOutputType | null
    _max: Em_eventMaxAggregateOutputType | null
  }

  type GetEm_eventGroupByPayload<T extends em_eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_eventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_eventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_eventGroupByOutputType[P]>
            : GetScalarType<T[P], Em_eventGroupByOutputType[P]>
        }
      >
    >


  export type em_eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    event_name?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    lokasi?: boolean
    created_date?: boolean
    last_update?: boolean
    em_event2?: boolean | em_event$em_event2Args<ExtArgs>
    _count?: boolean | Em_eventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_event"]>



  export type em_eventSelectScalar = {
    event_id?: boolean
    event_name?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    lokasi?: boolean
    created_date?: boolean
    last_update?: boolean
  }

  export type em_eventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"event_id" | "event_name" | "start_date" | "end_date" | "status" | "lokasi" | "created_date" | "last_update", ExtArgs["result"]["em_event"]>
  export type em_eventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_event2?: boolean | em_event$em_event2Args<ExtArgs>
    _count?: boolean | Em_eventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_event"
    objects: {
      em_event2: Prisma.$em_event2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: number
      event_name: string | null
      start_date: Date | null
      end_date: Date | null
      status: string | null
      lokasi: string | null
      created_date: Date | null
      last_update: Date | null
    }, ExtArgs["result"]["em_event"]>
    composites: {}
  }

  type em_eventGetPayload<S extends boolean | null | undefined | em_eventDefaultArgs> = $Result.GetResult<Prisma.$em_eventPayload, S>

  type em_eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_eventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_eventCountAggregateInputType | true
    }

  export interface em_eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_event'], meta: { name: 'em_event' } }
    /**
     * Find zero or one Em_event that matches the filter.
     * @param {em_eventFindUniqueArgs} args - Arguments to find a Em_event
     * @example
     * // Get one Em_event
     * const em_event = await prisma.em_event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_eventFindUniqueArgs>(args: SelectSubset<T, em_eventFindUniqueArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_eventFindUniqueOrThrowArgs} args - Arguments to find a Em_event
     * @example
     * // Get one Em_event
     * const em_event = await prisma.em_event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_eventFindUniqueOrThrowArgs>(args: SelectSubset<T, em_eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_eventFindFirstArgs} args - Arguments to find a Em_event
     * @example
     * // Get one Em_event
     * const em_event = await prisma.em_event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_eventFindFirstArgs>(args?: SelectSubset<T, em_eventFindFirstArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_eventFindFirstOrThrowArgs} args - Arguments to find a Em_event
     * @example
     * // Get one Em_event
     * const em_event = await prisma.em_event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_eventFindFirstOrThrowArgs>(args?: SelectSubset<T, em_eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_events
     * const em_events = await prisma.em_event.findMany()
     * 
     * // Get first 10 Em_events
     * const em_events = await prisma.em_event.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const em_eventWithEvent_idOnly = await prisma.em_event.findMany({ select: { event_id: true } })
     * 
     */
    findMany<T extends em_eventFindManyArgs>(args?: SelectSubset<T, em_eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_event.
     * @param {em_eventCreateArgs} args - Arguments to create a Em_event.
     * @example
     * // Create one Em_event
     * const Em_event = await prisma.em_event.create({
     *   data: {
     *     // ... data to create a Em_event
     *   }
     * })
     * 
     */
    create<T extends em_eventCreateArgs>(args: SelectSubset<T, em_eventCreateArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_events.
     * @param {em_eventCreateManyArgs} args - Arguments to create many Em_events.
     * @example
     * // Create many Em_events
     * const em_event = await prisma.em_event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_eventCreateManyArgs>(args?: SelectSubset<T, em_eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_event.
     * @param {em_eventDeleteArgs} args - Arguments to delete one Em_event.
     * @example
     * // Delete one Em_event
     * const Em_event = await prisma.em_event.delete({
     *   where: {
     *     // ... filter to delete one Em_event
     *   }
     * })
     * 
     */
    delete<T extends em_eventDeleteArgs>(args: SelectSubset<T, em_eventDeleteArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_event.
     * @param {em_eventUpdateArgs} args - Arguments to update one Em_event.
     * @example
     * // Update one Em_event
     * const em_event = await prisma.em_event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_eventUpdateArgs>(args: SelectSubset<T, em_eventUpdateArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_events.
     * @param {em_eventDeleteManyArgs} args - Arguments to filter Em_events to delete.
     * @example
     * // Delete a few Em_events
     * const { count } = await prisma.em_event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_eventDeleteManyArgs>(args?: SelectSubset<T, em_eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_events
     * const em_event = await prisma.em_event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_eventUpdateManyArgs>(args: SelectSubset<T, em_eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_event.
     * @param {em_eventUpsertArgs} args - Arguments to update or create a Em_event.
     * @example
     * // Update or create a Em_event
     * const em_event = await prisma.em_event.upsert({
     *   create: {
     *     // ... data to create a Em_event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_event we want to update
     *   }
     * })
     */
    upsert<T extends em_eventUpsertArgs>(args: SelectSubset<T, em_eventUpsertArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_eventCountArgs} args - Arguments to filter Em_events to count.
     * @example
     * // Count the number of Em_events
     * const count = await prisma.em_event.count({
     *   where: {
     *     // ... the filter for the Em_events we want to count
     *   }
     * })
    **/
    count<T extends em_eventCountArgs>(
      args?: Subset<T, em_eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_eventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_eventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_eventAggregateArgs>(args: Subset<T, Em_eventAggregateArgs>): Prisma.PrismaPromise<GetEm_eventAggregateType<T>>

    /**
     * Group by Em_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_eventGroupByArgs['orderBy'] }
        : { orderBy?: em_eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_eventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_event model
   */
  readonly fields: em_eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_event2<T extends em_event$em_event2Args<ExtArgs> = {}>(args?: Subset<T, em_event$em_event2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_event model
   */
  interface em_eventFieldRefs {
    readonly event_id: FieldRef<"em_event", 'Int'>
    readonly event_name: FieldRef<"em_event", 'String'>
    readonly start_date: FieldRef<"em_event", 'DateTime'>
    readonly end_date: FieldRef<"em_event", 'DateTime'>
    readonly status: FieldRef<"em_event", 'String'>
    readonly lokasi: FieldRef<"em_event", 'String'>
    readonly created_date: FieldRef<"em_event", 'DateTime'>
    readonly last_update: FieldRef<"em_event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_event findUnique
   */
  export type em_eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * Filter, which em_event to fetch.
     */
    where: em_eventWhereUniqueInput
  }

  /**
   * em_event findUniqueOrThrow
   */
  export type em_eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * Filter, which em_event to fetch.
     */
    where: em_eventWhereUniqueInput
  }

  /**
   * em_event findFirst
   */
  export type em_eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * Filter, which em_event to fetch.
     */
    where?: em_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_events to fetch.
     */
    orderBy?: em_eventOrderByWithRelationInput | em_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_events.
     */
    cursor?: em_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_events.
     */
    distinct?: Em_eventScalarFieldEnum | Em_eventScalarFieldEnum[]
  }

  /**
   * em_event findFirstOrThrow
   */
  export type em_eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * Filter, which em_event to fetch.
     */
    where?: em_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_events to fetch.
     */
    orderBy?: em_eventOrderByWithRelationInput | em_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_events.
     */
    cursor?: em_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_events.
     */
    distinct?: Em_eventScalarFieldEnum | Em_eventScalarFieldEnum[]
  }

  /**
   * em_event findMany
   */
  export type em_eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * Filter, which em_events to fetch.
     */
    where?: em_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_events to fetch.
     */
    orderBy?: em_eventOrderByWithRelationInput | em_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_events.
     */
    cursor?: em_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_events.
     */
    skip?: number
    distinct?: Em_eventScalarFieldEnum | Em_eventScalarFieldEnum[]
  }

  /**
   * em_event create
   */
  export type em_eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * The data needed to create a em_event.
     */
    data?: XOR<em_eventCreateInput, em_eventUncheckedCreateInput>
  }

  /**
   * em_event createMany
   */
  export type em_eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_events.
     */
    data: em_eventCreateManyInput | em_eventCreateManyInput[]
  }

  /**
   * em_event update
   */
  export type em_eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * The data needed to update a em_event.
     */
    data: XOR<em_eventUpdateInput, em_eventUncheckedUpdateInput>
    /**
     * Choose, which em_event to update.
     */
    where: em_eventWhereUniqueInput
  }

  /**
   * em_event updateMany
   */
  export type em_eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_events.
     */
    data: XOR<em_eventUpdateManyMutationInput, em_eventUncheckedUpdateManyInput>
    /**
     * Filter which em_events to update
     */
    where?: em_eventWhereInput
    /**
     * Limit how many em_events to update.
     */
    limit?: number
  }

  /**
   * em_event upsert
   */
  export type em_eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * The filter to search for the em_event to update in case it exists.
     */
    where: em_eventWhereUniqueInput
    /**
     * In case the em_event found by the `where` argument doesn't exist, create a new em_event with this data.
     */
    create: XOR<em_eventCreateInput, em_eventUncheckedCreateInput>
    /**
     * In case the em_event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_eventUpdateInput, em_eventUncheckedUpdateInput>
  }

  /**
   * em_event delete
   */
  export type em_eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    /**
     * Filter which em_event to delete.
     */
    where: em_eventWhereUniqueInput
  }

  /**
   * em_event deleteMany
   */
  export type em_eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_events to delete
     */
    where?: em_eventWhereInput
    /**
     * Limit how many em_events to delete.
     */
    limit?: number
  }

  /**
   * em_event.em_event2
   */
  export type em_event$em_event2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    where?: em_event2WhereInput
    orderBy?: em_event2OrderByWithRelationInput | em_event2OrderByWithRelationInput[]
    cursor?: em_event2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_event2ScalarFieldEnum | Em_event2ScalarFieldEnum[]
  }

  /**
   * em_event without action
   */
  export type em_eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
  }


  /**
   * Model em_event_reg
   */

  export type AggregateEm_event_reg = {
    _count: Em_event_regCountAggregateOutputType | null
    _avg: Em_event_regAvgAggregateOutputType | null
    _sum: Em_event_regSumAggregateOutputType | null
    _min: Em_event_regMinAggregateOutputType | null
    _max: Em_event_regMaxAggregateOutputType | null
  }

  export type Em_event_regAvgAggregateOutputType = {
    Regid: number | null
    profesi_id: number | null
    event_id: number | null
  }

  export type Em_event_regSumAggregateOutputType = {
    Regid: number | null
    profesi_id: number | null
    event_id: number | null
  }

  export type Em_event_regMinAggregateOutputType = {
    Regid: number | null
    name: string | null
    optic_name: string | null
    password: string | null
    wa_num: string | null
    email: string | null
    profesi_id: number | null
    event_id: number | null
    status: string | null
    first_login: boolean | null
    created_date: Date | null
    last_update: Date | null
    image_name: string | null
  }

  export type Em_event_regMaxAggregateOutputType = {
    Regid: number | null
    name: string | null
    optic_name: string | null
    password: string | null
    wa_num: string | null
    email: string | null
    profesi_id: number | null
    event_id: number | null
    status: string | null
    first_login: boolean | null
    created_date: Date | null
    last_update: Date | null
    image_name: string | null
  }

  export type Em_event_regCountAggregateOutputType = {
    Regid: number
    name: number
    optic_name: number
    password: number
    wa_num: number
    email: number
    profesi_id: number
    event_id: number
    status: number
    first_login: number
    created_date: number
    last_update: number
    image_name: number
    _all: number
  }


  export type Em_event_regAvgAggregateInputType = {
    Regid?: true
    profesi_id?: true
    event_id?: true
  }

  export type Em_event_regSumAggregateInputType = {
    Regid?: true
    profesi_id?: true
    event_id?: true
  }

  export type Em_event_regMinAggregateInputType = {
    Regid?: true
    name?: true
    optic_name?: true
    password?: true
    wa_num?: true
    email?: true
    profesi_id?: true
    event_id?: true
    status?: true
    first_login?: true
    created_date?: true
    last_update?: true
    image_name?: true
  }

  export type Em_event_regMaxAggregateInputType = {
    Regid?: true
    name?: true
    optic_name?: true
    password?: true
    wa_num?: true
    email?: true
    profesi_id?: true
    event_id?: true
    status?: true
    first_login?: true
    created_date?: true
    last_update?: true
    image_name?: true
  }

  export type Em_event_regCountAggregateInputType = {
    Regid?: true
    name?: true
    optic_name?: true
    password?: true
    wa_num?: true
    email?: true
    profesi_id?: true
    event_id?: true
    status?: true
    first_login?: true
    created_date?: true
    last_update?: true
    image_name?: true
    _all?: true
  }

  export type Em_event_regAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_event_reg to aggregate.
     */
    where?: em_event_regWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event_regs to fetch.
     */
    orderBy?: em_event_regOrderByWithRelationInput | em_event_regOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_event_regWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event_regs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event_regs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_event_regs
    **/
    _count?: true | Em_event_regCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_event_regAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_event_regSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_event_regMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_event_regMaxAggregateInputType
  }

  export type GetEm_event_regAggregateType<T extends Em_event_regAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_event_reg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_event_reg[P]>
      : GetScalarType<T[P], AggregateEm_event_reg[P]>
  }




  export type em_event_regGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_event_regWhereInput
    orderBy?: em_event_regOrderByWithAggregationInput | em_event_regOrderByWithAggregationInput[]
    by: Em_event_regScalarFieldEnum[] | Em_event_regScalarFieldEnum
    having?: em_event_regScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_event_regCountAggregateInputType | true
    _avg?: Em_event_regAvgAggregateInputType
    _sum?: Em_event_regSumAggregateInputType
    _min?: Em_event_regMinAggregateInputType
    _max?: Em_event_regMaxAggregateInputType
  }

  export type Em_event_regGroupByOutputType = {
    Regid: number
    name: string | null
    optic_name: string | null
    password: string | null
    wa_num: string | null
    email: string | null
    profesi_id: number | null
    event_id: number | null
    status: string | null
    first_login: boolean | null
    created_date: Date | null
    last_update: Date | null
    image_name: string | null
    _count: Em_event_regCountAggregateOutputType | null
    _avg: Em_event_regAvgAggregateOutputType | null
    _sum: Em_event_regSumAggregateOutputType | null
    _min: Em_event_regMinAggregateOutputType | null
    _max: Em_event_regMaxAggregateOutputType | null
  }

  type GetEm_event_regGroupByPayload<T extends em_event_regGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_event_regGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_event_regGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_event_regGroupByOutputType[P]>
            : GetScalarType<T[P], Em_event_regGroupByOutputType[P]>
        }
      >
    >


  export type em_event_regSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Regid?: boolean
    name?: boolean
    optic_name?: boolean
    password?: boolean
    wa_num?: boolean
    email?: boolean
    profesi_id?: boolean
    event_id?: boolean
    status?: boolean
    first_login?: boolean
    created_date?: boolean
    last_update?: boolean
    image_name?: boolean
  }, ExtArgs["result"]["em_event_reg"]>



  export type em_event_regSelectScalar = {
    Regid?: boolean
    name?: boolean
    optic_name?: boolean
    password?: boolean
    wa_num?: boolean
    email?: boolean
    profesi_id?: boolean
    event_id?: boolean
    status?: boolean
    first_login?: boolean
    created_date?: boolean
    last_update?: boolean
    image_name?: boolean
  }

  export type em_event_regOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Regid" | "name" | "optic_name" | "password" | "wa_num" | "email" | "profesi_id" | "event_id" | "status" | "first_login" | "created_date" | "last_update" | "image_name", ExtArgs["result"]["em_event_reg"]>

  export type $em_event_regPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_event_reg"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Regid: number
      name: string | null
      optic_name: string | null
      password: string | null
      wa_num: string | null
      email: string | null
      profesi_id: number | null
      event_id: number | null
      status: string | null
      first_login: boolean | null
      created_date: Date | null
      last_update: Date | null
      image_name: string | null
    }, ExtArgs["result"]["em_event_reg"]>
    composites: {}
  }

  type em_event_regGetPayload<S extends boolean | null | undefined | em_event_regDefaultArgs> = $Result.GetResult<Prisma.$em_event_regPayload, S>

  type em_event_regCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_event_regFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_event_regCountAggregateInputType | true
    }

  export interface em_event_regDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_event_reg'], meta: { name: 'em_event_reg' } }
    /**
     * Find zero or one Em_event_reg that matches the filter.
     * @param {em_event_regFindUniqueArgs} args - Arguments to find a Em_event_reg
     * @example
     * // Get one Em_event_reg
     * const em_event_reg = await prisma.em_event_reg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_event_regFindUniqueArgs>(args: SelectSubset<T, em_event_regFindUniqueArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_event_reg that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_event_regFindUniqueOrThrowArgs} args - Arguments to find a Em_event_reg
     * @example
     * // Get one Em_event_reg
     * const em_event_reg = await prisma.em_event_reg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_event_regFindUniqueOrThrowArgs>(args: SelectSubset<T, em_event_regFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_event_reg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event_regFindFirstArgs} args - Arguments to find a Em_event_reg
     * @example
     * // Get one Em_event_reg
     * const em_event_reg = await prisma.em_event_reg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_event_regFindFirstArgs>(args?: SelectSubset<T, em_event_regFindFirstArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_event_reg that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event_regFindFirstOrThrowArgs} args - Arguments to find a Em_event_reg
     * @example
     * // Get one Em_event_reg
     * const em_event_reg = await prisma.em_event_reg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_event_regFindFirstOrThrowArgs>(args?: SelectSubset<T, em_event_regFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_event_regs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event_regFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_event_regs
     * const em_event_regs = await prisma.em_event_reg.findMany()
     * 
     * // Get first 10 Em_event_regs
     * const em_event_regs = await prisma.em_event_reg.findMany({ take: 10 })
     * 
     * // Only select the `Regid`
     * const em_event_regWithRegidOnly = await prisma.em_event_reg.findMany({ select: { Regid: true } })
     * 
     */
    findMany<T extends em_event_regFindManyArgs>(args?: SelectSubset<T, em_event_regFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_event_reg.
     * @param {em_event_regCreateArgs} args - Arguments to create a Em_event_reg.
     * @example
     * // Create one Em_event_reg
     * const Em_event_reg = await prisma.em_event_reg.create({
     *   data: {
     *     // ... data to create a Em_event_reg
     *   }
     * })
     * 
     */
    create<T extends em_event_regCreateArgs>(args: SelectSubset<T, em_event_regCreateArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_event_regs.
     * @param {em_event_regCreateManyArgs} args - Arguments to create many Em_event_regs.
     * @example
     * // Create many Em_event_regs
     * const em_event_reg = await prisma.em_event_reg.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_event_regCreateManyArgs>(args?: SelectSubset<T, em_event_regCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_event_reg.
     * @param {em_event_regDeleteArgs} args - Arguments to delete one Em_event_reg.
     * @example
     * // Delete one Em_event_reg
     * const Em_event_reg = await prisma.em_event_reg.delete({
     *   where: {
     *     // ... filter to delete one Em_event_reg
     *   }
     * })
     * 
     */
    delete<T extends em_event_regDeleteArgs>(args: SelectSubset<T, em_event_regDeleteArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_event_reg.
     * @param {em_event_regUpdateArgs} args - Arguments to update one Em_event_reg.
     * @example
     * // Update one Em_event_reg
     * const em_event_reg = await prisma.em_event_reg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_event_regUpdateArgs>(args: SelectSubset<T, em_event_regUpdateArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_event_regs.
     * @param {em_event_regDeleteManyArgs} args - Arguments to filter Em_event_regs to delete.
     * @example
     * // Delete a few Em_event_regs
     * const { count } = await prisma.em_event_reg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_event_regDeleteManyArgs>(args?: SelectSubset<T, em_event_regDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_event_regs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event_regUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_event_regs
     * const em_event_reg = await prisma.em_event_reg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_event_regUpdateManyArgs>(args: SelectSubset<T, em_event_regUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_event_reg.
     * @param {em_event_regUpsertArgs} args - Arguments to update or create a Em_event_reg.
     * @example
     * // Update or create a Em_event_reg
     * const em_event_reg = await prisma.em_event_reg.upsert({
     *   create: {
     *     // ... data to create a Em_event_reg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_event_reg we want to update
     *   }
     * })
     */
    upsert<T extends em_event_regUpsertArgs>(args: SelectSubset<T, em_event_regUpsertArgs<ExtArgs>>): Prisma__em_event_regClient<$Result.GetResult<Prisma.$em_event_regPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_event_regs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event_regCountArgs} args - Arguments to filter Em_event_regs to count.
     * @example
     * // Count the number of Em_event_regs
     * const count = await prisma.em_event_reg.count({
     *   where: {
     *     // ... the filter for the Em_event_regs we want to count
     *   }
     * })
    **/
    count<T extends em_event_regCountArgs>(
      args?: Subset<T, em_event_regCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_event_regCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_event_reg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_event_regAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_event_regAggregateArgs>(args: Subset<T, Em_event_regAggregateArgs>): Prisma.PrismaPromise<GetEm_event_regAggregateType<T>>

    /**
     * Group by Em_event_reg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event_regGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_event_regGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_event_regGroupByArgs['orderBy'] }
        : { orderBy?: em_event_regGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_event_regGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_event_regGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_event_reg model
   */
  readonly fields: em_event_regFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_event_reg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_event_regClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_event_reg model
   */
  interface em_event_regFieldRefs {
    readonly Regid: FieldRef<"em_event_reg", 'Int'>
    readonly name: FieldRef<"em_event_reg", 'String'>
    readonly optic_name: FieldRef<"em_event_reg", 'String'>
    readonly password: FieldRef<"em_event_reg", 'String'>
    readonly wa_num: FieldRef<"em_event_reg", 'String'>
    readonly email: FieldRef<"em_event_reg", 'String'>
    readonly profesi_id: FieldRef<"em_event_reg", 'Int'>
    readonly event_id: FieldRef<"em_event_reg", 'Int'>
    readonly status: FieldRef<"em_event_reg", 'String'>
    readonly first_login: FieldRef<"em_event_reg", 'Boolean'>
    readonly created_date: FieldRef<"em_event_reg", 'DateTime'>
    readonly last_update: FieldRef<"em_event_reg", 'DateTime'>
    readonly image_name: FieldRef<"em_event_reg", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_event_reg findUnique
   */
  export type em_event_regFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * Filter, which em_event_reg to fetch.
     */
    where: em_event_regWhereUniqueInput
  }

  /**
   * em_event_reg findUniqueOrThrow
   */
  export type em_event_regFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * Filter, which em_event_reg to fetch.
     */
    where: em_event_regWhereUniqueInput
  }

  /**
   * em_event_reg findFirst
   */
  export type em_event_regFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * Filter, which em_event_reg to fetch.
     */
    where?: em_event_regWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event_regs to fetch.
     */
    orderBy?: em_event_regOrderByWithRelationInput | em_event_regOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_event_regs.
     */
    cursor?: em_event_regWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event_regs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event_regs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_event_regs.
     */
    distinct?: Em_event_regScalarFieldEnum | Em_event_regScalarFieldEnum[]
  }

  /**
   * em_event_reg findFirstOrThrow
   */
  export type em_event_regFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * Filter, which em_event_reg to fetch.
     */
    where?: em_event_regWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event_regs to fetch.
     */
    orderBy?: em_event_regOrderByWithRelationInput | em_event_regOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_event_regs.
     */
    cursor?: em_event_regWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event_regs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event_regs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_event_regs.
     */
    distinct?: Em_event_regScalarFieldEnum | Em_event_regScalarFieldEnum[]
  }

  /**
   * em_event_reg findMany
   */
  export type em_event_regFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * Filter, which em_event_regs to fetch.
     */
    where?: em_event_regWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event_regs to fetch.
     */
    orderBy?: em_event_regOrderByWithRelationInput | em_event_regOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_event_regs.
     */
    cursor?: em_event_regWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event_regs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event_regs.
     */
    skip?: number
    distinct?: Em_event_regScalarFieldEnum | Em_event_regScalarFieldEnum[]
  }

  /**
   * em_event_reg create
   */
  export type em_event_regCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * The data needed to create a em_event_reg.
     */
    data?: XOR<em_event_regCreateInput, em_event_regUncheckedCreateInput>
  }

  /**
   * em_event_reg createMany
   */
  export type em_event_regCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_event_regs.
     */
    data: em_event_regCreateManyInput | em_event_regCreateManyInput[]
  }

  /**
   * em_event_reg update
   */
  export type em_event_regUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * The data needed to update a em_event_reg.
     */
    data: XOR<em_event_regUpdateInput, em_event_regUncheckedUpdateInput>
    /**
     * Choose, which em_event_reg to update.
     */
    where: em_event_regWhereUniqueInput
  }

  /**
   * em_event_reg updateMany
   */
  export type em_event_regUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_event_regs.
     */
    data: XOR<em_event_regUpdateManyMutationInput, em_event_regUncheckedUpdateManyInput>
    /**
     * Filter which em_event_regs to update
     */
    where?: em_event_regWhereInput
    /**
     * Limit how many em_event_regs to update.
     */
    limit?: number
  }

  /**
   * em_event_reg upsert
   */
  export type em_event_regUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * The filter to search for the em_event_reg to update in case it exists.
     */
    where: em_event_regWhereUniqueInput
    /**
     * In case the em_event_reg found by the `where` argument doesn't exist, create a new em_event_reg with this data.
     */
    create: XOR<em_event_regCreateInput, em_event_regUncheckedCreateInput>
    /**
     * In case the em_event_reg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_event_regUpdateInput, em_event_regUncheckedUpdateInput>
  }

  /**
   * em_event_reg delete
   */
  export type em_event_regDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
    /**
     * Filter which em_event_reg to delete.
     */
    where: em_event_regWhereUniqueInput
  }

  /**
   * em_event_reg deleteMany
   */
  export type em_event_regDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_event_regs to delete
     */
    where?: em_event_regWhereInput
    /**
     * Limit how many em_event_regs to delete.
     */
    limit?: number
  }

  /**
   * em_event_reg without action
   */
  export type em_event_regDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event_reg
     */
    select?: em_event_regSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event_reg
     */
    omit?: em_event_regOmit<ExtArgs> | null
  }


  /**
   * Model em_event2
   */

  export type AggregateEm_event2 = {
    _count: Em_event2CountAggregateOutputType | null
    _avg: Em_event2AvgAggregateOutputType | null
    _sum: Em_event2SumAggregateOutputType | null
    _min: Em_event2MinAggregateOutputType | null
    _max: Em_event2MaxAggregateOutputType | null
  }

  export type Em_event2AvgAggregateOutputType = {
    sess_id: number | null
    event_id: number | null
  }

  export type Em_event2SumAggregateOutputType = {
    sess_id: number | null
    event_id: number | null
  }

  export type Em_event2MinAggregateOutputType = {
    sess_id: number | null
    event_id: number | null
    event_name: string | null
    status: string | null
    qr_code: string | null
  }

  export type Em_event2MaxAggregateOutputType = {
    sess_id: number | null
    event_id: number | null
    event_name: string | null
    status: string | null
    qr_code: string | null
  }

  export type Em_event2CountAggregateOutputType = {
    sess_id: number
    event_id: number
    event_name: number
    status: number
    qr_code: number
    _all: number
  }


  export type Em_event2AvgAggregateInputType = {
    sess_id?: true
    event_id?: true
  }

  export type Em_event2SumAggregateInputType = {
    sess_id?: true
    event_id?: true
  }

  export type Em_event2MinAggregateInputType = {
    sess_id?: true
    event_id?: true
    event_name?: true
    status?: true
    qr_code?: true
  }

  export type Em_event2MaxAggregateInputType = {
    sess_id?: true
    event_id?: true
    event_name?: true
    status?: true
    qr_code?: true
  }

  export type Em_event2CountAggregateInputType = {
    sess_id?: true
    event_id?: true
    event_name?: true
    status?: true
    qr_code?: true
    _all?: true
  }

  export type Em_event2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_event2 to aggregate.
     */
    where?: em_event2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event2s to fetch.
     */
    orderBy?: em_event2OrderByWithRelationInput | em_event2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_event2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_event2s
    **/
    _count?: true | Em_event2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_event2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_event2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_event2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_event2MaxAggregateInputType
  }

  export type GetEm_event2AggregateType<T extends Em_event2AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_event2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_event2[P]>
      : GetScalarType<T[P], AggregateEm_event2[P]>
  }




  export type em_event2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_event2WhereInput
    orderBy?: em_event2OrderByWithAggregationInput | em_event2OrderByWithAggregationInput[]
    by: Em_event2ScalarFieldEnum[] | Em_event2ScalarFieldEnum
    having?: em_event2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_event2CountAggregateInputType | true
    _avg?: Em_event2AvgAggregateInputType
    _sum?: Em_event2SumAggregateInputType
    _min?: Em_event2MinAggregateInputType
    _max?: Em_event2MaxAggregateInputType
  }

  export type Em_event2GroupByOutputType = {
    sess_id: number
    event_id: number | null
    event_name: string | null
    status: string | null
    qr_code: string | null
    _count: Em_event2CountAggregateOutputType | null
    _avg: Em_event2AvgAggregateOutputType | null
    _sum: Em_event2SumAggregateOutputType | null
    _min: Em_event2MinAggregateOutputType | null
    _max: Em_event2MaxAggregateOutputType | null
  }

  type GetEm_event2GroupByPayload<T extends em_event2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_event2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_event2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_event2GroupByOutputType[P]>
            : GetScalarType<T[P], Em_event2GroupByOutputType[P]>
        }
      >
    >


  export type em_event2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sess_id?: boolean
    event_id?: boolean
    event_name?: boolean
    status?: boolean
    qr_code?: boolean
    em_event?: boolean | em_event2$em_eventArgs<ExtArgs>
  }, ExtArgs["result"]["em_event2"]>



  export type em_event2SelectScalar = {
    sess_id?: boolean
    event_id?: boolean
    event_name?: boolean
    status?: boolean
    qr_code?: boolean
  }

  export type em_event2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sess_id" | "event_id" | "event_name" | "status" | "qr_code", ExtArgs["result"]["em_event2"]>
  export type em_event2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_event?: boolean | em_event2$em_eventArgs<ExtArgs>
  }

  export type $em_event2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_event2"
    objects: {
      em_event: Prisma.$em_eventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sess_id: number
      event_id: number | null
      event_name: string | null
      status: string | null
      qr_code: string | null
    }, ExtArgs["result"]["em_event2"]>
    composites: {}
  }

  type em_event2GetPayload<S extends boolean | null | undefined | em_event2DefaultArgs> = $Result.GetResult<Prisma.$em_event2Payload, S>

  type em_event2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_event2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_event2CountAggregateInputType | true
    }

  export interface em_event2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_event2'], meta: { name: 'em_event2' } }
    /**
     * Find zero or one Em_event2 that matches the filter.
     * @param {em_event2FindUniqueArgs} args - Arguments to find a Em_event2
     * @example
     * // Get one Em_event2
     * const em_event2 = await prisma.em_event2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_event2FindUniqueArgs>(args: SelectSubset<T, em_event2FindUniqueArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_event2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_event2FindUniqueOrThrowArgs} args - Arguments to find a Em_event2
     * @example
     * // Get one Em_event2
     * const em_event2 = await prisma.em_event2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_event2FindUniqueOrThrowArgs>(args: SelectSubset<T, em_event2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_event2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event2FindFirstArgs} args - Arguments to find a Em_event2
     * @example
     * // Get one Em_event2
     * const em_event2 = await prisma.em_event2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_event2FindFirstArgs>(args?: SelectSubset<T, em_event2FindFirstArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_event2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event2FindFirstOrThrowArgs} args - Arguments to find a Em_event2
     * @example
     * // Get one Em_event2
     * const em_event2 = await prisma.em_event2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_event2FindFirstOrThrowArgs>(args?: SelectSubset<T, em_event2FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_event2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_event2s
     * const em_event2s = await prisma.em_event2.findMany()
     * 
     * // Get first 10 Em_event2s
     * const em_event2s = await prisma.em_event2.findMany({ take: 10 })
     * 
     * // Only select the `sess_id`
     * const em_event2WithSess_idOnly = await prisma.em_event2.findMany({ select: { sess_id: true } })
     * 
     */
    findMany<T extends em_event2FindManyArgs>(args?: SelectSubset<T, em_event2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_event2.
     * @param {em_event2CreateArgs} args - Arguments to create a Em_event2.
     * @example
     * // Create one Em_event2
     * const Em_event2 = await prisma.em_event2.create({
     *   data: {
     *     // ... data to create a Em_event2
     *   }
     * })
     * 
     */
    create<T extends em_event2CreateArgs>(args: SelectSubset<T, em_event2CreateArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_event2s.
     * @param {em_event2CreateManyArgs} args - Arguments to create many Em_event2s.
     * @example
     * // Create many Em_event2s
     * const em_event2 = await prisma.em_event2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_event2CreateManyArgs>(args?: SelectSubset<T, em_event2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_event2.
     * @param {em_event2DeleteArgs} args - Arguments to delete one Em_event2.
     * @example
     * // Delete one Em_event2
     * const Em_event2 = await prisma.em_event2.delete({
     *   where: {
     *     // ... filter to delete one Em_event2
     *   }
     * })
     * 
     */
    delete<T extends em_event2DeleteArgs>(args: SelectSubset<T, em_event2DeleteArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_event2.
     * @param {em_event2UpdateArgs} args - Arguments to update one Em_event2.
     * @example
     * // Update one Em_event2
     * const em_event2 = await prisma.em_event2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_event2UpdateArgs>(args: SelectSubset<T, em_event2UpdateArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_event2s.
     * @param {em_event2DeleteManyArgs} args - Arguments to filter Em_event2s to delete.
     * @example
     * // Delete a few Em_event2s
     * const { count } = await prisma.em_event2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_event2DeleteManyArgs>(args?: SelectSubset<T, em_event2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_event2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_event2s
     * const em_event2 = await prisma.em_event2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_event2UpdateManyArgs>(args: SelectSubset<T, em_event2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_event2.
     * @param {em_event2UpsertArgs} args - Arguments to update or create a Em_event2.
     * @example
     * // Update or create a Em_event2
     * const em_event2 = await prisma.em_event2.upsert({
     *   create: {
     *     // ... data to create a Em_event2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_event2 we want to update
     *   }
     * })
     */
    upsert<T extends em_event2UpsertArgs>(args: SelectSubset<T, em_event2UpsertArgs<ExtArgs>>): Prisma__em_event2Client<$Result.GetResult<Prisma.$em_event2Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_event2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event2CountArgs} args - Arguments to filter Em_event2s to count.
     * @example
     * // Count the number of Em_event2s
     * const count = await prisma.em_event2.count({
     *   where: {
     *     // ... the filter for the Em_event2s we want to count
     *   }
     * })
    **/
    count<T extends em_event2CountArgs>(
      args?: Subset<T, em_event2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_event2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_event2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_event2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_event2AggregateArgs>(args: Subset<T, Em_event2AggregateArgs>): Prisma.PrismaPromise<GetEm_event2AggregateType<T>>

    /**
     * Group by Em_event2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_event2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_event2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_event2GroupByArgs['orderBy'] }
        : { orderBy?: em_event2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_event2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_event2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_event2 model
   */
  readonly fields: em_event2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_event2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_event2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_event<T extends em_event2$em_eventArgs<ExtArgs> = {}>(args?: Subset<T, em_event2$em_eventArgs<ExtArgs>>): Prisma__em_eventClient<$Result.GetResult<Prisma.$em_eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_event2 model
   */
  interface em_event2FieldRefs {
    readonly sess_id: FieldRef<"em_event2", 'Int'>
    readonly event_id: FieldRef<"em_event2", 'Int'>
    readonly event_name: FieldRef<"em_event2", 'String'>
    readonly status: FieldRef<"em_event2", 'String'>
    readonly qr_code: FieldRef<"em_event2", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_event2 findUnique
   */
  export type em_event2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * Filter, which em_event2 to fetch.
     */
    where: em_event2WhereUniqueInput
  }

  /**
   * em_event2 findUniqueOrThrow
   */
  export type em_event2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * Filter, which em_event2 to fetch.
     */
    where: em_event2WhereUniqueInput
  }

  /**
   * em_event2 findFirst
   */
  export type em_event2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * Filter, which em_event2 to fetch.
     */
    where?: em_event2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event2s to fetch.
     */
    orderBy?: em_event2OrderByWithRelationInput | em_event2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_event2s.
     */
    cursor?: em_event2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_event2s.
     */
    distinct?: Em_event2ScalarFieldEnum | Em_event2ScalarFieldEnum[]
  }

  /**
   * em_event2 findFirstOrThrow
   */
  export type em_event2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * Filter, which em_event2 to fetch.
     */
    where?: em_event2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event2s to fetch.
     */
    orderBy?: em_event2OrderByWithRelationInput | em_event2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_event2s.
     */
    cursor?: em_event2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_event2s.
     */
    distinct?: Em_event2ScalarFieldEnum | Em_event2ScalarFieldEnum[]
  }

  /**
   * em_event2 findMany
   */
  export type em_event2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * Filter, which em_event2s to fetch.
     */
    where?: em_event2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_event2s to fetch.
     */
    orderBy?: em_event2OrderByWithRelationInput | em_event2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_event2s.
     */
    cursor?: em_event2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_event2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_event2s.
     */
    skip?: number
    distinct?: Em_event2ScalarFieldEnum | Em_event2ScalarFieldEnum[]
  }

  /**
   * em_event2 create
   */
  export type em_event2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * The data needed to create a em_event2.
     */
    data?: XOR<em_event2CreateInput, em_event2UncheckedCreateInput>
  }

  /**
   * em_event2 createMany
   */
  export type em_event2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_event2s.
     */
    data: em_event2CreateManyInput | em_event2CreateManyInput[]
  }

  /**
   * em_event2 update
   */
  export type em_event2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * The data needed to update a em_event2.
     */
    data: XOR<em_event2UpdateInput, em_event2UncheckedUpdateInput>
    /**
     * Choose, which em_event2 to update.
     */
    where: em_event2WhereUniqueInput
  }

  /**
   * em_event2 updateMany
   */
  export type em_event2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_event2s.
     */
    data: XOR<em_event2UpdateManyMutationInput, em_event2UncheckedUpdateManyInput>
    /**
     * Filter which em_event2s to update
     */
    where?: em_event2WhereInput
    /**
     * Limit how many em_event2s to update.
     */
    limit?: number
  }

  /**
   * em_event2 upsert
   */
  export type em_event2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * The filter to search for the em_event2 to update in case it exists.
     */
    where: em_event2WhereUniqueInput
    /**
     * In case the em_event2 found by the `where` argument doesn't exist, create a new em_event2 with this data.
     */
    create: XOR<em_event2CreateInput, em_event2UncheckedCreateInput>
    /**
     * In case the em_event2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_event2UpdateInput, em_event2UncheckedUpdateInput>
  }

  /**
   * em_event2 delete
   */
  export type em_event2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
    /**
     * Filter which em_event2 to delete.
     */
    where: em_event2WhereUniqueInput
  }

  /**
   * em_event2 deleteMany
   */
  export type em_event2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_event2s to delete
     */
    where?: em_event2WhereInput
    /**
     * Limit how many em_event2s to delete.
     */
    limit?: number
  }

  /**
   * em_event2.em_event
   */
  export type em_event2$em_eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event
     */
    select?: em_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_event
     */
    omit?: em_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_eventInclude<ExtArgs> | null
    where?: em_eventWhereInput
  }

  /**
   * em_event2 without action
   */
  export type em_event2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_event2
     */
    select?: em_event2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_event2
     */
    omit?: em_event2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_event2Include<ExtArgs> | null
  }


  /**
   * Model em_exam_questions
   */

  export type AggregateEm_exam_questions = {
    _count: Em_exam_questionsCountAggregateOutputType | null
    _avg: Em_exam_questionsAvgAggregateOutputType | null
    _sum: Em_exam_questionsSumAggregateOutputType | null
    _min: Em_exam_questionsMinAggregateOutputType | null
    _max: Em_exam_questionsMaxAggregateOutputType | null
  }

  export type Em_exam_questionsAvgAggregateOutputType = {
    id: number | null
    exam_id: number | null
    question_id: number | null
  }

  export type Em_exam_questionsSumAggregateOutputType = {
    id: number | null
    exam_id: number | null
    question_id: number | null
  }

  export type Em_exam_questionsMinAggregateOutputType = {
    id: number | null
    exam_id: number | null
    question_id: number | null
  }

  export type Em_exam_questionsMaxAggregateOutputType = {
    id: number | null
    exam_id: number | null
    question_id: number | null
  }

  export type Em_exam_questionsCountAggregateOutputType = {
    id: number
    exam_id: number
    question_id: number
    _all: number
  }


  export type Em_exam_questionsAvgAggregateInputType = {
    id?: true
    exam_id?: true
    question_id?: true
  }

  export type Em_exam_questionsSumAggregateInputType = {
    id?: true
    exam_id?: true
    question_id?: true
  }

  export type Em_exam_questionsMinAggregateInputType = {
    id?: true
    exam_id?: true
    question_id?: true
  }

  export type Em_exam_questionsMaxAggregateInputType = {
    id?: true
    exam_id?: true
    question_id?: true
  }

  export type Em_exam_questionsCountAggregateInputType = {
    id?: true
    exam_id?: true
    question_id?: true
    _all?: true
  }

  export type Em_exam_questionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exam_questions to aggregate.
     */
    where?: em_exam_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exam_questions to fetch.
     */
    orderBy?: em_exam_questionsOrderByWithRelationInput | em_exam_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_exam_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exam_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exam_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_exam_questions
    **/
    _count?: true | Em_exam_questionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_exam_questionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_exam_questionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_exam_questionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_exam_questionsMaxAggregateInputType
  }

  export type GetEm_exam_questionsAggregateType<T extends Em_exam_questionsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_exam_questions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_exam_questions[P]>
      : GetScalarType<T[P], AggregateEm_exam_questions[P]>
  }




  export type em_exam_questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_exam_questionsWhereInput
    orderBy?: em_exam_questionsOrderByWithAggregationInput | em_exam_questionsOrderByWithAggregationInput[]
    by: Em_exam_questionsScalarFieldEnum[] | Em_exam_questionsScalarFieldEnum
    having?: em_exam_questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_exam_questionsCountAggregateInputType | true
    _avg?: Em_exam_questionsAvgAggregateInputType
    _sum?: Em_exam_questionsSumAggregateInputType
    _min?: Em_exam_questionsMinAggregateInputType
    _max?: Em_exam_questionsMaxAggregateInputType
  }

  export type Em_exam_questionsGroupByOutputType = {
    id: number
    exam_id: number
    question_id: number
    _count: Em_exam_questionsCountAggregateOutputType | null
    _avg: Em_exam_questionsAvgAggregateOutputType | null
    _sum: Em_exam_questionsSumAggregateOutputType | null
    _min: Em_exam_questionsMinAggregateOutputType | null
    _max: Em_exam_questionsMaxAggregateOutputType | null
  }

  type GetEm_exam_questionsGroupByPayload<T extends em_exam_questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_exam_questionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_exam_questionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_exam_questionsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_exam_questionsGroupByOutputType[P]>
        }
      >
    >


  export type em_exam_questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exam_id?: boolean
    question_id?: boolean
  }, ExtArgs["result"]["em_exam_questions"]>



  export type em_exam_questionsSelectScalar = {
    id?: boolean
    exam_id?: boolean
    question_id?: boolean
  }

  export type em_exam_questionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exam_id" | "question_id", ExtArgs["result"]["em_exam_questions"]>

  export type $em_exam_questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_exam_questions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exam_id: number
      question_id: number
    }, ExtArgs["result"]["em_exam_questions"]>
    composites: {}
  }

  type em_exam_questionsGetPayload<S extends boolean | null | undefined | em_exam_questionsDefaultArgs> = $Result.GetResult<Prisma.$em_exam_questionsPayload, S>

  type em_exam_questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_exam_questionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_exam_questionsCountAggregateInputType | true
    }

  export interface em_exam_questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_exam_questions'], meta: { name: 'em_exam_questions' } }
    /**
     * Find zero or one Em_exam_questions that matches the filter.
     * @param {em_exam_questionsFindUniqueArgs} args - Arguments to find a Em_exam_questions
     * @example
     * // Get one Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_exam_questionsFindUniqueArgs>(args: SelectSubset<T, em_exam_questionsFindUniqueArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_exam_questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_exam_questionsFindUniqueOrThrowArgs} args - Arguments to find a Em_exam_questions
     * @example
     * // Get one Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_exam_questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_exam_questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exam_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exam_questionsFindFirstArgs} args - Arguments to find a Em_exam_questions
     * @example
     * // Get one Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_exam_questionsFindFirstArgs>(args?: SelectSubset<T, em_exam_questionsFindFirstArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exam_questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exam_questionsFindFirstOrThrowArgs} args - Arguments to find a Em_exam_questions
     * @example
     * // Get one Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_exam_questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_exam_questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_exam_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exam_questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.findMany()
     * 
     * // Get first 10 Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_exam_questionsWithIdOnly = await prisma.em_exam_questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_exam_questionsFindManyArgs>(args?: SelectSubset<T, em_exam_questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_exam_questions.
     * @param {em_exam_questionsCreateArgs} args - Arguments to create a Em_exam_questions.
     * @example
     * // Create one Em_exam_questions
     * const Em_exam_questions = await prisma.em_exam_questions.create({
     *   data: {
     *     // ... data to create a Em_exam_questions
     *   }
     * })
     * 
     */
    create<T extends em_exam_questionsCreateArgs>(args: SelectSubset<T, em_exam_questionsCreateArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_exam_questions.
     * @param {em_exam_questionsCreateManyArgs} args - Arguments to create many Em_exam_questions.
     * @example
     * // Create many Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_exam_questionsCreateManyArgs>(args?: SelectSubset<T, em_exam_questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_exam_questions.
     * @param {em_exam_questionsDeleteArgs} args - Arguments to delete one Em_exam_questions.
     * @example
     * // Delete one Em_exam_questions
     * const Em_exam_questions = await prisma.em_exam_questions.delete({
     *   where: {
     *     // ... filter to delete one Em_exam_questions
     *   }
     * })
     * 
     */
    delete<T extends em_exam_questionsDeleteArgs>(args: SelectSubset<T, em_exam_questionsDeleteArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_exam_questions.
     * @param {em_exam_questionsUpdateArgs} args - Arguments to update one Em_exam_questions.
     * @example
     * // Update one Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_exam_questionsUpdateArgs>(args: SelectSubset<T, em_exam_questionsUpdateArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_exam_questions.
     * @param {em_exam_questionsDeleteManyArgs} args - Arguments to filter Em_exam_questions to delete.
     * @example
     * // Delete a few Em_exam_questions
     * const { count } = await prisma.em_exam_questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_exam_questionsDeleteManyArgs>(args?: SelectSubset<T, em_exam_questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_exam_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exam_questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_exam_questionsUpdateManyArgs>(args: SelectSubset<T, em_exam_questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_exam_questions.
     * @param {em_exam_questionsUpsertArgs} args - Arguments to update or create a Em_exam_questions.
     * @example
     * // Update or create a Em_exam_questions
     * const em_exam_questions = await prisma.em_exam_questions.upsert({
     *   create: {
     *     // ... data to create a Em_exam_questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_exam_questions we want to update
     *   }
     * })
     */
    upsert<T extends em_exam_questionsUpsertArgs>(args: SelectSubset<T, em_exam_questionsUpsertArgs<ExtArgs>>): Prisma__em_exam_questionsClient<$Result.GetResult<Prisma.$em_exam_questionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_exam_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exam_questionsCountArgs} args - Arguments to filter Em_exam_questions to count.
     * @example
     * // Count the number of Em_exam_questions
     * const count = await prisma.em_exam_questions.count({
     *   where: {
     *     // ... the filter for the Em_exam_questions we want to count
     *   }
     * })
    **/
    count<T extends em_exam_questionsCountArgs>(
      args?: Subset<T, em_exam_questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_exam_questionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_exam_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_exam_questionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_exam_questionsAggregateArgs>(args: Subset<T, Em_exam_questionsAggregateArgs>): Prisma.PrismaPromise<GetEm_exam_questionsAggregateType<T>>

    /**
     * Group by Em_exam_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exam_questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_exam_questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_exam_questionsGroupByArgs['orderBy'] }
        : { orderBy?: em_exam_questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_exam_questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_exam_questionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_exam_questions model
   */
  readonly fields: em_exam_questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_exam_questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_exam_questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_exam_questions model
   */
  interface em_exam_questionsFieldRefs {
    readonly id: FieldRef<"em_exam_questions", 'Int'>
    readonly exam_id: FieldRef<"em_exam_questions", 'Int'>
    readonly question_id: FieldRef<"em_exam_questions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_exam_questions findUnique
   */
  export type em_exam_questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * Filter, which em_exam_questions to fetch.
     */
    where: em_exam_questionsWhereUniqueInput
  }

  /**
   * em_exam_questions findUniqueOrThrow
   */
  export type em_exam_questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * Filter, which em_exam_questions to fetch.
     */
    where: em_exam_questionsWhereUniqueInput
  }

  /**
   * em_exam_questions findFirst
   */
  export type em_exam_questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * Filter, which em_exam_questions to fetch.
     */
    where?: em_exam_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exam_questions to fetch.
     */
    orderBy?: em_exam_questionsOrderByWithRelationInput | em_exam_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exam_questions.
     */
    cursor?: em_exam_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exam_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exam_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exam_questions.
     */
    distinct?: Em_exam_questionsScalarFieldEnum | Em_exam_questionsScalarFieldEnum[]
  }

  /**
   * em_exam_questions findFirstOrThrow
   */
  export type em_exam_questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * Filter, which em_exam_questions to fetch.
     */
    where?: em_exam_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exam_questions to fetch.
     */
    orderBy?: em_exam_questionsOrderByWithRelationInput | em_exam_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exam_questions.
     */
    cursor?: em_exam_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exam_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exam_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exam_questions.
     */
    distinct?: Em_exam_questionsScalarFieldEnum | Em_exam_questionsScalarFieldEnum[]
  }

  /**
   * em_exam_questions findMany
   */
  export type em_exam_questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * Filter, which em_exam_questions to fetch.
     */
    where?: em_exam_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exam_questions to fetch.
     */
    orderBy?: em_exam_questionsOrderByWithRelationInput | em_exam_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_exam_questions.
     */
    cursor?: em_exam_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exam_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exam_questions.
     */
    skip?: number
    distinct?: Em_exam_questionsScalarFieldEnum | Em_exam_questionsScalarFieldEnum[]
  }

  /**
   * em_exam_questions create
   */
  export type em_exam_questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * The data needed to create a em_exam_questions.
     */
    data: XOR<em_exam_questionsCreateInput, em_exam_questionsUncheckedCreateInput>
  }

  /**
   * em_exam_questions createMany
   */
  export type em_exam_questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_exam_questions.
     */
    data: em_exam_questionsCreateManyInput | em_exam_questionsCreateManyInput[]
  }

  /**
   * em_exam_questions update
   */
  export type em_exam_questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * The data needed to update a em_exam_questions.
     */
    data: XOR<em_exam_questionsUpdateInput, em_exam_questionsUncheckedUpdateInput>
    /**
     * Choose, which em_exam_questions to update.
     */
    where: em_exam_questionsWhereUniqueInput
  }

  /**
   * em_exam_questions updateMany
   */
  export type em_exam_questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_exam_questions.
     */
    data: XOR<em_exam_questionsUpdateManyMutationInput, em_exam_questionsUncheckedUpdateManyInput>
    /**
     * Filter which em_exam_questions to update
     */
    where?: em_exam_questionsWhereInput
    /**
     * Limit how many em_exam_questions to update.
     */
    limit?: number
  }

  /**
   * em_exam_questions upsert
   */
  export type em_exam_questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * The filter to search for the em_exam_questions to update in case it exists.
     */
    where: em_exam_questionsWhereUniqueInput
    /**
     * In case the em_exam_questions found by the `where` argument doesn't exist, create a new em_exam_questions with this data.
     */
    create: XOR<em_exam_questionsCreateInput, em_exam_questionsUncheckedCreateInput>
    /**
     * In case the em_exam_questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_exam_questionsUpdateInput, em_exam_questionsUncheckedUpdateInput>
  }

  /**
   * em_exam_questions delete
   */
  export type em_exam_questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
    /**
     * Filter which em_exam_questions to delete.
     */
    where: em_exam_questionsWhereUniqueInput
  }

  /**
   * em_exam_questions deleteMany
   */
  export type em_exam_questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exam_questions to delete
     */
    where?: em_exam_questionsWhereInput
    /**
     * Limit how many em_exam_questions to delete.
     */
    limit?: number
  }

  /**
   * em_exam_questions without action
   */
  export type em_exam_questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exam_questions
     */
    select?: em_exam_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exam_questions
     */
    omit?: em_exam_questionsOmit<ExtArgs> | null
  }


  /**
   * Model em_exams
   */

  export type AggregateEm_exams = {
    _count: Em_examsCountAggregateOutputType | null
    _avg: Em_examsAvgAggregateOutputType | null
    _sum: Em_examsSumAggregateOutputType | null
    _min: Em_examsMinAggregateOutputType | null
    _max: Em_examsMaxAggregateOutputType | null
  }

  export type Em_examsAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_examsSumAggregateOutputType = {
    id: number | null
  }

  export type Em_examsMinAggregateOutputType = {
    id: number | null
    exam_name: string | null
    UserId: string | null
    Status: string | null
    LastUpdate: Date | null
    Deskripsi: string | null
    FileImage: string | null
    CatType: string | null
  }

  export type Em_examsMaxAggregateOutputType = {
    id: number | null
    exam_name: string | null
    UserId: string | null
    Status: string | null
    LastUpdate: Date | null
    Deskripsi: string | null
    FileImage: string | null
    CatType: string | null
  }

  export type Em_examsCountAggregateOutputType = {
    id: number
    exam_name: number
    UserId: number
    Status: number
    LastUpdate: number
    Deskripsi: number
    FileImage: number
    CatType: number
    _all: number
  }


  export type Em_examsAvgAggregateInputType = {
    id?: true
  }

  export type Em_examsSumAggregateInputType = {
    id?: true
  }

  export type Em_examsMinAggregateInputType = {
    id?: true
    exam_name?: true
    UserId?: true
    Status?: true
    LastUpdate?: true
    Deskripsi?: true
    FileImage?: true
    CatType?: true
  }

  export type Em_examsMaxAggregateInputType = {
    id?: true
    exam_name?: true
    UserId?: true
    Status?: true
    LastUpdate?: true
    Deskripsi?: true
    FileImage?: true
    CatType?: true
  }

  export type Em_examsCountAggregateInputType = {
    id?: true
    exam_name?: true
    UserId?: true
    Status?: true
    LastUpdate?: true
    Deskripsi?: true
    FileImage?: true
    CatType?: true
    _all?: true
  }

  export type Em_examsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exams to aggregate.
     */
    where?: em_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams to fetch.
     */
    orderBy?: em_examsOrderByWithRelationInput | em_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_exams
    **/
    _count?: true | Em_examsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_examsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_examsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_examsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_examsMaxAggregateInputType
  }

  export type GetEm_examsAggregateType<T extends Em_examsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_exams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_exams[P]>
      : GetScalarType<T[P], AggregateEm_exams[P]>
  }




  export type em_examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_examsWhereInput
    orderBy?: em_examsOrderByWithAggregationInput | em_examsOrderByWithAggregationInput[]
    by: Em_examsScalarFieldEnum[] | Em_examsScalarFieldEnum
    having?: em_examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_examsCountAggregateInputType | true
    _avg?: Em_examsAvgAggregateInputType
    _sum?: Em_examsSumAggregateInputType
    _min?: Em_examsMinAggregateInputType
    _max?: Em_examsMaxAggregateInputType
  }

  export type Em_examsGroupByOutputType = {
    id: number
    exam_name: string
    UserId: string | null
    Status: string | null
    LastUpdate: Date | null
    Deskripsi: string | null
    FileImage: string | null
    CatType: string | null
    _count: Em_examsCountAggregateOutputType | null
    _avg: Em_examsAvgAggregateOutputType | null
    _sum: Em_examsSumAggregateOutputType | null
    _min: Em_examsMinAggregateOutputType | null
    _max: Em_examsMaxAggregateOutputType | null
  }

  type GetEm_examsGroupByPayload<T extends em_examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_examsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_examsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_examsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_examsGroupByOutputType[P]>
        }
      >
    >


  export type em_examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exam_name?: boolean
    UserId?: boolean
    Status?: boolean
    LastUpdate?: boolean
    Deskripsi?: boolean
    FileImage?: boolean
    CatType?: boolean
    em_loktopik?: boolean | em_exams$em_loktopikArgs<ExtArgs>
    scores?: boolean | em_exams$scoresArgs<ExtArgs>
    _count?: boolean | Em_examsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_exams"]>



  export type em_examsSelectScalar = {
    id?: boolean
    exam_name?: boolean
    UserId?: boolean
    Status?: boolean
    LastUpdate?: boolean
    Deskripsi?: boolean
    FileImage?: boolean
    CatType?: boolean
  }

  export type em_examsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exam_name" | "UserId" | "Status" | "LastUpdate" | "Deskripsi" | "FileImage" | "CatType", ExtArgs["result"]["em_exams"]>
  export type em_examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_loktopik?: boolean | em_exams$em_loktopikArgs<ExtArgs>
    scores?: boolean | em_exams$scoresArgs<ExtArgs>
    _count?: boolean | Em_examsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_exams"
    objects: {
      em_loktopik: Prisma.$em_loktopikPayload<ExtArgs>[]
      scores: Prisma.$scoresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exam_name: string
      UserId: string | null
      Status: string | null
      LastUpdate: Date | null
      Deskripsi: string | null
      FileImage: string | null
      CatType: string | null
    }, ExtArgs["result"]["em_exams"]>
    composites: {}
  }

  type em_examsGetPayload<S extends boolean | null | undefined | em_examsDefaultArgs> = $Result.GetResult<Prisma.$em_examsPayload, S>

  type em_examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_examsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_examsCountAggregateInputType | true
    }

  export interface em_examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_exams'], meta: { name: 'em_exams' } }
    /**
     * Find zero or one Em_exams that matches the filter.
     * @param {em_examsFindUniqueArgs} args - Arguments to find a Em_exams
     * @example
     * // Get one Em_exams
     * const em_exams = await prisma.em_exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_examsFindUniqueArgs>(args: SelectSubset<T, em_examsFindUniqueArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_examsFindUniqueOrThrowArgs} args - Arguments to find a Em_exams
     * @example
     * // Get one Em_exams
     * const em_exams = await prisma.em_exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_examsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_examsFindFirstArgs} args - Arguments to find a Em_exams
     * @example
     * // Get one Em_exams
     * const em_exams = await prisma.em_exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_examsFindFirstArgs>(args?: SelectSubset<T, em_examsFindFirstArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_examsFindFirstOrThrowArgs} args - Arguments to find a Em_exams
     * @example
     * // Get one Em_exams
     * const em_exams = await prisma.em_exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_examsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_exams
     * const em_exams = await prisma.em_exams.findMany()
     * 
     * // Get first 10 Em_exams
     * const em_exams = await prisma.em_exams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_examsWithIdOnly = await prisma.em_exams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_examsFindManyArgs>(args?: SelectSubset<T, em_examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_exams.
     * @param {em_examsCreateArgs} args - Arguments to create a Em_exams.
     * @example
     * // Create one Em_exams
     * const Em_exams = await prisma.em_exams.create({
     *   data: {
     *     // ... data to create a Em_exams
     *   }
     * })
     * 
     */
    create<T extends em_examsCreateArgs>(args: SelectSubset<T, em_examsCreateArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_exams.
     * @param {em_examsCreateManyArgs} args - Arguments to create many Em_exams.
     * @example
     * // Create many Em_exams
     * const em_exams = await prisma.em_exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_examsCreateManyArgs>(args?: SelectSubset<T, em_examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_exams.
     * @param {em_examsDeleteArgs} args - Arguments to delete one Em_exams.
     * @example
     * // Delete one Em_exams
     * const Em_exams = await prisma.em_exams.delete({
     *   where: {
     *     // ... filter to delete one Em_exams
     *   }
     * })
     * 
     */
    delete<T extends em_examsDeleteArgs>(args: SelectSubset<T, em_examsDeleteArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_exams.
     * @param {em_examsUpdateArgs} args - Arguments to update one Em_exams.
     * @example
     * // Update one Em_exams
     * const em_exams = await prisma.em_exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_examsUpdateArgs>(args: SelectSubset<T, em_examsUpdateArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_exams.
     * @param {em_examsDeleteManyArgs} args - Arguments to filter Em_exams to delete.
     * @example
     * // Delete a few Em_exams
     * const { count } = await prisma.em_exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_examsDeleteManyArgs>(args?: SelectSubset<T, em_examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_exams
     * const em_exams = await prisma.em_exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_examsUpdateManyArgs>(args: SelectSubset<T, em_examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_exams.
     * @param {em_examsUpsertArgs} args - Arguments to update or create a Em_exams.
     * @example
     * // Update or create a Em_exams
     * const em_exams = await prisma.em_exams.upsert({
     *   create: {
     *     // ... data to create a Em_exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_exams we want to update
     *   }
     * })
     */
    upsert<T extends em_examsUpsertArgs>(args: SelectSubset<T, em_examsUpsertArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_examsCountArgs} args - Arguments to filter Em_exams to count.
     * @example
     * // Count the number of Em_exams
     * const count = await prisma.em_exams.count({
     *   where: {
     *     // ... the filter for the Em_exams we want to count
     *   }
     * })
    **/
    count<T extends em_examsCountArgs>(
      args?: Subset<T, em_examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_examsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_examsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_examsAggregateArgs>(args: Subset<T, Em_examsAggregateArgs>): Prisma.PrismaPromise<GetEm_examsAggregateType<T>>

    /**
     * Group by Em_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_examsGroupByArgs['orderBy'] }
        : { orderBy?: em_examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_examsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_exams model
   */
  readonly fields: em_examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_loktopik<T extends em_exams$em_loktopikArgs<ExtArgs> = {}>(args?: Subset<T, em_exams$em_loktopikArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scores<T extends em_exams$scoresArgs<ExtArgs> = {}>(args?: Subset<T, em_exams$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_exams model
   */
  interface em_examsFieldRefs {
    readonly id: FieldRef<"em_exams", 'Int'>
    readonly exam_name: FieldRef<"em_exams", 'String'>
    readonly UserId: FieldRef<"em_exams", 'String'>
    readonly Status: FieldRef<"em_exams", 'String'>
    readonly LastUpdate: FieldRef<"em_exams", 'DateTime'>
    readonly Deskripsi: FieldRef<"em_exams", 'String'>
    readonly FileImage: FieldRef<"em_exams", 'String'>
    readonly CatType: FieldRef<"em_exams", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_exams findUnique
   */
  export type em_examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_exams to fetch.
     */
    where: em_examsWhereUniqueInput
  }

  /**
   * em_exams findUniqueOrThrow
   */
  export type em_examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_exams to fetch.
     */
    where: em_examsWhereUniqueInput
  }

  /**
   * em_exams findFirst
   */
  export type em_examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_exams to fetch.
     */
    where?: em_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams to fetch.
     */
    orderBy?: em_examsOrderByWithRelationInput | em_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exams.
     */
    cursor?: em_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exams.
     */
    distinct?: Em_examsScalarFieldEnum | Em_examsScalarFieldEnum[]
  }

  /**
   * em_exams findFirstOrThrow
   */
  export type em_examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_exams to fetch.
     */
    where?: em_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams to fetch.
     */
    orderBy?: em_examsOrderByWithRelationInput | em_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exams.
     */
    cursor?: em_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exams.
     */
    distinct?: Em_examsScalarFieldEnum | Em_examsScalarFieldEnum[]
  }

  /**
   * em_exams findMany
   */
  export type em_examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_exams to fetch.
     */
    where?: em_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams to fetch.
     */
    orderBy?: em_examsOrderByWithRelationInput | em_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_exams.
     */
    cursor?: em_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams.
     */
    skip?: number
    distinct?: Em_examsScalarFieldEnum | Em_examsScalarFieldEnum[]
  }

  /**
   * em_exams create
   */
  export type em_examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * The data needed to create a em_exams.
     */
    data: XOR<em_examsCreateInput, em_examsUncheckedCreateInput>
  }

  /**
   * em_exams createMany
   */
  export type em_examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_exams.
     */
    data: em_examsCreateManyInput | em_examsCreateManyInput[]
  }

  /**
   * em_exams update
   */
  export type em_examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * The data needed to update a em_exams.
     */
    data: XOR<em_examsUpdateInput, em_examsUncheckedUpdateInput>
    /**
     * Choose, which em_exams to update.
     */
    where: em_examsWhereUniqueInput
  }

  /**
   * em_exams updateMany
   */
  export type em_examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_exams.
     */
    data: XOR<em_examsUpdateManyMutationInput, em_examsUncheckedUpdateManyInput>
    /**
     * Filter which em_exams to update
     */
    where?: em_examsWhereInput
    /**
     * Limit how many em_exams to update.
     */
    limit?: number
  }

  /**
   * em_exams upsert
   */
  export type em_examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * The filter to search for the em_exams to update in case it exists.
     */
    where: em_examsWhereUniqueInput
    /**
     * In case the em_exams found by the `where` argument doesn't exist, create a new em_exams with this data.
     */
    create: XOR<em_examsCreateInput, em_examsUncheckedCreateInput>
    /**
     * In case the em_exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_examsUpdateInput, em_examsUncheckedUpdateInput>
  }

  /**
   * em_exams delete
   */
  export type em_examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
    /**
     * Filter which em_exams to delete.
     */
    where: em_examsWhereUniqueInput
  }

  /**
   * em_exams deleteMany
   */
  export type em_examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exams to delete
     */
    where?: em_examsWhereInput
    /**
     * Limit how many em_exams to delete.
     */
    limit?: number
  }

  /**
   * em_exams.em_loktopik
   */
  export type em_exams$em_loktopikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    where?: em_loktopikWhereInput
    orderBy?: em_loktopikOrderByWithRelationInput | em_loktopikOrderByWithRelationInput[]
    cursor?: em_loktopikWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_loktopikScalarFieldEnum | Em_loktopikScalarFieldEnum[]
  }

  /**
   * em_exams.scores
   */
  export type em_exams$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    where?: scoresWhereInput
    orderBy?: scoresOrderByWithRelationInput | scoresOrderByWithRelationInput[]
    cursor?: scoresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoresScalarFieldEnum | ScoresScalarFieldEnum[]
  }

  /**
   * em_exams without action
   */
  export type em_examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams
     */
    select?: em_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams
     */
    omit?: em_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_examsInclude<ExtArgs> | null
  }


  /**
   * Model em_exams_monitor
   */

  export type AggregateEm_exams_monitor = {
    _count: Em_exams_monitorCountAggregateOutputType | null
    _avg: Em_exams_monitorAvgAggregateOutputType | null
    _sum: Em_exams_monitorSumAggregateOutputType | null
    _min: Em_exams_monitorMinAggregateOutputType | null
    _max: Em_exams_monitorMaxAggregateOutputType | null
  }

  export type Em_exams_monitorAvgAggregateOutputType = {
    Id: number | null
    schedule_id: number | null
    empl_id: number | null
    jumlah_soal: number | null
  }

  export type Em_exams_monitorSumAggregateOutputType = {
    Id: bigint | null
    schedule_id: number | null
    empl_id: number | null
    jumlah_soal: number | null
  }

  export type Em_exams_monitorMinAggregateOutputType = {
    Id: bigint | null
    schedule_id: number | null
    exams_id: string | null
    empl_id: number | null
    tipe_soal: string | null
    jumlah_soal: number | null
    status: string | null
    created_at: Date | null
  }

  export type Em_exams_monitorMaxAggregateOutputType = {
    Id: bigint | null
    schedule_id: number | null
    exams_id: string | null
    empl_id: number | null
    tipe_soal: string | null
    jumlah_soal: number | null
    status: string | null
    created_at: Date | null
  }

  export type Em_exams_monitorCountAggregateOutputType = {
    Id: number
    schedule_id: number
    exams_id: number
    empl_id: number
    tipe_soal: number
    jumlah_soal: number
    status: number
    created_at: number
    _all: number
  }


  export type Em_exams_monitorAvgAggregateInputType = {
    Id?: true
    schedule_id?: true
    empl_id?: true
    jumlah_soal?: true
  }

  export type Em_exams_monitorSumAggregateInputType = {
    Id?: true
    schedule_id?: true
    empl_id?: true
    jumlah_soal?: true
  }

  export type Em_exams_monitorMinAggregateInputType = {
    Id?: true
    schedule_id?: true
    exams_id?: true
    empl_id?: true
    tipe_soal?: true
    jumlah_soal?: true
    status?: true
    created_at?: true
  }

  export type Em_exams_monitorMaxAggregateInputType = {
    Id?: true
    schedule_id?: true
    exams_id?: true
    empl_id?: true
    tipe_soal?: true
    jumlah_soal?: true
    status?: true
    created_at?: true
  }

  export type Em_exams_monitorCountAggregateInputType = {
    Id?: true
    schedule_id?: true
    exams_id?: true
    empl_id?: true
    tipe_soal?: true
    jumlah_soal?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Em_exams_monitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exams_monitor to aggregate.
     */
    where?: em_exams_monitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_monitors to fetch.
     */
    orderBy?: em_exams_monitorOrderByWithRelationInput | em_exams_monitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_exams_monitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_exams_monitors
    **/
    _count?: true | Em_exams_monitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_exams_monitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_exams_monitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_exams_monitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_exams_monitorMaxAggregateInputType
  }

  export type GetEm_exams_monitorAggregateType<T extends Em_exams_monitorAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_exams_monitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_exams_monitor[P]>
      : GetScalarType<T[P], AggregateEm_exams_monitor[P]>
  }




  export type em_exams_monitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_exams_monitorWhereInput
    orderBy?: em_exams_monitorOrderByWithAggregationInput | em_exams_monitorOrderByWithAggregationInput[]
    by: Em_exams_monitorScalarFieldEnum[] | Em_exams_monitorScalarFieldEnum
    having?: em_exams_monitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_exams_monitorCountAggregateInputType | true
    _avg?: Em_exams_monitorAvgAggregateInputType
    _sum?: Em_exams_monitorSumAggregateInputType
    _min?: Em_exams_monitorMinAggregateInputType
    _max?: Em_exams_monitorMaxAggregateInputType
  }

  export type Em_exams_monitorGroupByOutputType = {
    Id: bigint
    schedule_id: number | null
    exams_id: string | null
    empl_id: number | null
    tipe_soal: string | null
    jumlah_soal: number | null
    status: string | null
    created_at: Date | null
    _count: Em_exams_monitorCountAggregateOutputType | null
    _avg: Em_exams_monitorAvgAggregateOutputType | null
    _sum: Em_exams_monitorSumAggregateOutputType | null
    _min: Em_exams_monitorMinAggregateOutputType | null
    _max: Em_exams_monitorMaxAggregateOutputType | null
  }

  type GetEm_exams_monitorGroupByPayload<T extends em_exams_monitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_exams_monitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_exams_monitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_exams_monitorGroupByOutputType[P]>
            : GetScalarType<T[P], Em_exams_monitorGroupByOutputType[P]>
        }
      >
    >


  export type em_exams_monitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    schedule_id?: boolean
    exams_id?: boolean
    empl_id?: boolean
    tipe_soal?: boolean
    jumlah_soal?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["em_exams_monitor"]>



  export type em_exams_monitorSelectScalar = {
    Id?: boolean
    schedule_id?: boolean
    exams_id?: boolean
    empl_id?: boolean
    tipe_soal?: boolean
    jumlah_soal?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type em_exams_monitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "schedule_id" | "exams_id" | "empl_id" | "tipe_soal" | "jumlah_soal" | "status" | "created_at", ExtArgs["result"]["em_exams_monitor"]>

  export type $em_exams_monitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_exams_monitor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: bigint
      schedule_id: number | null
      exams_id: string | null
      empl_id: number | null
      tipe_soal: string | null
      jumlah_soal: number | null
      status: string | null
      created_at: Date | null
    }, ExtArgs["result"]["em_exams_monitor"]>
    composites: {}
  }

  type em_exams_monitorGetPayload<S extends boolean | null | undefined | em_exams_monitorDefaultArgs> = $Result.GetResult<Prisma.$em_exams_monitorPayload, S>

  type em_exams_monitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_exams_monitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_exams_monitorCountAggregateInputType | true
    }

  export interface em_exams_monitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_exams_monitor'], meta: { name: 'em_exams_monitor' } }
    /**
     * Find zero or one Em_exams_monitor that matches the filter.
     * @param {em_exams_monitorFindUniqueArgs} args - Arguments to find a Em_exams_monitor
     * @example
     * // Get one Em_exams_monitor
     * const em_exams_monitor = await prisma.em_exams_monitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_exams_monitorFindUniqueArgs>(args: SelectSubset<T, em_exams_monitorFindUniqueArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_exams_monitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_exams_monitorFindUniqueOrThrowArgs} args - Arguments to find a Em_exams_monitor
     * @example
     * // Get one Em_exams_monitor
     * const em_exams_monitor = await prisma.em_exams_monitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_exams_monitorFindUniqueOrThrowArgs>(args: SelectSubset<T, em_exams_monitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exams_monitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_monitorFindFirstArgs} args - Arguments to find a Em_exams_monitor
     * @example
     * // Get one Em_exams_monitor
     * const em_exams_monitor = await prisma.em_exams_monitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_exams_monitorFindFirstArgs>(args?: SelectSubset<T, em_exams_monitorFindFirstArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exams_monitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_monitorFindFirstOrThrowArgs} args - Arguments to find a Em_exams_monitor
     * @example
     * // Get one Em_exams_monitor
     * const em_exams_monitor = await prisma.em_exams_monitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_exams_monitorFindFirstOrThrowArgs>(args?: SelectSubset<T, em_exams_monitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_exams_monitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_monitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_exams_monitors
     * const em_exams_monitors = await prisma.em_exams_monitor.findMany()
     * 
     * // Get first 10 Em_exams_monitors
     * const em_exams_monitors = await prisma.em_exams_monitor.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_exams_monitorWithIdOnly = await prisma.em_exams_monitor.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_exams_monitorFindManyArgs>(args?: SelectSubset<T, em_exams_monitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_exams_monitor.
     * @param {em_exams_monitorCreateArgs} args - Arguments to create a Em_exams_monitor.
     * @example
     * // Create one Em_exams_monitor
     * const Em_exams_monitor = await prisma.em_exams_monitor.create({
     *   data: {
     *     // ... data to create a Em_exams_monitor
     *   }
     * })
     * 
     */
    create<T extends em_exams_monitorCreateArgs>(args: SelectSubset<T, em_exams_monitorCreateArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_exams_monitors.
     * @param {em_exams_monitorCreateManyArgs} args - Arguments to create many Em_exams_monitors.
     * @example
     * // Create many Em_exams_monitors
     * const em_exams_monitor = await prisma.em_exams_monitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_exams_monitorCreateManyArgs>(args?: SelectSubset<T, em_exams_monitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_exams_monitor.
     * @param {em_exams_monitorDeleteArgs} args - Arguments to delete one Em_exams_monitor.
     * @example
     * // Delete one Em_exams_monitor
     * const Em_exams_monitor = await prisma.em_exams_monitor.delete({
     *   where: {
     *     // ... filter to delete one Em_exams_monitor
     *   }
     * })
     * 
     */
    delete<T extends em_exams_monitorDeleteArgs>(args: SelectSubset<T, em_exams_monitorDeleteArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_exams_monitor.
     * @param {em_exams_monitorUpdateArgs} args - Arguments to update one Em_exams_monitor.
     * @example
     * // Update one Em_exams_monitor
     * const em_exams_monitor = await prisma.em_exams_monitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_exams_monitorUpdateArgs>(args: SelectSubset<T, em_exams_monitorUpdateArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_exams_monitors.
     * @param {em_exams_monitorDeleteManyArgs} args - Arguments to filter Em_exams_monitors to delete.
     * @example
     * // Delete a few Em_exams_monitors
     * const { count } = await prisma.em_exams_monitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_exams_monitorDeleteManyArgs>(args?: SelectSubset<T, em_exams_monitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_exams_monitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_monitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_exams_monitors
     * const em_exams_monitor = await prisma.em_exams_monitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_exams_monitorUpdateManyArgs>(args: SelectSubset<T, em_exams_monitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_exams_monitor.
     * @param {em_exams_monitorUpsertArgs} args - Arguments to update or create a Em_exams_monitor.
     * @example
     * // Update or create a Em_exams_monitor
     * const em_exams_monitor = await prisma.em_exams_monitor.upsert({
     *   create: {
     *     // ... data to create a Em_exams_monitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_exams_monitor we want to update
     *   }
     * })
     */
    upsert<T extends em_exams_monitorUpsertArgs>(args: SelectSubset<T, em_exams_monitorUpsertArgs<ExtArgs>>): Prisma__em_exams_monitorClient<$Result.GetResult<Prisma.$em_exams_monitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_exams_monitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_monitorCountArgs} args - Arguments to filter Em_exams_monitors to count.
     * @example
     * // Count the number of Em_exams_monitors
     * const count = await prisma.em_exams_monitor.count({
     *   where: {
     *     // ... the filter for the Em_exams_monitors we want to count
     *   }
     * })
    **/
    count<T extends em_exams_monitorCountArgs>(
      args?: Subset<T, em_exams_monitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_exams_monitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_exams_monitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_exams_monitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_exams_monitorAggregateArgs>(args: Subset<T, Em_exams_monitorAggregateArgs>): Prisma.PrismaPromise<GetEm_exams_monitorAggregateType<T>>

    /**
     * Group by Em_exams_monitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_monitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_exams_monitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_exams_monitorGroupByArgs['orderBy'] }
        : { orderBy?: em_exams_monitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_exams_monitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_exams_monitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_exams_monitor model
   */
  readonly fields: em_exams_monitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_exams_monitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_exams_monitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_exams_monitor model
   */
  interface em_exams_monitorFieldRefs {
    readonly Id: FieldRef<"em_exams_monitor", 'BigInt'>
    readonly schedule_id: FieldRef<"em_exams_monitor", 'Int'>
    readonly exams_id: FieldRef<"em_exams_monitor", 'String'>
    readonly empl_id: FieldRef<"em_exams_monitor", 'Int'>
    readonly tipe_soal: FieldRef<"em_exams_monitor", 'String'>
    readonly jumlah_soal: FieldRef<"em_exams_monitor", 'Int'>
    readonly status: FieldRef<"em_exams_monitor", 'String'>
    readonly created_at: FieldRef<"em_exams_monitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_exams_monitor findUnique
   */
  export type em_exams_monitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_monitor to fetch.
     */
    where: em_exams_monitorWhereUniqueInput
  }

  /**
   * em_exams_monitor findUniqueOrThrow
   */
  export type em_exams_monitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_monitor to fetch.
     */
    where: em_exams_monitorWhereUniqueInput
  }

  /**
   * em_exams_monitor findFirst
   */
  export type em_exams_monitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_monitor to fetch.
     */
    where?: em_exams_monitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_monitors to fetch.
     */
    orderBy?: em_exams_monitorOrderByWithRelationInput | em_exams_monitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exams_monitors.
     */
    cursor?: em_exams_monitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exams_monitors.
     */
    distinct?: Em_exams_monitorScalarFieldEnum | Em_exams_monitorScalarFieldEnum[]
  }

  /**
   * em_exams_monitor findFirstOrThrow
   */
  export type em_exams_monitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_monitor to fetch.
     */
    where?: em_exams_monitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_monitors to fetch.
     */
    orderBy?: em_exams_monitorOrderByWithRelationInput | em_exams_monitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exams_monitors.
     */
    cursor?: em_exams_monitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exams_monitors.
     */
    distinct?: Em_exams_monitorScalarFieldEnum | Em_exams_monitorScalarFieldEnum[]
  }

  /**
   * em_exams_monitor findMany
   */
  export type em_exams_monitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_monitors to fetch.
     */
    where?: em_exams_monitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_monitors to fetch.
     */
    orderBy?: em_exams_monitorOrderByWithRelationInput | em_exams_monitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_exams_monitors.
     */
    cursor?: em_exams_monitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_monitors.
     */
    skip?: number
    distinct?: Em_exams_monitorScalarFieldEnum | Em_exams_monitorScalarFieldEnum[]
  }

  /**
   * em_exams_monitor create
   */
  export type em_exams_monitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * The data needed to create a em_exams_monitor.
     */
    data?: XOR<em_exams_monitorCreateInput, em_exams_monitorUncheckedCreateInput>
  }

  /**
   * em_exams_monitor createMany
   */
  export type em_exams_monitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_exams_monitors.
     */
    data: em_exams_monitorCreateManyInput | em_exams_monitorCreateManyInput[]
  }

  /**
   * em_exams_monitor update
   */
  export type em_exams_monitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * The data needed to update a em_exams_monitor.
     */
    data: XOR<em_exams_monitorUpdateInput, em_exams_monitorUncheckedUpdateInput>
    /**
     * Choose, which em_exams_monitor to update.
     */
    where: em_exams_monitorWhereUniqueInput
  }

  /**
   * em_exams_monitor updateMany
   */
  export type em_exams_monitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_exams_monitors.
     */
    data: XOR<em_exams_monitorUpdateManyMutationInput, em_exams_monitorUncheckedUpdateManyInput>
    /**
     * Filter which em_exams_monitors to update
     */
    where?: em_exams_monitorWhereInput
    /**
     * Limit how many em_exams_monitors to update.
     */
    limit?: number
  }

  /**
   * em_exams_monitor upsert
   */
  export type em_exams_monitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * The filter to search for the em_exams_monitor to update in case it exists.
     */
    where: em_exams_monitorWhereUniqueInput
    /**
     * In case the em_exams_monitor found by the `where` argument doesn't exist, create a new em_exams_monitor with this data.
     */
    create: XOR<em_exams_monitorCreateInput, em_exams_monitorUncheckedCreateInput>
    /**
     * In case the em_exams_monitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_exams_monitorUpdateInput, em_exams_monitorUncheckedUpdateInput>
  }

  /**
   * em_exams_monitor delete
   */
  export type em_exams_monitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
    /**
     * Filter which em_exams_monitor to delete.
     */
    where: em_exams_monitorWhereUniqueInput
  }

  /**
   * em_exams_monitor deleteMany
   */
  export type em_exams_monitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exams_monitors to delete
     */
    where?: em_exams_monitorWhereInput
    /**
     * Limit how many em_exams_monitors to delete.
     */
    limit?: number
  }

  /**
   * em_exams_monitor without action
   */
  export type em_exams_monitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_monitor
     */
    select?: em_exams_monitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_monitor
     */
    omit?: em_exams_monitorOmit<ExtArgs> | null
  }


  /**
   * Model em_exams_results
   */

  export type AggregateEm_exams_results = {
    _count: Em_exams_resultsCountAggregateOutputType | null
    _avg: Em_exams_resultsAvgAggregateOutputType | null
    _sum: Em_exams_resultsSumAggregateOutputType | null
    _min: Em_exams_resultsMinAggregateOutputType | null
    _max: Em_exams_resultsMaxAggregateOutputType | null
  }

  export type Em_exams_resultsAvgAggregateOutputType = {
    Id: number | null
    empl_id: number | null
    soal_id: number | null
    is_changes: number | null
  }

  export type Em_exams_resultsSumAggregateOutputType = {
    Id: number | null
    empl_id: number | null
    soal_id: number | null
    is_changes: number | null
  }

  export type Em_exams_resultsMinAggregateOutputType = {
    Id: number | null
    exams_id: string | null
    empl_id: number | null
    soal_id: number | null
    is_changes: number | null
    is_answer: string | null
    is_time: Date | null
  }

  export type Em_exams_resultsMaxAggregateOutputType = {
    Id: number | null
    exams_id: string | null
    empl_id: number | null
    soal_id: number | null
    is_changes: number | null
    is_answer: string | null
    is_time: Date | null
  }

  export type Em_exams_resultsCountAggregateOutputType = {
    Id: number
    exams_id: number
    empl_id: number
    soal_id: number
    is_changes: number
    is_answer: number
    is_time: number
    _all: number
  }


  export type Em_exams_resultsAvgAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    is_changes?: true
  }

  export type Em_exams_resultsSumAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    is_changes?: true
  }

  export type Em_exams_resultsMinAggregateInputType = {
    Id?: true
    exams_id?: true
    empl_id?: true
    soal_id?: true
    is_changes?: true
    is_answer?: true
    is_time?: true
  }

  export type Em_exams_resultsMaxAggregateInputType = {
    Id?: true
    exams_id?: true
    empl_id?: true
    soal_id?: true
    is_changes?: true
    is_answer?: true
    is_time?: true
  }

  export type Em_exams_resultsCountAggregateInputType = {
    Id?: true
    exams_id?: true
    empl_id?: true
    soal_id?: true
    is_changes?: true
    is_answer?: true
    is_time?: true
    _all?: true
  }

  export type Em_exams_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exams_results to aggregate.
     */
    where?: em_exams_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_results to fetch.
     */
    orderBy?: em_exams_resultsOrderByWithRelationInput | em_exams_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_exams_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_exams_results
    **/
    _count?: true | Em_exams_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_exams_resultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_exams_resultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_exams_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_exams_resultsMaxAggregateInputType
  }

  export type GetEm_exams_resultsAggregateType<T extends Em_exams_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_exams_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_exams_results[P]>
      : GetScalarType<T[P], AggregateEm_exams_results[P]>
  }




  export type em_exams_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_exams_resultsWhereInput
    orderBy?: em_exams_resultsOrderByWithAggregationInput | em_exams_resultsOrderByWithAggregationInput[]
    by: Em_exams_resultsScalarFieldEnum[] | Em_exams_resultsScalarFieldEnum
    having?: em_exams_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_exams_resultsCountAggregateInputType | true
    _avg?: Em_exams_resultsAvgAggregateInputType
    _sum?: Em_exams_resultsSumAggregateInputType
    _min?: Em_exams_resultsMinAggregateInputType
    _max?: Em_exams_resultsMaxAggregateInputType
  }

  export type Em_exams_resultsGroupByOutputType = {
    Id: number
    exams_id: string | null
    empl_id: number | null
    soal_id: number | null
    is_changes: number | null
    is_answer: string | null
    is_time: Date | null
    _count: Em_exams_resultsCountAggregateOutputType | null
    _avg: Em_exams_resultsAvgAggregateOutputType | null
    _sum: Em_exams_resultsSumAggregateOutputType | null
    _min: Em_exams_resultsMinAggregateOutputType | null
    _max: Em_exams_resultsMaxAggregateOutputType | null
  }

  type GetEm_exams_resultsGroupByPayload<T extends em_exams_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_exams_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_exams_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_exams_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_exams_resultsGroupByOutputType[P]>
        }
      >
    >


  export type em_exams_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    exams_id?: boolean
    empl_id?: boolean
    soal_id?: boolean
    is_changes?: boolean
    is_answer?: boolean
    is_time?: boolean
  }, ExtArgs["result"]["em_exams_results"]>



  export type em_exams_resultsSelectScalar = {
    Id?: boolean
    exams_id?: boolean
    empl_id?: boolean
    soal_id?: boolean
    is_changes?: boolean
    is_answer?: boolean
    is_time?: boolean
  }

  export type em_exams_resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "exams_id" | "empl_id" | "soal_id" | "is_changes" | "is_answer" | "is_time", ExtArgs["result"]["em_exams_results"]>

  export type $em_exams_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_exams_results"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      exams_id: string | null
      empl_id: number | null
      soal_id: number | null
      is_changes: number | null
      is_answer: string | null
      is_time: Date | null
    }, ExtArgs["result"]["em_exams_results"]>
    composites: {}
  }

  type em_exams_resultsGetPayload<S extends boolean | null | undefined | em_exams_resultsDefaultArgs> = $Result.GetResult<Prisma.$em_exams_resultsPayload, S>

  type em_exams_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_exams_resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_exams_resultsCountAggregateInputType | true
    }

  export interface em_exams_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_exams_results'], meta: { name: 'em_exams_results' } }
    /**
     * Find zero or one Em_exams_results that matches the filter.
     * @param {em_exams_resultsFindUniqueArgs} args - Arguments to find a Em_exams_results
     * @example
     * // Get one Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_exams_resultsFindUniqueArgs>(args: SelectSubset<T, em_exams_resultsFindUniqueArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_exams_results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_exams_resultsFindUniqueOrThrowArgs} args - Arguments to find a Em_exams_results
     * @example
     * // Get one Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_exams_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_exams_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exams_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_resultsFindFirstArgs} args - Arguments to find a Em_exams_results
     * @example
     * // Get one Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_exams_resultsFindFirstArgs>(args?: SelectSubset<T, em_exams_resultsFindFirstArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_exams_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_resultsFindFirstOrThrowArgs} args - Arguments to find a Em_exams_results
     * @example
     * // Get one Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_exams_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_exams_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_exams_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.findMany()
     * 
     * // Get first 10 Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_exams_resultsWithIdOnly = await prisma.em_exams_results.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_exams_resultsFindManyArgs>(args?: SelectSubset<T, em_exams_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_exams_results.
     * @param {em_exams_resultsCreateArgs} args - Arguments to create a Em_exams_results.
     * @example
     * // Create one Em_exams_results
     * const Em_exams_results = await prisma.em_exams_results.create({
     *   data: {
     *     // ... data to create a Em_exams_results
     *   }
     * })
     * 
     */
    create<T extends em_exams_resultsCreateArgs>(args: SelectSubset<T, em_exams_resultsCreateArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_exams_results.
     * @param {em_exams_resultsCreateManyArgs} args - Arguments to create many Em_exams_results.
     * @example
     * // Create many Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_exams_resultsCreateManyArgs>(args?: SelectSubset<T, em_exams_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_exams_results.
     * @param {em_exams_resultsDeleteArgs} args - Arguments to delete one Em_exams_results.
     * @example
     * // Delete one Em_exams_results
     * const Em_exams_results = await prisma.em_exams_results.delete({
     *   where: {
     *     // ... filter to delete one Em_exams_results
     *   }
     * })
     * 
     */
    delete<T extends em_exams_resultsDeleteArgs>(args: SelectSubset<T, em_exams_resultsDeleteArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_exams_results.
     * @param {em_exams_resultsUpdateArgs} args - Arguments to update one Em_exams_results.
     * @example
     * // Update one Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_exams_resultsUpdateArgs>(args: SelectSubset<T, em_exams_resultsUpdateArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_exams_results.
     * @param {em_exams_resultsDeleteManyArgs} args - Arguments to filter Em_exams_results to delete.
     * @example
     * // Delete a few Em_exams_results
     * const { count } = await prisma.em_exams_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_exams_resultsDeleteManyArgs>(args?: SelectSubset<T, em_exams_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_exams_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_exams_resultsUpdateManyArgs>(args: SelectSubset<T, em_exams_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_exams_results.
     * @param {em_exams_resultsUpsertArgs} args - Arguments to update or create a Em_exams_results.
     * @example
     * // Update or create a Em_exams_results
     * const em_exams_results = await prisma.em_exams_results.upsert({
     *   create: {
     *     // ... data to create a Em_exams_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_exams_results we want to update
     *   }
     * })
     */
    upsert<T extends em_exams_resultsUpsertArgs>(args: SelectSubset<T, em_exams_resultsUpsertArgs<ExtArgs>>): Prisma__em_exams_resultsClient<$Result.GetResult<Prisma.$em_exams_resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_exams_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_resultsCountArgs} args - Arguments to filter Em_exams_results to count.
     * @example
     * // Count the number of Em_exams_results
     * const count = await prisma.em_exams_results.count({
     *   where: {
     *     // ... the filter for the Em_exams_results we want to count
     *   }
     * })
    **/
    count<T extends em_exams_resultsCountArgs>(
      args?: Subset<T, em_exams_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_exams_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_exams_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_exams_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_exams_resultsAggregateArgs>(args: Subset<T, Em_exams_resultsAggregateArgs>): Prisma.PrismaPromise<GetEm_exams_resultsAggregateType<T>>

    /**
     * Group by Em_exams_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_exams_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_exams_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_exams_resultsGroupByArgs['orderBy'] }
        : { orderBy?: em_exams_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_exams_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_exams_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_exams_results model
   */
  readonly fields: em_exams_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_exams_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_exams_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_exams_results model
   */
  interface em_exams_resultsFieldRefs {
    readonly Id: FieldRef<"em_exams_results", 'Int'>
    readonly exams_id: FieldRef<"em_exams_results", 'String'>
    readonly empl_id: FieldRef<"em_exams_results", 'Int'>
    readonly soal_id: FieldRef<"em_exams_results", 'Int'>
    readonly is_changes: FieldRef<"em_exams_results", 'Int'>
    readonly is_answer: FieldRef<"em_exams_results", 'String'>
    readonly is_time: FieldRef<"em_exams_results", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_exams_results findUnique
   */
  export type em_exams_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_results to fetch.
     */
    where: em_exams_resultsWhereUniqueInput
  }

  /**
   * em_exams_results findUniqueOrThrow
   */
  export type em_exams_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_results to fetch.
     */
    where: em_exams_resultsWhereUniqueInput
  }

  /**
   * em_exams_results findFirst
   */
  export type em_exams_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_results to fetch.
     */
    where?: em_exams_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_results to fetch.
     */
    orderBy?: em_exams_resultsOrderByWithRelationInput | em_exams_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exams_results.
     */
    cursor?: em_exams_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exams_results.
     */
    distinct?: Em_exams_resultsScalarFieldEnum | Em_exams_resultsScalarFieldEnum[]
  }

  /**
   * em_exams_results findFirstOrThrow
   */
  export type em_exams_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_results to fetch.
     */
    where?: em_exams_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_results to fetch.
     */
    orderBy?: em_exams_resultsOrderByWithRelationInput | em_exams_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_exams_results.
     */
    cursor?: em_exams_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_exams_results.
     */
    distinct?: Em_exams_resultsScalarFieldEnum | Em_exams_resultsScalarFieldEnum[]
  }

  /**
   * em_exams_results findMany
   */
  export type em_exams_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * Filter, which em_exams_results to fetch.
     */
    where?: em_exams_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_exams_results to fetch.
     */
    orderBy?: em_exams_resultsOrderByWithRelationInput | em_exams_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_exams_results.
     */
    cursor?: em_exams_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_exams_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_exams_results.
     */
    skip?: number
    distinct?: Em_exams_resultsScalarFieldEnum | Em_exams_resultsScalarFieldEnum[]
  }

  /**
   * em_exams_results create
   */
  export type em_exams_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * The data needed to create a em_exams_results.
     */
    data?: XOR<em_exams_resultsCreateInput, em_exams_resultsUncheckedCreateInput>
  }

  /**
   * em_exams_results createMany
   */
  export type em_exams_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_exams_results.
     */
    data: em_exams_resultsCreateManyInput | em_exams_resultsCreateManyInput[]
  }

  /**
   * em_exams_results update
   */
  export type em_exams_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * The data needed to update a em_exams_results.
     */
    data: XOR<em_exams_resultsUpdateInput, em_exams_resultsUncheckedUpdateInput>
    /**
     * Choose, which em_exams_results to update.
     */
    where: em_exams_resultsWhereUniqueInput
  }

  /**
   * em_exams_results updateMany
   */
  export type em_exams_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_exams_results.
     */
    data: XOR<em_exams_resultsUpdateManyMutationInput, em_exams_resultsUncheckedUpdateManyInput>
    /**
     * Filter which em_exams_results to update
     */
    where?: em_exams_resultsWhereInput
    /**
     * Limit how many em_exams_results to update.
     */
    limit?: number
  }

  /**
   * em_exams_results upsert
   */
  export type em_exams_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * The filter to search for the em_exams_results to update in case it exists.
     */
    where: em_exams_resultsWhereUniqueInput
    /**
     * In case the em_exams_results found by the `where` argument doesn't exist, create a new em_exams_results with this data.
     */
    create: XOR<em_exams_resultsCreateInput, em_exams_resultsUncheckedCreateInput>
    /**
     * In case the em_exams_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_exams_resultsUpdateInput, em_exams_resultsUncheckedUpdateInput>
  }

  /**
   * em_exams_results delete
   */
  export type em_exams_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
    /**
     * Filter which em_exams_results to delete.
     */
    where: em_exams_resultsWhereUniqueInput
  }

  /**
   * em_exams_results deleteMany
   */
  export type em_exams_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_exams_results to delete
     */
    where?: em_exams_resultsWhereInput
    /**
     * Limit how many em_exams_results to delete.
     */
    limit?: number
  }

  /**
   * em_exams_results without action
   */
  export type em_exams_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_exams_results
     */
    select?: em_exams_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_exams_results
     */
    omit?: em_exams_resultsOmit<ExtArgs> | null
  }


  /**
   * Model em_faq
   */

  export type AggregateEm_faq = {
    _count: Em_faqCountAggregateOutputType | null
    _avg: Em_faqAvgAggregateOutputType | null
    _sum: Em_faqSumAggregateOutputType | null
    _min: Em_faqMinAggregateOutputType | null
    _max: Em_faqMaxAggregateOutputType | null
  }

  export type Em_faqAvgAggregateOutputType = {
    fqId: number | null
    fqcatid: number | null
  }

  export type Em_faqSumAggregateOutputType = {
    fqId: number | null
    fqcatid: number | null
  }

  export type Em_faqMinAggregateOutputType = {
    fqId: number | null
    fqcatid: number | null
    isquestions: string | null
    isanswer: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    userid: string | null
  }

  export type Em_faqMaxAggregateOutputType = {
    fqId: number | null
    fqcatid: number | null
    isquestions: string | null
    isanswer: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    userid: string | null
  }

  export type Em_faqCountAggregateOutputType = {
    fqId: number
    fqcatid: number
    isquestions: number
    isanswer: number
    status: number
    created_at: number
    lastupdate: number
    userid: number
    _all: number
  }


  export type Em_faqAvgAggregateInputType = {
    fqId?: true
    fqcatid?: true
  }

  export type Em_faqSumAggregateInputType = {
    fqId?: true
    fqcatid?: true
  }

  export type Em_faqMinAggregateInputType = {
    fqId?: true
    fqcatid?: true
    isquestions?: true
    isanswer?: true
    status?: true
    created_at?: true
    lastupdate?: true
    userid?: true
  }

  export type Em_faqMaxAggregateInputType = {
    fqId?: true
    fqcatid?: true
    isquestions?: true
    isanswer?: true
    status?: true
    created_at?: true
    lastupdate?: true
    userid?: true
  }

  export type Em_faqCountAggregateInputType = {
    fqId?: true
    fqcatid?: true
    isquestions?: true
    isanswer?: true
    status?: true
    created_at?: true
    lastupdate?: true
    userid?: true
    _all?: true
  }

  export type Em_faqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_faq to aggregate.
     */
    where?: em_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faqs to fetch.
     */
    orderBy?: em_faqOrderByWithRelationInput | em_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_faqs
    **/
    _count?: true | Em_faqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_faqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_faqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_faqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_faqMaxAggregateInputType
  }

  export type GetEm_faqAggregateType<T extends Em_faqAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_faq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_faq[P]>
      : GetScalarType<T[P], AggregateEm_faq[P]>
  }




  export type em_faqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_faqWhereInput
    orderBy?: em_faqOrderByWithAggregationInput | em_faqOrderByWithAggregationInput[]
    by: Em_faqScalarFieldEnum[] | Em_faqScalarFieldEnum
    having?: em_faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_faqCountAggregateInputType | true
    _avg?: Em_faqAvgAggregateInputType
    _sum?: Em_faqSumAggregateInputType
    _min?: Em_faqMinAggregateInputType
    _max?: Em_faqMaxAggregateInputType
  }

  export type Em_faqGroupByOutputType = {
    fqId: number
    fqcatid: number | null
    isquestions: string | null
    isanswer: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    userid: string | null
    _count: Em_faqCountAggregateOutputType | null
    _avg: Em_faqAvgAggregateOutputType | null
    _sum: Em_faqSumAggregateOutputType | null
    _min: Em_faqMinAggregateOutputType | null
    _max: Em_faqMaxAggregateOutputType | null
  }

  type GetEm_faqGroupByPayload<T extends em_faqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_faqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_faqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_faqGroupByOutputType[P]>
            : GetScalarType<T[P], Em_faqGroupByOutputType[P]>
        }
      >
    >


  export type em_faqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fqId?: boolean
    fqcatid?: boolean
    isquestions?: boolean
    isanswer?: boolean
    status?: boolean
    created_at?: boolean
    lastupdate?: boolean
    userid?: boolean
    em_faq_cat?: boolean | em_faq$em_faq_catArgs<ExtArgs>
  }, ExtArgs["result"]["em_faq"]>



  export type em_faqSelectScalar = {
    fqId?: boolean
    fqcatid?: boolean
    isquestions?: boolean
    isanswer?: boolean
    status?: boolean
    created_at?: boolean
    lastupdate?: boolean
    userid?: boolean
  }

  export type em_faqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"fqId" | "fqcatid" | "isquestions" | "isanswer" | "status" | "created_at" | "lastupdate" | "userid", ExtArgs["result"]["em_faq"]>
  export type em_faqInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_faq_cat?: boolean | em_faq$em_faq_catArgs<ExtArgs>
  }

  export type $em_faqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_faq"
    objects: {
      em_faq_cat: Prisma.$em_faq_catPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      fqId: number
      fqcatid: number | null
      isquestions: string | null
      isanswer: string | null
      status: string | null
      created_at: Date | null
      lastupdate: Date | null
      userid: string | null
    }, ExtArgs["result"]["em_faq"]>
    composites: {}
  }

  type em_faqGetPayload<S extends boolean | null | undefined | em_faqDefaultArgs> = $Result.GetResult<Prisma.$em_faqPayload, S>

  type em_faqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_faqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_faqCountAggregateInputType | true
    }

  export interface em_faqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_faq'], meta: { name: 'em_faq' } }
    /**
     * Find zero or one Em_faq that matches the filter.
     * @param {em_faqFindUniqueArgs} args - Arguments to find a Em_faq
     * @example
     * // Get one Em_faq
     * const em_faq = await prisma.em_faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_faqFindUniqueArgs>(args: SelectSubset<T, em_faqFindUniqueArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_faqFindUniqueOrThrowArgs} args - Arguments to find a Em_faq
     * @example
     * // Get one Em_faq
     * const em_faq = await prisma.em_faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_faqFindUniqueOrThrowArgs>(args: SelectSubset<T, em_faqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faqFindFirstArgs} args - Arguments to find a Em_faq
     * @example
     * // Get one Em_faq
     * const em_faq = await prisma.em_faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_faqFindFirstArgs>(args?: SelectSubset<T, em_faqFindFirstArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faqFindFirstOrThrowArgs} args - Arguments to find a Em_faq
     * @example
     * // Get one Em_faq
     * const em_faq = await prisma.em_faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_faqFindFirstOrThrowArgs>(args?: SelectSubset<T, em_faqFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_faqs
     * const em_faqs = await prisma.em_faq.findMany()
     * 
     * // Get first 10 Em_faqs
     * const em_faqs = await prisma.em_faq.findMany({ take: 10 })
     * 
     * // Only select the `fqId`
     * const em_faqWithFqIdOnly = await prisma.em_faq.findMany({ select: { fqId: true } })
     * 
     */
    findMany<T extends em_faqFindManyArgs>(args?: SelectSubset<T, em_faqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_faq.
     * @param {em_faqCreateArgs} args - Arguments to create a Em_faq.
     * @example
     * // Create one Em_faq
     * const Em_faq = await prisma.em_faq.create({
     *   data: {
     *     // ... data to create a Em_faq
     *   }
     * })
     * 
     */
    create<T extends em_faqCreateArgs>(args: SelectSubset<T, em_faqCreateArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_faqs.
     * @param {em_faqCreateManyArgs} args - Arguments to create many Em_faqs.
     * @example
     * // Create many Em_faqs
     * const em_faq = await prisma.em_faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_faqCreateManyArgs>(args?: SelectSubset<T, em_faqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_faq.
     * @param {em_faqDeleteArgs} args - Arguments to delete one Em_faq.
     * @example
     * // Delete one Em_faq
     * const Em_faq = await prisma.em_faq.delete({
     *   where: {
     *     // ... filter to delete one Em_faq
     *   }
     * })
     * 
     */
    delete<T extends em_faqDeleteArgs>(args: SelectSubset<T, em_faqDeleteArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_faq.
     * @param {em_faqUpdateArgs} args - Arguments to update one Em_faq.
     * @example
     * // Update one Em_faq
     * const em_faq = await prisma.em_faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_faqUpdateArgs>(args: SelectSubset<T, em_faqUpdateArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_faqs.
     * @param {em_faqDeleteManyArgs} args - Arguments to filter Em_faqs to delete.
     * @example
     * // Delete a few Em_faqs
     * const { count } = await prisma.em_faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_faqDeleteManyArgs>(args?: SelectSubset<T, em_faqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_faqs
     * const em_faq = await prisma.em_faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_faqUpdateManyArgs>(args: SelectSubset<T, em_faqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_faq.
     * @param {em_faqUpsertArgs} args - Arguments to update or create a Em_faq.
     * @example
     * // Update or create a Em_faq
     * const em_faq = await prisma.em_faq.upsert({
     *   create: {
     *     // ... data to create a Em_faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_faq we want to update
     *   }
     * })
     */
    upsert<T extends em_faqUpsertArgs>(args: SelectSubset<T, em_faqUpsertArgs<ExtArgs>>): Prisma__em_faqClient<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faqCountArgs} args - Arguments to filter Em_faqs to count.
     * @example
     * // Count the number of Em_faqs
     * const count = await prisma.em_faq.count({
     *   where: {
     *     // ... the filter for the Em_faqs we want to count
     *   }
     * })
    **/
    count<T extends em_faqCountArgs>(
      args?: Subset<T, em_faqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_faqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_faqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_faqAggregateArgs>(args: Subset<T, Em_faqAggregateArgs>): Prisma.PrismaPromise<GetEm_faqAggregateType<T>>

    /**
     * Group by Em_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_faqGroupByArgs['orderBy'] }
        : { orderBy?: em_faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_faqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_faq model
   */
  readonly fields: em_faqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_faqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_faq_cat<T extends em_faq$em_faq_catArgs<ExtArgs> = {}>(args?: Subset<T, em_faq$em_faq_catArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_faq model
   */
  interface em_faqFieldRefs {
    readonly fqId: FieldRef<"em_faq", 'Int'>
    readonly fqcatid: FieldRef<"em_faq", 'Int'>
    readonly isquestions: FieldRef<"em_faq", 'String'>
    readonly isanswer: FieldRef<"em_faq", 'String'>
    readonly status: FieldRef<"em_faq", 'String'>
    readonly created_at: FieldRef<"em_faq", 'DateTime'>
    readonly lastupdate: FieldRef<"em_faq", 'DateTime'>
    readonly userid: FieldRef<"em_faq", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_faq findUnique
   */
  export type em_faqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * Filter, which em_faq to fetch.
     */
    where: em_faqWhereUniqueInput
  }

  /**
   * em_faq findUniqueOrThrow
   */
  export type em_faqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * Filter, which em_faq to fetch.
     */
    where: em_faqWhereUniqueInput
  }

  /**
   * em_faq findFirst
   */
  export type em_faqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * Filter, which em_faq to fetch.
     */
    where?: em_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faqs to fetch.
     */
    orderBy?: em_faqOrderByWithRelationInput | em_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_faqs.
     */
    cursor?: em_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_faqs.
     */
    distinct?: Em_faqScalarFieldEnum | Em_faqScalarFieldEnum[]
  }

  /**
   * em_faq findFirstOrThrow
   */
  export type em_faqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * Filter, which em_faq to fetch.
     */
    where?: em_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faqs to fetch.
     */
    orderBy?: em_faqOrderByWithRelationInput | em_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_faqs.
     */
    cursor?: em_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_faqs.
     */
    distinct?: Em_faqScalarFieldEnum | Em_faqScalarFieldEnum[]
  }

  /**
   * em_faq findMany
   */
  export type em_faqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * Filter, which em_faqs to fetch.
     */
    where?: em_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faqs to fetch.
     */
    orderBy?: em_faqOrderByWithRelationInput | em_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_faqs.
     */
    cursor?: em_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faqs.
     */
    skip?: number
    distinct?: Em_faqScalarFieldEnum | Em_faqScalarFieldEnum[]
  }

  /**
   * em_faq create
   */
  export type em_faqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * The data needed to create a em_faq.
     */
    data?: XOR<em_faqCreateInput, em_faqUncheckedCreateInput>
  }

  /**
   * em_faq createMany
   */
  export type em_faqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_faqs.
     */
    data: em_faqCreateManyInput | em_faqCreateManyInput[]
  }

  /**
   * em_faq update
   */
  export type em_faqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * The data needed to update a em_faq.
     */
    data: XOR<em_faqUpdateInput, em_faqUncheckedUpdateInput>
    /**
     * Choose, which em_faq to update.
     */
    where: em_faqWhereUniqueInput
  }

  /**
   * em_faq updateMany
   */
  export type em_faqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_faqs.
     */
    data: XOR<em_faqUpdateManyMutationInput, em_faqUncheckedUpdateManyInput>
    /**
     * Filter which em_faqs to update
     */
    where?: em_faqWhereInput
    /**
     * Limit how many em_faqs to update.
     */
    limit?: number
  }

  /**
   * em_faq upsert
   */
  export type em_faqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * The filter to search for the em_faq to update in case it exists.
     */
    where: em_faqWhereUniqueInput
    /**
     * In case the em_faq found by the `where` argument doesn't exist, create a new em_faq with this data.
     */
    create: XOR<em_faqCreateInput, em_faqUncheckedCreateInput>
    /**
     * In case the em_faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_faqUpdateInput, em_faqUncheckedUpdateInput>
  }

  /**
   * em_faq delete
   */
  export type em_faqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    /**
     * Filter which em_faq to delete.
     */
    where: em_faqWhereUniqueInput
  }

  /**
   * em_faq deleteMany
   */
  export type em_faqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_faqs to delete
     */
    where?: em_faqWhereInput
    /**
     * Limit how many em_faqs to delete.
     */
    limit?: number
  }

  /**
   * em_faq.em_faq_cat
   */
  export type em_faq$em_faq_catArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    where?: em_faq_catWhereInput
  }

  /**
   * em_faq without action
   */
  export type em_faqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
  }


  /**
   * Model em_faq_cat
   */

  export type AggregateEm_faq_cat = {
    _count: Em_faq_catCountAggregateOutputType | null
    _avg: Em_faq_catAvgAggregateOutputType | null
    _sum: Em_faq_catSumAggregateOutputType | null
    _min: Em_faq_catMinAggregateOutputType | null
    _max: Em_faq_catMaxAggregateOutputType | null
  }

  export type Em_faq_catAvgAggregateOutputType = {
    fqcatid: number | null
  }

  export type Em_faq_catSumAggregateOutputType = {
    fqcatid: number | null
  }

  export type Em_faq_catMinAggregateOutputType = {
    fqcatid: number | null
    name: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_faq_catMaxAggregateOutputType = {
    fqcatid: number | null
    name: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_faq_catCountAggregateOutputType = {
    fqcatid: number
    name: number
    status: number
    created_at: number
    lastupdate: number
    _all: number
  }


  export type Em_faq_catAvgAggregateInputType = {
    fqcatid?: true
  }

  export type Em_faq_catSumAggregateInputType = {
    fqcatid?: true
  }

  export type Em_faq_catMinAggregateInputType = {
    fqcatid?: true
    name?: true
    status?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_faq_catMaxAggregateInputType = {
    fqcatid?: true
    name?: true
    status?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_faq_catCountAggregateInputType = {
    fqcatid?: true
    name?: true
    status?: true
    created_at?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_faq_catAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_faq_cat to aggregate.
     */
    where?: em_faq_catWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faq_cats to fetch.
     */
    orderBy?: em_faq_catOrderByWithRelationInput | em_faq_catOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_faq_catWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faq_cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faq_cats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_faq_cats
    **/
    _count?: true | Em_faq_catCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_faq_catAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_faq_catSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_faq_catMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_faq_catMaxAggregateInputType
  }

  export type GetEm_faq_catAggregateType<T extends Em_faq_catAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_faq_cat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_faq_cat[P]>
      : GetScalarType<T[P], AggregateEm_faq_cat[P]>
  }




  export type em_faq_catGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_faq_catWhereInput
    orderBy?: em_faq_catOrderByWithAggregationInput | em_faq_catOrderByWithAggregationInput[]
    by: Em_faq_catScalarFieldEnum[] | Em_faq_catScalarFieldEnum
    having?: em_faq_catScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_faq_catCountAggregateInputType | true
    _avg?: Em_faq_catAvgAggregateInputType
    _sum?: Em_faq_catSumAggregateInputType
    _min?: Em_faq_catMinAggregateInputType
    _max?: Em_faq_catMaxAggregateInputType
  }

  export type Em_faq_catGroupByOutputType = {
    fqcatid: number
    name: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    _count: Em_faq_catCountAggregateOutputType | null
    _avg: Em_faq_catAvgAggregateOutputType | null
    _sum: Em_faq_catSumAggregateOutputType | null
    _min: Em_faq_catMinAggregateOutputType | null
    _max: Em_faq_catMaxAggregateOutputType | null
  }

  type GetEm_faq_catGroupByPayload<T extends em_faq_catGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_faq_catGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_faq_catGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_faq_catGroupByOutputType[P]>
            : GetScalarType<T[P], Em_faq_catGroupByOutputType[P]>
        }
      >
    >


  export type em_faq_catSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fqcatid?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    lastupdate?: boolean
    em_faq?: boolean | em_faq_cat$em_faqArgs<ExtArgs>
    _count?: boolean | Em_faq_catCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_faq_cat"]>



  export type em_faq_catSelectScalar = {
    fqcatid?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }

  export type em_faq_catOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"fqcatid" | "name" | "status" | "created_at" | "lastupdate", ExtArgs["result"]["em_faq_cat"]>
  export type em_faq_catInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_faq?: boolean | em_faq_cat$em_faqArgs<ExtArgs>
    _count?: boolean | Em_faq_catCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_faq_catPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_faq_cat"
    objects: {
      em_faq: Prisma.$em_faqPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      fqcatid: number
      name: string | null
      status: string | null
      created_at: Date | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_faq_cat"]>
    composites: {}
  }

  type em_faq_catGetPayload<S extends boolean | null | undefined | em_faq_catDefaultArgs> = $Result.GetResult<Prisma.$em_faq_catPayload, S>

  type em_faq_catCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_faq_catFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_faq_catCountAggregateInputType | true
    }

  export interface em_faq_catDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_faq_cat'], meta: { name: 'em_faq_cat' } }
    /**
     * Find zero or one Em_faq_cat that matches the filter.
     * @param {em_faq_catFindUniqueArgs} args - Arguments to find a Em_faq_cat
     * @example
     * // Get one Em_faq_cat
     * const em_faq_cat = await prisma.em_faq_cat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_faq_catFindUniqueArgs>(args: SelectSubset<T, em_faq_catFindUniqueArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_faq_cat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_faq_catFindUniqueOrThrowArgs} args - Arguments to find a Em_faq_cat
     * @example
     * // Get one Em_faq_cat
     * const em_faq_cat = await prisma.em_faq_cat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_faq_catFindUniqueOrThrowArgs>(args: SelectSubset<T, em_faq_catFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_faq_cat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faq_catFindFirstArgs} args - Arguments to find a Em_faq_cat
     * @example
     * // Get one Em_faq_cat
     * const em_faq_cat = await prisma.em_faq_cat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_faq_catFindFirstArgs>(args?: SelectSubset<T, em_faq_catFindFirstArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_faq_cat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faq_catFindFirstOrThrowArgs} args - Arguments to find a Em_faq_cat
     * @example
     * // Get one Em_faq_cat
     * const em_faq_cat = await prisma.em_faq_cat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_faq_catFindFirstOrThrowArgs>(args?: SelectSubset<T, em_faq_catFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_faq_cats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faq_catFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_faq_cats
     * const em_faq_cats = await prisma.em_faq_cat.findMany()
     * 
     * // Get first 10 Em_faq_cats
     * const em_faq_cats = await prisma.em_faq_cat.findMany({ take: 10 })
     * 
     * // Only select the `fqcatid`
     * const em_faq_catWithFqcatidOnly = await prisma.em_faq_cat.findMany({ select: { fqcatid: true } })
     * 
     */
    findMany<T extends em_faq_catFindManyArgs>(args?: SelectSubset<T, em_faq_catFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_faq_cat.
     * @param {em_faq_catCreateArgs} args - Arguments to create a Em_faq_cat.
     * @example
     * // Create one Em_faq_cat
     * const Em_faq_cat = await prisma.em_faq_cat.create({
     *   data: {
     *     // ... data to create a Em_faq_cat
     *   }
     * })
     * 
     */
    create<T extends em_faq_catCreateArgs>(args: SelectSubset<T, em_faq_catCreateArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_faq_cats.
     * @param {em_faq_catCreateManyArgs} args - Arguments to create many Em_faq_cats.
     * @example
     * // Create many Em_faq_cats
     * const em_faq_cat = await prisma.em_faq_cat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_faq_catCreateManyArgs>(args?: SelectSubset<T, em_faq_catCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_faq_cat.
     * @param {em_faq_catDeleteArgs} args - Arguments to delete one Em_faq_cat.
     * @example
     * // Delete one Em_faq_cat
     * const Em_faq_cat = await prisma.em_faq_cat.delete({
     *   where: {
     *     // ... filter to delete one Em_faq_cat
     *   }
     * })
     * 
     */
    delete<T extends em_faq_catDeleteArgs>(args: SelectSubset<T, em_faq_catDeleteArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_faq_cat.
     * @param {em_faq_catUpdateArgs} args - Arguments to update one Em_faq_cat.
     * @example
     * // Update one Em_faq_cat
     * const em_faq_cat = await prisma.em_faq_cat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_faq_catUpdateArgs>(args: SelectSubset<T, em_faq_catUpdateArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_faq_cats.
     * @param {em_faq_catDeleteManyArgs} args - Arguments to filter Em_faq_cats to delete.
     * @example
     * // Delete a few Em_faq_cats
     * const { count } = await prisma.em_faq_cat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_faq_catDeleteManyArgs>(args?: SelectSubset<T, em_faq_catDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_faq_cats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faq_catUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_faq_cats
     * const em_faq_cat = await prisma.em_faq_cat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_faq_catUpdateManyArgs>(args: SelectSubset<T, em_faq_catUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_faq_cat.
     * @param {em_faq_catUpsertArgs} args - Arguments to update or create a Em_faq_cat.
     * @example
     * // Update or create a Em_faq_cat
     * const em_faq_cat = await prisma.em_faq_cat.upsert({
     *   create: {
     *     // ... data to create a Em_faq_cat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_faq_cat we want to update
     *   }
     * })
     */
    upsert<T extends em_faq_catUpsertArgs>(args: SelectSubset<T, em_faq_catUpsertArgs<ExtArgs>>): Prisma__em_faq_catClient<$Result.GetResult<Prisma.$em_faq_catPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_faq_cats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faq_catCountArgs} args - Arguments to filter Em_faq_cats to count.
     * @example
     * // Count the number of Em_faq_cats
     * const count = await prisma.em_faq_cat.count({
     *   where: {
     *     // ... the filter for the Em_faq_cats we want to count
     *   }
     * })
    **/
    count<T extends em_faq_catCountArgs>(
      args?: Subset<T, em_faq_catCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_faq_catCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_faq_cat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_faq_catAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_faq_catAggregateArgs>(args: Subset<T, Em_faq_catAggregateArgs>): Prisma.PrismaPromise<GetEm_faq_catAggregateType<T>>

    /**
     * Group by Em_faq_cat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_faq_catGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_faq_catGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_faq_catGroupByArgs['orderBy'] }
        : { orderBy?: em_faq_catGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_faq_catGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_faq_catGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_faq_cat model
   */
  readonly fields: em_faq_catFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_faq_cat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_faq_catClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_faq<T extends em_faq_cat$em_faqArgs<ExtArgs> = {}>(args?: Subset<T, em_faq_cat$em_faqArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_faq_cat model
   */
  interface em_faq_catFieldRefs {
    readonly fqcatid: FieldRef<"em_faq_cat", 'Int'>
    readonly name: FieldRef<"em_faq_cat", 'String'>
    readonly status: FieldRef<"em_faq_cat", 'String'>
    readonly created_at: FieldRef<"em_faq_cat", 'DateTime'>
    readonly lastupdate: FieldRef<"em_faq_cat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_faq_cat findUnique
   */
  export type em_faq_catFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * Filter, which em_faq_cat to fetch.
     */
    where: em_faq_catWhereUniqueInput
  }

  /**
   * em_faq_cat findUniqueOrThrow
   */
  export type em_faq_catFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * Filter, which em_faq_cat to fetch.
     */
    where: em_faq_catWhereUniqueInput
  }

  /**
   * em_faq_cat findFirst
   */
  export type em_faq_catFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * Filter, which em_faq_cat to fetch.
     */
    where?: em_faq_catWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faq_cats to fetch.
     */
    orderBy?: em_faq_catOrderByWithRelationInput | em_faq_catOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_faq_cats.
     */
    cursor?: em_faq_catWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faq_cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faq_cats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_faq_cats.
     */
    distinct?: Em_faq_catScalarFieldEnum | Em_faq_catScalarFieldEnum[]
  }

  /**
   * em_faq_cat findFirstOrThrow
   */
  export type em_faq_catFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * Filter, which em_faq_cat to fetch.
     */
    where?: em_faq_catWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faq_cats to fetch.
     */
    orderBy?: em_faq_catOrderByWithRelationInput | em_faq_catOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_faq_cats.
     */
    cursor?: em_faq_catWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faq_cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faq_cats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_faq_cats.
     */
    distinct?: Em_faq_catScalarFieldEnum | Em_faq_catScalarFieldEnum[]
  }

  /**
   * em_faq_cat findMany
   */
  export type em_faq_catFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * Filter, which em_faq_cats to fetch.
     */
    where?: em_faq_catWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_faq_cats to fetch.
     */
    orderBy?: em_faq_catOrderByWithRelationInput | em_faq_catOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_faq_cats.
     */
    cursor?: em_faq_catWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_faq_cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_faq_cats.
     */
    skip?: number
    distinct?: Em_faq_catScalarFieldEnum | Em_faq_catScalarFieldEnum[]
  }

  /**
   * em_faq_cat create
   */
  export type em_faq_catCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * The data needed to create a em_faq_cat.
     */
    data?: XOR<em_faq_catCreateInput, em_faq_catUncheckedCreateInput>
  }

  /**
   * em_faq_cat createMany
   */
  export type em_faq_catCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_faq_cats.
     */
    data: em_faq_catCreateManyInput | em_faq_catCreateManyInput[]
  }

  /**
   * em_faq_cat update
   */
  export type em_faq_catUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * The data needed to update a em_faq_cat.
     */
    data: XOR<em_faq_catUpdateInput, em_faq_catUncheckedUpdateInput>
    /**
     * Choose, which em_faq_cat to update.
     */
    where: em_faq_catWhereUniqueInput
  }

  /**
   * em_faq_cat updateMany
   */
  export type em_faq_catUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_faq_cats.
     */
    data: XOR<em_faq_catUpdateManyMutationInput, em_faq_catUncheckedUpdateManyInput>
    /**
     * Filter which em_faq_cats to update
     */
    where?: em_faq_catWhereInput
    /**
     * Limit how many em_faq_cats to update.
     */
    limit?: number
  }

  /**
   * em_faq_cat upsert
   */
  export type em_faq_catUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * The filter to search for the em_faq_cat to update in case it exists.
     */
    where: em_faq_catWhereUniqueInput
    /**
     * In case the em_faq_cat found by the `where` argument doesn't exist, create a new em_faq_cat with this data.
     */
    create: XOR<em_faq_catCreateInput, em_faq_catUncheckedCreateInput>
    /**
     * In case the em_faq_cat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_faq_catUpdateInput, em_faq_catUncheckedUpdateInput>
  }

  /**
   * em_faq_cat delete
   */
  export type em_faq_catDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
    /**
     * Filter which em_faq_cat to delete.
     */
    where: em_faq_catWhereUniqueInput
  }

  /**
   * em_faq_cat deleteMany
   */
  export type em_faq_catDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_faq_cats to delete
     */
    where?: em_faq_catWhereInput
    /**
     * Limit how many em_faq_cats to delete.
     */
    limit?: number
  }

  /**
   * em_faq_cat.em_faq
   */
  export type em_faq_cat$em_faqArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq
     */
    select?: em_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq
     */
    omit?: em_faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faqInclude<ExtArgs> | null
    where?: em_faqWhereInput
    orderBy?: em_faqOrderByWithRelationInput | em_faqOrderByWithRelationInput[]
    cursor?: em_faqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_faqScalarFieldEnum | Em_faqScalarFieldEnum[]
  }

  /**
   * em_faq_cat without action
   */
  export type em_faq_catDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_faq_cat
     */
    select?: em_faq_catSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_faq_cat
     */
    omit?: em_faq_catOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_faq_catInclude<ExtArgs> | null
  }


  /**
   * Model em_galeri_materi
   */

  export type AggregateEm_galeri_materi = {
    _count: Em_galeri_materiCountAggregateOutputType | null
    _avg: Em_galeri_materiAvgAggregateOutputType | null
    _sum: Em_galeri_materiSumAggregateOutputType | null
    _min: Em_galeri_materiMinAggregateOutputType | null
    _max: Em_galeri_materiMaxAggregateOutputType | null
  }

  export type Em_galeri_materiAvgAggregateOutputType = {
    id: number | null
    file_type: number | null
    file_size: number | null
    urutan: number | null
  }

  export type Em_galeri_materiSumAggregateOutputType = {
    id: number | null
    file_type: number | null
    file_size: number | null
    urutan: number | null
  }

  export type Em_galeri_materiMinAggregateOutputType = {
    id: number | null
    title: string | null
    file_type: number | null
    file_name: string | null
    file_size: number | null
    url: string | null
    urutan: number | null
    status: string | null
    created_date: Date | null
    last_update: Date | null
  }

  export type Em_galeri_materiMaxAggregateOutputType = {
    id: number | null
    title: string | null
    file_type: number | null
    file_name: string | null
    file_size: number | null
    url: string | null
    urutan: number | null
    status: string | null
    created_date: Date | null
    last_update: Date | null
  }

  export type Em_galeri_materiCountAggregateOutputType = {
    id: number
    title: number
    file_type: number
    file_name: number
    file_size: number
    url: number
    urutan: number
    status: number
    created_date: number
    last_update: number
    _all: number
  }


  export type Em_galeri_materiAvgAggregateInputType = {
    id?: true
    file_type?: true
    file_size?: true
    urutan?: true
  }

  export type Em_galeri_materiSumAggregateInputType = {
    id?: true
    file_type?: true
    file_size?: true
    urutan?: true
  }

  export type Em_galeri_materiMinAggregateInputType = {
    id?: true
    title?: true
    file_type?: true
    file_name?: true
    file_size?: true
    url?: true
    urutan?: true
    status?: true
    created_date?: true
    last_update?: true
  }

  export type Em_galeri_materiMaxAggregateInputType = {
    id?: true
    title?: true
    file_type?: true
    file_name?: true
    file_size?: true
    url?: true
    urutan?: true
    status?: true
    created_date?: true
    last_update?: true
  }

  export type Em_galeri_materiCountAggregateInputType = {
    id?: true
    title?: true
    file_type?: true
    file_name?: true
    file_size?: true
    url?: true
    urutan?: true
    status?: true
    created_date?: true
    last_update?: true
    _all?: true
  }

  export type Em_galeri_materiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_galeri_materi to aggregate.
     */
    where?: em_galeri_materiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_galeri_materis to fetch.
     */
    orderBy?: em_galeri_materiOrderByWithRelationInput | em_galeri_materiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_galeri_materiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_galeri_materis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_galeri_materis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_galeri_materis
    **/
    _count?: true | Em_galeri_materiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_galeri_materiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_galeri_materiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_galeri_materiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_galeri_materiMaxAggregateInputType
  }

  export type GetEm_galeri_materiAggregateType<T extends Em_galeri_materiAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_galeri_materi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_galeri_materi[P]>
      : GetScalarType<T[P], AggregateEm_galeri_materi[P]>
  }




  export type em_galeri_materiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_galeri_materiWhereInput
    orderBy?: em_galeri_materiOrderByWithAggregationInput | em_galeri_materiOrderByWithAggregationInput[]
    by: Em_galeri_materiScalarFieldEnum[] | Em_galeri_materiScalarFieldEnum
    having?: em_galeri_materiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_galeri_materiCountAggregateInputType | true
    _avg?: Em_galeri_materiAvgAggregateInputType
    _sum?: Em_galeri_materiSumAggregateInputType
    _min?: Em_galeri_materiMinAggregateInputType
    _max?: Em_galeri_materiMaxAggregateInputType
  }

  export type Em_galeri_materiGroupByOutputType = {
    id: number
    title: string
    file_type: number
    file_name: string | null
    file_size: number | null
    url: string | null
    urutan: number | null
    status: string | null
    created_date: Date | null
    last_update: Date | null
    _count: Em_galeri_materiCountAggregateOutputType | null
    _avg: Em_galeri_materiAvgAggregateOutputType | null
    _sum: Em_galeri_materiSumAggregateOutputType | null
    _min: Em_galeri_materiMinAggregateOutputType | null
    _max: Em_galeri_materiMaxAggregateOutputType | null
  }

  type GetEm_galeri_materiGroupByPayload<T extends em_galeri_materiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_galeri_materiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_galeri_materiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_galeri_materiGroupByOutputType[P]>
            : GetScalarType<T[P], Em_galeri_materiGroupByOutputType[P]>
        }
      >
    >


  export type em_galeri_materiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    file_type?: boolean
    file_name?: boolean
    file_size?: boolean
    url?: boolean
    urutan?: boolean
    status?: boolean
    created_date?: boolean
    last_update?: boolean
  }, ExtArgs["result"]["em_galeri_materi"]>



  export type em_galeri_materiSelectScalar = {
    id?: boolean
    title?: boolean
    file_type?: boolean
    file_name?: boolean
    file_size?: boolean
    url?: boolean
    urutan?: boolean
    status?: boolean
    created_date?: boolean
    last_update?: boolean
  }

  export type em_galeri_materiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "file_type" | "file_name" | "file_size" | "url" | "urutan" | "status" | "created_date" | "last_update", ExtArgs["result"]["em_galeri_materi"]>

  export type $em_galeri_materiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_galeri_materi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      file_type: number
      file_name: string | null
      file_size: number | null
      url: string | null
      urutan: number | null
      status: string | null
      created_date: Date | null
      last_update: Date | null
    }, ExtArgs["result"]["em_galeri_materi"]>
    composites: {}
  }

  type em_galeri_materiGetPayload<S extends boolean | null | undefined | em_galeri_materiDefaultArgs> = $Result.GetResult<Prisma.$em_galeri_materiPayload, S>

  type em_galeri_materiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_galeri_materiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_galeri_materiCountAggregateInputType | true
    }

  export interface em_galeri_materiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_galeri_materi'], meta: { name: 'em_galeri_materi' } }
    /**
     * Find zero or one Em_galeri_materi that matches the filter.
     * @param {em_galeri_materiFindUniqueArgs} args - Arguments to find a Em_galeri_materi
     * @example
     * // Get one Em_galeri_materi
     * const em_galeri_materi = await prisma.em_galeri_materi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_galeri_materiFindUniqueArgs>(args: SelectSubset<T, em_galeri_materiFindUniqueArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_galeri_materi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_galeri_materiFindUniqueOrThrowArgs} args - Arguments to find a Em_galeri_materi
     * @example
     * // Get one Em_galeri_materi
     * const em_galeri_materi = await prisma.em_galeri_materi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_galeri_materiFindUniqueOrThrowArgs>(args: SelectSubset<T, em_galeri_materiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_galeri_materi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_galeri_materiFindFirstArgs} args - Arguments to find a Em_galeri_materi
     * @example
     * // Get one Em_galeri_materi
     * const em_galeri_materi = await prisma.em_galeri_materi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_galeri_materiFindFirstArgs>(args?: SelectSubset<T, em_galeri_materiFindFirstArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_galeri_materi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_galeri_materiFindFirstOrThrowArgs} args - Arguments to find a Em_galeri_materi
     * @example
     * // Get one Em_galeri_materi
     * const em_galeri_materi = await prisma.em_galeri_materi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_galeri_materiFindFirstOrThrowArgs>(args?: SelectSubset<T, em_galeri_materiFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_galeri_materis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_galeri_materiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_galeri_materis
     * const em_galeri_materis = await prisma.em_galeri_materi.findMany()
     * 
     * // Get first 10 Em_galeri_materis
     * const em_galeri_materis = await prisma.em_galeri_materi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_galeri_materiWithIdOnly = await prisma.em_galeri_materi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_galeri_materiFindManyArgs>(args?: SelectSubset<T, em_galeri_materiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_galeri_materi.
     * @param {em_galeri_materiCreateArgs} args - Arguments to create a Em_galeri_materi.
     * @example
     * // Create one Em_galeri_materi
     * const Em_galeri_materi = await prisma.em_galeri_materi.create({
     *   data: {
     *     // ... data to create a Em_galeri_materi
     *   }
     * })
     * 
     */
    create<T extends em_galeri_materiCreateArgs>(args: SelectSubset<T, em_galeri_materiCreateArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_galeri_materis.
     * @param {em_galeri_materiCreateManyArgs} args - Arguments to create many Em_galeri_materis.
     * @example
     * // Create many Em_galeri_materis
     * const em_galeri_materi = await prisma.em_galeri_materi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_galeri_materiCreateManyArgs>(args?: SelectSubset<T, em_galeri_materiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_galeri_materi.
     * @param {em_galeri_materiDeleteArgs} args - Arguments to delete one Em_galeri_materi.
     * @example
     * // Delete one Em_galeri_materi
     * const Em_galeri_materi = await prisma.em_galeri_materi.delete({
     *   where: {
     *     // ... filter to delete one Em_galeri_materi
     *   }
     * })
     * 
     */
    delete<T extends em_galeri_materiDeleteArgs>(args: SelectSubset<T, em_galeri_materiDeleteArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_galeri_materi.
     * @param {em_galeri_materiUpdateArgs} args - Arguments to update one Em_galeri_materi.
     * @example
     * // Update one Em_galeri_materi
     * const em_galeri_materi = await prisma.em_galeri_materi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_galeri_materiUpdateArgs>(args: SelectSubset<T, em_galeri_materiUpdateArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_galeri_materis.
     * @param {em_galeri_materiDeleteManyArgs} args - Arguments to filter Em_galeri_materis to delete.
     * @example
     * // Delete a few Em_galeri_materis
     * const { count } = await prisma.em_galeri_materi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_galeri_materiDeleteManyArgs>(args?: SelectSubset<T, em_galeri_materiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_galeri_materis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_galeri_materiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_galeri_materis
     * const em_galeri_materi = await prisma.em_galeri_materi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_galeri_materiUpdateManyArgs>(args: SelectSubset<T, em_galeri_materiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_galeri_materi.
     * @param {em_galeri_materiUpsertArgs} args - Arguments to update or create a Em_galeri_materi.
     * @example
     * // Update or create a Em_galeri_materi
     * const em_galeri_materi = await prisma.em_galeri_materi.upsert({
     *   create: {
     *     // ... data to create a Em_galeri_materi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_galeri_materi we want to update
     *   }
     * })
     */
    upsert<T extends em_galeri_materiUpsertArgs>(args: SelectSubset<T, em_galeri_materiUpsertArgs<ExtArgs>>): Prisma__em_galeri_materiClient<$Result.GetResult<Prisma.$em_galeri_materiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_galeri_materis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_galeri_materiCountArgs} args - Arguments to filter Em_galeri_materis to count.
     * @example
     * // Count the number of Em_galeri_materis
     * const count = await prisma.em_galeri_materi.count({
     *   where: {
     *     // ... the filter for the Em_galeri_materis we want to count
     *   }
     * })
    **/
    count<T extends em_galeri_materiCountArgs>(
      args?: Subset<T, em_galeri_materiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_galeri_materiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_galeri_materi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_galeri_materiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_galeri_materiAggregateArgs>(args: Subset<T, Em_galeri_materiAggregateArgs>): Prisma.PrismaPromise<GetEm_galeri_materiAggregateType<T>>

    /**
     * Group by Em_galeri_materi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_galeri_materiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_galeri_materiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_galeri_materiGroupByArgs['orderBy'] }
        : { orderBy?: em_galeri_materiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_galeri_materiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_galeri_materiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_galeri_materi model
   */
  readonly fields: em_galeri_materiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_galeri_materi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_galeri_materiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_galeri_materi model
   */
  interface em_galeri_materiFieldRefs {
    readonly id: FieldRef<"em_galeri_materi", 'Int'>
    readonly title: FieldRef<"em_galeri_materi", 'String'>
    readonly file_type: FieldRef<"em_galeri_materi", 'Int'>
    readonly file_name: FieldRef<"em_galeri_materi", 'String'>
    readonly file_size: FieldRef<"em_galeri_materi", 'Float'>
    readonly url: FieldRef<"em_galeri_materi", 'String'>
    readonly urutan: FieldRef<"em_galeri_materi", 'Int'>
    readonly status: FieldRef<"em_galeri_materi", 'String'>
    readonly created_date: FieldRef<"em_galeri_materi", 'DateTime'>
    readonly last_update: FieldRef<"em_galeri_materi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_galeri_materi findUnique
   */
  export type em_galeri_materiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * Filter, which em_galeri_materi to fetch.
     */
    where: em_galeri_materiWhereUniqueInput
  }

  /**
   * em_galeri_materi findUniqueOrThrow
   */
  export type em_galeri_materiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * Filter, which em_galeri_materi to fetch.
     */
    where: em_galeri_materiWhereUniqueInput
  }

  /**
   * em_galeri_materi findFirst
   */
  export type em_galeri_materiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * Filter, which em_galeri_materi to fetch.
     */
    where?: em_galeri_materiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_galeri_materis to fetch.
     */
    orderBy?: em_galeri_materiOrderByWithRelationInput | em_galeri_materiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_galeri_materis.
     */
    cursor?: em_galeri_materiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_galeri_materis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_galeri_materis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_galeri_materis.
     */
    distinct?: Em_galeri_materiScalarFieldEnum | Em_galeri_materiScalarFieldEnum[]
  }

  /**
   * em_galeri_materi findFirstOrThrow
   */
  export type em_galeri_materiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * Filter, which em_galeri_materi to fetch.
     */
    where?: em_galeri_materiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_galeri_materis to fetch.
     */
    orderBy?: em_galeri_materiOrderByWithRelationInput | em_galeri_materiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_galeri_materis.
     */
    cursor?: em_galeri_materiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_galeri_materis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_galeri_materis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_galeri_materis.
     */
    distinct?: Em_galeri_materiScalarFieldEnum | Em_galeri_materiScalarFieldEnum[]
  }

  /**
   * em_galeri_materi findMany
   */
  export type em_galeri_materiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * Filter, which em_galeri_materis to fetch.
     */
    where?: em_galeri_materiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_galeri_materis to fetch.
     */
    orderBy?: em_galeri_materiOrderByWithRelationInput | em_galeri_materiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_galeri_materis.
     */
    cursor?: em_galeri_materiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_galeri_materis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_galeri_materis.
     */
    skip?: number
    distinct?: Em_galeri_materiScalarFieldEnum | Em_galeri_materiScalarFieldEnum[]
  }

  /**
   * em_galeri_materi create
   */
  export type em_galeri_materiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * The data needed to create a em_galeri_materi.
     */
    data: XOR<em_galeri_materiCreateInput, em_galeri_materiUncheckedCreateInput>
  }

  /**
   * em_galeri_materi createMany
   */
  export type em_galeri_materiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_galeri_materis.
     */
    data: em_galeri_materiCreateManyInput | em_galeri_materiCreateManyInput[]
  }

  /**
   * em_galeri_materi update
   */
  export type em_galeri_materiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * The data needed to update a em_galeri_materi.
     */
    data: XOR<em_galeri_materiUpdateInput, em_galeri_materiUncheckedUpdateInput>
    /**
     * Choose, which em_galeri_materi to update.
     */
    where: em_galeri_materiWhereUniqueInput
  }

  /**
   * em_galeri_materi updateMany
   */
  export type em_galeri_materiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_galeri_materis.
     */
    data: XOR<em_galeri_materiUpdateManyMutationInput, em_galeri_materiUncheckedUpdateManyInput>
    /**
     * Filter which em_galeri_materis to update
     */
    where?: em_galeri_materiWhereInput
    /**
     * Limit how many em_galeri_materis to update.
     */
    limit?: number
  }

  /**
   * em_galeri_materi upsert
   */
  export type em_galeri_materiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * The filter to search for the em_galeri_materi to update in case it exists.
     */
    where: em_galeri_materiWhereUniqueInput
    /**
     * In case the em_galeri_materi found by the `where` argument doesn't exist, create a new em_galeri_materi with this data.
     */
    create: XOR<em_galeri_materiCreateInput, em_galeri_materiUncheckedCreateInput>
    /**
     * In case the em_galeri_materi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_galeri_materiUpdateInput, em_galeri_materiUncheckedUpdateInput>
  }

  /**
   * em_galeri_materi delete
   */
  export type em_galeri_materiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
    /**
     * Filter which em_galeri_materi to delete.
     */
    where: em_galeri_materiWhereUniqueInput
  }

  /**
   * em_galeri_materi deleteMany
   */
  export type em_galeri_materiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_galeri_materis to delete
     */
    where?: em_galeri_materiWhereInput
    /**
     * Limit how many em_galeri_materis to delete.
     */
    limit?: number
  }

  /**
   * em_galeri_materi without action
   */
  export type em_galeri_materiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_galeri_materi
     */
    select?: em_galeri_materiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_galeri_materi
     */
    omit?: em_galeri_materiOmit<ExtArgs> | null
  }


  /**
   * Model em_group
   */

  export type AggregateEm_group = {
    _count: Em_groupCountAggregateOutputType | null
    _avg: Em_groupAvgAggregateOutputType | null
    _sum: Em_groupSumAggregateOutputType | null
    _min: Em_groupMinAggregateOutputType | null
    _max: Em_groupMaxAggregateOutputType | null
  }

  export type Em_groupAvgAggregateOutputType = {
    GroupId: number | null
  }

  export type Em_groupSumAggregateOutputType = {
    GroupId: number | null
  }

  export type Em_groupMinAggregateOutputType = {
    GroupId: number | null
    GroupName: string | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
  }

  export type Em_groupMaxAggregateOutputType = {
    GroupId: number | null
    GroupName: string | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
  }

  export type Em_groupCountAggregateOutputType = {
    GroupId: number
    GroupName: number
    Status: number
    CreateDate: number
    LastUpdate: number
    _all: number
  }


  export type Em_groupAvgAggregateInputType = {
    GroupId?: true
  }

  export type Em_groupSumAggregateInputType = {
    GroupId?: true
  }

  export type Em_groupMinAggregateInputType = {
    GroupId?: true
    GroupName?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
  }

  export type Em_groupMaxAggregateInputType = {
    GroupId?: true
    GroupName?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
  }

  export type Em_groupCountAggregateInputType = {
    GroupId?: true
    GroupName?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
    _all?: true
  }

  export type Em_groupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_group to aggregate.
     */
    where?: em_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_groups to fetch.
     */
    orderBy?: em_groupOrderByWithRelationInput | em_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_groups
    **/
    _count?: true | Em_groupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_groupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_groupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_groupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_groupMaxAggregateInputType
  }

  export type GetEm_groupAggregateType<T extends Em_groupAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_group]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_group[P]>
      : GetScalarType<T[P], AggregateEm_group[P]>
  }




  export type em_groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_groupWhereInput
    orderBy?: em_groupOrderByWithAggregationInput | em_groupOrderByWithAggregationInput[]
    by: Em_groupScalarFieldEnum[] | Em_groupScalarFieldEnum
    having?: em_groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_groupCountAggregateInputType | true
    _avg?: Em_groupAvgAggregateInputType
    _sum?: Em_groupSumAggregateInputType
    _min?: Em_groupMinAggregateInputType
    _max?: Em_groupMaxAggregateInputType
  }

  export type Em_groupGroupByOutputType = {
    GroupId: number
    GroupName: string | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
    _count: Em_groupCountAggregateOutputType | null
    _avg: Em_groupAvgAggregateOutputType | null
    _sum: Em_groupSumAggregateOutputType | null
    _min: Em_groupMinAggregateOutputType | null
    _max: Em_groupMaxAggregateOutputType | null
  }

  type GetEm_groupGroupByPayload<T extends em_groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_groupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_groupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_groupGroupByOutputType[P]>
            : GetScalarType<T[P], Em_groupGroupByOutputType[P]>
        }
      >
    >


  export type em_groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    GroupId?: boolean
    GroupName?: boolean
    Status?: boolean
    CreateDate?: boolean
    LastUpdate?: boolean
  }, ExtArgs["result"]["em_group"]>



  export type em_groupSelectScalar = {
    GroupId?: boolean
    GroupName?: boolean
    Status?: boolean
    CreateDate?: boolean
    LastUpdate?: boolean
  }

  export type em_groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"GroupId" | "GroupName" | "Status" | "CreateDate" | "LastUpdate", ExtArgs["result"]["em_group"]>

  export type $em_groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_group"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      GroupId: number
      GroupName: string | null
      Status: string | null
      CreateDate: Date | null
      LastUpdate: Date | null
    }, ExtArgs["result"]["em_group"]>
    composites: {}
  }

  type em_groupGetPayload<S extends boolean | null | undefined | em_groupDefaultArgs> = $Result.GetResult<Prisma.$em_groupPayload, S>

  type em_groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_groupCountAggregateInputType | true
    }

  export interface em_groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_group'], meta: { name: 'em_group' } }
    /**
     * Find zero or one Em_group that matches the filter.
     * @param {em_groupFindUniqueArgs} args - Arguments to find a Em_group
     * @example
     * // Get one Em_group
     * const em_group = await prisma.em_group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_groupFindUniqueArgs>(args: SelectSubset<T, em_groupFindUniqueArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_groupFindUniqueOrThrowArgs} args - Arguments to find a Em_group
     * @example
     * // Get one Em_group
     * const em_group = await prisma.em_group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_groupFindUniqueOrThrowArgs>(args: SelectSubset<T, em_groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_groupFindFirstArgs} args - Arguments to find a Em_group
     * @example
     * // Get one Em_group
     * const em_group = await prisma.em_group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_groupFindFirstArgs>(args?: SelectSubset<T, em_groupFindFirstArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_groupFindFirstOrThrowArgs} args - Arguments to find a Em_group
     * @example
     * // Get one Em_group
     * const em_group = await prisma.em_group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_groupFindFirstOrThrowArgs>(args?: SelectSubset<T, em_groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_groups
     * const em_groups = await prisma.em_group.findMany()
     * 
     * // Get first 10 Em_groups
     * const em_groups = await prisma.em_group.findMany({ take: 10 })
     * 
     * // Only select the `GroupId`
     * const em_groupWithGroupIdOnly = await prisma.em_group.findMany({ select: { GroupId: true } })
     * 
     */
    findMany<T extends em_groupFindManyArgs>(args?: SelectSubset<T, em_groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_group.
     * @param {em_groupCreateArgs} args - Arguments to create a Em_group.
     * @example
     * // Create one Em_group
     * const Em_group = await prisma.em_group.create({
     *   data: {
     *     // ... data to create a Em_group
     *   }
     * })
     * 
     */
    create<T extends em_groupCreateArgs>(args: SelectSubset<T, em_groupCreateArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_groups.
     * @param {em_groupCreateManyArgs} args - Arguments to create many Em_groups.
     * @example
     * // Create many Em_groups
     * const em_group = await prisma.em_group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_groupCreateManyArgs>(args?: SelectSubset<T, em_groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_group.
     * @param {em_groupDeleteArgs} args - Arguments to delete one Em_group.
     * @example
     * // Delete one Em_group
     * const Em_group = await prisma.em_group.delete({
     *   where: {
     *     // ... filter to delete one Em_group
     *   }
     * })
     * 
     */
    delete<T extends em_groupDeleteArgs>(args: SelectSubset<T, em_groupDeleteArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_group.
     * @param {em_groupUpdateArgs} args - Arguments to update one Em_group.
     * @example
     * // Update one Em_group
     * const em_group = await prisma.em_group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_groupUpdateArgs>(args: SelectSubset<T, em_groupUpdateArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_groups.
     * @param {em_groupDeleteManyArgs} args - Arguments to filter Em_groups to delete.
     * @example
     * // Delete a few Em_groups
     * const { count } = await prisma.em_group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_groupDeleteManyArgs>(args?: SelectSubset<T, em_groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_groups
     * const em_group = await prisma.em_group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_groupUpdateManyArgs>(args: SelectSubset<T, em_groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_group.
     * @param {em_groupUpsertArgs} args - Arguments to update or create a Em_group.
     * @example
     * // Update or create a Em_group
     * const em_group = await prisma.em_group.upsert({
     *   create: {
     *     // ... data to create a Em_group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_group we want to update
     *   }
     * })
     */
    upsert<T extends em_groupUpsertArgs>(args: SelectSubset<T, em_groupUpsertArgs<ExtArgs>>): Prisma__em_groupClient<$Result.GetResult<Prisma.$em_groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_groupCountArgs} args - Arguments to filter Em_groups to count.
     * @example
     * // Count the number of Em_groups
     * const count = await prisma.em_group.count({
     *   where: {
     *     // ... the filter for the Em_groups we want to count
     *   }
     * })
    **/
    count<T extends em_groupCountArgs>(
      args?: Subset<T, em_groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_groupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_groupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_groupAggregateArgs>(args: Subset<T, Em_groupAggregateArgs>): Prisma.PrismaPromise<GetEm_groupAggregateType<T>>

    /**
     * Group by Em_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_groupGroupByArgs['orderBy'] }
        : { orderBy?: em_groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_groupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_group model
   */
  readonly fields: em_groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_group model
   */
  interface em_groupFieldRefs {
    readonly GroupId: FieldRef<"em_group", 'Int'>
    readonly GroupName: FieldRef<"em_group", 'String'>
    readonly Status: FieldRef<"em_group", 'String'>
    readonly CreateDate: FieldRef<"em_group", 'DateTime'>
    readonly LastUpdate: FieldRef<"em_group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_group findUnique
   */
  export type em_groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * Filter, which em_group to fetch.
     */
    where: em_groupWhereUniqueInput
  }

  /**
   * em_group findUniqueOrThrow
   */
  export type em_groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * Filter, which em_group to fetch.
     */
    where: em_groupWhereUniqueInput
  }

  /**
   * em_group findFirst
   */
  export type em_groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * Filter, which em_group to fetch.
     */
    where?: em_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_groups to fetch.
     */
    orderBy?: em_groupOrderByWithRelationInput | em_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_groups.
     */
    cursor?: em_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_groups.
     */
    distinct?: Em_groupScalarFieldEnum | Em_groupScalarFieldEnum[]
  }

  /**
   * em_group findFirstOrThrow
   */
  export type em_groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * Filter, which em_group to fetch.
     */
    where?: em_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_groups to fetch.
     */
    orderBy?: em_groupOrderByWithRelationInput | em_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_groups.
     */
    cursor?: em_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_groups.
     */
    distinct?: Em_groupScalarFieldEnum | Em_groupScalarFieldEnum[]
  }

  /**
   * em_group findMany
   */
  export type em_groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * Filter, which em_groups to fetch.
     */
    where?: em_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_groups to fetch.
     */
    orderBy?: em_groupOrderByWithRelationInput | em_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_groups.
     */
    cursor?: em_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_groups.
     */
    skip?: number
    distinct?: Em_groupScalarFieldEnum | Em_groupScalarFieldEnum[]
  }

  /**
   * em_group create
   */
  export type em_groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * The data needed to create a em_group.
     */
    data?: XOR<em_groupCreateInput, em_groupUncheckedCreateInput>
  }

  /**
   * em_group createMany
   */
  export type em_groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_groups.
     */
    data: em_groupCreateManyInput | em_groupCreateManyInput[]
  }

  /**
   * em_group update
   */
  export type em_groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * The data needed to update a em_group.
     */
    data: XOR<em_groupUpdateInput, em_groupUncheckedUpdateInput>
    /**
     * Choose, which em_group to update.
     */
    where: em_groupWhereUniqueInput
  }

  /**
   * em_group updateMany
   */
  export type em_groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_groups.
     */
    data: XOR<em_groupUpdateManyMutationInput, em_groupUncheckedUpdateManyInput>
    /**
     * Filter which em_groups to update
     */
    where?: em_groupWhereInput
    /**
     * Limit how many em_groups to update.
     */
    limit?: number
  }

  /**
   * em_group upsert
   */
  export type em_groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * The filter to search for the em_group to update in case it exists.
     */
    where: em_groupWhereUniqueInput
    /**
     * In case the em_group found by the `where` argument doesn't exist, create a new em_group with this data.
     */
    create: XOR<em_groupCreateInput, em_groupUncheckedCreateInput>
    /**
     * In case the em_group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_groupUpdateInput, em_groupUncheckedUpdateInput>
  }

  /**
   * em_group delete
   */
  export type em_groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
    /**
     * Filter which em_group to delete.
     */
    where: em_groupWhereUniqueInput
  }

  /**
   * em_group deleteMany
   */
  export type em_groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_groups to delete
     */
    where?: em_groupWhereInput
    /**
     * Limit how many em_groups to delete.
     */
    limit?: number
  }

  /**
   * em_group without action
   */
  export type em_groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_group
     */
    select?: em_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_group
     */
    omit?: em_groupOmit<ExtArgs> | null
  }


  /**
   * Model em_hero_section
   */

  export type AggregateEm_hero_section = {
    _count: Em_hero_sectionCountAggregateOutputType | null
    _avg: Em_hero_sectionAvgAggregateOutputType | null
    _sum: Em_hero_sectionSumAggregateOutputType | null
    _min: Em_hero_sectionMinAggregateOutputType | null
    _max: Em_hero_sectionMaxAggregateOutputType | null
  }

  export type Em_hero_sectionAvgAggregateOutputType = {
    hsId: number | null
    Urutan: number | null
  }

  export type Em_hero_sectionSumAggregateOutputType = {
    hsId: number | null
    Urutan: number | null
  }

  export type Em_hero_sectionMinAggregateOutputType = {
    hsId: number | null
    hsName: string | null
    hsDesc: string | null
    hsStats: string | null
    hsFileImage: string | null
    hsLink: string | null
    hsUserid: string | null
    hsDate: Date | null
    hsLastupdate: Date | null
    Urutan: number | null
  }

  export type Em_hero_sectionMaxAggregateOutputType = {
    hsId: number | null
    hsName: string | null
    hsDesc: string | null
    hsStats: string | null
    hsFileImage: string | null
    hsLink: string | null
    hsUserid: string | null
    hsDate: Date | null
    hsLastupdate: Date | null
    Urutan: number | null
  }

  export type Em_hero_sectionCountAggregateOutputType = {
    hsId: number
    hsName: number
    hsDesc: number
    hsStats: number
    hsFileImage: number
    hsLink: number
    hsUserid: number
    hsDate: number
    hsLastupdate: number
    Urutan: number
    _all: number
  }


  export type Em_hero_sectionAvgAggregateInputType = {
    hsId?: true
    Urutan?: true
  }

  export type Em_hero_sectionSumAggregateInputType = {
    hsId?: true
    Urutan?: true
  }

  export type Em_hero_sectionMinAggregateInputType = {
    hsId?: true
    hsName?: true
    hsDesc?: true
    hsStats?: true
    hsFileImage?: true
    hsLink?: true
    hsUserid?: true
    hsDate?: true
    hsLastupdate?: true
    Urutan?: true
  }

  export type Em_hero_sectionMaxAggregateInputType = {
    hsId?: true
    hsName?: true
    hsDesc?: true
    hsStats?: true
    hsFileImage?: true
    hsLink?: true
    hsUserid?: true
    hsDate?: true
    hsLastupdate?: true
    Urutan?: true
  }

  export type Em_hero_sectionCountAggregateInputType = {
    hsId?: true
    hsName?: true
    hsDesc?: true
    hsStats?: true
    hsFileImage?: true
    hsLink?: true
    hsUserid?: true
    hsDate?: true
    hsLastupdate?: true
    Urutan?: true
    _all?: true
  }

  export type Em_hero_sectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_hero_section to aggregate.
     */
    where?: em_hero_sectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_hero_sections to fetch.
     */
    orderBy?: em_hero_sectionOrderByWithRelationInput | em_hero_sectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_hero_sectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_hero_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_hero_sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_hero_sections
    **/
    _count?: true | Em_hero_sectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_hero_sectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_hero_sectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_hero_sectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_hero_sectionMaxAggregateInputType
  }

  export type GetEm_hero_sectionAggregateType<T extends Em_hero_sectionAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_hero_section]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_hero_section[P]>
      : GetScalarType<T[P], AggregateEm_hero_section[P]>
  }




  export type em_hero_sectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_hero_sectionWhereInput
    orderBy?: em_hero_sectionOrderByWithAggregationInput | em_hero_sectionOrderByWithAggregationInput[]
    by: Em_hero_sectionScalarFieldEnum[] | Em_hero_sectionScalarFieldEnum
    having?: em_hero_sectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_hero_sectionCountAggregateInputType | true
    _avg?: Em_hero_sectionAvgAggregateInputType
    _sum?: Em_hero_sectionSumAggregateInputType
    _min?: Em_hero_sectionMinAggregateInputType
    _max?: Em_hero_sectionMaxAggregateInputType
  }

  export type Em_hero_sectionGroupByOutputType = {
    hsId: number
    hsName: string | null
    hsDesc: string | null
    hsStats: string | null
    hsFileImage: string | null
    hsLink: string | null
    hsUserid: string | null
    hsDate: Date | null
    hsLastupdate: Date | null
    Urutan: number | null
    _count: Em_hero_sectionCountAggregateOutputType | null
    _avg: Em_hero_sectionAvgAggregateOutputType | null
    _sum: Em_hero_sectionSumAggregateOutputType | null
    _min: Em_hero_sectionMinAggregateOutputType | null
    _max: Em_hero_sectionMaxAggregateOutputType | null
  }

  type GetEm_hero_sectionGroupByPayload<T extends em_hero_sectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_hero_sectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_hero_sectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_hero_sectionGroupByOutputType[P]>
            : GetScalarType<T[P], Em_hero_sectionGroupByOutputType[P]>
        }
      >
    >


  export type em_hero_sectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hsId?: boolean
    hsName?: boolean
    hsDesc?: boolean
    hsStats?: boolean
    hsFileImage?: boolean
    hsLink?: boolean
    hsUserid?: boolean
    hsDate?: boolean
    hsLastupdate?: boolean
    Urutan?: boolean
  }, ExtArgs["result"]["em_hero_section"]>



  export type em_hero_sectionSelectScalar = {
    hsId?: boolean
    hsName?: boolean
    hsDesc?: boolean
    hsStats?: boolean
    hsFileImage?: boolean
    hsLink?: boolean
    hsUserid?: boolean
    hsDate?: boolean
    hsLastupdate?: boolean
    Urutan?: boolean
  }

  export type em_hero_sectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hsId" | "hsName" | "hsDesc" | "hsStats" | "hsFileImage" | "hsLink" | "hsUserid" | "hsDate" | "hsLastupdate" | "Urutan", ExtArgs["result"]["em_hero_section"]>

  export type $em_hero_sectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_hero_section"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hsId: number
      hsName: string | null
      hsDesc: string | null
      hsStats: string | null
      hsFileImage: string | null
      hsLink: string | null
      hsUserid: string | null
      hsDate: Date | null
      hsLastupdate: Date | null
      Urutan: number | null
    }, ExtArgs["result"]["em_hero_section"]>
    composites: {}
  }

  type em_hero_sectionGetPayload<S extends boolean | null | undefined | em_hero_sectionDefaultArgs> = $Result.GetResult<Prisma.$em_hero_sectionPayload, S>

  type em_hero_sectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_hero_sectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_hero_sectionCountAggregateInputType | true
    }

  export interface em_hero_sectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_hero_section'], meta: { name: 'em_hero_section' } }
    /**
     * Find zero or one Em_hero_section that matches the filter.
     * @param {em_hero_sectionFindUniqueArgs} args - Arguments to find a Em_hero_section
     * @example
     * // Get one Em_hero_section
     * const em_hero_section = await prisma.em_hero_section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_hero_sectionFindUniqueArgs>(args: SelectSubset<T, em_hero_sectionFindUniqueArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_hero_section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_hero_sectionFindUniqueOrThrowArgs} args - Arguments to find a Em_hero_section
     * @example
     * // Get one Em_hero_section
     * const em_hero_section = await prisma.em_hero_section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_hero_sectionFindUniqueOrThrowArgs>(args: SelectSubset<T, em_hero_sectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_hero_section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_hero_sectionFindFirstArgs} args - Arguments to find a Em_hero_section
     * @example
     * // Get one Em_hero_section
     * const em_hero_section = await prisma.em_hero_section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_hero_sectionFindFirstArgs>(args?: SelectSubset<T, em_hero_sectionFindFirstArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_hero_section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_hero_sectionFindFirstOrThrowArgs} args - Arguments to find a Em_hero_section
     * @example
     * // Get one Em_hero_section
     * const em_hero_section = await prisma.em_hero_section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_hero_sectionFindFirstOrThrowArgs>(args?: SelectSubset<T, em_hero_sectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_hero_sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_hero_sectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_hero_sections
     * const em_hero_sections = await prisma.em_hero_section.findMany()
     * 
     * // Get first 10 Em_hero_sections
     * const em_hero_sections = await prisma.em_hero_section.findMany({ take: 10 })
     * 
     * // Only select the `hsId`
     * const em_hero_sectionWithHsIdOnly = await prisma.em_hero_section.findMany({ select: { hsId: true } })
     * 
     */
    findMany<T extends em_hero_sectionFindManyArgs>(args?: SelectSubset<T, em_hero_sectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_hero_section.
     * @param {em_hero_sectionCreateArgs} args - Arguments to create a Em_hero_section.
     * @example
     * // Create one Em_hero_section
     * const Em_hero_section = await prisma.em_hero_section.create({
     *   data: {
     *     // ... data to create a Em_hero_section
     *   }
     * })
     * 
     */
    create<T extends em_hero_sectionCreateArgs>(args: SelectSubset<T, em_hero_sectionCreateArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_hero_sections.
     * @param {em_hero_sectionCreateManyArgs} args - Arguments to create many Em_hero_sections.
     * @example
     * // Create many Em_hero_sections
     * const em_hero_section = await prisma.em_hero_section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_hero_sectionCreateManyArgs>(args?: SelectSubset<T, em_hero_sectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_hero_section.
     * @param {em_hero_sectionDeleteArgs} args - Arguments to delete one Em_hero_section.
     * @example
     * // Delete one Em_hero_section
     * const Em_hero_section = await prisma.em_hero_section.delete({
     *   where: {
     *     // ... filter to delete one Em_hero_section
     *   }
     * })
     * 
     */
    delete<T extends em_hero_sectionDeleteArgs>(args: SelectSubset<T, em_hero_sectionDeleteArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_hero_section.
     * @param {em_hero_sectionUpdateArgs} args - Arguments to update one Em_hero_section.
     * @example
     * // Update one Em_hero_section
     * const em_hero_section = await prisma.em_hero_section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_hero_sectionUpdateArgs>(args: SelectSubset<T, em_hero_sectionUpdateArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_hero_sections.
     * @param {em_hero_sectionDeleteManyArgs} args - Arguments to filter Em_hero_sections to delete.
     * @example
     * // Delete a few Em_hero_sections
     * const { count } = await prisma.em_hero_section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_hero_sectionDeleteManyArgs>(args?: SelectSubset<T, em_hero_sectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_hero_sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_hero_sectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_hero_sections
     * const em_hero_section = await prisma.em_hero_section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_hero_sectionUpdateManyArgs>(args: SelectSubset<T, em_hero_sectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_hero_section.
     * @param {em_hero_sectionUpsertArgs} args - Arguments to update or create a Em_hero_section.
     * @example
     * // Update or create a Em_hero_section
     * const em_hero_section = await prisma.em_hero_section.upsert({
     *   create: {
     *     // ... data to create a Em_hero_section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_hero_section we want to update
     *   }
     * })
     */
    upsert<T extends em_hero_sectionUpsertArgs>(args: SelectSubset<T, em_hero_sectionUpsertArgs<ExtArgs>>): Prisma__em_hero_sectionClient<$Result.GetResult<Prisma.$em_hero_sectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_hero_sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_hero_sectionCountArgs} args - Arguments to filter Em_hero_sections to count.
     * @example
     * // Count the number of Em_hero_sections
     * const count = await prisma.em_hero_section.count({
     *   where: {
     *     // ... the filter for the Em_hero_sections we want to count
     *   }
     * })
    **/
    count<T extends em_hero_sectionCountArgs>(
      args?: Subset<T, em_hero_sectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_hero_sectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_hero_section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_hero_sectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_hero_sectionAggregateArgs>(args: Subset<T, Em_hero_sectionAggregateArgs>): Prisma.PrismaPromise<GetEm_hero_sectionAggregateType<T>>

    /**
     * Group by Em_hero_section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_hero_sectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_hero_sectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_hero_sectionGroupByArgs['orderBy'] }
        : { orderBy?: em_hero_sectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_hero_sectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_hero_sectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_hero_section model
   */
  readonly fields: em_hero_sectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_hero_section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_hero_sectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_hero_section model
   */
  interface em_hero_sectionFieldRefs {
    readonly hsId: FieldRef<"em_hero_section", 'Int'>
    readonly hsName: FieldRef<"em_hero_section", 'String'>
    readonly hsDesc: FieldRef<"em_hero_section", 'String'>
    readonly hsStats: FieldRef<"em_hero_section", 'String'>
    readonly hsFileImage: FieldRef<"em_hero_section", 'String'>
    readonly hsLink: FieldRef<"em_hero_section", 'String'>
    readonly hsUserid: FieldRef<"em_hero_section", 'String'>
    readonly hsDate: FieldRef<"em_hero_section", 'DateTime'>
    readonly hsLastupdate: FieldRef<"em_hero_section", 'DateTime'>
    readonly Urutan: FieldRef<"em_hero_section", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_hero_section findUnique
   */
  export type em_hero_sectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * Filter, which em_hero_section to fetch.
     */
    where: em_hero_sectionWhereUniqueInput
  }

  /**
   * em_hero_section findUniqueOrThrow
   */
  export type em_hero_sectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * Filter, which em_hero_section to fetch.
     */
    where: em_hero_sectionWhereUniqueInput
  }

  /**
   * em_hero_section findFirst
   */
  export type em_hero_sectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * Filter, which em_hero_section to fetch.
     */
    where?: em_hero_sectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_hero_sections to fetch.
     */
    orderBy?: em_hero_sectionOrderByWithRelationInput | em_hero_sectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_hero_sections.
     */
    cursor?: em_hero_sectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_hero_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_hero_sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_hero_sections.
     */
    distinct?: Em_hero_sectionScalarFieldEnum | Em_hero_sectionScalarFieldEnum[]
  }

  /**
   * em_hero_section findFirstOrThrow
   */
  export type em_hero_sectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * Filter, which em_hero_section to fetch.
     */
    where?: em_hero_sectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_hero_sections to fetch.
     */
    orderBy?: em_hero_sectionOrderByWithRelationInput | em_hero_sectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_hero_sections.
     */
    cursor?: em_hero_sectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_hero_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_hero_sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_hero_sections.
     */
    distinct?: Em_hero_sectionScalarFieldEnum | Em_hero_sectionScalarFieldEnum[]
  }

  /**
   * em_hero_section findMany
   */
  export type em_hero_sectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * Filter, which em_hero_sections to fetch.
     */
    where?: em_hero_sectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_hero_sections to fetch.
     */
    orderBy?: em_hero_sectionOrderByWithRelationInput | em_hero_sectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_hero_sections.
     */
    cursor?: em_hero_sectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_hero_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_hero_sections.
     */
    skip?: number
    distinct?: Em_hero_sectionScalarFieldEnum | Em_hero_sectionScalarFieldEnum[]
  }

  /**
   * em_hero_section create
   */
  export type em_hero_sectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * The data needed to create a em_hero_section.
     */
    data?: XOR<em_hero_sectionCreateInput, em_hero_sectionUncheckedCreateInput>
  }

  /**
   * em_hero_section createMany
   */
  export type em_hero_sectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_hero_sections.
     */
    data: em_hero_sectionCreateManyInput | em_hero_sectionCreateManyInput[]
  }

  /**
   * em_hero_section update
   */
  export type em_hero_sectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * The data needed to update a em_hero_section.
     */
    data: XOR<em_hero_sectionUpdateInput, em_hero_sectionUncheckedUpdateInput>
    /**
     * Choose, which em_hero_section to update.
     */
    where: em_hero_sectionWhereUniqueInput
  }

  /**
   * em_hero_section updateMany
   */
  export type em_hero_sectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_hero_sections.
     */
    data: XOR<em_hero_sectionUpdateManyMutationInput, em_hero_sectionUncheckedUpdateManyInput>
    /**
     * Filter which em_hero_sections to update
     */
    where?: em_hero_sectionWhereInput
    /**
     * Limit how many em_hero_sections to update.
     */
    limit?: number
  }

  /**
   * em_hero_section upsert
   */
  export type em_hero_sectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * The filter to search for the em_hero_section to update in case it exists.
     */
    where: em_hero_sectionWhereUniqueInput
    /**
     * In case the em_hero_section found by the `where` argument doesn't exist, create a new em_hero_section with this data.
     */
    create: XOR<em_hero_sectionCreateInput, em_hero_sectionUncheckedCreateInput>
    /**
     * In case the em_hero_section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_hero_sectionUpdateInput, em_hero_sectionUncheckedUpdateInput>
  }

  /**
   * em_hero_section delete
   */
  export type em_hero_sectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
    /**
     * Filter which em_hero_section to delete.
     */
    where: em_hero_sectionWhereUniqueInput
  }

  /**
   * em_hero_section deleteMany
   */
  export type em_hero_sectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_hero_sections to delete
     */
    where?: em_hero_sectionWhereInput
    /**
     * Limit how many em_hero_sections to delete.
     */
    limit?: number
  }

  /**
   * em_hero_section without action
   */
  export type em_hero_sectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_hero_section
     */
    select?: em_hero_sectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_hero_section
     */
    omit?: em_hero_sectionOmit<ExtArgs> | null
  }


  /**
   * Model em_jawaban_peserta
   */

  export type AggregateEm_jawaban_peserta = {
    _count: Em_jawaban_pesertaCountAggregateOutputType | null
    _avg: Em_jawaban_pesertaAvgAggregateOutputType | null
    _sum: Em_jawaban_pesertaSumAggregateOutputType | null
    _min: Em_jawaban_pesertaMinAggregateOutputType | null
    _max: Em_jawaban_pesertaMaxAggregateOutputType | null
  }

  export type Em_jawaban_pesertaAvgAggregateOutputType = {
    Id: number | null
    empl_id: number | null
    soal_id: number | null
    Score: number | null
    is_correction: number | null
  }

  export type Em_jawaban_pesertaSumAggregateOutputType = {
    Id: number | null
    empl_id: number | null
    soal_id: number | null
    Score: number | null
    is_correction: number | null
  }

  export type Em_jawaban_pesertaMinAggregateOutputType = {
    Id: number | null
    empl_id: number | null
    soal_id: number | null
    session_exams_id: string | null
    jawaban: string | null
    jawaban2: string | null
    waktu_jawab: Date | null
    Score: number | null
    is_correction: number | null
    is_train_jawaban: boolean | null
  }

  export type Em_jawaban_pesertaMaxAggregateOutputType = {
    Id: number | null
    empl_id: number | null
    soal_id: number | null
    session_exams_id: string | null
    jawaban: string | null
    jawaban2: string | null
    waktu_jawab: Date | null
    Score: number | null
    is_correction: number | null
    is_train_jawaban: boolean | null
  }

  export type Em_jawaban_pesertaCountAggregateOutputType = {
    Id: number
    empl_id: number
    soal_id: number
    session_exams_id: number
    jawaban: number
    jawaban2: number
    waktu_jawab: number
    Score: number
    is_correction: number
    is_train_jawaban: number
    _all: number
  }


  export type Em_jawaban_pesertaAvgAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    Score?: true
    is_correction?: true
  }

  export type Em_jawaban_pesertaSumAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    Score?: true
    is_correction?: true
  }

  export type Em_jawaban_pesertaMinAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    session_exams_id?: true
    jawaban?: true
    jawaban2?: true
    waktu_jawab?: true
    Score?: true
    is_correction?: true
    is_train_jawaban?: true
  }

  export type Em_jawaban_pesertaMaxAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    session_exams_id?: true
    jawaban?: true
    jawaban2?: true
    waktu_jawab?: true
    Score?: true
    is_correction?: true
    is_train_jawaban?: true
  }

  export type Em_jawaban_pesertaCountAggregateInputType = {
    Id?: true
    empl_id?: true
    soal_id?: true
    session_exams_id?: true
    jawaban?: true
    jawaban2?: true
    waktu_jawab?: true
    Score?: true
    is_correction?: true
    is_train_jawaban?: true
    _all?: true
  }

  export type Em_jawaban_pesertaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_jawaban_peserta to aggregate.
     */
    where?: em_jawaban_pesertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_pesertas to fetch.
     */
    orderBy?: em_jawaban_pesertaOrderByWithRelationInput | em_jawaban_pesertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_jawaban_pesertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_pesertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_pesertas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_jawaban_pesertas
    **/
    _count?: true | Em_jawaban_pesertaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_jawaban_pesertaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_jawaban_pesertaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_jawaban_pesertaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_jawaban_pesertaMaxAggregateInputType
  }

  export type GetEm_jawaban_pesertaAggregateType<T extends Em_jawaban_pesertaAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_jawaban_peserta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_jawaban_peserta[P]>
      : GetScalarType<T[P], AggregateEm_jawaban_peserta[P]>
  }




  export type em_jawaban_pesertaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_jawaban_pesertaWhereInput
    orderBy?: em_jawaban_pesertaOrderByWithAggregationInput | em_jawaban_pesertaOrderByWithAggregationInput[]
    by: Em_jawaban_pesertaScalarFieldEnum[] | Em_jawaban_pesertaScalarFieldEnum
    having?: em_jawaban_pesertaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_jawaban_pesertaCountAggregateInputType | true
    _avg?: Em_jawaban_pesertaAvgAggregateInputType
    _sum?: Em_jawaban_pesertaSumAggregateInputType
    _min?: Em_jawaban_pesertaMinAggregateInputType
    _max?: Em_jawaban_pesertaMaxAggregateInputType
  }

  export type Em_jawaban_pesertaGroupByOutputType = {
    Id: number
    empl_id: number
    soal_id: number
    session_exams_id: string
    jawaban: string | null
    jawaban2: string | null
    waktu_jawab: Date | null
    Score: number | null
    is_correction: number | null
    is_train_jawaban: boolean | null
    _count: Em_jawaban_pesertaCountAggregateOutputType | null
    _avg: Em_jawaban_pesertaAvgAggregateOutputType | null
    _sum: Em_jawaban_pesertaSumAggregateOutputType | null
    _min: Em_jawaban_pesertaMinAggregateOutputType | null
    _max: Em_jawaban_pesertaMaxAggregateOutputType | null
  }

  type GetEm_jawaban_pesertaGroupByPayload<T extends em_jawaban_pesertaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_jawaban_pesertaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_jawaban_pesertaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_jawaban_pesertaGroupByOutputType[P]>
            : GetScalarType<T[P], Em_jawaban_pesertaGroupByOutputType[P]>
        }
      >
    >


  export type em_jawaban_pesertaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    empl_id?: boolean
    soal_id?: boolean
    session_exams_id?: boolean
    jawaban?: boolean
    jawaban2?: boolean
    waktu_jawab?: boolean
    Score?: boolean
    is_correction?: boolean
    is_train_jawaban?: boolean
    em_session_exams?: boolean | em_session_examsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_jawaban_peserta"]>



  export type em_jawaban_pesertaSelectScalar = {
    Id?: boolean
    empl_id?: boolean
    soal_id?: boolean
    session_exams_id?: boolean
    jawaban?: boolean
    jawaban2?: boolean
    waktu_jawab?: boolean
    Score?: boolean
    is_correction?: boolean
    is_train_jawaban?: boolean
  }

  export type em_jawaban_pesertaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "empl_id" | "soal_id" | "session_exams_id" | "jawaban" | "jawaban2" | "waktu_jawab" | "Score" | "is_correction" | "is_train_jawaban", ExtArgs["result"]["em_jawaban_peserta"]>
  export type em_jawaban_pesertaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_session_exams?: boolean | em_session_examsDefaultArgs<ExtArgs>
  }

  export type $em_jawaban_pesertaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_jawaban_peserta"
    objects: {
      em_session_exams: Prisma.$em_session_examsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      empl_id: number
      soal_id: number
      session_exams_id: string
      jawaban: string | null
      jawaban2: string | null
      waktu_jawab: Date | null
      Score: number | null
      is_correction: number | null
      is_train_jawaban: boolean | null
    }, ExtArgs["result"]["em_jawaban_peserta"]>
    composites: {}
  }

  type em_jawaban_pesertaGetPayload<S extends boolean | null | undefined | em_jawaban_pesertaDefaultArgs> = $Result.GetResult<Prisma.$em_jawaban_pesertaPayload, S>

  type em_jawaban_pesertaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_jawaban_pesertaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_jawaban_pesertaCountAggregateInputType | true
    }

  export interface em_jawaban_pesertaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_jawaban_peserta'], meta: { name: 'em_jawaban_peserta' } }
    /**
     * Find zero or one Em_jawaban_peserta that matches the filter.
     * @param {em_jawaban_pesertaFindUniqueArgs} args - Arguments to find a Em_jawaban_peserta
     * @example
     * // Get one Em_jawaban_peserta
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_jawaban_pesertaFindUniqueArgs>(args: SelectSubset<T, em_jawaban_pesertaFindUniqueArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_jawaban_peserta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_jawaban_pesertaFindUniqueOrThrowArgs} args - Arguments to find a Em_jawaban_peserta
     * @example
     * // Get one Em_jawaban_peserta
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_jawaban_pesertaFindUniqueOrThrowArgs>(args: SelectSubset<T, em_jawaban_pesertaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_jawaban_peserta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_pesertaFindFirstArgs} args - Arguments to find a Em_jawaban_peserta
     * @example
     * // Get one Em_jawaban_peserta
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_jawaban_pesertaFindFirstArgs>(args?: SelectSubset<T, em_jawaban_pesertaFindFirstArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_jawaban_peserta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_pesertaFindFirstOrThrowArgs} args - Arguments to find a Em_jawaban_peserta
     * @example
     * // Get one Em_jawaban_peserta
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_jawaban_pesertaFindFirstOrThrowArgs>(args?: SelectSubset<T, em_jawaban_pesertaFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_jawaban_pesertas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_pesertaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_jawaban_pesertas
     * const em_jawaban_pesertas = await prisma.em_jawaban_peserta.findMany()
     * 
     * // Get first 10 Em_jawaban_pesertas
     * const em_jawaban_pesertas = await prisma.em_jawaban_peserta.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_jawaban_pesertaWithIdOnly = await prisma.em_jawaban_peserta.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_jawaban_pesertaFindManyArgs>(args?: SelectSubset<T, em_jawaban_pesertaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_jawaban_peserta.
     * @param {em_jawaban_pesertaCreateArgs} args - Arguments to create a Em_jawaban_peserta.
     * @example
     * // Create one Em_jawaban_peserta
     * const Em_jawaban_peserta = await prisma.em_jawaban_peserta.create({
     *   data: {
     *     // ... data to create a Em_jawaban_peserta
     *   }
     * })
     * 
     */
    create<T extends em_jawaban_pesertaCreateArgs>(args: SelectSubset<T, em_jawaban_pesertaCreateArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_jawaban_pesertas.
     * @param {em_jawaban_pesertaCreateManyArgs} args - Arguments to create many Em_jawaban_pesertas.
     * @example
     * // Create many Em_jawaban_pesertas
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_jawaban_pesertaCreateManyArgs>(args?: SelectSubset<T, em_jawaban_pesertaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_jawaban_peserta.
     * @param {em_jawaban_pesertaDeleteArgs} args - Arguments to delete one Em_jawaban_peserta.
     * @example
     * // Delete one Em_jawaban_peserta
     * const Em_jawaban_peserta = await prisma.em_jawaban_peserta.delete({
     *   where: {
     *     // ... filter to delete one Em_jawaban_peserta
     *   }
     * })
     * 
     */
    delete<T extends em_jawaban_pesertaDeleteArgs>(args: SelectSubset<T, em_jawaban_pesertaDeleteArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_jawaban_peserta.
     * @param {em_jawaban_pesertaUpdateArgs} args - Arguments to update one Em_jawaban_peserta.
     * @example
     * // Update one Em_jawaban_peserta
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_jawaban_pesertaUpdateArgs>(args: SelectSubset<T, em_jawaban_pesertaUpdateArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_jawaban_pesertas.
     * @param {em_jawaban_pesertaDeleteManyArgs} args - Arguments to filter Em_jawaban_pesertas to delete.
     * @example
     * // Delete a few Em_jawaban_pesertas
     * const { count } = await prisma.em_jawaban_peserta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_jawaban_pesertaDeleteManyArgs>(args?: SelectSubset<T, em_jawaban_pesertaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_jawaban_pesertas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_pesertaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_jawaban_pesertas
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_jawaban_pesertaUpdateManyArgs>(args: SelectSubset<T, em_jawaban_pesertaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_jawaban_peserta.
     * @param {em_jawaban_pesertaUpsertArgs} args - Arguments to update or create a Em_jawaban_peserta.
     * @example
     * // Update or create a Em_jawaban_peserta
     * const em_jawaban_peserta = await prisma.em_jawaban_peserta.upsert({
     *   create: {
     *     // ... data to create a Em_jawaban_peserta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_jawaban_peserta we want to update
     *   }
     * })
     */
    upsert<T extends em_jawaban_pesertaUpsertArgs>(args: SelectSubset<T, em_jawaban_pesertaUpsertArgs<ExtArgs>>): Prisma__em_jawaban_pesertaClient<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_jawaban_pesertas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_pesertaCountArgs} args - Arguments to filter Em_jawaban_pesertas to count.
     * @example
     * // Count the number of Em_jawaban_pesertas
     * const count = await prisma.em_jawaban_peserta.count({
     *   where: {
     *     // ... the filter for the Em_jawaban_pesertas we want to count
     *   }
     * })
    **/
    count<T extends em_jawaban_pesertaCountArgs>(
      args?: Subset<T, em_jawaban_pesertaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_jawaban_pesertaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_jawaban_peserta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_jawaban_pesertaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_jawaban_pesertaAggregateArgs>(args: Subset<T, Em_jawaban_pesertaAggregateArgs>): Prisma.PrismaPromise<GetEm_jawaban_pesertaAggregateType<T>>

    /**
     * Group by Em_jawaban_peserta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_pesertaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_jawaban_pesertaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_jawaban_pesertaGroupByArgs['orderBy'] }
        : { orderBy?: em_jawaban_pesertaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_jawaban_pesertaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_jawaban_pesertaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_jawaban_peserta model
   */
  readonly fields: em_jawaban_pesertaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_jawaban_peserta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_jawaban_pesertaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_session_exams<T extends em_session_examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_session_examsDefaultArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_jawaban_peserta model
   */
  interface em_jawaban_pesertaFieldRefs {
    readonly Id: FieldRef<"em_jawaban_peserta", 'Int'>
    readonly empl_id: FieldRef<"em_jawaban_peserta", 'Int'>
    readonly soal_id: FieldRef<"em_jawaban_peserta", 'Int'>
    readonly session_exams_id: FieldRef<"em_jawaban_peserta", 'String'>
    readonly jawaban: FieldRef<"em_jawaban_peserta", 'String'>
    readonly jawaban2: FieldRef<"em_jawaban_peserta", 'String'>
    readonly waktu_jawab: FieldRef<"em_jawaban_peserta", 'DateTime'>
    readonly Score: FieldRef<"em_jawaban_peserta", 'Float'>
    readonly is_correction: FieldRef<"em_jawaban_peserta", 'Int'>
    readonly is_train_jawaban: FieldRef<"em_jawaban_peserta", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * em_jawaban_peserta findUnique
   */
  export type em_jawaban_pesertaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta to fetch.
     */
    where: em_jawaban_pesertaWhereUniqueInput
  }

  /**
   * em_jawaban_peserta findUniqueOrThrow
   */
  export type em_jawaban_pesertaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta to fetch.
     */
    where: em_jawaban_pesertaWhereUniqueInput
  }

  /**
   * em_jawaban_peserta findFirst
   */
  export type em_jawaban_pesertaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta to fetch.
     */
    where?: em_jawaban_pesertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_pesertas to fetch.
     */
    orderBy?: em_jawaban_pesertaOrderByWithRelationInput | em_jawaban_pesertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_jawaban_pesertas.
     */
    cursor?: em_jawaban_pesertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_pesertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_pesertas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_jawaban_pesertas.
     */
    distinct?: Em_jawaban_pesertaScalarFieldEnum | Em_jawaban_pesertaScalarFieldEnum[]
  }

  /**
   * em_jawaban_peserta findFirstOrThrow
   */
  export type em_jawaban_pesertaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta to fetch.
     */
    where?: em_jawaban_pesertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_pesertas to fetch.
     */
    orderBy?: em_jawaban_pesertaOrderByWithRelationInput | em_jawaban_pesertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_jawaban_pesertas.
     */
    cursor?: em_jawaban_pesertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_pesertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_pesertas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_jawaban_pesertas.
     */
    distinct?: Em_jawaban_pesertaScalarFieldEnum | Em_jawaban_pesertaScalarFieldEnum[]
  }

  /**
   * em_jawaban_peserta findMany
   */
  export type em_jawaban_pesertaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_pesertas to fetch.
     */
    where?: em_jawaban_pesertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_pesertas to fetch.
     */
    orderBy?: em_jawaban_pesertaOrderByWithRelationInput | em_jawaban_pesertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_jawaban_pesertas.
     */
    cursor?: em_jawaban_pesertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_pesertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_pesertas.
     */
    skip?: number
    distinct?: Em_jawaban_pesertaScalarFieldEnum | Em_jawaban_pesertaScalarFieldEnum[]
  }

  /**
   * em_jawaban_peserta create
   */
  export type em_jawaban_pesertaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * The data needed to create a em_jawaban_peserta.
     */
    data: XOR<em_jawaban_pesertaCreateInput, em_jawaban_pesertaUncheckedCreateInput>
  }

  /**
   * em_jawaban_peserta createMany
   */
  export type em_jawaban_pesertaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_jawaban_pesertas.
     */
    data: em_jawaban_pesertaCreateManyInput | em_jawaban_pesertaCreateManyInput[]
  }

  /**
   * em_jawaban_peserta update
   */
  export type em_jawaban_pesertaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * The data needed to update a em_jawaban_peserta.
     */
    data: XOR<em_jawaban_pesertaUpdateInput, em_jawaban_pesertaUncheckedUpdateInput>
    /**
     * Choose, which em_jawaban_peserta to update.
     */
    where: em_jawaban_pesertaWhereUniqueInput
  }

  /**
   * em_jawaban_peserta updateMany
   */
  export type em_jawaban_pesertaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_jawaban_pesertas.
     */
    data: XOR<em_jawaban_pesertaUpdateManyMutationInput, em_jawaban_pesertaUncheckedUpdateManyInput>
    /**
     * Filter which em_jawaban_pesertas to update
     */
    where?: em_jawaban_pesertaWhereInput
    /**
     * Limit how many em_jawaban_pesertas to update.
     */
    limit?: number
  }

  /**
   * em_jawaban_peserta upsert
   */
  export type em_jawaban_pesertaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * The filter to search for the em_jawaban_peserta to update in case it exists.
     */
    where: em_jawaban_pesertaWhereUniqueInput
    /**
     * In case the em_jawaban_peserta found by the `where` argument doesn't exist, create a new em_jawaban_peserta with this data.
     */
    create: XOR<em_jawaban_pesertaCreateInput, em_jawaban_pesertaUncheckedCreateInput>
    /**
     * In case the em_jawaban_peserta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_jawaban_pesertaUpdateInput, em_jawaban_pesertaUncheckedUpdateInput>
  }

  /**
   * em_jawaban_peserta delete
   */
  export type em_jawaban_pesertaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    /**
     * Filter which em_jawaban_peserta to delete.
     */
    where: em_jawaban_pesertaWhereUniqueInput
  }

  /**
   * em_jawaban_peserta deleteMany
   */
  export type em_jawaban_pesertaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_jawaban_pesertas to delete
     */
    where?: em_jawaban_pesertaWhereInput
    /**
     * Limit how many em_jawaban_pesertas to delete.
     */
    limit?: number
  }

  /**
   * em_jawaban_peserta without action
   */
  export type em_jawaban_pesertaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
  }


  /**
   * Model em_jawaban_peserta_apc
   */

  export type AggregateEm_jawaban_peserta_apc = {
    _count: Em_jawaban_peserta_apcCountAggregateOutputType | null
    _avg: Em_jawaban_peserta_apcAvgAggregateOutputType | null
    _sum: Em_jawaban_peserta_apcSumAggregateOutputType | null
    _min: Em_jawaban_peserta_apcMinAggregateOutputType | null
    _max: Em_jawaban_peserta_apcMaxAggregateOutputType | null
  }

  export type Em_jawaban_peserta_apcAvgAggregateOutputType = {
    Id: number | null
    apc_id: number | null
    soal_id: number | null
    topic_id: number | null
    score: number | null
  }

  export type Em_jawaban_peserta_apcSumAggregateOutputType = {
    Id: number | null
    apc_id: number | null
    soal_id: number | null
    topic_id: number | null
    score: number | null
  }

  export type Em_jawaban_peserta_apcMinAggregateOutputType = {
    Id: number | null
    apc_id: number | null
    soal_id: number | null
    topic_id: number | null
    session_exams_id: string | null
    jawaban_option: string | null
    jawaban_text: string | null
    waktu_jawab: Date | null
    score: number | null
    is_correction: boolean | null
    is_train_jawaban: boolean | null
  }

  export type Em_jawaban_peserta_apcMaxAggregateOutputType = {
    Id: number | null
    apc_id: number | null
    soal_id: number | null
    topic_id: number | null
    session_exams_id: string | null
    jawaban_option: string | null
    jawaban_text: string | null
    waktu_jawab: Date | null
    score: number | null
    is_correction: boolean | null
    is_train_jawaban: boolean | null
  }

  export type Em_jawaban_peserta_apcCountAggregateOutputType = {
    Id: number
    apc_id: number
    soal_id: number
    topic_id: number
    session_exams_id: number
    jawaban_option: number
    jawaban_text: number
    waktu_jawab: number
    score: number
    is_correction: number
    is_train_jawaban: number
    _all: number
  }


  export type Em_jawaban_peserta_apcAvgAggregateInputType = {
    Id?: true
    apc_id?: true
    soal_id?: true
    topic_id?: true
    score?: true
  }

  export type Em_jawaban_peserta_apcSumAggregateInputType = {
    Id?: true
    apc_id?: true
    soal_id?: true
    topic_id?: true
    score?: true
  }

  export type Em_jawaban_peserta_apcMinAggregateInputType = {
    Id?: true
    apc_id?: true
    soal_id?: true
    topic_id?: true
    session_exams_id?: true
    jawaban_option?: true
    jawaban_text?: true
    waktu_jawab?: true
    score?: true
    is_correction?: true
    is_train_jawaban?: true
  }

  export type Em_jawaban_peserta_apcMaxAggregateInputType = {
    Id?: true
    apc_id?: true
    soal_id?: true
    topic_id?: true
    session_exams_id?: true
    jawaban_option?: true
    jawaban_text?: true
    waktu_jawab?: true
    score?: true
    is_correction?: true
    is_train_jawaban?: true
  }

  export type Em_jawaban_peserta_apcCountAggregateInputType = {
    Id?: true
    apc_id?: true
    soal_id?: true
    topic_id?: true
    session_exams_id?: true
    jawaban_option?: true
    jawaban_text?: true
    waktu_jawab?: true
    score?: true
    is_correction?: true
    is_train_jawaban?: true
    _all?: true
  }

  export type Em_jawaban_peserta_apcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_jawaban_peserta_apc to aggregate.
     */
    where?: em_jawaban_peserta_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_peserta_apcs to fetch.
     */
    orderBy?: em_jawaban_peserta_apcOrderByWithRelationInput | em_jawaban_peserta_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_jawaban_peserta_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_peserta_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_peserta_apcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_jawaban_peserta_apcs
    **/
    _count?: true | Em_jawaban_peserta_apcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_jawaban_peserta_apcAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_jawaban_peserta_apcSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_jawaban_peserta_apcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_jawaban_peserta_apcMaxAggregateInputType
  }

  export type GetEm_jawaban_peserta_apcAggregateType<T extends Em_jawaban_peserta_apcAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_jawaban_peserta_apc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_jawaban_peserta_apc[P]>
      : GetScalarType<T[P], AggregateEm_jawaban_peserta_apc[P]>
  }




  export type em_jawaban_peserta_apcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_jawaban_peserta_apcWhereInput
    orderBy?: em_jawaban_peserta_apcOrderByWithAggregationInput | em_jawaban_peserta_apcOrderByWithAggregationInput[]
    by: Em_jawaban_peserta_apcScalarFieldEnum[] | Em_jawaban_peserta_apcScalarFieldEnum
    having?: em_jawaban_peserta_apcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_jawaban_peserta_apcCountAggregateInputType | true
    _avg?: Em_jawaban_peserta_apcAvgAggregateInputType
    _sum?: Em_jawaban_peserta_apcSumAggregateInputType
    _min?: Em_jawaban_peserta_apcMinAggregateInputType
    _max?: Em_jawaban_peserta_apcMaxAggregateInputType
  }

  export type Em_jawaban_peserta_apcGroupByOutputType = {
    Id: number
    apc_id: number
    soal_id: number
    topic_id: number
    session_exams_id: string
    jawaban_option: string | null
    jawaban_text: string | null
    waktu_jawab: Date | null
    score: number | null
    is_correction: boolean | null
    is_train_jawaban: boolean | null
    _count: Em_jawaban_peserta_apcCountAggregateOutputType | null
    _avg: Em_jawaban_peserta_apcAvgAggregateOutputType | null
    _sum: Em_jawaban_peserta_apcSumAggregateOutputType | null
    _min: Em_jawaban_peserta_apcMinAggregateOutputType | null
    _max: Em_jawaban_peserta_apcMaxAggregateOutputType | null
  }

  type GetEm_jawaban_peserta_apcGroupByPayload<T extends em_jawaban_peserta_apcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_jawaban_peserta_apcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_jawaban_peserta_apcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_jawaban_peserta_apcGroupByOutputType[P]>
            : GetScalarType<T[P], Em_jawaban_peserta_apcGroupByOutputType[P]>
        }
      >
    >


  export type em_jawaban_peserta_apcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    apc_id?: boolean
    soal_id?: boolean
    topic_id?: boolean
    session_exams_id?: boolean
    jawaban_option?: boolean
    jawaban_text?: boolean
    waktu_jawab?: boolean
    score?: boolean
    is_correction?: boolean
    is_train_jawaban?: boolean
    em_session_exams_apc?: boolean | em_session_exams_apcDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_jawaban_peserta_apc"]>



  export type em_jawaban_peserta_apcSelectScalar = {
    Id?: boolean
    apc_id?: boolean
    soal_id?: boolean
    topic_id?: boolean
    session_exams_id?: boolean
    jawaban_option?: boolean
    jawaban_text?: boolean
    waktu_jawab?: boolean
    score?: boolean
    is_correction?: boolean
    is_train_jawaban?: boolean
  }

  export type em_jawaban_peserta_apcOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "apc_id" | "soal_id" | "topic_id" | "session_exams_id" | "jawaban_option" | "jawaban_text" | "waktu_jawab" | "score" | "is_correction" | "is_train_jawaban", ExtArgs["result"]["em_jawaban_peserta_apc"]>
  export type em_jawaban_peserta_apcInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_session_exams_apc?: boolean | em_session_exams_apcDefaultArgs<ExtArgs>
  }

  export type $em_jawaban_peserta_apcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_jawaban_peserta_apc"
    objects: {
      em_session_exams_apc: Prisma.$em_session_exams_apcPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      apc_id: number
      soal_id: number
      topic_id: number
      session_exams_id: string
      jawaban_option: string | null
      jawaban_text: string | null
      waktu_jawab: Date | null
      score: number | null
      is_correction: boolean | null
      is_train_jawaban: boolean | null
    }, ExtArgs["result"]["em_jawaban_peserta_apc"]>
    composites: {}
  }

  type em_jawaban_peserta_apcGetPayload<S extends boolean | null | undefined | em_jawaban_peserta_apcDefaultArgs> = $Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload, S>

  type em_jawaban_peserta_apcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_jawaban_peserta_apcFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_jawaban_peserta_apcCountAggregateInputType | true
    }

  export interface em_jawaban_peserta_apcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_jawaban_peserta_apc'], meta: { name: 'em_jawaban_peserta_apc' } }
    /**
     * Find zero or one Em_jawaban_peserta_apc that matches the filter.
     * @param {em_jawaban_peserta_apcFindUniqueArgs} args - Arguments to find a Em_jawaban_peserta_apc
     * @example
     * // Get one Em_jawaban_peserta_apc
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_jawaban_peserta_apcFindUniqueArgs>(args: SelectSubset<T, em_jawaban_peserta_apcFindUniqueArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_jawaban_peserta_apc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_jawaban_peserta_apcFindUniqueOrThrowArgs} args - Arguments to find a Em_jawaban_peserta_apc
     * @example
     * // Get one Em_jawaban_peserta_apc
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_jawaban_peserta_apcFindUniqueOrThrowArgs>(args: SelectSubset<T, em_jawaban_peserta_apcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_jawaban_peserta_apc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_peserta_apcFindFirstArgs} args - Arguments to find a Em_jawaban_peserta_apc
     * @example
     * // Get one Em_jawaban_peserta_apc
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_jawaban_peserta_apcFindFirstArgs>(args?: SelectSubset<T, em_jawaban_peserta_apcFindFirstArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_jawaban_peserta_apc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_peserta_apcFindFirstOrThrowArgs} args - Arguments to find a Em_jawaban_peserta_apc
     * @example
     * // Get one Em_jawaban_peserta_apc
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_jawaban_peserta_apcFindFirstOrThrowArgs>(args?: SelectSubset<T, em_jawaban_peserta_apcFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_jawaban_peserta_apcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_peserta_apcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_jawaban_peserta_apcs
     * const em_jawaban_peserta_apcs = await prisma.em_jawaban_peserta_apc.findMany()
     * 
     * // Get first 10 Em_jawaban_peserta_apcs
     * const em_jawaban_peserta_apcs = await prisma.em_jawaban_peserta_apc.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_jawaban_peserta_apcWithIdOnly = await prisma.em_jawaban_peserta_apc.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_jawaban_peserta_apcFindManyArgs>(args?: SelectSubset<T, em_jawaban_peserta_apcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_jawaban_peserta_apc.
     * @param {em_jawaban_peserta_apcCreateArgs} args - Arguments to create a Em_jawaban_peserta_apc.
     * @example
     * // Create one Em_jawaban_peserta_apc
     * const Em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.create({
     *   data: {
     *     // ... data to create a Em_jawaban_peserta_apc
     *   }
     * })
     * 
     */
    create<T extends em_jawaban_peserta_apcCreateArgs>(args: SelectSubset<T, em_jawaban_peserta_apcCreateArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_jawaban_peserta_apcs.
     * @param {em_jawaban_peserta_apcCreateManyArgs} args - Arguments to create many Em_jawaban_peserta_apcs.
     * @example
     * // Create many Em_jawaban_peserta_apcs
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_jawaban_peserta_apcCreateManyArgs>(args?: SelectSubset<T, em_jawaban_peserta_apcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_jawaban_peserta_apc.
     * @param {em_jawaban_peserta_apcDeleteArgs} args - Arguments to delete one Em_jawaban_peserta_apc.
     * @example
     * // Delete one Em_jawaban_peserta_apc
     * const Em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.delete({
     *   where: {
     *     // ... filter to delete one Em_jawaban_peserta_apc
     *   }
     * })
     * 
     */
    delete<T extends em_jawaban_peserta_apcDeleteArgs>(args: SelectSubset<T, em_jawaban_peserta_apcDeleteArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_jawaban_peserta_apc.
     * @param {em_jawaban_peserta_apcUpdateArgs} args - Arguments to update one Em_jawaban_peserta_apc.
     * @example
     * // Update one Em_jawaban_peserta_apc
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_jawaban_peserta_apcUpdateArgs>(args: SelectSubset<T, em_jawaban_peserta_apcUpdateArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_jawaban_peserta_apcs.
     * @param {em_jawaban_peserta_apcDeleteManyArgs} args - Arguments to filter Em_jawaban_peserta_apcs to delete.
     * @example
     * // Delete a few Em_jawaban_peserta_apcs
     * const { count } = await prisma.em_jawaban_peserta_apc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_jawaban_peserta_apcDeleteManyArgs>(args?: SelectSubset<T, em_jawaban_peserta_apcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_jawaban_peserta_apcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_peserta_apcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_jawaban_peserta_apcs
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_jawaban_peserta_apcUpdateManyArgs>(args: SelectSubset<T, em_jawaban_peserta_apcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_jawaban_peserta_apc.
     * @param {em_jawaban_peserta_apcUpsertArgs} args - Arguments to update or create a Em_jawaban_peserta_apc.
     * @example
     * // Update or create a Em_jawaban_peserta_apc
     * const em_jawaban_peserta_apc = await prisma.em_jawaban_peserta_apc.upsert({
     *   create: {
     *     // ... data to create a Em_jawaban_peserta_apc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_jawaban_peserta_apc we want to update
     *   }
     * })
     */
    upsert<T extends em_jawaban_peserta_apcUpsertArgs>(args: SelectSubset<T, em_jawaban_peserta_apcUpsertArgs<ExtArgs>>): Prisma__em_jawaban_peserta_apcClient<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_jawaban_peserta_apcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_peserta_apcCountArgs} args - Arguments to filter Em_jawaban_peserta_apcs to count.
     * @example
     * // Count the number of Em_jawaban_peserta_apcs
     * const count = await prisma.em_jawaban_peserta_apc.count({
     *   where: {
     *     // ... the filter for the Em_jawaban_peserta_apcs we want to count
     *   }
     * })
    **/
    count<T extends em_jawaban_peserta_apcCountArgs>(
      args?: Subset<T, em_jawaban_peserta_apcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_jawaban_peserta_apcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_jawaban_peserta_apc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_jawaban_peserta_apcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_jawaban_peserta_apcAggregateArgs>(args: Subset<T, Em_jawaban_peserta_apcAggregateArgs>): Prisma.PrismaPromise<GetEm_jawaban_peserta_apcAggregateType<T>>

    /**
     * Group by Em_jawaban_peserta_apc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jawaban_peserta_apcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_jawaban_peserta_apcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_jawaban_peserta_apcGroupByArgs['orderBy'] }
        : { orderBy?: em_jawaban_peserta_apcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_jawaban_peserta_apcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_jawaban_peserta_apcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_jawaban_peserta_apc model
   */
  readonly fields: em_jawaban_peserta_apcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_jawaban_peserta_apc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_jawaban_peserta_apcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_session_exams_apc<T extends em_session_exams_apcDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_session_exams_apcDefaultArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_jawaban_peserta_apc model
   */
  interface em_jawaban_peserta_apcFieldRefs {
    readonly Id: FieldRef<"em_jawaban_peserta_apc", 'Int'>
    readonly apc_id: FieldRef<"em_jawaban_peserta_apc", 'Int'>
    readonly soal_id: FieldRef<"em_jawaban_peserta_apc", 'Int'>
    readonly topic_id: FieldRef<"em_jawaban_peserta_apc", 'Int'>
    readonly session_exams_id: FieldRef<"em_jawaban_peserta_apc", 'String'>
    readonly jawaban_option: FieldRef<"em_jawaban_peserta_apc", 'String'>
    readonly jawaban_text: FieldRef<"em_jawaban_peserta_apc", 'String'>
    readonly waktu_jawab: FieldRef<"em_jawaban_peserta_apc", 'DateTime'>
    readonly score: FieldRef<"em_jawaban_peserta_apc", 'Float'>
    readonly is_correction: FieldRef<"em_jawaban_peserta_apc", 'Boolean'>
    readonly is_train_jawaban: FieldRef<"em_jawaban_peserta_apc", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * em_jawaban_peserta_apc findUnique
   */
  export type em_jawaban_peserta_apcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta_apc to fetch.
     */
    where: em_jawaban_peserta_apcWhereUniqueInput
  }

  /**
   * em_jawaban_peserta_apc findUniqueOrThrow
   */
  export type em_jawaban_peserta_apcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta_apc to fetch.
     */
    where: em_jawaban_peserta_apcWhereUniqueInput
  }

  /**
   * em_jawaban_peserta_apc findFirst
   */
  export type em_jawaban_peserta_apcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta_apc to fetch.
     */
    where?: em_jawaban_peserta_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_peserta_apcs to fetch.
     */
    orderBy?: em_jawaban_peserta_apcOrderByWithRelationInput | em_jawaban_peserta_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_jawaban_peserta_apcs.
     */
    cursor?: em_jawaban_peserta_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_peserta_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_peserta_apcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_jawaban_peserta_apcs.
     */
    distinct?: Em_jawaban_peserta_apcScalarFieldEnum | Em_jawaban_peserta_apcScalarFieldEnum[]
  }

  /**
   * em_jawaban_peserta_apc findFirstOrThrow
   */
  export type em_jawaban_peserta_apcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta_apc to fetch.
     */
    where?: em_jawaban_peserta_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_peserta_apcs to fetch.
     */
    orderBy?: em_jawaban_peserta_apcOrderByWithRelationInput | em_jawaban_peserta_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_jawaban_peserta_apcs.
     */
    cursor?: em_jawaban_peserta_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_peserta_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_peserta_apcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_jawaban_peserta_apcs.
     */
    distinct?: Em_jawaban_peserta_apcScalarFieldEnum | Em_jawaban_peserta_apcScalarFieldEnum[]
  }

  /**
   * em_jawaban_peserta_apc findMany
   */
  export type em_jawaban_peserta_apcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_jawaban_peserta_apcs to fetch.
     */
    where?: em_jawaban_peserta_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jawaban_peserta_apcs to fetch.
     */
    orderBy?: em_jawaban_peserta_apcOrderByWithRelationInput | em_jawaban_peserta_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_jawaban_peserta_apcs.
     */
    cursor?: em_jawaban_peserta_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jawaban_peserta_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jawaban_peserta_apcs.
     */
    skip?: number
    distinct?: Em_jawaban_peserta_apcScalarFieldEnum | Em_jawaban_peserta_apcScalarFieldEnum[]
  }

  /**
   * em_jawaban_peserta_apc create
   */
  export type em_jawaban_peserta_apcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * The data needed to create a em_jawaban_peserta_apc.
     */
    data: XOR<em_jawaban_peserta_apcCreateInput, em_jawaban_peserta_apcUncheckedCreateInput>
  }

  /**
   * em_jawaban_peserta_apc createMany
   */
  export type em_jawaban_peserta_apcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_jawaban_peserta_apcs.
     */
    data: em_jawaban_peserta_apcCreateManyInput | em_jawaban_peserta_apcCreateManyInput[]
  }

  /**
   * em_jawaban_peserta_apc update
   */
  export type em_jawaban_peserta_apcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * The data needed to update a em_jawaban_peserta_apc.
     */
    data: XOR<em_jawaban_peserta_apcUpdateInput, em_jawaban_peserta_apcUncheckedUpdateInput>
    /**
     * Choose, which em_jawaban_peserta_apc to update.
     */
    where: em_jawaban_peserta_apcWhereUniqueInput
  }

  /**
   * em_jawaban_peserta_apc updateMany
   */
  export type em_jawaban_peserta_apcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_jawaban_peserta_apcs.
     */
    data: XOR<em_jawaban_peserta_apcUpdateManyMutationInput, em_jawaban_peserta_apcUncheckedUpdateManyInput>
    /**
     * Filter which em_jawaban_peserta_apcs to update
     */
    where?: em_jawaban_peserta_apcWhereInput
    /**
     * Limit how many em_jawaban_peserta_apcs to update.
     */
    limit?: number
  }

  /**
   * em_jawaban_peserta_apc upsert
   */
  export type em_jawaban_peserta_apcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * The filter to search for the em_jawaban_peserta_apc to update in case it exists.
     */
    where: em_jawaban_peserta_apcWhereUniqueInput
    /**
     * In case the em_jawaban_peserta_apc found by the `where` argument doesn't exist, create a new em_jawaban_peserta_apc with this data.
     */
    create: XOR<em_jawaban_peserta_apcCreateInput, em_jawaban_peserta_apcUncheckedCreateInput>
    /**
     * In case the em_jawaban_peserta_apc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_jawaban_peserta_apcUpdateInput, em_jawaban_peserta_apcUncheckedUpdateInput>
  }

  /**
   * em_jawaban_peserta_apc delete
   */
  export type em_jawaban_peserta_apcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    /**
     * Filter which em_jawaban_peserta_apc to delete.
     */
    where: em_jawaban_peserta_apcWhereUniqueInput
  }

  /**
   * em_jawaban_peserta_apc deleteMany
   */
  export type em_jawaban_peserta_apcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_jawaban_peserta_apcs to delete
     */
    where?: em_jawaban_peserta_apcWhereInput
    /**
     * Limit how many em_jawaban_peserta_apcs to delete.
     */
    limit?: number
  }

  /**
   * em_jawaban_peserta_apc without action
   */
  export type em_jawaban_peserta_apcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
  }


  /**
   * Model em_jobfair
   */

  export type AggregateEm_jobfair = {
    _count: Em_jobfairCountAggregateOutputType | null
    _avg: Em_jobfairAvgAggregateOutputType | null
    _sum: Em_jobfairSumAggregateOutputType | null
    _min: Em_jobfairMinAggregateOutputType | null
    _max: Em_jobfairMaxAggregateOutputType | null
  }

  export type Em_jobfairAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_jobfairSumAggregateOutputType = {
    id: number | null
  }

  export type Em_jobfairMinAggregateOutputType = {
    id: number | null
    lokasi: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_jobfairMaxAggregateOutputType = {
    id: number | null
    lokasi: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_jobfairCountAggregateOutputType = {
    id: number
    lokasi: number
    status: number
    lastupdate: number
    _all: number
  }


  export type Em_jobfairAvgAggregateInputType = {
    id?: true
  }

  export type Em_jobfairSumAggregateInputType = {
    id?: true
  }

  export type Em_jobfairMinAggregateInputType = {
    id?: true
    lokasi?: true
    status?: true
    lastupdate?: true
  }

  export type Em_jobfairMaxAggregateInputType = {
    id?: true
    lokasi?: true
    status?: true
    lastupdate?: true
  }

  export type Em_jobfairCountAggregateInputType = {
    id?: true
    lokasi?: true
    status?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_jobfairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_jobfair to aggregate.
     */
    where?: em_jobfairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jobfairs to fetch.
     */
    orderBy?: em_jobfairOrderByWithRelationInput | em_jobfairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_jobfairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jobfairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jobfairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_jobfairs
    **/
    _count?: true | Em_jobfairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_jobfairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_jobfairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_jobfairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_jobfairMaxAggregateInputType
  }

  export type GetEm_jobfairAggregateType<T extends Em_jobfairAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_jobfair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_jobfair[P]>
      : GetScalarType<T[P], AggregateEm_jobfair[P]>
  }




  export type em_jobfairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_jobfairWhereInput
    orderBy?: em_jobfairOrderByWithAggregationInput | em_jobfairOrderByWithAggregationInput[]
    by: Em_jobfairScalarFieldEnum[] | Em_jobfairScalarFieldEnum
    having?: em_jobfairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_jobfairCountAggregateInputType | true
    _avg?: Em_jobfairAvgAggregateInputType
    _sum?: Em_jobfairSumAggregateInputType
    _min?: Em_jobfairMinAggregateInputType
    _max?: Em_jobfairMaxAggregateInputType
  }

  export type Em_jobfairGroupByOutputType = {
    id: number
    lokasi: string
    status: string | null
    lastupdate: Date | null
    _count: Em_jobfairCountAggregateOutputType | null
    _avg: Em_jobfairAvgAggregateOutputType | null
    _sum: Em_jobfairSumAggregateOutputType | null
    _min: Em_jobfairMinAggregateOutputType | null
    _max: Em_jobfairMaxAggregateOutputType | null
  }

  type GetEm_jobfairGroupByPayload<T extends em_jobfairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_jobfairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_jobfairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_jobfairGroupByOutputType[P]>
            : GetScalarType<T[P], Em_jobfairGroupByOutputType[P]>
        }
      >
    >


  export type em_jobfairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lokasi?: boolean
    status?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["em_jobfair"]>



  export type em_jobfairSelectScalar = {
    id?: boolean
    lokasi?: boolean
    status?: boolean
    lastupdate?: boolean
  }

  export type em_jobfairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lokasi" | "status" | "lastupdate", ExtArgs["result"]["em_jobfair"]>

  export type $em_jobfairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_jobfair"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lokasi: string
      status: string | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_jobfair"]>
    composites: {}
  }

  type em_jobfairGetPayload<S extends boolean | null | undefined | em_jobfairDefaultArgs> = $Result.GetResult<Prisma.$em_jobfairPayload, S>

  type em_jobfairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_jobfairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_jobfairCountAggregateInputType | true
    }

  export interface em_jobfairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_jobfair'], meta: { name: 'em_jobfair' } }
    /**
     * Find zero or one Em_jobfair that matches the filter.
     * @param {em_jobfairFindUniqueArgs} args - Arguments to find a Em_jobfair
     * @example
     * // Get one Em_jobfair
     * const em_jobfair = await prisma.em_jobfair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_jobfairFindUniqueArgs>(args: SelectSubset<T, em_jobfairFindUniqueArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_jobfair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_jobfairFindUniqueOrThrowArgs} args - Arguments to find a Em_jobfair
     * @example
     * // Get one Em_jobfair
     * const em_jobfair = await prisma.em_jobfair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_jobfairFindUniqueOrThrowArgs>(args: SelectSubset<T, em_jobfairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_jobfair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jobfairFindFirstArgs} args - Arguments to find a Em_jobfair
     * @example
     * // Get one Em_jobfair
     * const em_jobfair = await prisma.em_jobfair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_jobfairFindFirstArgs>(args?: SelectSubset<T, em_jobfairFindFirstArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_jobfair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jobfairFindFirstOrThrowArgs} args - Arguments to find a Em_jobfair
     * @example
     * // Get one Em_jobfair
     * const em_jobfair = await prisma.em_jobfair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_jobfairFindFirstOrThrowArgs>(args?: SelectSubset<T, em_jobfairFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_jobfairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jobfairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_jobfairs
     * const em_jobfairs = await prisma.em_jobfair.findMany()
     * 
     * // Get first 10 Em_jobfairs
     * const em_jobfairs = await prisma.em_jobfair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_jobfairWithIdOnly = await prisma.em_jobfair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_jobfairFindManyArgs>(args?: SelectSubset<T, em_jobfairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_jobfair.
     * @param {em_jobfairCreateArgs} args - Arguments to create a Em_jobfair.
     * @example
     * // Create one Em_jobfair
     * const Em_jobfair = await prisma.em_jobfair.create({
     *   data: {
     *     // ... data to create a Em_jobfair
     *   }
     * })
     * 
     */
    create<T extends em_jobfairCreateArgs>(args: SelectSubset<T, em_jobfairCreateArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_jobfairs.
     * @param {em_jobfairCreateManyArgs} args - Arguments to create many Em_jobfairs.
     * @example
     * // Create many Em_jobfairs
     * const em_jobfair = await prisma.em_jobfair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_jobfairCreateManyArgs>(args?: SelectSubset<T, em_jobfairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_jobfair.
     * @param {em_jobfairDeleteArgs} args - Arguments to delete one Em_jobfair.
     * @example
     * // Delete one Em_jobfair
     * const Em_jobfair = await prisma.em_jobfair.delete({
     *   where: {
     *     // ... filter to delete one Em_jobfair
     *   }
     * })
     * 
     */
    delete<T extends em_jobfairDeleteArgs>(args: SelectSubset<T, em_jobfairDeleteArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_jobfair.
     * @param {em_jobfairUpdateArgs} args - Arguments to update one Em_jobfair.
     * @example
     * // Update one Em_jobfair
     * const em_jobfair = await prisma.em_jobfair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_jobfairUpdateArgs>(args: SelectSubset<T, em_jobfairUpdateArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_jobfairs.
     * @param {em_jobfairDeleteManyArgs} args - Arguments to filter Em_jobfairs to delete.
     * @example
     * // Delete a few Em_jobfairs
     * const { count } = await prisma.em_jobfair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_jobfairDeleteManyArgs>(args?: SelectSubset<T, em_jobfairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_jobfairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jobfairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_jobfairs
     * const em_jobfair = await prisma.em_jobfair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_jobfairUpdateManyArgs>(args: SelectSubset<T, em_jobfairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_jobfair.
     * @param {em_jobfairUpsertArgs} args - Arguments to update or create a Em_jobfair.
     * @example
     * // Update or create a Em_jobfair
     * const em_jobfair = await prisma.em_jobfair.upsert({
     *   create: {
     *     // ... data to create a Em_jobfair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_jobfair we want to update
     *   }
     * })
     */
    upsert<T extends em_jobfairUpsertArgs>(args: SelectSubset<T, em_jobfairUpsertArgs<ExtArgs>>): Prisma__em_jobfairClient<$Result.GetResult<Prisma.$em_jobfairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_jobfairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jobfairCountArgs} args - Arguments to filter Em_jobfairs to count.
     * @example
     * // Count the number of Em_jobfairs
     * const count = await prisma.em_jobfair.count({
     *   where: {
     *     // ... the filter for the Em_jobfairs we want to count
     *   }
     * })
    **/
    count<T extends em_jobfairCountArgs>(
      args?: Subset<T, em_jobfairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_jobfairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_jobfair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_jobfairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_jobfairAggregateArgs>(args: Subset<T, Em_jobfairAggregateArgs>): Prisma.PrismaPromise<GetEm_jobfairAggregateType<T>>

    /**
     * Group by Em_jobfair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_jobfairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_jobfairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_jobfairGroupByArgs['orderBy'] }
        : { orderBy?: em_jobfairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_jobfairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_jobfairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_jobfair model
   */
  readonly fields: em_jobfairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_jobfair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_jobfairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_jobfair model
   */
  interface em_jobfairFieldRefs {
    readonly id: FieldRef<"em_jobfair", 'Int'>
    readonly lokasi: FieldRef<"em_jobfair", 'String'>
    readonly status: FieldRef<"em_jobfair", 'String'>
    readonly lastupdate: FieldRef<"em_jobfair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_jobfair findUnique
   */
  export type em_jobfairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * Filter, which em_jobfair to fetch.
     */
    where: em_jobfairWhereUniqueInput
  }

  /**
   * em_jobfair findUniqueOrThrow
   */
  export type em_jobfairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * Filter, which em_jobfair to fetch.
     */
    where: em_jobfairWhereUniqueInput
  }

  /**
   * em_jobfair findFirst
   */
  export type em_jobfairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * Filter, which em_jobfair to fetch.
     */
    where?: em_jobfairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jobfairs to fetch.
     */
    orderBy?: em_jobfairOrderByWithRelationInput | em_jobfairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_jobfairs.
     */
    cursor?: em_jobfairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jobfairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jobfairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_jobfairs.
     */
    distinct?: Em_jobfairScalarFieldEnum | Em_jobfairScalarFieldEnum[]
  }

  /**
   * em_jobfair findFirstOrThrow
   */
  export type em_jobfairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * Filter, which em_jobfair to fetch.
     */
    where?: em_jobfairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jobfairs to fetch.
     */
    orderBy?: em_jobfairOrderByWithRelationInput | em_jobfairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_jobfairs.
     */
    cursor?: em_jobfairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jobfairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jobfairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_jobfairs.
     */
    distinct?: Em_jobfairScalarFieldEnum | Em_jobfairScalarFieldEnum[]
  }

  /**
   * em_jobfair findMany
   */
  export type em_jobfairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * Filter, which em_jobfairs to fetch.
     */
    where?: em_jobfairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_jobfairs to fetch.
     */
    orderBy?: em_jobfairOrderByWithRelationInput | em_jobfairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_jobfairs.
     */
    cursor?: em_jobfairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_jobfairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_jobfairs.
     */
    skip?: number
    distinct?: Em_jobfairScalarFieldEnum | Em_jobfairScalarFieldEnum[]
  }

  /**
   * em_jobfair create
   */
  export type em_jobfairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * The data needed to create a em_jobfair.
     */
    data: XOR<em_jobfairCreateInput, em_jobfairUncheckedCreateInput>
  }

  /**
   * em_jobfair createMany
   */
  export type em_jobfairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_jobfairs.
     */
    data: em_jobfairCreateManyInput | em_jobfairCreateManyInput[]
  }

  /**
   * em_jobfair update
   */
  export type em_jobfairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * The data needed to update a em_jobfair.
     */
    data: XOR<em_jobfairUpdateInput, em_jobfairUncheckedUpdateInput>
    /**
     * Choose, which em_jobfair to update.
     */
    where: em_jobfairWhereUniqueInput
  }

  /**
   * em_jobfair updateMany
   */
  export type em_jobfairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_jobfairs.
     */
    data: XOR<em_jobfairUpdateManyMutationInput, em_jobfairUncheckedUpdateManyInput>
    /**
     * Filter which em_jobfairs to update
     */
    where?: em_jobfairWhereInput
    /**
     * Limit how many em_jobfairs to update.
     */
    limit?: number
  }

  /**
   * em_jobfair upsert
   */
  export type em_jobfairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * The filter to search for the em_jobfair to update in case it exists.
     */
    where: em_jobfairWhereUniqueInput
    /**
     * In case the em_jobfair found by the `where` argument doesn't exist, create a new em_jobfair with this data.
     */
    create: XOR<em_jobfairCreateInput, em_jobfairUncheckedCreateInput>
    /**
     * In case the em_jobfair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_jobfairUpdateInput, em_jobfairUncheckedUpdateInput>
  }

  /**
   * em_jobfair delete
   */
  export type em_jobfairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
    /**
     * Filter which em_jobfair to delete.
     */
    where: em_jobfairWhereUniqueInput
  }

  /**
   * em_jobfair deleteMany
   */
  export type em_jobfairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_jobfairs to delete
     */
    where?: em_jobfairWhereInput
    /**
     * Limit how many em_jobfairs to delete.
     */
    limit?: number
  }

  /**
   * em_jobfair without action
   */
  export type em_jobfairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jobfair
     */
    select?: em_jobfairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jobfair
     */
    omit?: em_jobfairOmit<ExtArgs> | null
  }


  /**
   * Model em_levelposs
   */

  export type AggregateEm_levelposs = {
    _count: Em_levelpossCountAggregateOutputType | null
    _avg: Em_levelpossAvgAggregateOutputType | null
    _sum: Em_levelpossSumAggregateOutputType | null
    _min: Em_levelpossMinAggregateOutputType | null
    _max: Em_levelpossMaxAggregateOutputType | null
  }

  export type Em_levelpossAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_levelpossSumAggregateOutputType = {
    id: number | null
  }

  export type Em_levelpossMinAggregateOutputType = {
    id: number | null
    level_text: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_levelpossMaxAggregateOutputType = {
    id: number | null
    level_text: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_levelpossCountAggregateOutputType = {
    id: number
    level_text: number
    status: number
    lastupdate: number
    _all: number
  }


  export type Em_levelpossAvgAggregateInputType = {
    id?: true
  }

  export type Em_levelpossSumAggregateInputType = {
    id?: true
  }

  export type Em_levelpossMinAggregateInputType = {
    id?: true
    level_text?: true
    status?: true
    lastupdate?: true
  }

  export type Em_levelpossMaxAggregateInputType = {
    id?: true
    level_text?: true
    status?: true
    lastupdate?: true
  }

  export type Em_levelpossCountAggregateInputType = {
    id?: true
    level_text?: true
    status?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_levelpossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_levelposs to aggregate.
     */
    where?: em_levelpossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_levelposses to fetch.
     */
    orderBy?: em_levelpossOrderByWithRelationInput | em_levelpossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_levelpossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_levelposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_levelposses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_levelposses
    **/
    _count?: true | Em_levelpossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_levelpossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_levelpossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_levelpossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_levelpossMaxAggregateInputType
  }

  export type GetEm_levelpossAggregateType<T extends Em_levelpossAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_levelposs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_levelposs[P]>
      : GetScalarType<T[P], AggregateEm_levelposs[P]>
  }




  export type em_levelpossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_levelpossWhereInput
    orderBy?: em_levelpossOrderByWithAggregationInput | em_levelpossOrderByWithAggregationInput[]
    by: Em_levelpossScalarFieldEnum[] | Em_levelpossScalarFieldEnum
    having?: em_levelpossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_levelpossCountAggregateInputType | true
    _avg?: Em_levelpossAvgAggregateInputType
    _sum?: Em_levelpossSumAggregateInputType
    _min?: Em_levelpossMinAggregateInputType
    _max?: Em_levelpossMaxAggregateInputType
  }

  export type Em_levelpossGroupByOutputType = {
    id: number
    level_text: string
    status: string | null
    lastupdate: Date | null
    _count: Em_levelpossCountAggregateOutputType | null
    _avg: Em_levelpossAvgAggregateOutputType | null
    _sum: Em_levelpossSumAggregateOutputType | null
    _min: Em_levelpossMinAggregateOutputType | null
    _max: Em_levelpossMaxAggregateOutputType | null
  }

  type GetEm_levelpossGroupByPayload<T extends em_levelpossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_levelpossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_levelpossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_levelpossGroupByOutputType[P]>
            : GetScalarType<T[P], Em_levelpossGroupByOutputType[P]>
        }
      >
    >


  export type em_levelpossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_text?: boolean
    status?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["em_levelposs"]>



  export type em_levelpossSelectScalar = {
    id?: boolean
    level_text?: boolean
    status?: boolean
    lastupdate?: boolean
  }

  export type em_levelpossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level_text" | "status" | "lastupdate", ExtArgs["result"]["em_levelposs"]>

  export type $em_levelpossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_levelposs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level_text: string
      status: string | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_levelposs"]>
    composites: {}
  }

  type em_levelpossGetPayload<S extends boolean | null | undefined | em_levelpossDefaultArgs> = $Result.GetResult<Prisma.$em_levelpossPayload, S>

  type em_levelpossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_levelpossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_levelpossCountAggregateInputType | true
    }

  export interface em_levelpossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_levelposs'], meta: { name: 'em_levelposs' } }
    /**
     * Find zero or one Em_levelposs that matches the filter.
     * @param {em_levelpossFindUniqueArgs} args - Arguments to find a Em_levelposs
     * @example
     * // Get one Em_levelposs
     * const em_levelposs = await prisma.em_levelposs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_levelpossFindUniqueArgs>(args: SelectSubset<T, em_levelpossFindUniqueArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_levelposs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_levelpossFindUniqueOrThrowArgs} args - Arguments to find a Em_levelposs
     * @example
     * // Get one Em_levelposs
     * const em_levelposs = await prisma.em_levelposs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_levelpossFindUniqueOrThrowArgs>(args: SelectSubset<T, em_levelpossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_levelposs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_levelpossFindFirstArgs} args - Arguments to find a Em_levelposs
     * @example
     * // Get one Em_levelposs
     * const em_levelposs = await prisma.em_levelposs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_levelpossFindFirstArgs>(args?: SelectSubset<T, em_levelpossFindFirstArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_levelposs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_levelpossFindFirstOrThrowArgs} args - Arguments to find a Em_levelposs
     * @example
     * // Get one Em_levelposs
     * const em_levelposs = await prisma.em_levelposs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_levelpossFindFirstOrThrowArgs>(args?: SelectSubset<T, em_levelpossFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_levelposses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_levelpossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_levelposses
     * const em_levelposses = await prisma.em_levelposs.findMany()
     * 
     * // Get first 10 Em_levelposses
     * const em_levelposses = await prisma.em_levelposs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_levelpossWithIdOnly = await prisma.em_levelposs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_levelpossFindManyArgs>(args?: SelectSubset<T, em_levelpossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_levelposs.
     * @param {em_levelpossCreateArgs} args - Arguments to create a Em_levelposs.
     * @example
     * // Create one Em_levelposs
     * const Em_levelposs = await prisma.em_levelposs.create({
     *   data: {
     *     // ... data to create a Em_levelposs
     *   }
     * })
     * 
     */
    create<T extends em_levelpossCreateArgs>(args: SelectSubset<T, em_levelpossCreateArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_levelposses.
     * @param {em_levelpossCreateManyArgs} args - Arguments to create many Em_levelposses.
     * @example
     * // Create many Em_levelposses
     * const em_levelposs = await prisma.em_levelposs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_levelpossCreateManyArgs>(args?: SelectSubset<T, em_levelpossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_levelposs.
     * @param {em_levelpossDeleteArgs} args - Arguments to delete one Em_levelposs.
     * @example
     * // Delete one Em_levelposs
     * const Em_levelposs = await prisma.em_levelposs.delete({
     *   where: {
     *     // ... filter to delete one Em_levelposs
     *   }
     * })
     * 
     */
    delete<T extends em_levelpossDeleteArgs>(args: SelectSubset<T, em_levelpossDeleteArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_levelposs.
     * @param {em_levelpossUpdateArgs} args - Arguments to update one Em_levelposs.
     * @example
     * // Update one Em_levelposs
     * const em_levelposs = await prisma.em_levelposs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_levelpossUpdateArgs>(args: SelectSubset<T, em_levelpossUpdateArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_levelposses.
     * @param {em_levelpossDeleteManyArgs} args - Arguments to filter Em_levelposses to delete.
     * @example
     * // Delete a few Em_levelposses
     * const { count } = await prisma.em_levelposs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_levelpossDeleteManyArgs>(args?: SelectSubset<T, em_levelpossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_levelposses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_levelpossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_levelposses
     * const em_levelposs = await prisma.em_levelposs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_levelpossUpdateManyArgs>(args: SelectSubset<T, em_levelpossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_levelposs.
     * @param {em_levelpossUpsertArgs} args - Arguments to update or create a Em_levelposs.
     * @example
     * // Update or create a Em_levelposs
     * const em_levelposs = await prisma.em_levelposs.upsert({
     *   create: {
     *     // ... data to create a Em_levelposs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_levelposs we want to update
     *   }
     * })
     */
    upsert<T extends em_levelpossUpsertArgs>(args: SelectSubset<T, em_levelpossUpsertArgs<ExtArgs>>): Prisma__em_levelpossClient<$Result.GetResult<Prisma.$em_levelpossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_levelposses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_levelpossCountArgs} args - Arguments to filter Em_levelposses to count.
     * @example
     * // Count the number of Em_levelposses
     * const count = await prisma.em_levelposs.count({
     *   where: {
     *     // ... the filter for the Em_levelposses we want to count
     *   }
     * })
    **/
    count<T extends em_levelpossCountArgs>(
      args?: Subset<T, em_levelpossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_levelpossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_levelposs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_levelpossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_levelpossAggregateArgs>(args: Subset<T, Em_levelpossAggregateArgs>): Prisma.PrismaPromise<GetEm_levelpossAggregateType<T>>

    /**
     * Group by Em_levelposs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_levelpossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_levelpossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_levelpossGroupByArgs['orderBy'] }
        : { orderBy?: em_levelpossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_levelpossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_levelpossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_levelposs model
   */
  readonly fields: em_levelpossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_levelposs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_levelpossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_levelposs model
   */
  interface em_levelpossFieldRefs {
    readonly id: FieldRef<"em_levelposs", 'Int'>
    readonly level_text: FieldRef<"em_levelposs", 'String'>
    readonly status: FieldRef<"em_levelposs", 'String'>
    readonly lastupdate: FieldRef<"em_levelposs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_levelposs findUnique
   */
  export type em_levelpossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * Filter, which em_levelposs to fetch.
     */
    where: em_levelpossWhereUniqueInput
  }

  /**
   * em_levelposs findUniqueOrThrow
   */
  export type em_levelpossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * Filter, which em_levelposs to fetch.
     */
    where: em_levelpossWhereUniqueInput
  }

  /**
   * em_levelposs findFirst
   */
  export type em_levelpossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * Filter, which em_levelposs to fetch.
     */
    where?: em_levelpossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_levelposses to fetch.
     */
    orderBy?: em_levelpossOrderByWithRelationInput | em_levelpossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_levelposses.
     */
    cursor?: em_levelpossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_levelposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_levelposses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_levelposses.
     */
    distinct?: Em_levelpossScalarFieldEnum | Em_levelpossScalarFieldEnum[]
  }

  /**
   * em_levelposs findFirstOrThrow
   */
  export type em_levelpossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * Filter, which em_levelposs to fetch.
     */
    where?: em_levelpossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_levelposses to fetch.
     */
    orderBy?: em_levelpossOrderByWithRelationInput | em_levelpossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_levelposses.
     */
    cursor?: em_levelpossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_levelposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_levelposses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_levelposses.
     */
    distinct?: Em_levelpossScalarFieldEnum | Em_levelpossScalarFieldEnum[]
  }

  /**
   * em_levelposs findMany
   */
  export type em_levelpossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * Filter, which em_levelposses to fetch.
     */
    where?: em_levelpossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_levelposses to fetch.
     */
    orderBy?: em_levelpossOrderByWithRelationInput | em_levelpossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_levelposses.
     */
    cursor?: em_levelpossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_levelposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_levelposses.
     */
    skip?: number
    distinct?: Em_levelpossScalarFieldEnum | Em_levelpossScalarFieldEnum[]
  }

  /**
   * em_levelposs create
   */
  export type em_levelpossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * The data needed to create a em_levelposs.
     */
    data: XOR<em_levelpossCreateInput, em_levelpossUncheckedCreateInput>
  }

  /**
   * em_levelposs createMany
   */
  export type em_levelpossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_levelposses.
     */
    data: em_levelpossCreateManyInput | em_levelpossCreateManyInput[]
  }

  /**
   * em_levelposs update
   */
  export type em_levelpossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * The data needed to update a em_levelposs.
     */
    data: XOR<em_levelpossUpdateInput, em_levelpossUncheckedUpdateInput>
    /**
     * Choose, which em_levelposs to update.
     */
    where: em_levelpossWhereUniqueInput
  }

  /**
   * em_levelposs updateMany
   */
  export type em_levelpossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_levelposses.
     */
    data: XOR<em_levelpossUpdateManyMutationInput, em_levelpossUncheckedUpdateManyInput>
    /**
     * Filter which em_levelposses to update
     */
    where?: em_levelpossWhereInput
    /**
     * Limit how many em_levelposses to update.
     */
    limit?: number
  }

  /**
   * em_levelposs upsert
   */
  export type em_levelpossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * The filter to search for the em_levelposs to update in case it exists.
     */
    where: em_levelpossWhereUniqueInput
    /**
     * In case the em_levelposs found by the `where` argument doesn't exist, create a new em_levelposs with this data.
     */
    create: XOR<em_levelpossCreateInput, em_levelpossUncheckedCreateInput>
    /**
     * In case the em_levelposs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_levelpossUpdateInput, em_levelpossUncheckedUpdateInput>
  }

  /**
   * em_levelposs delete
   */
  export type em_levelpossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
    /**
     * Filter which em_levelposs to delete.
     */
    where: em_levelpossWhereUniqueInput
  }

  /**
   * em_levelposs deleteMany
   */
  export type em_levelpossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_levelposses to delete
     */
    where?: em_levelpossWhereInput
    /**
     * Limit how many em_levelposses to delete.
     */
    limit?: number
  }

  /**
   * em_levelposs without action
   */
  export type em_levelpossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_levelposs
     */
    select?: em_levelpossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_levelposs
     */
    omit?: em_levelpossOmit<ExtArgs> | null
  }


  /**
   * Model em_logs
   */

  export type AggregateEm_logs = {
    _count: Em_logsCountAggregateOutputType | null
    _avg: Em_logsAvgAggregateOutputType | null
    _sum: Em_logsSumAggregateOutputType | null
    _min: Em_logsMinAggregateOutputType | null
    _max: Em_logsMaxAggregateOutputType | null
  }

  export type Em_logsAvgAggregateOutputType = {
    Id: number | null
    LogId: number | null
  }

  export type Em_logsSumAggregateOutputType = {
    Id: number | null
    LogId: number | null
  }

  export type Em_logsMinAggregateOutputType = {
    Id: number | null
    IP: string | null
    Login: Date | null
    Logout: Date | null
    UserId: string | null
    LogId: number | null
    Notes: string | null
    LastUpdate: Date | null
  }

  export type Em_logsMaxAggregateOutputType = {
    Id: number | null
    IP: string | null
    Login: Date | null
    Logout: Date | null
    UserId: string | null
    LogId: number | null
    Notes: string | null
    LastUpdate: Date | null
  }

  export type Em_logsCountAggregateOutputType = {
    Id: number
    IP: number
    Login: number
    Logout: number
    UserId: number
    LogId: number
    Notes: number
    LastUpdate: number
    _all: number
  }


  export type Em_logsAvgAggregateInputType = {
    Id?: true
    LogId?: true
  }

  export type Em_logsSumAggregateInputType = {
    Id?: true
    LogId?: true
  }

  export type Em_logsMinAggregateInputType = {
    Id?: true
    IP?: true
    Login?: true
    Logout?: true
    UserId?: true
    LogId?: true
    Notes?: true
    LastUpdate?: true
  }

  export type Em_logsMaxAggregateInputType = {
    Id?: true
    IP?: true
    Login?: true
    Logout?: true
    UserId?: true
    LogId?: true
    Notes?: true
    LastUpdate?: true
  }

  export type Em_logsCountAggregateInputType = {
    Id?: true
    IP?: true
    Login?: true
    Logout?: true
    UserId?: true
    LogId?: true
    Notes?: true
    LastUpdate?: true
    _all?: true
  }

  export type Em_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_logs to aggregate.
     */
    where?: em_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_logs to fetch.
     */
    orderBy?: em_logsOrderByWithRelationInput | em_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_logs
    **/
    _count?: true | Em_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_logsMaxAggregateInputType
  }

  export type GetEm_logsAggregateType<T extends Em_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_logs[P]>
      : GetScalarType<T[P], AggregateEm_logs[P]>
  }




  export type em_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_logsWhereInput
    orderBy?: em_logsOrderByWithAggregationInput | em_logsOrderByWithAggregationInput[]
    by: Em_logsScalarFieldEnum[] | Em_logsScalarFieldEnum
    having?: em_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_logsCountAggregateInputType | true
    _avg?: Em_logsAvgAggregateInputType
    _sum?: Em_logsSumAggregateInputType
    _min?: Em_logsMinAggregateInputType
    _max?: Em_logsMaxAggregateInputType
  }

  export type Em_logsGroupByOutputType = {
    Id: number
    IP: string | null
    Login: Date | null
    Logout: Date | null
    UserId: string | null
    LogId: number | null
    Notes: string | null
    LastUpdate: Date | null
    _count: Em_logsCountAggregateOutputType | null
    _avg: Em_logsAvgAggregateOutputType | null
    _sum: Em_logsSumAggregateOutputType | null
    _min: Em_logsMinAggregateOutputType | null
    _max: Em_logsMaxAggregateOutputType | null
  }

  type GetEm_logsGroupByPayload<T extends em_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_logsGroupByOutputType[P]>
        }
      >
    >


  export type em_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    IP?: boolean
    Login?: boolean
    Logout?: boolean
    UserId?: boolean
    LogId?: boolean
    Notes?: boolean
    LastUpdate?: boolean
  }, ExtArgs["result"]["em_logs"]>



  export type em_logsSelectScalar = {
    Id?: boolean
    IP?: boolean
    Login?: boolean
    Logout?: boolean
    UserId?: boolean
    LogId?: boolean
    Notes?: boolean
    LastUpdate?: boolean
  }

  export type em_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "IP" | "Login" | "Logout" | "UserId" | "LogId" | "Notes" | "LastUpdate", ExtArgs["result"]["em_logs"]>

  export type $em_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      IP: string | null
      Login: Date | null
      Logout: Date | null
      UserId: string | null
      LogId: number | null
      Notes: string | null
      LastUpdate: Date | null
    }, ExtArgs["result"]["em_logs"]>
    composites: {}
  }

  type em_logsGetPayload<S extends boolean | null | undefined | em_logsDefaultArgs> = $Result.GetResult<Prisma.$em_logsPayload, S>

  type em_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_logsCountAggregateInputType | true
    }

  export interface em_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_logs'], meta: { name: 'em_logs' } }
    /**
     * Find zero or one Em_logs that matches the filter.
     * @param {em_logsFindUniqueArgs} args - Arguments to find a Em_logs
     * @example
     * // Get one Em_logs
     * const em_logs = await prisma.em_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_logsFindUniqueArgs>(args: SelectSubset<T, em_logsFindUniqueArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_logsFindUniqueOrThrowArgs} args - Arguments to find a Em_logs
     * @example
     * // Get one Em_logs
     * const em_logs = await prisma.em_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_logsFindFirstArgs} args - Arguments to find a Em_logs
     * @example
     * // Get one Em_logs
     * const em_logs = await prisma.em_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_logsFindFirstArgs>(args?: SelectSubset<T, em_logsFindFirstArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_logsFindFirstOrThrowArgs} args - Arguments to find a Em_logs
     * @example
     * // Get one Em_logs
     * const em_logs = await prisma.em_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_logs
     * const em_logs = await prisma.em_logs.findMany()
     * 
     * // Get first 10 Em_logs
     * const em_logs = await prisma.em_logs.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_logsWithIdOnly = await prisma.em_logs.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_logsFindManyArgs>(args?: SelectSubset<T, em_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_logs.
     * @param {em_logsCreateArgs} args - Arguments to create a Em_logs.
     * @example
     * // Create one Em_logs
     * const Em_logs = await prisma.em_logs.create({
     *   data: {
     *     // ... data to create a Em_logs
     *   }
     * })
     * 
     */
    create<T extends em_logsCreateArgs>(args: SelectSubset<T, em_logsCreateArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_logs.
     * @param {em_logsCreateManyArgs} args - Arguments to create many Em_logs.
     * @example
     * // Create many Em_logs
     * const em_logs = await prisma.em_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_logsCreateManyArgs>(args?: SelectSubset<T, em_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_logs.
     * @param {em_logsDeleteArgs} args - Arguments to delete one Em_logs.
     * @example
     * // Delete one Em_logs
     * const Em_logs = await prisma.em_logs.delete({
     *   where: {
     *     // ... filter to delete one Em_logs
     *   }
     * })
     * 
     */
    delete<T extends em_logsDeleteArgs>(args: SelectSubset<T, em_logsDeleteArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_logs.
     * @param {em_logsUpdateArgs} args - Arguments to update one Em_logs.
     * @example
     * // Update one Em_logs
     * const em_logs = await prisma.em_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_logsUpdateArgs>(args: SelectSubset<T, em_logsUpdateArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_logs.
     * @param {em_logsDeleteManyArgs} args - Arguments to filter Em_logs to delete.
     * @example
     * // Delete a few Em_logs
     * const { count } = await prisma.em_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_logsDeleteManyArgs>(args?: SelectSubset<T, em_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_logs
     * const em_logs = await prisma.em_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_logsUpdateManyArgs>(args: SelectSubset<T, em_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_logs.
     * @param {em_logsUpsertArgs} args - Arguments to update or create a Em_logs.
     * @example
     * // Update or create a Em_logs
     * const em_logs = await prisma.em_logs.upsert({
     *   create: {
     *     // ... data to create a Em_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_logs we want to update
     *   }
     * })
     */
    upsert<T extends em_logsUpsertArgs>(args: SelectSubset<T, em_logsUpsertArgs<ExtArgs>>): Prisma__em_logsClient<$Result.GetResult<Prisma.$em_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_logsCountArgs} args - Arguments to filter Em_logs to count.
     * @example
     * // Count the number of Em_logs
     * const count = await prisma.em_logs.count({
     *   where: {
     *     // ... the filter for the Em_logs we want to count
     *   }
     * })
    **/
    count<T extends em_logsCountArgs>(
      args?: Subset<T, em_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_logsAggregateArgs>(args: Subset<T, Em_logsAggregateArgs>): Prisma.PrismaPromise<GetEm_logsAggregateType<T>>

    /**
     * Group by Em_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_logsGroupByArgs['orderBy'] }
        : { orderBy?: em_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_logs model
   */
  readonly fields: em_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_logs model
   */
  interface em_logsFieldRefs {
    readonly Id: FieldRef<"em_logs", 'Int'>
    readonly IP: FieldRef<"em_logs", 'String'>
    readonly Login: FieldRef<"em_logs", 'DateTime'>
    readonly Logout: FieldRef<"em_logs", 'DateTime'>
    readonly UserId: FieldRef<"em_logs", 'String'>
    readonly LogId: FieldRef<"em_logs", 'Int'>
    readonly Notes: FieldRef<"em_logs", 'String'>
    readonly LastUpdate: FieldRef<"em_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_logs findUnique
   */
  export type em_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * Filter, which em_logs to fetch.
     */
    where: em_logsWhereUniqueInput
  }

  /**
   * em_logs findUniqueOrThrow
   */
  export type em_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * Filter, which em_logs to fetch.
     */
    where: em_logsWhereUniqueInput
  }

  /**
   * em_logs findFirst
   */
  export type em_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * Filter, which em_logs to fetch.
     */
    where?: em_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_logs to fetch.
     */
    orderBy?: em_logsOrderByWithRelationInput | em_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_logs.
     */
    cursor?: em_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_logs.
     */
    distinct?: Em_logsScalarFieldEnum | Em_logsScalarFieldEnum[]
  }

  /**
   * em_logs findFirstOrThrow
   */
  export type em_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * Filter, which em_logs to fetch.
     */
    where?: em_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_logs to fetch.
     */
    orderBy?: em_logsOrderByWithRelationInput | em_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_logs.
     */
    cursor?: em_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_logs.
     */
    distinct?: Em_logsScalarFieldEnum | Em_logsScalarFieldEnum[]
  }

  /**
   * em_logs findMany
   */
  export type em_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * Filter, which em_logs to fetch.
     */
    where?: em_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_logs to fetch.
     */
    orderBy?: em_logsOrderByWithRelationInput | em_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_logs.
     */
    cursor?: em_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_logs.
     */
    skip?: number
    distinct?: Em_logsScalarFieldEnum | Em_logsScalarFieldEnum[]
  }

  /**
   * em_logs create
   */
  export type em_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a em_logs.
     */
    data?: XOR<em_logsCreateInput, em_logsUncheckedCreateInput>
  }

  /**
   * em_logs createMany
   */
  export type em_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_logs.
     */
    data: em_logsCreateManyInput | em_logsCreateManyInput[]
  }

  /**
   * em_logs update
   */
  export type em_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a em_logs.
     */
    data: XOR<em_logsUpdateInput, em_logsUncheckedUpdateInput>
    /**
     * Choose, which em_logs to update.
     */
    where: em_logsWhereUniqueInput
  }

  /**
   * em_logs updateMany
   */
  export type em_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_logs.
     */
    data: XOR<em_logsUpdateManyMutationInput, em_logsUncheckedUpdateManyInput>
    /**
     * Filter which em_logs to update
     */
    where?: em_logsWhereInput
    /**
     * Limit how many em_logs to update.
     */
    limit?: number
  }

  /**
   * em_logs upsert
   */
  export type em_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the em_logs to update in case it exists.
     */
    where: em_logsWhereUniqueInput
    /**
     * In case the em_logs found by the `where` argument doesn't exist, create a new em_logs with this data.
     */
    create: XOR<em_logsCreateInput, em_logsUncheckedCreateInput>
    /**
     * In case the em_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_logsUpdateInput, em_logsUncheckedUpdateInput>
  }

  /**
   * em_logs delete
   */
  export type em_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
    /**
     * Filter which em_logs to delete.
     */
    where: em_logsWhereUniqueInput
  }

  /**
   * em_logs deleteMany
   */
  export type em_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_logs to delete
     */
    where?: em_logsWhereInput
    /**
     * Limit how many em_logs to delete.
     */
    limit?: number
  }

  /**
   * em_logs without action
   */
  export type em_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_logs
     */
    select?: em_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_logs
     */
    omit?: em_logsOmit<ExtArgs> | null
  }


  /**
   * Model em_loker
   */

  export type AggregateEm_loker = {
    _count: Em_lokerCountAggregateOutputType | null
    _avg: Em_lokerAvgAggregateOutputType | null
    _sum: Em_lokerSumAggregateOutputType | null
    _min: Em_lokerMinAggregateOutputType | null
    _max: Em_lokerMaxAggregateOutputType | null
  }

  export type Em_lokerAvgAggregateOutputType = {
    lokerid: number | null
    possid: number | null
    kategori: number | null
  }

  export type Em_lokerSumAggregateOutputType = {
    lokerid: number | null
    possid: number | null
    kategori: number | null
  }

  export type Em_lokerMinAggregateOutputType = {
    lokerid: number | null
    possid: number | null
    startdate: Date | null
    enddate: Date | null
    jobdesc: string | null
    qualify: string | null
    worktype: string | null
    salary: string | null
    contrtype: string | null
    posslevel: string | null
    status: string | null
    benefit: string | null
    fileimage: string | null
    createdate: Date | null
    lastupdate: Date | null
    userid: string | null
    kategori: number | null
  }

  export type Em_lokerMaxAggregateOutputType = {
    lokerid: number | null
    possid: number | null
    startdate: Date | null
    enddate: Date | null
    jobdesc: string | null
    qualify: string | null
    worktype: string | null
    salary: string | null
    contrtype: string | null
    posslevel: string | null
    status: string | null
    benefit: string | null
    fileimage: string | null
    createdate: Date | null
    lastupdate: Date | null
    userid: string | null
    kategori: number | null
  }

  export type Em_lokerCountAggregateOutputType = {
    lokerid: number
    possid: number
    startdate: number
    enddate: number
    jobdesc: number
    qualify: number
    worktype: number
    salary: number
    contrtype: number
    posslevel: number
    status: number
    benefit: number
    fileimage: number
    createdate: number
    lastupdate: number
    userid: number
    kategori: number
    _all: number
  }


  export type Em_lokerAvgAggregateInputType = {
    lokerid?: true
    possid?: true
    kategori?: true
  }

  export type Em_lokerSumAggregateInputType = {
    lokerid?: true
    possid?: true
    kategori?: true
  }

  export type Em_lokerMinAggregateInputType = {
    lokerid?: true
    possid?: true
    startdate?: true
    enddate?: true
    jobdesc?: true
    qualify?: true
    worktype?: true
    salary?: true
    contrtype?: true
    posslevel?: true
    status?: true
    benefit?: true
    fileimage?: true
    createdate?: true
    lastupdate?: true
    userid?: true
    kategori?: true
  }

  export type Em_lokerMaxAggregateInputType = {
    lokerid?: true
    possid?: true
    startdate?: true
    enddate?: true
    jobdesc?: true
    qualify?: true
    worktype?: true
    salary?: true
    contrtype?: true
    posslevel?: true
    status?: true
    benefit?: true
    fileimage?: true
    createdate?: true
    lastupdate?: true
    userid?: true
    kategori?: true
  }

  export type Em_lokerCountAggregateInputType = {
    lokerid?: true
    possid?: true
    startdate?: true
    enddate?: true
    jobdesc?: true
    qualify?: true
    worktype?: true
    salary?: true
    contrtype?: true
    posslevel?: true
    status?: true
    benefit?: true
    fileimage?: true
    createdate?: true
    lastupdate?: true
    userid?: true
    kategori?: true
    _all?: true
  }

  export type Em_lokerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_loker to aggregate.
     */
    where?: em_lokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_lokers to fetch.
     */
    orderBy?: em_lokerOrderByWithRelationInput | em_lokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_lokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_lokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_lokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_lokers
    **/
    _count?: true | Em_lokerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_lokerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_lokerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_lokerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_lokerMaxAggregateInputType
  }

  export type GetEm_lokerAggregateType<T extends Em_lokerAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_loker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_loker[P]>
      : GetScalarType<T[P], AggregateEm_loker[P]>
  }




  export type em_lokerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_lokerWhereInput
    orderBy?: em_lokerOrderByWithAggregationInput | em_lokerOrderByWithAggregationInput[]
    by: Em_lokerScalarFieldEnum[] | Em_lokerScalarFieldEnum
    having?: em_lokerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_lokerCountAggregateInputType | true
    _avg?: Em_lokerAvgAggregateInputType
    _sum?: Em_lokerSumAggregateInputType
    _min?: Em_lokerMinAggregateInputType
    _max?: Em_lokerMaxAggregateInputType
  }

  export type Em_lokerGroupByOutputType = {
    lokerid: number
    possid: number
    startdate: Date | null
    enddate: Date | null
    jobdesc: string | null
    qualify: string | null
    worktype: string | null
    salary: string | null
    contrtype: string | null
    posslevel: string | null
    status: string | null
    benefit: string | null
    fileimage: string | null
    createdate: Date | null
    lastupdate: Date | null
    userid: string | null
    kategori: number | null
    _count: Em_lokerCountAggregateOutputType | null
    _avg: Em_lokerAvgAggregateOutputType | null
    _sum: Em_lokerSumAggregateOutputType | null
    _min: Em_lokerMinAggregateOutputType | null
    _max: Em_lokerMaxAggregateOutputType | null
  }

  type GetEm_lokerGroupByPayload<T extends em_lokerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_lokerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_lokerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_lokerGroupByOutputType[P]>
            : GetScalarType<T[P], Em_lokerGroupByOutputType[P]>
        }
      >
    >


  export type em_lokerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lokerid?: boolean
    possid?: boolean
    startdate?: boolean
    enddate?: boolean
    jobdesc?: boolean
    qualify?: boolean
    worktype?: boolean
    salary?: boolean
    contrtype?: boolean
    posslevel?: boolean
    status?: boolean
    benefit?: boolean
    fileimage?: boolean
    createdate?: boolean
    lastupdate?: boolean
    userid?: boolean
    kategori?: boolean
    em_loktopik?: boolean | em_loker$em_loktopikArgs<ExtArgs>
    _count?: boolean | Em_lokerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_loker"]>



  export type em_lokerSelectScalar = {
    lokerid?: boolean
    possid?: boolean
    startdate?: boolean
    enddate?: boolean
    jobdesc?: boolean
    qualify?: boolean
    worktype?: boolean
    salary?: boolean
    contrtype?: boolean
    posslevel?: boolean
    status?: boolean
    benefit?: boolean
    fileimage?: boolean
    createdate?: boolean
    lastupdate?: boolean
    userid?: boolean
    kategori?: boolean
  }

  export type em_lokerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lokerid" | "possid" | "startdate" | "enddate" | "jobdesc" | "qualify" | "worktype" | "salary" | "contrtype" | "posslevel" | "status" | "benefit" | "fileimage" | "createdate" | "lastupdate" | "userid" | "kategori", ExtArgs["result"]["em_loker"]>
  export type em_lokerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_loktopik?: boolean | em_loker$em_loktopikArgs<ExtArgs>
    _count?: boolean | Em_lokerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_lokerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_loker"
    objects: {
      em_loktopik: Prisma.$em_loktopikPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      lokerid: number
      possid: number
      startdate: Date | null
      enddate: Date | null
      jobdesc: string | null
      qualify: string | null
      worktype: string | null
      salary: string | null
      contrtype: string | null
      posslevel: string | null
      status: string | null
      benefit: string | null
      fileimage: string | null
      createdate: Date | null
      lastupdate: Date | null
      userid: string | null
      kategori: number | null
    }, ExtArgs["result"]["em_loker"]>
    composites: {}
  }

  type em_lokerGetPayload<S extends boolean | null | undefined | em_lokerDefaultArgs> = $Result.GetResult<Prisma.$em_lokerPayload, S>

  type em_lokerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_lokerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_lokerCountAggregateInputType | true
    }

  export interface em_lokerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_loker'], meta: { name: 'em_loker' } }
    /**
     * Find zero or one Em_loker that matches the filter.
     * @param {em_lokerFindUniqueArgs} args - Arguments to find a Em_loker
     * @example
     * // Get one Em_loker
     * const em_loker = await prisma.em_loker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_lokerFindUniqueArgs>(args: SelectSubset<T, em_lokerFindUniqueArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_loker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_lokerFindUniqueOrThrowArgs} args - Arguments to find a Em_loker
     * @example
     * // Get one Em_loker
     * const em_loker = await prisma.em_loker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_lokerFindUniqueOrThrowArgs>(args: SelectSubset<T, em_lokerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_loker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_lokerFindFirstArgs} args - Arguments to find a Em_loker
     * @example
     * // Get one Em_loker
     * const em_loker = await prisma.em_loker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_lokerFindFirstArgs>(args?: SelectSubset<T, em_lokerFindFirstArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_loker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_lokerFindFirstOrThrowArgs} args - Arguments to find a Em_loker
     * @example
     * // Get one Em_loker
     * const em_loker = await prisma.em_loker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_lokerFindFirstOrThrowArgs>(args?: SelectSubset<T, em_lokerFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_lokers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_lokerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_lokers
     * const em_lokers = await prisma.em_loker.findMany()
     * 
     * // Get first 10 Em_lokers
     * const em_lokers = await prisma.em_loker.findMany({ take: 10 })
     * 
     * // Only select the `lokerid`
     * const em_lokerWithLokeridOnly = await prisma.em_loker.findMany({ select: { lokerid: true } })
     * 
     */
    findMany<T extends em_lokerFindManyArgs>(args?: SelectSubset<T, em_lokerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_loker.
     * @param {em_lokerCreateArgs} args - Arguments to create a Em_loker.
     * @example
     * // Create one Em_loker
     * const Em_loker = await prisma.em_loker.create({
     *   data: {
     *     // ... data to create a Em_loker
     *   }
     * })
     * 
     */
    create<T extends em_lokerCreateArgs>(args: SelectSubset<T, em_lokerCreateArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_lokers.
     * @param {em_lokerCreateManyArgs} args - Arguments to create many Em_lokers.
     * @example
     * // Create many Em_lokers
     * const em_loker = await prisma.em_loker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_lokerCreateManyArgs>(args?: SelectSubset<T, em_lokerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_loker.
     * @param {em_lokerDeleteArgs} args - Arguments to delete one Em_loker.
     * @example
     * // Delete one Em_loker
     * const Em_loker = await prisma.em_loker.delete({
     *   where: {
     *     // ... filter to delete one Em_loker
     *   }
     * })
     * 
     */
    delete<T extends em_lokerDeleteArgs>(args: SelectSubset<T, em_lokerDeleteArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_loker.
     * @param {em_lokerUpdateArgs} args - Arguments to update one Em_loker.
     * @example
     * // Update one Em_loker
     * const em_loker = await prisma.em_loker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_lokerUpdateArgs>(args: SelectSubset<T, em_lokerUpdateArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_lokers.
     * @param {em_lokerDeleteManyArgs} args - Arguments to filter Em_lokers to delete.
     * @example
     * // Delete a few Em_lokers
     * const { count } = await prisma.em_loker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_lokerDeleteManyArgs>(args?: SelectSubset<T, em_lokerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_lokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_lokerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_lokers
     * const em_loker = await prisma.em_loker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_lokerUpdateManyArgs>(args: SelectSubset<T, em_lokerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_loker.
     * @param {em_lokerUpsertArgs} args - Arguments to update or create a Em_loker.
     * @example
     * // Update or create a Em_loker
     * const em_loker = await prisma.em_loker.upsert({
     *   create: {
     *     // ... data to create a Em_loker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_loker we want to update
     *   }
     * })
     */
    upsert<T extends em_lokerUpsertArgs>(args: SelectSubset<T, em_lokerUpsertArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_lokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_lokerCountArgs} args - Arguments to filter Em_lokers to count.
     * @example
     * // Count the number of Em_lokers
     * const count = await prisma.em_loker.count({
     *   where: {
     *     // ... the filter for the Em_lokers we want to count
     *   }
     * })
    **/
    count<T extends em_lokerCountArgs>(
      args?: Subset<T, em_lokerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_lokerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_loker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_lokerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_lokerAggregateArgs>(args: Subset<T, Em_lokerAggregateArgs>): Prisma.PrismaPromise<GetEm_lokerAggregateType<T>>

    /**
     * Group by Em_loker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_lokerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_lokerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_lokerGroupByArgs['orderBy'] }
        : { orderBy?: em_lokerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_lokerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_lokerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_loker model
   */
  readonly fields: em_lokerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_loker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_lokerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_loktopik<T extends em_loker$em_loktopikArgs<ExtArgs> = {}>(args?: Subset<T, em_loker$em_loktopikArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_loker model
   */
  interface em_lokerFieldRefs {
    readonly lokerid: FieldRef<"em_loker", 'Int'>
    readonly possid: FieldRef<"em_loker", 'Int'>
    readonly startdate: FieldRef<"em_loker", 'DateTime'>
    readonly enddate: FieldRef<"em_loker", 'DateTime'>
    readonly jobdesc: FieldRef<"em_loker", 'String'>
    readonly qualify: FieldRef<"em_loker", 'String'>
    readonly worktype: FieldRef<"em_loker", 'String'>
    readonly salary: FieldRef<"em_loker", 'String'>
    readonly contrtype: FieldRef<"em_loker", 'String'>
    readonly posslevel: FieldRef<"em_loker", 'String'>
    readonly status: FieldRef<"em_loker", 'String'>
    readonly benefit: FieldRef<"em_loker", 'String'>
    readonly fileimage: FieldRef<"em_loker", 'String'>
    readonly createdate: FieldRef<"em_loker", 'DateTime'>
    readonly lastupdate: FieldRef<"em_loker", 'DateTime'>
    readonly userid: FieldRef<"em_loker", 'String'>
    readonly kategori: FieldRef<"em_loker", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_loker findUnique
   */
  export type em_lokerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * Filter, which em_loker to fetch.
     */
    where: em_lokerWhereUniqueInput
  }

  /**
   * em_loker findUniqueOrThrow
   */
  export type em_lokerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * Filter, which em_loker to fetch.
     */
    where: em_lokerWhereUniqueInput
  }

  /**
   * em_loker findFirst
   */
  export type em_lokerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * Filter, which em_loker to fetch.
     */
    where?: em_lokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_lokers to fetch.
     */
    orderBy?: em_lokerOrderByWithRelationInput | em_lokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_lokers.
     */
    cursor?: em_lokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_lokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_lokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_lokers.
     */
    distinct?: Em_lokerScalarFieldEnum | Em_lokerScalarFieldEnum[]
  }

  /**
   * em_loker findFirstOrThrow
   */
  export type em_lokerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * Filter, which em_loker to fetch.
     */
    where?: em_lokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_lokers to fetch.
     */
    orderBy?: em_lokerOrderByWithRelationInput | em_lokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_lokers.
     */
    cursor?: em_lokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_lokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_lokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_lokers.
     */
    distinct?: Em_lokerScalarFieldEnum | Em_lokerScalarFieldEnum[]
  }

  /**
   * em_loker findMany
   */
  export type em_lokerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * Filter, which em_lokers to fetch.
     */
    where?: em_lokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_lokers to fetch.
     */
    orderBy?: em_lokerOrderByWithRelationInput | em_lokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_lokers.
     */
    cursor?: em_lokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_lokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_lokers.
     */
    skip?: number
    distinct?: Em_lokerScalarFieldEnum | Em_lokerScalarFieldEnum[]
  }

  /**
   * em_loker create
   */
  export type em_lokerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * The data needed to create a em_loker.
     */
    data: XOR<em_lokerCreateInput, em_lokerUncheckedCreateInput>
  }

  /**
   * em_loker createMany
   */
  export type em_lokerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_lokers.
     */
    data: em_lokerCreateManyInput | em_lokerCreateManyInput[]
  }

  /**
   * em_loker update
   */
  export type em_lokerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * The data needed to update a em_loker.
     */
    data: XOR<em_lokerUpdateInput, em_lokerUncheckedUpdateInput>
    /**
     * Choose, which em_loker to update.
     */
    where: em_lokerWhereUniqueInput
  }

  /**
   * em_loker updateMany
   */
  export type em_lokerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_lokers.
     */
    data: XOR<em_lokerUpdateManyMutationInput, em_lokerUncheckedUpdateManyInput>
    /**
     * Filter which em_lokers to update
     */
    where?: em_lokerWhereInput
    /**
     * Limit how many em_lokers to update.
     */
    limit?: number
  }

  /**
   * em_loker upsert
   */
  export type em_lokerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * The filter to search for the em_loker to update in case it exists.
     */
    where: em_lokerWhereUniqueInput
    /**
     * In case the em_loker found by the `where` argument doesn't exist, create a new em_loker with this data.
     */
    create: XOR<em_lokerCreateInput, em_lokerUncheckedCreateInput>
    /**
     * In case the em_loker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_lokerUpdateInput, em_lokerUncheckedUpdateInput>
  }

  /**
   * em_loker delete
   */
  export type em_lokerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
    /**
     * Filter which em_loker to delete.
     */
    where: em_lokerWhereUniqueInput
  }

  /**
   * em_loker deleteMany
   */
  export type em_lokerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_lokers to delete
     */
    where?: em_lokerWhereInput
    /**
     * Limit how many em_lokers to delete.
     */
    limit?: number
  }

  /**
   * em_loker.em_loktopik
   */
  export type em_loker$em_loktopikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    where?: em_loktopikWhereInput
    orderBy?: em_loktopikOrderByWithRelationInput | em_loktopikOrderByWithRelationInput[]
    cursor?: em_loktopikWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_loktopikScalarFieldEnum | Em_loktopikScalarFieldEnum[]
  }

  /**
   * em_loker without action
   */
  export type em_lokerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loker
     */
    select?: em_lokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loker
     */
    omit?: em_lokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_lokerInclude<ExtArgs> | null
  }


  /**
   * Model em_loktopik
   */

  export type AggregateEm_loktopik = {
    _count: Em_loktopikCountAggregateOutputType | null
    _avg: Em_loktopikAvgAggregateOutputType | null
    _sum: Em_loktopikSumAggregateOutputType | null
    _min: Em_loktopikMinAggregateOutputType | null
    _max: Em_loktopikMaxAggregateOutputType | null
  }

  export type Em_loktopikAvgAggregateOutputType = {
    id: number | null
    loker_id: number | null
    topik_id: number | null
    jmlh_soal: number | null
    possid: number | null
    urutan: number | null
  }

  export type Em_loktopikSumAggregateOutputType = {
    id: number | null
    loker_id: number | null
    topik_id: number | null
    jmlh_soal: number | null
    possid: number | null
    urutan: number | null
  }

  export type Em_loktopikMinAggregateOutputType = {
    id: number | null
    loker_id: number | null
    topik_id: number | null
    jmlh_soal: number | null
    created_at: Date | null
    possid: number | null
    urutan: number | null
  }

  export type Em_loktopikMaxAggregateOutputType = {
    id: number | null
    loker_id: number | null
    topik_id: number | null
    jmlh_soal: number | null
    created_at: Date | null
    possid: number | null
    urutan: number | null
  }

  export type Em_loktopikCountAggregateOutputType = {
    id: number
    loker_id: number
    topik_id: number
    jmlh_soal: number
    created_at: number
    possid: number
    urutan: number
    _all: number
  }


  export type Em_loktopikAvgAggregateInputType = {
    id?: true
    loker_id?: true
    topik_id?: true
    jmlh_soal?: true
    possid?: true
    urutan?: true
  }

  export type Em_loktopikSumAggregateInputType = {
    id?: true
    loker_id?: true
    topik_id?: true
    jmlh_soal?: true
    possid?: true
    urutan?: true
  }

  export type Em_loktopikMinAggregateInputType = {
    id?: true
    loker_id?: true
    topik_id?: true
    jmlh_soal?: true
    created_at?: true
    possid?: true
    urutan?: true
  }

  export type Em_loktopikMaxAggregateInputType = {
    id?: true
    loker_id?: true
    topik_id?: true
    jmlh_soal?: true
    created_at?: true
    possid?: true
    urutan?: true
  }

  export type Em_loktopikCountAggregateInputType = {
    id?: true
    loker_id?: true
    topik_id?: true
    jmlh_soal?: true
    created_at?: true
    possid?: true
    urutan?: true
    _all?: true
  }

  export type Em_loktopikAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_loktopik to aggregate.
     */
    where?: em_loktopikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_loktopiks to fetch.
     */
    orderBy?: em_loktopikOrderByWithRelationInput | em_loktopikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_loktopikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_loktopiks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_loktopiks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_loktopiks
    **/
    _count?: true | Em_loktopikCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_loktopikAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_loktopikSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_loktopikMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_loktopikMaxAggregateInputType
  }

  export type GetEm_loktopikAggregateType<T extends Em_loktopikAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_loktopik]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_loktopik[P]>
      : GetScalarType<T[P], AggregateEm_loktopik[P]>
  }




  export type em_loktopikGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_loktopikWhereInput
    orderBy?: em_loktopikOrderByWithAggregationInput | em_loktopikOrderByWithAggregationInput[]
    by: Em_loktopikScalarFieldEnum[] | Em_loktopikScalarFieldEnum
    having?: em_loktopikScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_loktopikCountAggregateInputType | true
    _avg?: Em_loktopikAvgAggregateInputType
    _sum?: Em_loktopikSumAggregateInputType
    _min?: Em_loktopikMinAggregateInputType
    _max?: Em_loktopikMaxAggregateInputType
  }

  export type Em_loktopikGroupByOutputType = {
    id: number
    loker_id: number
    topik_id: number
    jmlh_soal: number
    created_at: Date | null
    possid: number | null
    urutan: number | null
    _count: Em_loktopikCountAggregateOutputType | null
    _avg: Em_loktopikAvgAggregateOutputType | null
    _sum: Em_loktopikSumAggregateOutputType | null
    _min: Em_loktopikMinAggregateOutputType | null
    _max: Em_loktopikMaxAggregateOutputType | null
  }

  type GetEm_loktopikGroupByPayload<T extends em_loktopikGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_loktopikGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_loktopikGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_loktopikGroupByOutputType[P]>
            : GetScalarType<T[P], Em_loktopikGroupByOutputType[P]>
        }
      >
    >


  export type em_loktopikSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loker_id?: boolean
    topik_id?: boolean
    jmlh_soal?: boolean
    created_at?: boolean
    possid?: boolean
    urutan?: boolean
    em_loker?: boolean | em_lokerDefaultArgs<ExtArgs>
    em_exams?: boolean | em_examsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_loktopik"]>



  export type em_loktopikSelectScalar = {
    id?: boolean
    loker_id?: boolean
    topik_id?: boolean
    jmlh_soal?: boolean
    created_at?: boolean
    possid?: boolean
    urutan?: boolean
  }

  export type em_loktopikOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loker_id" | "topik_id" | "jmlh_soal" | "created_at" | "possid" | "urutan", ExtArgs["result"]["em_loktopik"]>
  export type em_loktopikInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_loker?: boolean | em_lokerDefaultArgs<ExtArgs>
    em_exams?: boolean | em_examsDefaultArgs<ExtArgs>
  }

  export type $em_loktopikPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_loktopik"
    objects: {
      em_loker: Prisma.$em_lokerPayload<ExtArgs>
      em_exams: Prisma.$em_examsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loker_id: number
      topik_id: number
      jmlh_soal: number
      created_at: Date | null
      possid: number | null
      urutan: number | null
    }, ExtArgs["result"]["em_loktopik"]>
    composites: {}
  }

  type em_loktopikGetPayload<S extends boolean | null | undefined | em_loktopikDefaultArgs> = $Result.GetResult<Prisma.$em_loktopikPayload, S>

  type em_loktopikCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_loktopikFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_loktopikCountAggregateInputType | true
    }

  export interface em_loktopikDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_loktopik'], meta: { name: 'em_loktopik' } }
    /**
     * Find zero or one Em_loktopik that matches the filter.
     * @param {em_loktopikFindUniqueArgs} args - Arguments to find a Em_loktopik
     * @example
     * // Get one Em_loktopik
     * const em_loktopik = await prisma.em_loktopik.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_loktopikFindUniqueArgs>(args: SelectSubset<T, em_loktopikFindUniqueArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_loktopik that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_loktopikFindUniqueOrThrowArgs} args - Arguments to find a Em_loktopik
     * @example
     * // Get one Em_loktopik
     * const em_loktopik = await prisma.em_loktopik.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_loktopikFindUniqueOrThrowArgs>(args: SelectSubset<T, em_loktopikFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_loktopik that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_loktopikFindFirstArgs} args - Arguments to find a Em_loktopik
     * @example
     * // Get one Em_loktopik
     * const em_loktopik = await prisma.em_loktopik.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_loktopikFindFirstArgs>(args?: SelectSubset<T, em_loktopikFindFirstArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_loktopik that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_loktopikFindFirstOrThrowArgs} args - Arguments to find a Em_loktopik
     * @example
     * // Get one Em_loktopik
     * const em_loktopik = await prisma.em_loktopik.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_loktopikFindFirstOrThrowArgs>(args?: SelectSubset<T, em_loktopikFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_loktopiks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_loktopikFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_loktopiks
     * const em_loktopiks = await prisma.em_loktopik.findMany()
     * 
     * // Get first 10 Em_loktopiks
     * const em_loktopiks = await prisma.em_loktopik.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_loktopikWithIdOnly = await prisma.em_loktopik.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_loktopikFindManyArgs>(args?: SelectSubset<T, em_loktopikFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_loktopik.
     * @param {em_loktopikCreateArgs} args - Arguments to create a Em_loktopik.
     * @example
     * // Create one Em_loktopik
     * const Em_loktopik = await prisma.em_loktopik.create({
     *   data: {
     *     // ... data to create a Em_loktopik
     *   }
     * })
     * 
     */
    create<T extends em_loktopikCreateArgs>(args: SelectSubset<T, em_loktopikCreateArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_loktopiks.
     * @param {em_loktopikCreateManyArgs} args - Arguments to create many Em_loktopiks.
     * @example
     * // Create many Em_loktopiks
     * const em_loktopik = await prisma.em_loktopik.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_loktopikCreateManyArgs>(args?: SelectSubset<T, em_loktopikCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_loktopik.
     * @param {em_loktopikDeleteArgs} args - Arguments to delete one Em_loktopik.
     * @example
     * // Delete one Em_loktopik
     * const Em_loktopik = await prisma.em_loktopik.delete({
     *   where: {
     *     // ... filter to delete one Em_loktopik
     *   }
     * })
     * 
     */
    delete<T extends em_loktopikDeleteArgs>(args: SelectSubset<T, em_loktopikDeleteArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_loktopik.
     * @param {em_loktopikUpdateArgs} args - Arguments to update one Em_loktopik.
     * @example
     * // Update one Em_loktopik
     * const em_loktopik = await prisma.em_loktopik.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_loktopikUpdateArgs>(args: SelectSubset<T, em_loktopikUpdateArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_loktopiks.
     * @param {em_loktopikDeleteManyArgs} args - Arguments to filter Em_loktopiks to delete.
     * @example
     * // Delete a few Em_loktopiks
     * const { count } = await prisma.em_loktopik.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_loktopikDeleteManyArgs>(args?: SelectSubset<T, em_loktopikDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_loktopiks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_loktopikUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_loktopiks
     * const em_loktopik = await prisma.em_loktopik.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_loktopikUpdateManyArgs>(args: SelectSubset<T, em_loktopikUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_loktopik.
     * @param {em_loktopikUpsertArgs} args - Arguments to update or create a Em_loktopik.
     * @example
     * // Update or create a Em_loktopik
     * const em_loktopik = await prisma.em_loktopik.upsert({
     *   create: {
     *     // ... data to create a Em_loktopik
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_loktopik we want to update
     *   }
     * })
     */
    upsert<T extends em_loktopikUpsertArgs>(args: SelectSubset<T, em_loktopikUpsertArgs<ExtArgs>>): Prisma__em_loktopikClient<$Result.GetResult<Prisma.$em_loktopikPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_loktopiks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_loktopikCountArgs} args - Arguments to filter Em_loktopiks to count.
     * @example
     * // Count the number of Em_loktopiks
     * const count = await prisma.em_loktopik.count({
     *   where: {
     *     // ... the filter for the Em_loktopiks we want to count
     *   }
     * })
    **/
    count<T extends em_loktopikCountArgs>(
      args?: Subset<T, em_loktopikCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_loktopikCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_loktopik.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_loktopikAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_loktopikAggregateArgs>(args: Subset<T, Em_loktopikAggregateArgs>): Prisma.PrismaPromise<GetEm_loktopikAggregateType<T>>

    /**
     * Group by Em_loktopik.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_loktopikGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_loktopikGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_loktopikGroupByArgs['orderBy'] }
        : { orderBy?: em_loktopikGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_loktopikGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_loktopikGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_loktopik model
   */
  readonly fields: em_loktopikFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_loktopik.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_loktopikClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_loker<T extends em_lokerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_lokerDefaultArgs<ExtArgs>>): Prisma__em_lokerClient<$Result.GetResult<Prisma.$em_lokerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    em_exams<T extends em_examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_examsDefaultArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_loktopik model
   */
  interface em_loktopikFieldRefs {
    readonly id: FieldRef<"em_loktopik", 'Int'>
    readonly loker_id: FieldRef<"em_loktopik", 'Int'>
    readonly topik_id: FieldRef<"em_loktopik", 'Int'>
    readonly jmlh_soal: FieldRef<"em_loktopik", 'Int'>
    readonly created_at: FieldRef<"em_loktopik", 'DateTime'>
    readonly possid: FieldRef<"em_loktopik", 'Int'>
    readonly urutan: FieldRef<"em_loktopik", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_loktopik findUnique
   */
  export type em_loktopikFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * Filter, which em_loktopik to fetch.
     */
    where: em_loktopikWhereUniqueInput
  }

  /**
   * em_loktopik findUniqueOrThrow
   */
  export type em_loktopikFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * Filter, which em_loktopik to fetch.
     */
    where: em_loktopikWhereUniqueInput
  }

  /**
   * em_loktopik findFirst
   */
  export type em_loktopikFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * Filter, which em_loktopik to fetch.
     */
    where?: em_loktopikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_loktopiks to fetch.
     */
    orderBy?: em_loktopikOrderByWithRelationInput | em_loktopikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_loktopiks.
     */
    cursor?: em_loktopikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_loktopiks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_loktopiks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_loktopiks.
     */
    distinct?: Em_loktopikScalarFieldEnum | Em_loktopikScalarFieldEnum[]
  }

  /**
   * em_loktopik findFirstOrThrow
   */
  export type em_loktopikFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * Filter, which em_loktopik to fetch.
     */
    where?: em_loktopikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_loktopiks to fetch.
     */
    orderBy?: em_loktopikOrderByWithRelationInput | em_loktopikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_loktopiks.
     */
    cursor?: em_loktopikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_loktopiks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_loktopiks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_loktopiks.
     */
    distinct?: Em_loktopikScalarFieldEnum | Em_loktopikScalarFieldEnum[]
  }

  /**
   * em_loktopik findMany
   */
  export type em_loktopikFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * Filter, which em_loktopiks to fetch.
     */
    where?: em_loktopikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_loktopiks to fetch.
     */
    orderBy?: em_loktopikOrderByWithRelationInput | em_loktopikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_loktopiks.
     */
    cursor?: em_loktopikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_loktopiks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_loktopiks.
     */
    skip?: number
    distinct?: Em_loktopikScalarFieldEnum | Em_loktopikScalarFieldEnum[]
  }

  /**
   * em_loktopik create
   */
  export type em_loktopikCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * The data needed to create a em_loktopik.
     */
    data: XOR<em_loktopikCreateInput, em_loktopikUncheckedCreateInput>
  }

  /**
   * em_loktopik createMany
   */
  export type em_loktopikCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_loktopiks.
     */
    data: em_loktopikCreateManyInput | em_loktopikCreateManyInput[]
  }

  /**
   * em_loktopik update
   */
  export type em_loktopikUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * The data needed to update a em_loktopik.
     */
    data: XOR<em_loktopikUpdateInput, em_loktopikUncheckedUpdateInput>
    /**
     * Choose, which em_loktopik to update.
     */
    where: em_loktopikWhereUniqueInput
  }

  /**
   * em_loktopik updateMany
   */
  export type em_loktopikUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_loktopiks.
     */
    data: XOR<em_loktopikUpdateManyMutationInput, em_loktopikUncheckedUpdateManyInput>
    /**
     * Filter which em_loktopiks to update
     */
    where?: em_loktopikWhereInput
    /**
     * Limit how many em_loktopiks to update.
     */
    limit?: number
  }

  /**
   * em_loktopik upsert
   */
  export type em_loktopikUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * The filter to search for the em_loktopik to update in case it exists.
     */
    where: em_loktopikWhereUniqueInput
    /**
     * In case the em_loktopik found by the `where` argument doesn't exist, create a new em_loktopik with this data.
     */
    create: XOR<em_loktopikCreateInput, em_loktopikUncheckedCreateInput>
    /**
     * In case the em_loktopik was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_loktopikUpdateInput, em_loktopikUncheckedUpdateInput>
  }

  /**
   * em_loktopik delete
   */
  export type em_loktopikDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
    /**
     * Filter which em_loktopik to delete.
     */
    where: em_loktopikWhereUniqueInput
  }

  /**
   * em_loktopik deleteMany
   */
  export type em_loktopikDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_loktopiks to delete
     */
    where?: em_loktopikWhereInput
    /**
     * Limit how many em_loktopiks to delete.
     */
    limit?: number
  }

  /**
   * em_loktopik without action
   */
  export type em_loktopikDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_loktopik
     */
    select?: em_loktopikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_loktopik
     */
    omit?: em_loktopikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_loktopikInclude<ExtArgs> | null
  }


  /**
   * Model em_materi_file
   */

  export type AggregateEm_materi_file = {
    _count: Em_materi_fileCountAggregateOutputType | null
    _avg: Em_materi_fileAvgAggregateOutputType | null
    _sum: Em_materi_fileSumAggregateOutputType | null
    _min: Em_materi_fileMinAggregateOutputType | null
    _max: Em_materi_fileMaxAggregateOutputType | null
  }

  export type Em_materi_fileAvgAggregateOutputType = {
    id: number | null
    materi_id: number | null
    file_type: number | null
    file_size: number | null
    urutan: number | null
    galeri_id: number | null
  }

  export type Em_materi_fileSumAggregateOutputType = {
    id: number | null
    materi_id: number | null
    file_type: number | null
    file_size: number | null
    urutan: number | null
    galeri_id: number | null
  }

  export type Em_materi_fileMinAggregateOutputType = {
    id: number | null
    materi_id: number | null
    file_name: string | null
    file_type: number | null
    file_size: number | null
    url: string | null
    urutan: number | null
    judul: string | null
    created_at: Date | null
    updated_at: Date | null
    galeri_id: number | null
  }

  export type Em_materi_fileMaxAggregateOutputType = {
    id: number | null
    materi_id: number | null
    file_name: string | null
    file_type: number | null
    file_size: number | null
    url: string | null
    urutan: number | null
    judul: string | null
    created_at: Date | null
    updated_at: Date | null
    galeri_id: number | null
  }

  export type Em_materi_fileCountAggregateOutputType = {
    id: number
    materi_id: number
    file_name: number
    file_type: number
    file_size: number
    url: number
    urutan: number
    judul: number
    created_at: number
    updated_at: number
    galeri_id: number
    _all: number
  }


  export type Em_materi_fileAvgAggregateInputType = {
    id?: true
    materi_id?: true
    file_type?: true
    file_size?: true
    urutan?: true
    galeri_id?: true
  }

  export type Em_materi_fileSumAggregateInputType = {
    id?: true
    materi_id?: true
    file_type?: true
    file_size?: true
    urutan?: true
    galeri_id?: true
  }

  export type Em_materi_fileMinAggregateInputType = {
    id?: true
    materi_id?: true
    file_name?: true
    file_type?: true
    file_size?: true
    url?: true
    urutan?: true
    judul?: true
    created_at?: true
    updated_at?: true
    galeri_id?: true
  }

  export type Em_materi_fileMaxAggregateInputType = {
    id?: true
    materi_id?: true
    file_name?: true
    file_type?: true
    file_size?: true
    url?: true
    urutan?: true
    judul?: true
    created_at?: true
    updated_at?: true
    galeri_id?: true
  }

  export type Em_materi_fileCountAggregateInputType = {
    id?: true
    materi_id?: true
    file_name?: true
    file_type?: true
    file_size?: true
    url?: true
    urutan?: true
    judul?: true
    created_at?: true
    updated_at?: true
    galeri_id?: true
    _all?: true
  }

  export type Em_materi_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi_file to aggregate.
     */
    where?: em_materi_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_files to fetch.
     */
    orderBy?: em_materi_fileOrderByWithRelationInput | em_materi_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_materi_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_materi_files
    **/
    _count?: true | Em_materi_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_materi_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_materi_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_materi_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_materi_fileMaxAggregateInputType
  }

  export type GetEm_materi_fileAggregateType<T extends Em_materi_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_materi_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_materi_file[P]>
      : GetScalarType<T[P], AggregateEm_materi_file[P]>
  }




  export type em_materi_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi_fileWhereInput
    orderBy?: em_materi_fileOrderByWithAggregationInput | em_materi_fileOrderByWithAggregationInput[]
    by: Em_materi_fileScalarFieldEnum[] | Em_materi_fileScalarFieldEnum
    having?: em_materi_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_materi_fileCountAggregateInputType | true
    _avg?: Em_materi_fileAvgAggregateInputType
    _sum?: Em_materi_fileSumAggregateInputType
    _min?: Em_materi_fileMinAggregateInputType
    _max?: Em_materi_fileMaxAggregateInputType
  }

  export type Em_materi_fileGroupByOutputType = {
    id: number
    materi_id: number
    file_name: string
    file_type: number
    file_size: number | null
    url: string | null
    urutan: number | null
    judul: string | null
    created_at: Date | null
    updated_at: Date | null
    galeri_id: number | null
    _count: Em_materi_fileCountAggregateOutputType | null
    _avg: Em_materi_fileAvgAggregateOutputType | null
    _sum: Em_materi_fileSumAggregateOutputType | null
    _min: Em_materi_fileMinAggregateOutputType | null
    _max: Em_materi_fileMaxAggregateOutputType | null
  }

  type GetEm_materi_fileGroupByPayload<T extends em_materi_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_materi_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_materi_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_materi_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Em_materi_fileGroupByOutputType[P]>
        }
      >
    >


  export type em_materi_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materi_id?: boolean
    file_name?: boolean
    file_type?: boolean
    file_size?: boolean
    url?: boolean
    urutan?: boolean
    judul?: boolean
    created_at?: boolean
    updated_at?: boolean
    galeri_id?: boolean
    em_materi1?: boolean | em_materi1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_materi_file"]>



  export type em_materi_fileSelectScalar = {
    id?: boolean
    materi_id?: boolean
    file_name?: boolean
    file_type?: boolean
    file_size?: boolean
    url?: boolean
    urutan?: boolean
    judul?: boolean
    created_at?: boolean
    updated_at?: boolean
    galeri_id?: boolean
  }

  export type em_materi_fileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materi_id" | "file_name" | "file_type" | "file_size" | "url" | "urutan" | "judul" | "created_at" | "updated_at" | "galeri_id", ExtArgs["result"]["em_materi_file"]>
  export type em_materi_fileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_materi1?: boolean | em_materi1DefaultArgs<ExtArgs>
  }

  export type $em_materi_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_materi_file"
    objects: {
      em_materi1: Prisma.$em_materi1Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materi_id: number
      file_name: string
      file_type: number
      file_size: number | null
      url: string | null
      urutan: number | null
      judul: string | null
      created_at: Date | null
      updated_at: Date | null
      galeri_id: number | null
    }, ExtArgs["result"]["em_materi_file"]>
    composites: {}
  }

  type em_materi_fileGetPayload<S extends boolean | null | undefined | em_materi_fileDefaultArgs> = $Result.GetResult<Prisma.$em_materi_filePayload, S>

  type em_materi_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_materi_fileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_materi_fileCountAggregateInputType | true
    }

  export interface em_materi_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_materi_file'], meta: { name: 'em_materi_file' } }
    /**
     * Find zero or one Em_materi_file that matches the filter.
     * @param {em_materi_fileFindUniqueArgs} args - Arguments to find a Em_materi_file
     * @example
     * // Get one Em_materi_file
     * const em_materi_file = await prisma.em_materi_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_materi_fileFindUniqueArgs>(args: SelectSubset<T, em_materi_fileFindUniqueArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_materi_file that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_materi_fileFindUniqueOrThrowArgs} args - Arguments to find a Em_materi_file
     * @example
     * // Get one Em_materi_file
     * const em_materi_file = await prisma.em_materi_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_materi_fileFindUniqueOrThrowArgs>(args: SelectSubset<T, em_materi_fileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_fileFindFirstArgs} args - Arguments to find a Em_materi_file
     * @example
     * // Get one Em_materi_file
     * const em_materi_file = await prisma.em_materi_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_materi_fileFindFirstArgs>(args?: SelectSubset<T, em_materi_fileFindFirstArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_fileFindFirstOrThrowArgs} args - Arguments to find a Em_materi_file
     * @example
     * // Get one Em_materi_file
     * const em_materi_file = await prisma.em_materi_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_materi_fileFindFirstOrThrowArgs>(args?: SelectSubset<T, em_materi_fileFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_materi_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_fileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_materi_files
     * const em_materi_files = await prisma.em_materi_file.findMany()
     * 
     * // Get first 10 Em_materi_files
     * const em_materi_files = await prisma.em_materi_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_materi_fileWithIdOnly = await prisma.em_materi_file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_materi_fileFindManyArgs>(args?: SelectSubset<T, em_materi_fileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_materi_file.
     * @param {em_materi_fileCreateArgs} args - Arguments to create a Em_materi_file.
     * @example
     * // Create one Em_materi_file
     * const Em_materi_file = await prisma.em_materi_file.create({
     *   data: {
     *     // ... data to create a Em_materi_file
     *   }
     * })
     * 
     */
    create<T extends em_materi_fileCreateArgs>(args: SelectSubset<T, em_materi_fileCreateArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_materi_files.
     * @param {em_materi_fileCreateManyArgs} args - Arguments to create many Em_materi_files.
     * @example
     * // Create many Em_materi_files
     * const em_materi_file = await prisma.em_materi_file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_materi_fileCreateManyArgs>(args?: SelectSubset<T, em_materi_fileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_materi_file.
     * @param {em_materi_fileDeleteArgs} args - Arguments to delete one Em_materi_file.
     * @example
     * // Delete one Em_materi_file
     * const Em_materi_file = await prisma.em_materi_file.delete({
     *   where: {
     *     // ... filter to delete one Em_materi_file
     *   }
     * })
     * 
     */
    delete<T extends em_materi_fileDeleteArgs>(args: SelectSubset<T, em_materi_fileDeleteArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_materi_file.
     * @param {em_materi_fileUpdateArgs} args - Arguments to update one Em_materi_file.
     * @example
     * // Update one Em_materi_file
     * const em_materi_file = await prisma.em_materi_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_materi_fileUpdateArgs>(args: SelectSubset<T, em_materi_fileUpdateArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_materi_files.
     * @param {em_materi_fileDeleteManyArgs} args - Arguments to filter Em_materi_files to delete.
     * @example
     * // Delete a few Em_materi_files
     * const { count } = await prisma.em_materi_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_materi_fileDeleteManyArgs>(args?: SelectSubset<T, em_materi_fileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_materi_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_materi_files
     * const em_materi_file = await prisma.em_materi_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_materi_fileUpdateManyArgs>(args: SelectSubset<T, em_materi_fileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_materi_file.
     * @param {em_materi_fileUpsertArgs} args - Arguments to update or create a Em_materi_file.
     * @example
     * // Update or create a Em_materi_file
     * const em_materi_file = await prisma.em_materi_file.upsert({
     *   create: {
     *     // ... data to create a Em_materi_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_materi_file we want to update
     *   }
     * })
     */
    upsert<T extends em_materi_fileUpsertArgs>(args: SelectSubset<T, em_materi_fileUpsertArgs<ExtArgs>>): Prisma__em_materi_fileClient<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_materi_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_fileCountArgs} args - Arguments to filter Em_materi_files to count.
     * @example
     * // Count the number of Em_materi_files
     * const count = await prisma.em_materi_file.count({
     *   where: {
     *     // ... the filter for the Em_materi_files we want to count
     *   }
     * })
    **/
    count<T extends em_materi_fileCountArgs>(
      args?: Subset<T, em_materi_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_materi_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_materi_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_materi_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_materi_fileAggregateArgs>(args: Subset<T, Em_materi_fileAggregateArgs>): Prisma.PrismaPromise<GetEm_materi_fileAggregateType<T>>

    /**
     * Group by Em_materi_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_materi_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_materi_fileGroupByArgs['orderBy'] }
        : { orderBy?: em_materi_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_materi_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_materi_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_materi_file model
   */
  readonly fields: em_materi_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_materi_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_materi_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_materi1<T extends em_materi1DefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_materi1DefaultArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_materi_file model
   */
  interface em_materi_fileFieldRefs {
    readonly id: FieldRef<"em_materi_file", 'Int'>
    readonly materi_id: FieldRef<"em_materi_file", 'Int'>
    readonly file_name: FieldRef<"em_materi_file", 'String'>
    readonly file_type: FieldRef<"em_materi_file", 'Int'>
    readonly file_size: FieldRef<"em_materi_file", 'Float'>
    readonly url: FieldRef<"em_materi_file", 'String'>
    readonly urutan: FieldRef<"em_materi_file", 'Int'>
    readonly judul: FieldRef<"em_materi_file", 'String'>
    readonly created_at: FieldRef<"em_materi_file", 'DateTime'>
    readonly updated_at: FieldRef<"em_materi_file", 'DateTime'>
    readonly galeri_id: FieldRef<"em_materi_file", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_materi_file findUnique
   */
  export type em_materi_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_file to fetch.
     */
    where: em_materi_fileWhereUniqueInput
  }

  /**
   * em_materi_file findUniqueOrThrow
   */
  export type em_materi_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_file to fetch.
     */
    where: em_materi_fileWhereUniqueInput
  }

  /**
   * em_materi_file findFirst
   */
  export type em_materi_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_file to fetch.
     */
    where?: em_materi_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_files to fetch.
     */
    orderBy?: em_materi_fileOrderByWithRelationInput | em_materi_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi_files.
     */
    cursor?: em_materi_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi_files.
     */
    distinct?: Em_materi_fileScalarFieldEnum | Em_materi_fileScalarFieldEnum[]
  }

  /**
   * em_materi_file findFirstOrThrow
   */
  export type em_materi_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_file to fetch.
     */
    where?: em_materi_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_files to fetch.
     */
    orderBy?: em_materi_fileOrderByWithRelationInput | em_materi_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi_files.
     */
    cursor?: em_materi_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi_files.
     */
    distinct?: Em_materi_fileScalarFieldEnum | Em_materi_fileScalarFieldEnum[]
  }

  /**
   * em_materi_file findMany
   */
  export type em_materi_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_files to fetch.
     */
    where?: em_materi_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_files to fetch.
     */
    orderBy?: em_materi_fileOrderByWithRelationInput | em_materi_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_materi_files.
     */
    cursor?: em_materi_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_files.
     */
    skip?: number
    distinct?: Em_materi_fileScalarFieldEnum | Em_materi_fileScalarFieldEnum[]
  }

  /**
   * em_materi_file create
   */
  export type em_materi_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * The data needed to create a em_materi_file.
     */
    data: XOR<em_materi_fileCreateInput, em_materi_fileUncheckedCreateInput>
  }

  /**
   * em_materi_file createMany
   */
  export type em_materi_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_materi_files.
     */
    data: em_materi_fileCreateManyInput | em_materi_fileCreateManyInput[]
  }

  /**
   * em_materi_file update
   */
  export type em_materi_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * The data needed to update a em_materi_file.
     */
    data: XOR<em_materi_fileUpdateInput, em_materi_fileUncheckedUpdateInput>
    /**
     * Choose, which em_materi_file to update.
     */
    where: em_materi_fileWhereUniqueInput
  }

  /**
   * em_materi_file updateMany
   */
  export type em_materi_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_materi_files.
     */
    data: XOR<em_materi_fileUpdateManyMutationInput, em_materi_fileUncheckedUpdateManyInput>
    /**
     * Filter which em_materi_files to update
     */
    where?: em_materi_fileWhereInput
    /**
     * Limit how many em_materi_files to update.
     */
    limit?: number
  }

  /**
   * em_materi_file upsert
   */
  export type em_materi_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * The filter to search for the em_materi_file to update in case it exists.
     */
    where: em_materi_fileWhereUniqueInput
    /**
     * In case the em_materi_file found by the `where` argument doesn't exist, create a new em_materi_file with this data.
     */
    create: XOR<em_materi_fileCreateInput, em_materi_fileUncheckedCreateInput>
    /**
     * In case the em_materi_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_materi_fileUpdateInput, em_materi_fileUncheckedUpdateInput>
  }

  /**
   * em_materi_file delete
   */
  export type em_materi_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    /**
     * Filter which em_materi_file to delete.
     */
    where: em_materi_fileWhereUniqueInput
  }

  /**
   * em_materi_file deleteMany
   */
  export type em_materi_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi_files to delete
     */
    where?: em_materi_fileWhereInput
    /**
     * Limit how many em_materi_files to delete.
     */
    limit?: number
  }

  /**
   * em_materi_file without action
   */
  export type em_materi_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
  }


  /**
   * Model em_materi_kategori
   */

  export type AggregateEm_materi_kategori = {
    _count: Em_materi_kategoriCountAggregateOutputType | null
    _avg: Em_materi_kategoriAvgAggregateOutputType | null
    _sum: Em_materi_kategoriSumAggregateOutputType | null
    _min: Em_materi_kategoriMinAggregateOutputType | null
    _max: Em_materi_kategoriMaxAggregateOutputType | null
  }

  export type Em_materi_kategoriAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_materi_kategoriSumAggregateOutputType = {
    id: number | null
  }

  export type Em_materi_kategoriMinAggregateOutputType = {
    id: number | null
    kategori_nama: string | null
    kategori_deskripsi: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type Em_materi_kategoriMaxAggregateOutputType = {
    id: number | null
    kategori_nama: string | null
    kategori_deskripsi: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type Em_materi_kategoriCountAggregateOutputType = {
    id: number
    kategori_nama: number
    kategori_deskripsi: number
    is_active: number
    created_at: number
    _all: number
  }


  export type Em_materi_kategoriAvgAggregateInputType = {
    id?: true
  }

  export type Em_materi_kategoriSumAggregateInputType = {
    id?: true
  }

  export type Em_materi_kategoriMinAggregateInputType = {
    id?: true
    kategori_nama?: true
    kategori_deskripsi?: true
    is_active?: true
    created_at?: true
  }

  export type Em_materi_kategoriMaxAggregateInputType = {
    id?: true
    kategori_nama?: true
    kategori_deskripsi?: true
    is_active?: true
    created_at?: true
  }

  export type Em_materi_kategoriCountAggregateInputType = {
    id?: true
    kategori_nama?: true
    kategori_deskripsi?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type Em_materi_kategoriAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi_kategori to aggregate.
     */
    where?: em_materi_kategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_kategoris to fetch.
     */
    orderBy?: em_materi_kategoriOrderByWithRelationInput | em_materi_kategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_materi_kategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_kategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_kategoris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_materi_kategoris
    **/
    _count?: true | Em_materi_kategoriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_materi_kategoriAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_materi_kategoriSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_materi_kategoriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_materi_kategoriMaxAggregateInputType
  }

  export type GetEm_materi_kategoriAggregateType<T extends Em_materi_kategoriAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_materi_kategori]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_materi_kategori[P]>
      : GetScalarType<T[P], AggregateEm_materi_kategori[P]>
  }




  export type em_materi_kategoriGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi_kategoriWhereInput
    orderBy?: em_materi_kategoriOrderByWithAggregationInput | em_materi_kategoriOrderByWithAggregationInput[]
    by: Em_materi_kategoriScalarFieldEnum[] | Em_materi_kategoriScalarFieldEnum
    having?: em_materi_kategoriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_materi_kategoriCountAggregateInputType | true
    _avg?: Em_materi_kategoriAvgAggregateInputType
    _sum?: Em_materi_kategoriSumAggregateInputType
    _min?: Em_materi_kategoriMinAggregateInputType
    _max?: Em_materi_kategoriMaxAggregateInputType
  }

  export type Em_materi_kategoriGroupByOutputType = {
    id: number
    kategori_nama: string
    kategori_deskripsi: string | null
    is_active: boolean | null
    created_at: Date | null
    _count: Em_materi_kategoriCountAggregateOutputType | null
    _avg: Em_materi_kategoriAvgAggregateOutputType | null
    _sum: Em_materi_kategoriSumAggregateOutputType | null
    _min: Em_materi_kategoriMinAggregateOutputType | null
    _max: Em_materi_kategoriMaxAggregateOutputType | null
  }

  type GetEm_materi_kategoriGroupByPayload<T extends em_materi_kategoriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_materi_kategoriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_materi_kategoriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_materi_kategoriGroupByOutputType[P]>
            : GetScalarType<T[P], Em_materi_kategoriGroupByOutputType[P]>
        }
      >
    >


  export type em_materi_kategoriSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kategori_nama?: boolean
    kategori_deskripsi?: boolean
    is_active?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["em_materi_kategori"]>



  export type em_materi_kategoriSelectScalar = {
    id?: boolean
    kategori_nama?: boolean
    kategori_deskripsi?: boolean
    is_active?: boolean
    created_at?: boolean
  }

  export type em_materi_kategoriOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kategori_nama" | "kategori_deskripsi" | "is_active" | "created_at", ExtArgs["result"]["em_materi_kategori"]>

  export type $em_materi_kategoriPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_materi_kategori"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kategori_nama: string
      kategori_deskripsi: string | null
      is_active: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["em_materi_kategori"]>
    composites: {}
  }

  type em_materi_kategoriGetPayload<S extends boolean | null | undefined | em_materi_kategoriDefaultArgs> = $Result.GetResult<Prisma.$em_materi_kategoriPayload, S>

  type em_materi_kategoriCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_materi_kategoriFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_materi_kategoriCountAggregateInputType | true
    }

  export interface em_materi_kategoriDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_materi_kategori'], meta: { name: 'em_materi_kategori' } }
    /**
     * Find zero or one Em_materi_kategori that matches the filter.
     * @param {em_materi_kategoriFindUniqueArgs} args - Arguments to find a Em_materi_kategori
     * @example
     * // Get one Em_materi_kategori
     * const em_materi_kategori = await prisma.em_materi_kategori.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_materi_kategoriFindUniqueArgs>(args: SelectSubset<T, em_materi_kategoriFindUniqueArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_materi_kategori that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_materi_kategoriFindUniqueOrThrowArgs} args - Arguments to find a Em_materi_kategori
     * @example
     * // Get one Em_materi_kategori
     * const em_materi_kategori = await prisma.em_materi_kategori.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_materi_kategoriFindUniqueOrThrowArgs>(args: SelectSubset<T, em_materi_kategoriFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi_kategori that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_kategoriFindFirstArgs} args - Arguments to find a Em_materi_kategori
     * @example
     * // Get one Em_materi_kategori
     * const em_materi_kategori = await prisma.em_materi_kategori.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_materi_kategoriFindFirstArgs>(args?: SelectSubset<T, em_materi_kategoriFindFirstArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi_kategori that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_kategoriFindFirstOrThrowArgs} args - Arguments to find a Em_materi_kategori
     * @example
     * // Get one Em_materi_kategori
     * const em_materi_kategori = await prisma.em_materi_kategori.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_materi_kategoriFindFirstOrThrowArgs>(args?: SelectSubset<T, em_materi_kategoriFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_materi_kategoris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_kategoriFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_materi_kategoris
     * const em_materi_kategoris = await prisma.em_materi_kategori.findMany()
     * 
     * // Get first 10 Em_materi_kategoris
     * const em_materi_kategoris = await prisma.em_materi_kategori.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_materi_kategoriWithIdOnly = await prisma.em_materi_kategori.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_materi_kategoriFindManyArgs>(args?: SelectSubset<T, em_materi_kategoriFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_materi_kategori.
     * @param {em_materi_kategoriCreateArgs} args - Arguments to create a Em_materi_kategori.
     * @example
     * // Create one Em_materi_kategori
     * const Em_materi_kategori = await prisma.em_materi_kategori.create({
     *   data: {
     *     // ... data to create a Em_materi_kategori
     *   }
     * })
     * 
     */
    create<T extends em_materi_kategoriCreateArgs>(args: SelectSubset<T, em_materi_kategoriCreateArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_materi_kategoris.
     * @param {em_materi_kategoriCreateManyArgs} args - Arguments to create many Em_materi_kategoris.
     * @example
     * // Create many Em_materi_kategoris
     * const em_materi_kategori = await prisma.em_materi_kategori.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_materi_kategoriCreateManyArgs>(args?: SelectSubset<T, em_materi_kategoriCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_materi_kategori.
     * @param {em_materi_kategoriDeleteArgs} args - Arguments to delete one Em_materi_kategori.
     * @example
     * // Delete one Em_materi_kategori
     * const Em_materi_kategori = await prisma.em_materi_kategori.delete({
     *   where: {
     *     // ... filter to delete one Em_materi_kategori
     *   }
     * })
     * 
     */
    delete<T extends em_materi_kategoriDeleteArgs>(args: SelectSubset<T, em_materi_kategoriDeleteArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_materi_kategori.
     * @param {em_materi_kategoriUpdateArgs} args - Arguments to update one Em_materi_kategori.
     * @example
     * // Update one Em_materi_kategori
     * const em_materi_kategori = await prisma.em_materi_kategori.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_materi_kategoriUpdateArgs>(args: SelectSubset<T, em_materi_kategoriUpdateArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_materi_kategoris.
     * @param {em_materi_kategoriDeleteManyArgs} args - Arguments to filter Em_materi_kategoris to delete.
     * @example
     * // Delete a few Em_materi_kategoris
     * const { count } = await prisma.em_materi_kategori.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_materi_kategoriDeleteManyArgs>(args?: SelectSubset<T, em_materi_kategoriDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_materi_kategoris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_kategoriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_materi_kategoris
     * const em_materi_kategori = await prisma.em_materi_kategori.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_materi_kategoriUpdateManyArgs>(args: SelectSubset<T, em_materi_kategoriUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_materi_kategori.
     * @param {em_materi_kategoriUpsertArgs} args - Arguments to update or create a Em_materi_kategori.
     * @example
     * // Update or create a Em_materi_kategori
     * const em_materi_kategori = await prisma.em_materi_kategori.upsert({
     *   create: {
     *     // ... data to create a Em_materi_kategori
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_materi_kategori we want to update
     *   }
     * })
     */
    upsert<T extends em_materi_kategoriUpsertArgs>(args: SelectSubset<T, em_materi_kategoriUpsertArgs<ExtArgs>>): Prisma__em_materi_kategoriClient<$Result.GetResult<Prisma.$em_materi_kategoriPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_materi_kategoris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_kategoriCountArgs} args - Arguments to filter Em_materi_kategoris to count.
     * @example
     * // Count the number of Em_materi_kategoris
     * const count = await prisma.em_materi_kategori.count({
     *   where: {
     *     // ... the filter for the Em_materi_kategoris we want to count
     *   }
     * })
    **/
    count<T extends em_materi_kategoriCountArgs>(
      args?: Subset<T, em_materi_kategoriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_materi_kategoriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_materi_kategori.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_materi_kategoriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_materi_kategoriAggregateArgs>(args: Subset<T, Em_materi_kategoriAggregateArgs>): Prisma.PrismaPromise<GetEm_materi_kategoriAggregateType<T>>

    /**
     * Group by Em_materi_kategori.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_kategoriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_materi_kategoriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_materi_kategoriGroupByArgs['orderBy'] }
        : { orderBy?: em_materi_kategoriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_materi_kategoriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_materi_kategoriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_materi_kategori model
   */
  readonly fields: em_materi_kategoriFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_materi_kategori.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_materi_kategoriClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_materi_kategori model
   */
  interface em_materi_kategoriFieldRefs {
    readonly id: FieldRef<"em_materi_kategori", 'Int'>
    readonly kategori_nama: FieldRef<"em_materi_kategori", 'String'>
    readonly kategori_deskripsi: FieldRef<"em_materi_kategori", 'String'>
    readonly is_active: FieldRef<"em_materi_kategori", 'Boolean'>
    readonly created_at: FieldRef<"em_materi_kategori", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_materi_kategori findUnique
   */
  export type em_materi_kategoriFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * Filter, which em_materi_kategori to fetch.
     */
    where: em_materi_kategoriWhereUniqueInput
  }

  /**
   * em_materi_kategori findUniqueOrThrow
   */
  export type em_materi_kategoriFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * Filter, which em_materi_kategori to fetch.
     */
    where: em_materi_kategoriWhereUniqueInput
  }

  /**
   * em_materi_kategori findFirst
   */
  export type em_materi_kategoriFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * Filter, which em_materi_kategori to fetch.
     */
    where?: em_materi_kategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_kategoris to fetch.
     */
    orderBy?: em_materi_kategoriOrderByWithRelationInput | em_materi_kategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi_kategoris.
     */
    cursor?: em_materi_kategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_kategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_kategoris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi_kategoris.
     */
    distinct?: Em_materi_kategoriScalarFieldEnum | Em_materi_kategoriScalarFieldEnum[]
  }

  /**
   * em_materi_kategori findFirstOrThrow
   */
  export type em_materi_kategoriFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * Filter, which em_materi_kategori to fetch.
     */
    where?: em_materi_kategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_kategoris to fetch.
     */
    orderBy?: em_materi_kategoriOrderByWithRelationInput | em_materi_kategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi_kategoris.
     */
    cursor?: em_materi_kategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_kategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_kategoris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi_kategoris.
     */
    distinct?: Em_materi_kategoriScalarFieldEnum | Em_materi_kategoriScalarFieldEnum[]
  }

  /**
   * em_materi_kategori findMany
   */
  export type em_materi_kategoriFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * Filter, which em_materi_kategoris to fetch.
     */
    where?: em_materi_kategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_kategoris to fetch.
     */
    orderBy?: em_materi_kategoriOrderByWithRelationInput | em_materi_kategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_materi_kategoris.
     */
    cursor?: em_materi_kategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_kategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_kategoris.
     */
    skip?: number
    distinct?: Em_materi_kategoriScalarFieldEnum | Em_materi_kategoriScalarFieldEnum[]
  }

  /**
   * em_materi_kategori create
   */
  export type em_materi_kategoriCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * The data needed to create a em_materi_kategori.
     */
    data: XOR<em_materi_kategoriCreateInput, em_materi_kategoriUncheckedCreateInput>
  }

  /**
   * em_materi_kategori createMany
   */
  export type em_materi_kategoriCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_materi_kategoris.
     */
    data: em_materi_kategoriCreateManyInput | em_materi_kategoriCreateManyInput[]
  }

  /**
   * em_materi_kategori update
   */
  export type em_materi_kategoriUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * The data needed to update a em_materi_kategori.
     */
    data: XOR<em_materi_kategoriUpdateInput, em_materi_kategoriUncheckedUpdateInput>
    /**
     * Choose, which em_materi_kategori to update.
     */
    where: em_materi_kategoriWhereUniqueInput
  }

  /**
   * em_materi_kategori updateMany
   */
  export type em_materi_kategoriUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_materi_kategoris.
     */
    data: XOR<em_materi_kategoriUpdateManyMutationInput, em_materi_kategoriUncheckedUpdateManyInput>
    /**
     * Filter which em_materi_kategoris to update
     */
    where?: em_materi_kategoriWhereInput
    /**
     * Limit how many em_materi_kategoris to update.
     */
    limit?: number
  }

  /**
   * em_materi_kategori upsert
   */
  export type em_materi_kategoriUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * The filter to search for the em_materi_kategori to update in case it exists.
     */
    where: em_materi_kategoriWhereUniqueInput
    /**
     * In case the em_materi_kategori found by the `where` argument doesn't exist, create a new em_materi_kategori with this data.
     */
    create: XOR<em_materi_kategoriCreateInput, em_materi_kategoriUncheckedCreateInput>
    /**
     * In case the em_materi_kategori was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_materi_kategoriUpdateInput, em_materi_kategoriUncheckedUpdateInput>
  }

  /**
   * em_materi_kategori delete
   */
  export type em_materi_kategoriDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
    /**
     * Filter which em_materi_kategori to delete.
     */
    where: em_materi_kategoriWhereUniqueInput
  }

  /**
   * em_materi_kategori deleteMany
   */
  export type em_materi_kategoriDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi_kategoris to delete
     */
    where?: em_materi_kategoriWhereInput
    /**
     * Limit how many em_materi_kategoris to delete.
     */
    limit?: number
  }

  /**
   * em_materi_kategori without action
   */
  export type em_materi_kategoriDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_kategori
     */
    select?: em_materi_kategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_kategori
     */
    omit?: em_materi_kategoriOmit<ExtArgs> | null
  }


  /**
   * Model em_materi_type
   */

  export type AggregateEm_materi_type = {
    _count: Em_materi_typeCountAggregateOutputType | null
    _avg: Em_materi_typeAvgAggregateOutputType | null
    _sum: Em_materi_typeSumAggregateOutputType | null
    _min: Em_materi_typeMinAggregateOutputType | null
    _max: Em_materi_typeMaxAggregateOutputType | null
  }

  export type Em_materi_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_materi_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Em_materi_typeMinAggregateOutputType = {
    id: number | null
    materi_name: string | null
    deskripsi: string | null
    status: string | null
    created_at: Date | null
    created_by: string | null
    lastupdate: Date | null
  }

  export type Em_materi_typeMaxAggregateOutputType = {
    id: number | null
    materi_name: string | null
    deskripsi: string | null
    status: string | null
    created_at: Date | null
    created_by: string | null
    lastupdate: Date | null
  }

  export type Em_materi_typeCountAggregateOutputType = {
    id: number
    materi_name: number
    deskripsi: number
    status: number
    created_at: number
    created_by: number
    lastupdate: number
    _all: number
  }


  export type Em_materi_typeAvgAggregateInputType = {
    id?: true
  }

  export type Em_materi_typeSumAggregateInputType = {
    id?: true
  }

  export type Em_materi_typeMinAggregateInputType = {
    id?: true
    materi_name?: true
    deskripsi?: true
    status?: true
    created_at?: true
    created_by?: true
    lastupdate?: true
  }

  export type Em_materi_typeMaxAggregateInputType = {
    id?: true
    materi_name?: true
    deskripsi?: true
    status?: true
    created_at?: true
    created_by?: true
    lastupdate?: true
  }

  export type Em_materi_typeCountAggregateInputType = {
    id?: true
    materi_name?: true
    deskripsi?: true
    status?: true
    created_at?: true
    created_by?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_materi_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi_type to aggregate.
     */
    where?: em_materi_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_types to fetch.
     */
    orderBy?: em_materi_typeOrderByWithRelationInput | em_materi_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_materi_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_materi_types
    **/
    _count?: true | Em_materi_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_materi_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_materi_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_materi_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_materi_typeMaxAggregateInputType
  }

  export type GetEm_materi_typeAggregateType<T extends Em_materi_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_materi_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_materi_type[P]>
      : GetScalarType<T[P], AggregateEm_materi_type[P]>
  }




  export type em_materi_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi_typeWhereInput
    orderBy?: em_materi_typeOrderByWithAggregationInput | em_materi_typeOrderByWithAggregationInput[]
    by: Em_materi_typeScalarFieldEnum[] | Em_materi_typeScalarFieldEnum
    having?: em_materi_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_materi_typeCountAggregateInputType | true
    _avg?: Em_materi_typeAvgAggregateInputType
    _sum?: Em_materi_typeSumAggregateInputType
    _min?: Em_materi_typeMinAggregateInputType
    _max?: Em_materi_typeMaxAggregateInputType
  }

  export type Em_materi_typeGroupByOutputType = {
    id: number
    materi_name: string
    deskripsi: string | null
    status: string | null
    created_at: Date
    created_by: string | null
    lastupdate: Date | null
    _count: Em_materi_typeCountAggregateOutputType | null
    _avg: Em_materi_typeAvgAggregateOutputType | null
    _sum: Em_materi_typeSumAggregateOutputType | null
    _min: Em_materi_typeMinAggregateOutputType | null
    _max: Em_materi_typeMaxAggregateOutputType | null
  }

  type GetEm_materi_typeGroupByPayload<T extends em_materi_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_materi_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_materi_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_materi_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Em_materi_typeGroupByOutputType[P]>
        }
      >
    >


  export type em_materi_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materi_name?: boolean
    deskripsi?: boolean
    status?: boolean
    created_at?: boolean
    created_by?: boolean
    lastupdate?: boolean
    em_materi2?: boolean | em_materi_type$em_materi2Args<ExtArgs>
    _count?: boolean | Em_materi_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_materi_type"]>



  export type em_materi_typeSelectScalar = {
    id?: boolean
    materi_name?: boolean
    deskripsi?: boolean
    status?: boolean
    created_at?: boolean
    created_by?: boolean
    lastupdate?: boolean
  }

  export type em_materi_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materi_name" | "deskripsi" | "status" | "created_at" | "created_by" | "lastupdate", ExtArgs["result"]["em_materi_type"]>
  export type em_materi_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_materi2?: boolean | em_materi_type$em_materi2Args<ExtArgs>
    _count?: boolean | Em_materi_typeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_materi_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_materi_type"
    objects: {
      em_materi2: Prisma.$em_materi2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materi_name: string
      deskripsi: string | null
      status: string | null
      created_at: Date
      created_by: string | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_materi_type"]>
    composites: {}
  }

  type em_materi_typeGetPayload<S extends boolean | null | undefined | em_materi_typeDefaultArgs> = $Result.GetResult<Prisma.$em_materi_typePayload, S>

  type em_materi_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_materi_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_materi_typeCountAggregateInputType | true
    }

  export interface em_materi_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_materi_type'], meta: { name: 'em_materi_type' } }
    /**
     * Find zero or one Em_materi_type that matches the filter.
     * @param {em_materi_typeFindUniqueArgs} args - Arguments to find a Em_materi_type
     * @example
     * // Get one Em_materi_type
     * const em_materi_type = await prisma.em_materi_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_materi_typeFindUniqueArgs>(args: SelectSubset<T, em_materi_typeFindUniqueArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_materi_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_materi_typeFindUniqueOrThrowArgs} args - Arguments to find a Em_materi_type
     * @example
     * // Get one Em_materi_type
     * const em_materi_type = await prisma.em_materi_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_materi_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, em_materi_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_typeFindFirstArgs} args - Arguments to find a Em_materi_type
     * @example
     * // Get one Em_materi_type
     * const em_materi_type = await prisma.em_materi_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_materi_typeFindFirstArgs>(args?: SelectSubset<T, em_materi_typeFindFirstArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_typeFindFirstOrThrowArgs} args - Arguments to find a Em_materi_type
     * @example
     * // Get one Em_materi_type
     * const em_materi_type = await prisma.em_materi_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_materi_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, em_materi_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_materi_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_materi_types
     * const em_materi_types = await prisma.em_materi_type.findMany()
     * 
     * // Get first 10 Em_materi_types
     * const em_materi_types = await prisma.em_materi_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_materi_typeWithIdOnly = await prisma.em_materi_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_materi_typeFindManyArgs>(args?: SelectSubset<T, em_materi_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_materi_type.
     * @param {em_materi_typeCreateArgs} args - Arguments to create a Em_materi_type.
     * @example
     * // Create one Em_materi_type
     * const Em_materi_type = await prisma.em_materi_type.create({
     *   data: {
     *     // ... data to create a Em_materi_type
     *   }
     * })
     * 
     */
    create<T extends em_materi_typeCreateArgs>(args: SelectSubset<T, em_materi_typeCreateArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_materi_types.
     * @param {em_materi_typeCreateManyArgs} args - Arguments to create many Em_materi_types.
     * @example
     * // Create many Em_materi_types
     * const em_materi_type = await prisma.em_materi_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_materi_typeCreateManyArgs>(args?: SelectSubset<T, em_materi_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_materi_type.
     * @param {em_materi_typeDeleteArgs} args - Arguments to delete one Em_materi_type.
     * @example
     * // Delete one Em_materi_type
     * const Em_materi_type = await prisma.em_materi_type.delete({
     *   where: {
     *     // ... filter to delete one Em_materi_type
     *   }
     * })
     * 
     */
    delete<T extends em_materi_typeDeleteArgs>(args: SelectSubset<T, em_materi_typeDeleteArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_materi_type.
     * @param {em_materi_typeUpdateArgs} args - Arguments to update one Em_materi_type.
     * @example
     * // Update one Em_materi_type
     * const em_materi_type = await prisma.em_materi_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_materi_typeUpdateArgs>(args: SelectSubset<T, em_materi_typeUpdateArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_materi_types.
     * @param {em_materi_typeDeleteManyArgs} args - Arguments to filter Em_materi_types to delete.
     * @example
     * // Delete a few Em_materi_types
     * const { count } = await prisma.em_materi_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_materi_typeDeleteManyArgs>(args?: SelectSubset<T, em_materi_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_materi_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_materi_types
     * const em_materi_type = await prisma.em_materi_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_materi_typeUpdateManyArgs>(args: SelectSubset<T, em_materi_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_materi_type.
     * @param {em_materi_typeUpsertArgs} args - Arguments to update or create a Em_materi_type.
     * @example
     * // Update or create a Em_materi_type
     * const em_materi_type = await prisma.em_materi_type.upsert({
     *   create: {
     *     // ... data to create a Em_materi_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_materi_type we want to update
     *   }
     * })
     */
    upsert<T extends em_materi_typeUpsertArgs>(args: SelectSubset<T, em_materi_typeUpsertArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_materi_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_typeCountArgs} args - Arguments to filter Em_materi_types to count.
     * @example
     * // Count the number of Em_materi_types
     * const count = await prisma.em_materi_type.count({
     *   where: {
     *     // ... the filter for the Em_materi_types we want to count
     *   }
     * })
    **/
    count<T extends em_materi_typeCountArgs>(
      args?: Subset<T, em_materi_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_materi_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_materi_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_materi_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_materi_typeAggregateArgs>(args: Subset<T, Em_materi_typeAggregateArgs>): Prisma.PrismaPromise<GetEm_materi_typeAggregateType<T>>

    /**
     * Group by Em_materi_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_materi_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_materi_typeGroupByArgs['orderBy'] }
        : { orderBy?: em_materi_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_materi_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_materi_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_materi_type model
   */
  readonly fields: em_materi_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_materi_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_materi_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_materi2<T extends em_materi_type$em_materi2Args<ExtArgs> = {}>(args?: Subset<T, em_materi_type$em_materi2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_materi_type model
   */
  interface em_materi_typeFieldRefs {
    readonly id: FieldRef<"em_materi_type", 'Int'>
    readonly materi_name: FieldRef<"em_materi_type", 'String'>
    readonly deskripsi: FieldRef<"em_materi_type", 'String'>
    readonly status: FieldRef<"em_materi_type", 'String'>
    readonly created_at: FieldRef<"em_materi_type", 'DateTime'>
    readonly created_by: FieldRef<"em_materi_type", 'String'>
    readonly lastupdate: FieldRef<"em_materi_type", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_materi_type findUnique
   */
  export type em_materi_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_type to fetch.
     */
    where: em_materi_typeWhereUniqueInput
  }

  /**
   * em_materi_type findUniqueOrThrow
   */
  export type em_materi_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_type to fetch.
     */
    where: em_materi_typeWhereUniqueInput
  }

  /**
   * em_materi_type findFirst
   */
  export type em_materi_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_type to fetch.
     */
    where?: em_materi_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_types to fetch.
     */
    orderBy?: em_materi_typeOrderByWithRelationInput | em_materi_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi_types.
     */
    cursor?: em_materi_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi_types.
     */
    distinct?: Em_materi_typeScalarFieldEnum | Em_materi_typeScalarFieldEnum[]
  }

  /**
   * em_materi_type findFirstOrThrow
   */
  export type em_materi_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_type to fetch.
     */
    where?: em_materi_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_types to fetch.
     */
    orderBy?: em_materi_typeOrderByWithRelationInput | em_materi_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi_types.
     */
    cursor?: em_materi_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi_types.
     */
    distinct?: Em_materi_typeScalarFieldEnum | Em_materi_typeScalarFieldEnum[]
  }

  /**
   * em_materi_type findMany
   */
  export type em_materi_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * Filter, which em_materi_types to fetch.
     */
    where?: em_materi_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi_types to fetch.
     */
    orderBy?: em_materi_typeOrderByWithRelationInput | em_materi_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_materi_types.
     */
    cursor?: em_materi_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi_types.
     */
    skip?: number
    distinct?: Em_materi_typeScalarFieldEnum | Em_materi_typeScalarFieldEnum[]
  }

  /**
   * em_materi_type create
   */
  export type em_materi_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a em_materi_type.
     */
    data: XOR<em_materi_typeCreateInput, em_materi_typeUncheckedCreateInput>
  }

  /**
   * em_materi_type createMany
   */
  export type em_materi_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_materi_types.
     */
    data: em_materi_typeCreateManyInput | em_materi_typeCreateManyInput[]
  }

  /**
   * em_materi_type update
   */
  export type em_materi_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a em_materi_type.
     */
    data: XOR<em_materi_typeUpdateInput, em_materi_typeUncheckedUpdateInput>
    /**
     * Choose, which em_materi_type to update.
     */
    where: em_materi_typeWhereUniqueInput
  }

  /**
   * em_materi_type updateMany
   */
  export type em_materi_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_materi_types.
     */
    data: XOR<em_materi_typeUpdateManyMutationInput, em_materi_typeUncheckedUpdateManyInput>
    /**
     * Filter which em_materi_types to update
     */
    where?: em_materi_typeWhereInput
    /**
     * Limit how many em_materi_types to update.
     */
    limit?: number
  }

  /**
   * em_materi_type upsert
   */
  export type em_materi_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the em_materi_type to update in case it exists.
     */
    where: em_materi_typeWhereUniqueInput
    /**
     * In case the em_materi_type found by the `where` argument doesn't exist, create a new em_materi_type with this data.
     */
    create: XOR<em_materi_typeCreateInput, em_materi_typeUncheckedCreateInput>
    /**
     * In case the em_materi_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_materi_typeUpdateInput, em_materi_typeUncheckedUpdateInput>
  }

  /**
   * em_materi_type delete
   */
  export type em_materi_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
    /**
     * Filter which em_materi_type to delete.
     */
    where: em_materi_typeWhereUniqueInput
  }

  /**
   * em_materi_type deleteMany
   */
  export type em_materi_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi_types to delete
     */
    where?: em_materi_typeWhereInput
    /**
     * Limit how many em_materi_types to delete.
     */
    limit?: number
  }

  /**
   * em_materi_type.em_materi2
   */
  export type em_materi_type$em_materi2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    where?: em_materi2WhereInput
    orderBy?: em_materi2OrderByWithRelationInput | em_materi2OrderByWithRelationInput[]
    cursor?: em_materi2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_materi2ScalarFieldEnum | Em_materi2ScalarFieldEnum[]
  }

  /**
   * em_materi_type without action
   */
  export type em_materi_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_type
     */
    select?: em_materi_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_type
     */
    omit?: em_materi_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_typeInclude<ExtArgs> | null
  }


  /**
   * Model em_materi1
   */

  export type AggregateEm_materi1 = {
    _count: Em_materi1CountAggregateOutputType | null
    _avg: Em_materi1AvgAggregateOutputType | null
    _sum: Em_materi1SumAggregateOutputType | null
    _min: Em_materi1MinAggregateOutputType | null
    _max: Em_materi1MaxAggregateOutputType | null
  }

  export type Em_materi1AvgAggregateOutputType = {
    id: number | null
    kategori: number | null
    urutan: number | null
  }

  export type Em_materi1SumAggregateOutputType = {
    id: number | null
    kategori: number | null
    urutan: number | null
  }

  export type Em_materi1MinAggregateOutputType = {
    id: number | null
    kode_materi: string | null
    judul_materi: string | null
    deskripsi_materi: string | null
    kategori: number | null
    urutan: number | null
    is_required: boolean | null
    status: string | null
    created_by: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_materi1MaxAggregateOutputType = {
    id: number | null
    kode_materi: string | null
    judul_materi: string | null
    deskripsi_materi: string | null
    kategori: number | null
    urutan: number | null
    is_required: boolean | null
    status: string | null
    created_by: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type Em_materi1CountAggregateOutputType = {
    id: number
    kode_materi: number
    judul_materi: number
    deskripsi_materi: number
    kategori: number
    urutan: number
    is_required: number
    status: number
    created_by: number
    created_at: number
    lastupdate: number
    _all: number
  }


  export type Em_materi1AvgAggregateInputType = {
    id?: true
    kategori?: true
    urutan?: true
  }

  export type Em_materi1SumAggregateInputType = {
    id?: true
    kategori?: true
    urutan?: true
  }

  export type Em_materi1MinAggregateInputType = {
    id?: true
    kode_materi?: true
    judul_materi?: true
    deskripsi_materi?: true
    kategori?: true
    urutan?: true
    is_required?: true
    status?: true
    created_by?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_materi1MaxAggregateInputType = {
    id?: true
    kode_materi?: true
    judul_materi?: true
    deskripsi_materi?: true
    kategori?: true
    urutan?: true
    is_required?: true
    status?: true
    created_by?: true
    created_at?: true
    lastupdate?: true
  }

  export type Em_materi1CountAggregateInputType = {
    id?: true
    kode_materi?: true
    judul_materi?: true
    deskripsi_materi?: true
    kategori?: true
    urutan?: true
    is_required?: true
    status?: true
    created_by?: true
    created_at?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_materi1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi1 to aggregate.
     */
    where?: em_materi1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi1s to fetch.
     */
    orderBy?: em_materi1OrderByWithRelationInput | em_materi1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_materi1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_materi1s
    **/
    _count?: true | Em_materi1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_materi1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_materi1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_materi1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_materi1MaxAggregateInputType
  }

  export type GetEm_materi1AggregateType<T extends Em_materi1AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_materi1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_materi1[P]>
      : GetScalarType<T[P], AggregateEm_materi1[P]>
  }




  export type em_materi1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi1WhereInput
    orderBy?: em_materi1OrderByWithAggregationInput | em_materi1OrderByWithAggregationInput[]
    by: Em_materi1ScalarFieldEnum[] | Em_materi1ScalarFieldEnum
    having?: em_materi1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_materi1CountAggregateInputType | true
    _avg?: Em_materi1AvgAggregateInputType
    _sum?: Em_materi1SumAggregateInputType
    _min?: Em_materi1MinAggregateInputType
    _max?: Em_materi1MaxAggregateInputType
  }

  export type Em_materi1GroupByOutputType = {
    id: number
    kode_materi: string
    judul_materi: string
    deskripsi_materi: string | null
    kategori: number | null
    urutan: number
    is_required: boolean
    status: string | null
    created_by: string | null
    created_at: Date
    lastupdate: Date | null
    _count: Em_materi1CountAggregateOutputType | null
    _avg: Em_materi1AvgAggregateOutputType | null
    _sum: Em_materi1SumAggregateOutputType | null
    _min: Em_materi1MinAggregateOutputType | null
    _max: Em_materi1MaxAggregateOutputType | null
  }

  type GetEm_materi1GroupByPayload<T extends em_materi1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_materi1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_materi1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_materi1GroupByOutputType[P]>
            : GetScalarType<T[P], Em_materi1GroupByOutputType[P]>
        }
      >
    >


  export type em_materi1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_materi?: boolean
    judul_materi?: boolean
    deskripsi_materi?: boolean
    kategori?: boolean
    urutan?: boolean
    is_required?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    em_materi_file?: boolean | em_materi1$em_materi_fileArgs<ExtArgs>
    em_materi2?: boolean | em_materi1$em_materi2Args<ExtArgs>
    _count?: boolean | Em_materi1CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_materi1"]>



  export type em_materi1SelectScalar = {
    id?: boolean
    kode_materi?: boolean
    judul_materi?: boolean
    deskripsi_materi?: boolean
    kategori?: boolean
    urutan?: boolean
    is_required?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }

  export type em_materi1Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kode_materi" | "judul_materi" | "deskripsi_materi" | "kategori" | "urutan" | "is_required" | "status" | "created_by" | "created_at" | "lastupdate", ExtArgs["result"]["em_materi1"]>
  export type em_materi1Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_materi_file?: boolean | em_materi1$em_materi_fileArgs<ExtArgs>
    em_materi2?: boolean | em_materi1$em_materi2Args<ExtArgs>
    _count?: boolean | Em_materi1CountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_materi1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_materi1"
    objects: {
      em_materi_file: Prisma.$em_materi_filePayload<ExtArgs>[]
      em_materi2: Prisma.$em_materi2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode_materi: string
      judul_materi: string
      deskripsi_materi: string | null
      kategori: number | null
      urutan: number
      is_required: boolean
      status: string | null
      created_by: string | null
      created_at: Date
      lastupdate: Date | null
    }, ExtArgs["result"]["em_materi1"]>
    composites: {}
  }

  type em_materi1GetPayload<S extends boolean | null | undefined | em_materi1DefaultArgs> = $Result.GetResult<Prisma.$em_materi1Payload, S>

  type em_materi1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_materi1FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_materi1CountAggregateInputType | true
    }

  export interface em_materi1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_materi1'], meta: { name: 'em_materi1' } }
    /**
     * Find zero or one Em_materi1 that matches the filter.
     * @param {em_materi1FindUniqueArgs} args - Arguments to find a Em_materi1
     * @example
     * // Get one Em_materi1
     * const em_materi1 = await prisma.em_materi1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_materi1FindUniqueArgs>(args: SelectSubset<T, em_materi1FindUniqueArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_materi1 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_materi1FindUniqueOrThrowArgs} args - Arguments to find a Em_materi1
     * @example
     * // Get one Em_materi1
     * const em_materi1 = await prisma.em_materi1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_materi1FindUniqueOrThrowArgs>(args: SelectSubset<T, em_materi1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi1FindFirstArgs} args - Arguments to find a Em_materi1
     * @example
     * // Get one Em_materi1
     * const em_materi1 = await prisma.em_materi1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_materi1FindFirstArgs>(args?: SelectSubset<T, em_materi1FindFirstArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi1FindFirstOrThrowArgs} args - Arguments to find a Em_materi1
     * @example
     * // Get one Em_materi1
     * const em_materi1 = await prisma.em_materi1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_materi1FindFirstOrThrowArgs>(args?: SelectSubset<T, em_materi1FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_materi1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_materi1s
     * const em_materi1s = await prisma.em_materi1.findMany()
     * 
     * // Get first 10 Em_materi1s
     * const em_materi1s = await prisma.em_materi1.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_materi1WithIdOnly = await prisma.em_materi1.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_materi1FindManyArgs>(args?: SelectSubset<T, em_materi1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_materi1.
     * @param {em_materi1CreateArgs} args - Arguments to create a Em_materi1.
     * @example
     * // Create one Em_materi1
     * const Em_materi1 = await prisma.em_materi1.create({
     *   data: {
     *     // ... data to create a Em_materi1
     *   }
     * })
     * 
     */
    create<T extends em_materi1CreateArgs>(args: SelectSubset<T, em_materi1CreateArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_materi1s.
     * @param {em_materi1CreateManyArgs} args - Arguments to create many Em_materi1s.
     * @example
     * // Create many Em_materi1s
     * const em_materi1 = await prisma.em_materi1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_materi1CreateManyArgs>(args?: SelectSubset<T, em_materi1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_materi1.
     * @param {em_materi1DeleteArgs} args - Arguments to delete one Em_materi1.
     * @example
     * // Delete one Em_materi1
     * const Em_materi1 = await prisma.em_materi1.delete({
     *   where: {
     *     // ... filter to delete one Em_materi1
     *   }
     * })
     * 
     */
    delete<T extends em_materi1DeleteArgs>(args: SelectSubset<T, em_materi1DeleteArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_materi1.
     * @param {em_materi1UpdateArgs} args - Arguments to update one Em_materi1.
     * @example
     * // Update one Em_materi1
     * const em_materi1 = await prisma.em_materi1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_materi1UpdateArgs>(args: SelectSubset<T, em_materi1UpdateArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_materi1s.
     * @param {em_materi1DeleteManyArgs} args - Arguments to filter Em_materi1s to delete.
     * @example
     * // Delete a few Em_materi1s
     * const { count } = await prisma.em_materi1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_materi1DeleteManyArgs>(args?: SelectSubset<T, em_materi1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_materi1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_materi1s
     * const em_materi1 = await prisma.em_materi1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_materi1UpdateManyArgs>(args: SelectSubset<T, em_materi1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_materi1.
     * @param {em_materi1UpsertArgs} args - Arguments to update or create a Em_materi1.
     * @example
     * // Update or create a Em_materi1
     * const em_materi1 = await prisma.em_materi1.upsert({
     *   create: {
     *     // ... data to create a Em_materi1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_materi1 we want to update
     *   }
     * })
     */
    upsert<T extends em_materi1UpsertArgs>(args: SelectSubset<T, em_materi1UpsertArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_materi1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi1CountArgs} args - Arguments to filter Em_materi1s to count.
     * @example
     * // Count the number of Em_materi1s
     * const count = await prisma.em_materi1.count({
     *   where: {
     *     // ... the filter for the Em_materi1s we want to count
     *   }
     * })
    **/
    count<T extends em_materi1CountArgs>(
      args?: Subset<T, em_materi1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_materi1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_materi1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_materi1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_materi1AggregateArgs>(args: Subset<T, Em_materi1AggregateArgs>): Prisma.PrismaPromise<GetEm_materi1AggregateType<T>>

    /**
     * Group by Em_materi1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_materi1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_materi1GroupByArgs['orderBy'] }
        : { orderBy?: em_materi1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_materi1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_materi1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_materi1 model
   */
  readonly fields: em_materi1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_materi1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_materi1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_materi_file<T extends em_materi1$em_materi_fileArgs<ExtArgs> = {}>(args?: Subset<T, em_materi1$em_materi_fileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi_filePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_materi2<T extends em_materi1$em_materi2Args<ExtArgs> = {}>(args?: Subset<T, em_materi1$em_materi2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_materi1 model
   */
  interface em_materi1FieldRefs {
    readonly id: FieldRef<"em_materi1", 'Int'>
    readonly kode_materi: FieldRef<"em_materi1", 'String'>
    readonly judul_materi: FieldRef<"em_materi1", 'String'>
    readonly deskripsi_materi: FieldRef<"em_materi1", 'String'>
    readonly kategori: FieldRef<"em_materi1", 'Int'>
    readonly urutan: FieldRef<"em_materi1", 'Int'>
    readonly is_required: FieldRef<"em_materi1", 'Boolean'>
    readonly status: FieldRef<"em_materi1", 'String'>
    readonly created_by: FieldRef<"em_materi1", 'String'>
    readonly created_at: FieldRef<"em_materi1", 'DateTime'>
    readonly lastupdate: FieldRef<"em_materi1", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_materi1 findUnique
   */
  export type em_materi1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * Filter, which em_materi1 to fetch.
     */
    where: em_materi1WhereUniqueInput
  }

  /**
   * em_materi1 findUniqueOrThrow
   */
  export type em_materi1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * Filter, which em_materi1 to fetch.
     */
    where: em_materi1WhereUniqueInput
  }

  /**
   * em_materi1 findFirst
   */
  export type em_materi1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * Filter, which em_materi1 to fetch.
     */
    where?: em_materi1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi1s to fetch.
     */
    orderBy?: em_materi1OrderByWithRelationInput | em_materi1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi1s.
     */
    cursor?: em_materi1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi1s.
     */
    distinct?: Em_materi1ScalarFieldEnum | Em_materi1ScalarFieldEnum[]
  }

  /**
   * em_materi1 findFirstOrThrow
   */
  export type em_materi1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * Filter, which em_materi1 to fetch.
     */
    where?: em_materi1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi1s to fetch.
     */
    orderBy?: em_materi1OrderByWithRelationInput | em_materi1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi1s.
     */
    cursor?: em_materi1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi1s.
     */
    distinct?: Em_materi1ScalarFieldEnum | Em_materi1ScalarFieldEnum[]
  }

  /**
   * em_materi1 findMany
   */
  export type em_materi1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * Filter, which em_materi1s to fetch.
     */
    where?: em_materi1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi1s to fetch.
     */
    orderBy?: em_materi1OrderByWithRelationInput | em_materi1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_materi1s.
     */
    cursor?: em_materi1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi1s.
     */
    skip?: number
    distinct?: Em_materi1ScalarFieldEnum | Em_materi1ScalarFieldEnum[]
  }

  /**
   * em_materi1 create
   */
  export type em_materi1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * The data needed to create a em_materi1.
     */
    data: XOR<em_materi1CreateInput, em_materi1UncheckedCreateInput>
  }

  /**
   * em_materi1 createMany
   */
  export type em_materi1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_materi1s.
     */
    data: em_materi1CreateManyInput | em_materi1CreateManyInput[]
  }

  /**
   * em_materi1 update
   */
  export type em_materi1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * The data needed to update a em_materi1.
     */
    data: XOR<em_materi1UpdateInput, em_materi1UncheckedUpdateInput>
    /**
     * Choose, which em_materi1 to update.
     */
    where: em_materi1WhereUniqueInput
  }

  /**
   * em_materi1 updateMany
   */
  export type em_materi1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_materi1s.
     */
    data: XOR<em_materi1UpdateManyMutationInput, em_materi1UncheckedUpdateManyInput>
    /**
     * Filter which em_materi1s to update
     */
    where?: em_materi1WhereInput
    /**
     * Limit how many em_materi1s to update.
     */
    limit?: number
  }

  /**
   * em_materi1 upsert
   */
  export type em_materi1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * The filter to search for the em_materi1 to update in case it exists.
     */
    where: em_materi1WhereUniqueInput
    /**
     * In case the em_materi1 found by the `where` argument doesn't exist, create a new em_materi1 with this data.
     */
    create: XOR<em_materi1CreateInput, em_materi1UncheckedCreateInput>
    /**
     * In case the em_materi1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_materi1UpdateInput, em_materi1UncheckedUpdateInput>
  }

  /**
   * em_materi1 delete
   */
  export type em_materi1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
    /**
     * Filter which em_materi1 to delete.
     */
    where: em_materi1WhereUniqueInput
  }

  /**
   * em_materi1 deleteMany
   */
  export type em_materi1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi1s to delete
     */
    where?: em_materi1WhereInput
    /**
     * Limit how many em_materi1s to delete.
     */
    limit?: number
  }

  /**
   * em_materi1.em_materi_file
   */
  export type em_materi1$em_materi_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi_file
     */
    select?: em_materi_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi_file
     */
    omit?: em_materi_fileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi_fileInclude<ExtArgs> | null
    where?: em_materi_fileWhereInput
    orderBy?: em_materi_fileOrderByWithRelationInput | em_materi_fileOrderByWithRelationInput[]
    cursor?: em_materi_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_materi_fileScalarFieldEnum | Em_materi_fileScalarFieldEnum[]
  }

  /**
   * em_materi1.em_materi2
   */
  export type em_materi1$em_materi2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    where?: em_materi2WhereInput
    orderBy?: em_materi2OrderByWithRelationInput | em_materi2OrderByWithRelationInput[]
    cursor?: em_materi2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_materi2ScalarFieldEnum | Em_materi2ScalarFieldEnum[]
  }

  /**
   * em_materi1 without action
   */
  export type em_materi1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi1
     */
    select?: em_materi1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi1
     */
    omit?: em_materi1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi1Include<ExtArgs> | null
  }


  /**
   * Model em_materi2
   */

  export type AggregateEm_materi2 = {
    _count: Em_materi2CountAggregateOutputType | null
    _avg: Em_materi2AvgAggregateOutputType | null
    _sum: Em_materi2SumAggregateOutputType | null
    _min: Em_materi2MinAggregateOutputType | null
    _max: Em_materi2MaxAggregateOutputType | null
  }

  export type Em_materi2AvgAggregateOutputType = {
    id: number | null
    materi_id: number | null
    materi_type: number | null
  }

  export type Em_materi2SumAggregateOutputType = {
    id: number | null
    materi_id: number | null
    materi_type: number | null
  }

  export type Em_materi2MinAggregateOutputType = {
    id: number | null
    materi_id: number | null
    materi_type: number | null
  }

  export type Em_materi2MaxAggregateOutputType = {
    id: number | null
    materi_id: number | null
    materi_type: number | null
  }

  export type Em_materi2CountAggregateOutputType = {
    id: number
    materi_id: number
    materi_type: number
    _all: number
  }


  export type Em_materi2AvgAggregateInputType = {
    id?: true
    materi_id?: true
    materi_type?: true
  }

  export type Em_materi2SumAggregateInputType = {
    id?: true
    materi_id?: true
    materi_type?: true
  }

  export type Em_materi2MinAggregateInputType = {
    id?: true
    materi_id?: true
    materi_type?: true
  }

  export type Em_materi2MaxAggregateInputType = {
    id?: true
    materi_id?: true
    materi_type?: true
  }

  export type Em_materi2CountAggregateInputType = {
    id?: true
    materi_id?: true
    materi_type?: true
    _all?: true
  }

  export type Em_materi2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi2 to aggregate.
     */
    where?: em_materi2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi2s to fetch.
     */
    orderBy?: em_materi2OrderByWithRelationInput | em_materi2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_materi2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_materi2s
    **/
    _count?: true | Em_materi2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_materi2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_materi2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_materi2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_materi2MaxAggregateInputType
  }

  export type GetEm_materi2AggregateType<T extends Em_materi2AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_materi2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_materi2[P]>
      : GetScalarType<T[P], AggregateEm_materi2[P]>
  }




  export type em_materi2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_materi2WhereInput
    orderBy?: em_materi2OrderByWithAggregationInput | em_materi2OrderByWithAggregationInput[]
    by: Em_materi2ScalarFieldEnum[] | Em_materi2ScalarFieldEnum
    having?: em_materi2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_materi2CountAggregateInputType | true
    _avg?: Em_materi2AvgAggregateInputType
    _sum?: Em_materi2SumAggregateInputType
    _min?: Em_materi2MinAggregateInputType
    _max?: Em_materi2MaxAggregateInputType
  }

  export type Em_materi2GroupByOutputType = {
    id: number
    materi_id: number
    materi_type: number
    _count: Em_materi2CountAggregateOutputType | null
    _avg: Em_materi2AvgAggregateOutputType | null
    _sum: Em_materi2SumAggregateOutputType | null
    _min: Em_materi2MinAggregateOutputType | null
    _max: Em_materi2MaxAggregateOutputType | null
  }

  type GetEm_materi2GroupByPayload<T extends em_materi2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_materi2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_materi2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_materi2GroupByOutputType[P]>
            : GetScalarType<T[P], Em_materi2GroupByOutputType[P]>
        }
      >
    >


  export type em_materi2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materi_id?: boolean
    materi_type?: boolean
    em_materi_type?: boolean | em_materi_typeDefaultArgs<ExtArgs>
    em_materi1?: boolean | em_materi1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_materi2"]>



  export type em_materi2SelectScalar = {
    id?: boolean
    materi_id?: boolean
    materi_type?: boolean
  }

  export type em_materi2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materi_id" | "materi_type", ExtArgs["result"]["em_materi2"]>
  export type em_materi2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_materi_type?: boolean | em_materi_typeDefaultArgs<ExtArgs>
    em_materi1?: boolean | em_materi1DefaultArgs<ExtArgs>
  }

  export type $em_materi2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_materi2"
    objects: {
      em_materi_type: Prisma.$em_materi_typePayload<ExtArgs>
      em_materi1: Prisma.$em_materi1Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materi_id: number
      materi_type: number
    }, ExtArgs["result"]["em_materi2"]>
    composites: {}
  }

  type em_materi2GetPayload<S extends boolean | null | undefined | em_materi2DefaultArgs> = $Result.GetResult<Prisma.$em_materi2Payload, S>

  type em_materi2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_materi2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_materi2CountAggregateInputType | true
    }

  export interface em_materi2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_materi2'], meta: { name: 'em_materi2' } }
    /**
     * Find zero or one Em_materi2 that matches the filter.
     * @param {em_materi2FindUniqueArgs} args - Arguments to find a Em_materi2
     * @example
     * // Get one Em_materi2
     * const em_materi2 = await prisma.em_materi2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_materi2FindUniqueArgs>(args: SelectSubset<T, em_materi2FindUniqueArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_materi2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_materi2FindUniqueOrThrowArgs} args - Arguments to find a Em_materi2
     * @example
     * // Get one Em_materi2
     * const em_materi2 = await prisma.em_materi2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_materi2FindUniqueOrThrowArgs>(args: SelectSubset<T, em_materi2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi2FindFirstArgs} args - Arguments to find a Em_materi2
     * @example
     * // Get one Em_materi2
     * const em_materi2 = await prisma.em_materi2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_materi2FindFirstArgs>(args?: SelectSubset<T, em_materi2FindFirstArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_materi2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi2FindFirstOrThrowArgs} args - Arguments to find a Em_materi2
     * @example
     * // Get one Em_materi2
     * const em_materi2 = await prisma.em_materi2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_materi2FindFirstOrThrowArgs>(args?: SelectSubset<T, em_materi2FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_materi2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_materi2s
     * const em_materi2s = await prisma.em_materi2.findMany()
     * 
     * // Get first 10 Em_materi2s
     * const em_materi2s = await prisma.em_materi2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_materi2WithIdOnly = await prisma.em_materi2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_materi2FindManyArgs>(args?: SelectSubset<T, em_materi2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_materi2.
     * @param {em_materi2CreateArgs} args - Arguments to create a Em_materi2.
     * @example
     * // Create one Em_materi2
     * const Em_materi2 = await prisma.em_materi2.create({
     *   data: {
     *     // ... data to create a Em_materi2
     *   }
     * })
     * 
     */
    create<T extends em_materi2CreateArgs>(args: SelectSubset<T, em_materi2CreateArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_materi2s.
     * @param {em_materi2CreateManyArgs} args - Arguments to create many Em_materi2s.
     * @example
     * // Create many Em_materi2s
     * const em_materi2 = await prisma.em_materi2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_materi2CreateManyArgs>(args?: SelectSubset<T, em_materi2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_materi2.
     * @param {em_materi2DeleteArgs} args - Arguments to delete one Em_materi2.
     * @example
     * // Delete one Em_materi2
     * const Em_materi2 = await prisma.em_materi2.delete({
     *   where: {
     *     // ... filter to delete one Em_materi2
     *   }
     * })
     * 
     */
    delete<T extends em_materi2DeleteArgs>(args: SelectSubset<T, em_materi2DeleteArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_materi2.
     * @param {em_materi2UpdateArgs} args - Arguments to update one Em_materi2.
     * @example
     * // Update one Em_materi2
     * const em_materi2 = await prisma.em_materi2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_materi2UpdateArgs>(args: SelectSubset<T, em_materi2UpdateArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_materi2s.
     * @param {em_materi2DeleteManyArgs} args - Arguments to filter Em_materi2s to delete.
     * @example
     * // Delete a few Em_materi2s
     * const { count } = await prisma.em_materi2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_materi2DeleteManyArgs>(args?: SelectSubset<T, em_materi2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_materi2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_materi2s
     * const em_materi2 = await prisma.em_materi2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_materi2UpdateManyArgs>(args: SelectSubset<T, em_materi2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_materi2.
     * @param {em_materi2UpsertArgs} args - Arguments to update or create a Em_materi2.
     * @example
     * // Update or create a Em_materi2
     * const em_materi2 = await prisma.em_materi2.upsert({
     *   create: {
     *     // ... data to create a Em_materi2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_materi2 we want to update
     *   }
     * })
     */
    upsert<T extends em_materi2UpsertArgs>(args: SelectSubset<T, em_materi2UpsertArgs<ExtArgs>>): Prisma__em_materi2Client<$Result.GetResult<Prisma.$em_materi2Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_materi2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi2CountArgs} args - Arguments to filter Em_materi2s to count.
     * @example
     * // Count the number of Em_materi2s
     * const count = await prisma.em_materi2.count({
     *   where: {
     *     // ... the filter for the Em_materi2s we want to count
     *   }
     * })
    **/
    count<T extends em_materi2CountArgs>(
      args?: Subset<T, em_materi2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_materi2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_materi2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_materi2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_materi2AggregateArgs>(args: Subset<T, Em_materi2AggregateArgs>): Prisma.PrismaPromise<GetEm_materi2AggregateType<T>>

    /**
     * Group by Em_materi2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_materi2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_materi2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_materi2GroupByArgs['orderBy'] }
        : { orderBy?: em_materi2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_materi2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_materi2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_materi2 model
   */
  readonly fields: em_materi2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_materi2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_materi2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_materi_type<T extends em_materi_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_materi_typeDefaultArgs<ExtArgs>>): Prisma__em_materi_typeClient<$Result.GetResult<Prisma.$em_materi_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    em_materi1<T extends em_materi1DefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_materi1DefaultArgs<ExtArgs>>): Prisma__em_materi1Client<$Result.GetResult<Prisma.$em_materi1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_materi2 model
   */
  interface em_materi2FieldRefs {
    readonly id: FieldRef<"em_materi2", 'Int'>
    readonly materi_id: FieldRef<"em_materi2", 'Int'>
    readonly materi_type: FieldRef<"em_materi2", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_materi2 findUnique
   */
  export type em_materi2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * Filter, which em_materi2 to fetch.
     */
    where: em_materi2WhereUniqueInput
  }

  /**
   * em_materi2 findUniqueOrThrow
   */
  export type em_materi2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * Filter, which em_materi2 to fetch.
     */
    where: em_materi2WhereUniqueInput
  }

  /**
   * em_materi2 findFirst
   */
  export type em_materi2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * Filter, which em_materi2 to fetch.
     */
    where?: em_materi2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi2s to fetch.
     */
    orderBy?: em_materi2OrderByWithRelationInput | em_materi2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi2s.
     */
    cursor?: em_materi2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi2s.
     */
    distinct?: Em_materi2ScalarFieldEnum | Em_materi2ScalarFieldEnum[]
  }

  /**
   * em_materi2 findFirstOrThrow
   */
  export type em_materi2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * Filter, which em_materi2 to fetch.
     */
    where?: em_materi2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi2s to fetch.
     */
    orderBy?: em_materi2OrderByWithRelationInput | em_materi2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_materi2s.
     */
    cursor?: em_materi2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_materi2s.
     */
    distinct?: Em_materi2ScalarFieldEnum | Em_materi2ScalarFieldEnum[]
  }

  /**
   * em_materi2 findMany
   */
  export type em_materi2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * Filter, which em_materi2s to fetch.
     */
    where?: em_materi2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_materi2s to fetch.
     */
    orderBy?: em_materi2OrderByWithRelationInput | em_materi2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_materi2s.
     */
    cursor?: em_materi2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_materi2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_materi2s.
     */
    skip?: number
    distinct?: Em_materi2ScalarFieldEnum | Em_materi2ScalarFieldEnum[]
  }

  /**
   * em_materi2 create
   */
  export type em_materi2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * The data needed to create a em_materi2.
     */
    data: XOR<em_materi2CreateInput, em_materi2UncheckedCreateInput>
  }

  /**
   * em_materi2 createMany
   */
  export type em_materi2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_materi2s.
     */
    data: em_materi2CreateManyInput | em_materi2CreateManyInput[]
  }

  /**
   * em_materi2 update
   */
  export type em_materi2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * The data needed to update a em_materi2.
     */
    data: XOR<em_materi2UpdateInput, em_materi2UncheckedUpdateInput>
    /**
     * Choose, which em_materi2 to update.
     */
    where: em_materi2WhereUniqueInput
  }

  /**
   * em_materi2 updateMany
   */
  export type em_materi2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_materi2s.
     */
    data: XOR<em_materi2UpdateManyMutationInput, em_materi2UncheckedUpdateManyInput>
    /**
     * Filter which em_materi2s to update
     */
    where?: em_materi2WhereInput
    /**
     * Limit how many em_materi2s to update.
     */
    limit?: number
  }

  /**
   * em_materi2 upsert
   */
  export type em_materi2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * The filter to search for the em_materi2 to update in case it exists.
     */
    where: em_materi2WhereUniqueInput
    /**
     * In case the em_materi2 found by the `where` argument doesn't exist, create a new em_materi2 with this data.
     */
    create: XOR<em_materi2CreateInput, em_materi2UncheckedCreateInput>
    /**
     * In case the em_materi2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_materi2UpdateInput, em_materi2UncheckedUpdateInput>
  }

  /**
   * em_materi2 delete
   */
  export type em_materi2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
    /**
     * Filter which em_materi2 to delete.
     */
    where: em_materi2WhereUniqueInput
  }

  /**
   * em_materi2 deleteMany
   */
  export type em_materi2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_materi2s to delete
     */
    where?: em_materi2WhereInput
    /**
     * Limit how many em_materi2s to delete.
     */
    limit?: number
  }

  /**
   * em_materi2 without action
   */
  export type em_materi2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_materi2
     */
    select?: em_materi2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_materi2
     */
    omit?: em_materi2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_materi2Include<ExtArgs> | null
  }


  /**
   * Model em_menu
   */

  export type AggregateEm_menu = {
    _count: Em_menuCountAggregateOutputType | null
    _avg: Em_menuAvgAggregateOutputType | null
    _sum: Em_menuSumAggregateOutputType | null
    _min: Em_menuMinAggregateOutputType | null
    _max: Em_menuMaxAggregateOutputType | null
  }

  export type Em_menuAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_menuSumAggregateOutputType = {
    id: number | null
  }

  export type Em_menuMinAggregateOutputType = {
    id: number | null
    menuid: string | null
    name: string | null
    parent_id: string | null
    link: string | null
    visible: boolean | null
    status: string | null
    lastupdate: Date | null
    icon: string | null
    menutype: string | null
  }

  export type Em_menuMaxAggregateOutputType = {
    id: number | null
    menuid: string | null
    name: string | null
    parent_id: string | null
    link: string | null
    visible: boolean | null
    status: string | null
    lastupdate: Date | null
    icon: string | null
    menutype: string | null
  }

  export type Em_menuCountAggregateOutputType = {
    id: number
    menuid: number
    name: number
    parent_id: number
    link: number
    visible: number
    status: number
    lastupdate: number
    icon: number
    menutype: number
    _all: number
  }


  export type Em_menuAvgAggregateInputType = {
    id?: true
  }

  export type Em_menuSumAggregateInputType = {
    id?: true
  }

  export type Em_menuMinAggregateInputType = {
    id?: true
    menuid?: true
    name?: true
    parent_id?: true
    link?: true
    visible?: true
    status?: true
    lastupdate?: true
    icon?: true
    menutype?: true
  }

  export type Em_menuMaxAggregateInputType = {
    id?: true
    menuid?: true
    name?: true
    parent_id?: true
    link?: true
    visible?: true
    status?: true
    lastupdate?: true
    icon?: true
    menutype?: true
  }

  export type Em_menuCountAggregateInputType = {
    id?: true
    menuid?: true
    name?: true
    parent_id?: true
    link?: true
    visible?: true
    status?: true
    lastupdate?: true
    icon?: true
    menutype?: true
    _all?: true
  }

  export type Em_menuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_menu to aggregate.
     */
    where?: em_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_menus to fetch.
     */
    orderBy?: em_menuOrderByWithRelationInput | em_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_menus
    **/
    _count?: true | Em_menuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_menuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_menuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_menuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_menuMaxAggregateInputType
  }

  export type GetEm_menuAggregateType<T extends Em_menuAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_menu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_menu[P]>
      : GetScalarType<T[P], AggregateEm_menu[P]>
  }




  export type em_menuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_menuWhereInput
    orderBy?: em_menuOrderByWithAggregationInput | em_menuOrderByWithAggregationInput[]
    by: Em_menuScalarFieldEnum[] | Em_menuScalarFieldEnum
    having?: em_menuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_menuCountAggregateInputType | true
    _avg?: Em_menuAvgAggregateInputType
    _sum?: Em_menuSumAggregateInputType
    _min?: Em_menuMinAggregateInputType
    _max?: Em_menuMaxAggregateInputType
  }

  export type Em_menuGroupByOutputType = {
    id: number
    menuid: string
    name: string
    parent_id: string | null
    link: string | null
    visible: boolean
    status: string | null
    lastupdate: Date | null
    icon: string | null
    menutype: string | null
    _count: Em_menuCountAggregateOutputType | null
    _avg: Em_menuAvgAggregateOutputType | null
    _sum: Em_menuSumAggregateOutputType | null
    _min: Em_menuMinAggregateOutputType | null
    _max: Em_menuMaxAggregateOutputType | null
  }

  type GetEm_menuGroupByPayload<T extends em_menuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_menuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_menuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_menuGroupByOutputType[P]>
            : GetScalarType<T[P], Em_menuGroupByOutputType[P]>
        }
      >
    >


  export type em_menuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuid?: boolean
    name?: boolean
    parent_id?: boolean
    link?: boolean
    visible?: boolean
    status?: boolean
    lastupdate?: boolean
    icon?: boolean
    menutype?: boolean
  }, ExtArgs["result"]["em_menu"]>



  export type em_menuSelectScalar = {
    id?: boolean
    menuid?: boolean
    name?: boolean
    parent_id?: boolean
    link?: boolean
    visible?: boolean
    status?: boolean
    lastupdate?: boolean
    icon?: boolean
    menutype?: boolean
  }

  export type em_menuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuid" | "name" | "parent_id" | "link" | "visible" | "status" | "lastupdate" | "icon" | "menutype", ExtArgs["result"]["em_menu"]>

  export type $em_menuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_menu"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      menuid: string
      name: string
      parent_id: string | null
      link: string | null
      visible: boolean
      status: string | null
      lastupdate: Date | null
      icon: string | null
      menutype: string | null
    }, ExtArgs["result"]["em_menu"]>
    composites: {}
  }

  type em_menuGetPayload<S extends boolean | null | undefined | em_menuDefaultArgs> = $Result.GetResult<Prisma.$em_menuPayload, S>

  type em_menuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_menuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_menuCountAggregateInputType | true
    }

  export interface em_menuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_menu'], meta: { name: 'em_menu' } }
    /**
     * Find zero or one Em_menu that matches the filter.
     * @param {em_menuFindUniqueArgs} args - Arguments to find a Em_menu
     * @example
     * // Get one Em_menu
     * const em_menu = await prisma.em_menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_menuFindUniqueArgs>(args: SelectSubset<T, em_menuFindUniqueArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_menuFindUniqueOrThrowArgs} args - Arguments to find a Em_menu
     * @example
     * // Get one Em_menu
     * const em_menu = await prisma.em_menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_menuFindUniqueOrThrowArgs>(args: SelectSubset<T, em_menuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_menuFindFirstArgs} args - Arguments to find a Em_menu
     * @example
     * // Get one Em_menu
     * const em_menu = await prisma.em_menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_menuFindFirstArgs>(args?: SelectSubset<T, em_menuFindFirstArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_menuFindFirstOrThrowArgs} args - Arguments to find a Em_menu
     * @example
     * // Get one Em_menu
     * const em_menu = await prisma.em_menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_menuFindFirstOrThrowArgs>(args?: SelectSubset<T, em_menuFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_menuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_menus
     * const em_menus = await prisma.em_menu.findMany()
     * 
     * // Get first 10 Em_menus
     * const em_menus = await prisma.em_menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_menuWithIdOnly = await prisma.em_menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_menuFindManyArgs>(args?: SelectSubset<T, em_menuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_menu.
     * @param {em_menuCreateArgs} args - Arguments to create a Em_menu.
     * @example
     * // Create one Em_menu
     * const Em_menu = await prisma.em_menu.create({
     *   data: {
     *     // ... data to create a Em_menu
     *   }
     * })
     * 
     */
    create<T extends em_menuCreateArgs>(args: SelectSubset<T, em_menuCreateArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_menus.
     * @param {em_menuCreateManyArgs} args - Arguments to create many Em_menus.
     * @example
     * // Create many Em_menus
     * const em_menu = await prisma.em_menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_menuCreateManyArgs>(args?: SelectSubset<T, em_menuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_menu.
     * @param {em_menuDeleteArgs} args - Arguments to delete one Em_menu.
     * @example
     * // Delete one Em_menu
     * const Em_menu = await prisma.em_menu.delete({
     *   where: {
     *     // ... filter to delete one Em_menu
     *   }
     * })
     * 
     */
    delete<T extends em_menuDeleteArgs>(args: SelectSubset<T, em_menuDeleteArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_menu.
     * @param {em_menuUpdateArgs} args - Arguments to update one Em_menu.
     * @example
     * // Update one Em_menu
     * const em_menu = await prisma.em_menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_menuUpdateArgs>(args: SelectSubset<T, em_menuUpdateArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_menus.
     * @param {em_menuDeleteManyArgs} args - Arguments to filter Em_menus to delete.
     * @example
     * // Delete a few Em_menus
     * const { count } = await prisma.em_menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_menuDeleteManyArgs>(args?: SelectSubset<T, em_menuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_menuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_menus
     * const em_menu = await prisma.em_menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_menuUpdateManyArgs>(args: SelectSubset<T, em_menuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_menu.
     * @param {em_menuUpsertArgs} args - Arguments to update or create a Em_menu.
     * @example
     * // Update or create a Em_menu
     * const em_menu = await prisma.em_menu.upsert({
     *   create: {
     *     // ... data to create a Em_menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_menu we want to update
     *   }
     * })
     */
    upsert<T extends em_menuUpsertArgs>(args: SelectSubset<T, em_menuUpsertArgs<ExtArgs>>): Prisma__em_menuClient<$Result.GetResult<Prisma.$em_menuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_menuCountArgs} args - Arguments to filter Em_menus to count.
     * @example
     * // Count the number of Em_menus
     * const count = await prisma.em_menu.count({
     *   where: {
     *     // ... the filter for the Em_menus we want to count
     *   }
     * })
    **/
    count<T extends em_menuCountArgs>(
      args?: Subset<T, em_menuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_menuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_menuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_menuAggregateArgs>(args: Subset<T, Em_menuAggregateArgs>): Prisma.PrismaPromise<GetEm_menuAggregateType<T>>

    /**
     * Group by Em_menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_menuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_menuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_menuGroupByArgs['orderBy'] }
        : { orderBy?: em_menuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_menuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_menuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_menu model
   */
  readonly fields: em_menuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_menuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_menu model
   */
  interface em_menuFieldRefs {
    readonly id: FieldRef<"em_menu", 'Int'>
    readonly menuid: FieldRef<"em_menu", 'String'>
    readonly name: FieldRef<"em_menu", 'String'>
    readonly parent_id: FieldRef<"em_menu", 'String'>
    readonly link: FieldRef<"em_menu", 'String'>
    readonly visible: FieldRef<"em_menu", 'Boolean'>
    readonly status: FieldRef<"em_menu", 'String'>
    readonly lastupdate: FieldRef<"em_menu", 'DateTime'>
    readonly icon: FieldRef<"em_menu", 'String'>
    readonly menutype: FieldRef<"em_menu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_menu findUnique
   */
  export type em_menuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * Filter, which em_menu to fetch.
     */
    where: em_menuWhereUniqueInput
  }

  /**
   * em_menu findUniqueOrThrow
   */
  export type em_menuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * Filter, which em_menu to fetch.
     */
    where: em_menuWhereUniqueInput
  }

  /**
   * em_menu findFirst
   */
  export type em_menuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * Filter, which em_menu to fetch.
     */
    where?: em_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_menus to fetch.
     */
    orderBy?: em_menuOrderByWithRelationInput | em_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_menus.
     */
    cursor?: em_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_menus.
     */
    distinct?: Em_menuScalarFieldEnum | Em_menuScalarFieldEnum[]
  }

  /**
   * em_menu findFirstOrThrow
   */
  export type em_menuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * Filter, which em_menu to fetch.
     */
    where?: em_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_menus to fetch.
     */
    orderBy?: em_menuOrderByWithRelationInput | em_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_menus.
     */
    cursor?: em_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_menus.
     */
    distinct?: Em_menuScalarFieldEnum | Em_menuScalarFieldEnum[]
  }

  /**
   * em_menu findMany
   */
  export type em_menuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * Filter, which em_menus to fetch.
     */
    where?: em_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_menus to fetch.
     */
    orderBy?: em_menuOrderByWithRelationInput | em_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_menus.
     */
    cursor?: em_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_menus.
     */
    skip?: number
    distinct?: Em_menuScalarFieldEnum | Em_menuScalarFieldEnum[]
  }

  /**
   * em_menu create
   */
  export type em_menuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * The data needed to create a em_menu.
     */
    data: XOR<em_menuCreateInput, em_menuUncheckedCreateInput>
  }

  /**
   * em_menu createMany
   */
  export type em_menuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_menus.
     */
    data: em_menuCreateManyInput | em_menuCreateManyInput[]
  }

  /**
   * em_menu update
   */
  export type em_menuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * The data needed to update a em_menu.
     */
    data: XOR<em_menuUpdateInput, em_menuUncheckedUpdateInput>
    /**
     * Choose, which em_menu to update.
     */
    where: em_menuWhereUniqueInput
  }

  /**
   * em_menu updateMany
   */
  export type em_menuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_menus.
     */
    data: XOR<em_menuUpdateManyMutationInput, em_menuUncheckedUpdateManyInput>
    /**
     * Filter which em_menus to update
     */
    where?: em_menuWhereInput
    /**
     * Limit how many em_menus to update.
     */
    limit?: number
  }

  /**
   * em_menu upsert
   */
  export type em_menuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * The filter to search for the em_menu to update in case it exists.
     */
    where: em_menuWhereUniqueInput
    /**
     * In case the em_menu found by the `where` argument doesn't exist, create a new em_menu with this data.
     */
    create: XOR<em_menuCreateInput, em_menuUncheckedCreateInput>
    /**
     * In case the em_menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_menuUpdateInput, em_menuUncheckedUpdateInput>
  }

  /**
   * em_menu delete
   */
  export type em_menuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
    /**
     * Filter which em_menu to delete.
     */
    where: em_menuWhereUniqueInput
  }

  /**
   * em_menu deleteMany
   */
  export type em_menuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_menus to delete
     */
    where?: em_menuWhereInput
    /**
     * Limit how many em_menus to delete.
     */
    limit?: number
  }

  /**
   * em_menu without action
   */
  export type em_menuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_menu
     */
    select?: em_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_menu
     */
    omit?: em_menuOmit<ExtArgs> | null
  }


  /**
   * Model em_notifikasi
   */

  export type AggregateEm_notifikasi = {
    _count: Em_notifikasiCountAggregateOutputType | null
    _avg: Em_notifikasiAvgAggregateOutputType | null
    _sum: Em_notifikasiSumAggregateOutputType | null
    _min: Em_notifikasiMinAggregateOutputType | null
    _max: Em_notifikasiMaxAggregateOutputType | null
  }

  export type Em_notifikasiAvgAggregateOutputType = {
    NotifyId: number | null
    UserId: number | null
    GroupId: number | null
  }

  export type Em_notifikasiSumAggregateOutputType = {
    NotifyId: number | null
    UserId: number | null
    GroupId: number | null
  }

  export type Em_notifikasiMinAggregateOutputType = {
    NotifyId: number | null
    UserId: number | null
    GroupId: number | null
    Note: string | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
  }

  export type Em_notifikasiMaxAggregateOutputType = {
    NotifyId: number | null
    UserId: number | null
    GroupId: number | null
    Note: string | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
  }

  export type Em_notifikasiCountAggregateOutputType = {
    NotifyId: number
    UserId: number
    GroupId: number
    Note: number
    Status: number
    CreateDate: number
    LastUpdate: number
    _all: number
  }


  export type Em_notifikasiAvgAggregateInputType = {
    NotifyId?: true
    UserId?: true
    GroupId?: true
  }

  export type Em_notifikasiSumAggregateInputType = {
    NotifyId?: true
    UserId?: true
    GroupId?: true
  }

  export type Em_notifikasiMinAggregateInputType = {
    NotifyId?: true
    UserId?: true
    GroupId?: true
    Note?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
  }

  export type Em_notifikasiMaxAggregateInputType = {
    NotifyId?: true
    UserId?: true
    GroupId?: true
    Note?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
  }

  export type Em_notifikasiCountAggregateInputType = {
    NotifyId?: true
    UserId?: true
    GroupId?: true
    Note?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
    _all?: true
  }

  export type Em_notifikasiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_notifikasi to aggregate.
     */
    where?: em_notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasis to fetch.
     */
    orderBy?: em_notifikasiOrderByWithRelationInput | em_notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_notifikasis
    **/
    _count?: true | Em_notifikasiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_notifikasiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_notifikasiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_notifikasiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_notifikasiMaxAggregateInputType
  }

  export type GetEm_notifikasiAggregateType<T extends Em_notifikasiAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_notifikasi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_notifikasi[P]>
      : GetScalarType<T[P], AggregateEm_notifikasi[P]>
  }




  export type em_notifikasiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_notifikasiWhereInput
    orderBy?: em_notifikasiOrderByWithAggregationInput | em_notifikasiOrderByWithAggregationInput[]
    by: Em_notifikasiScalarFieldEnum[] | Em_notifikasiScalarFieldEnum
    having?: em_notifikasiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_notifikasiCountAggregateInputType | true
    _avg?: Em_notifikasiAvgAggregateInputType
    _sum?: Em_notifikasiSumAggregateInputType
    _min?: Em_notifikasiMinAggregateInputType
    _max?: Em_notifikasiMaxAggregateInputType
  }

  export type Em_notifikasiGroupByOutputType = {
    NotifyId: number
    UserId: number | null
    GroupId: number | null
    Note: string | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
    _count: Em_notifikasiCountAggregateOutputType | null
    _avg: Em_notifikasiAvgAggregateOutputType | null
    _sum: Em_notifikasiSumAggregateOutputType | null
    _min: Em_notifikasiMinAggregateOutputType | null
    _max: Em_notifikasiMaxAggregateOutputType | null
  }

  type GetEm_notifikasiGroupByPayload<T extends em_notifikasiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_notifikasiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_notifikasiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_notifikasiGroupByOutputType[P]>
            : GetScalarType<T[P], Em_notifikasiGroupByOutputType[P]>
        }
      >
    >


  export type em_notifikasiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NotifyId?: boolean
    UserId?: boolean
    GroupId?: boolean
    Note?: boolean
    Status?: boolean
    CreateDate?: boolean
    LastUpdate?: boolean
  }, ExtArgs["result"]["em_notifikasi"]>



  export type em_notifikasiSelectScalar = {
    NotifyId?: boolean
    UserId?: boolean
    GroupId?: boolean
    Note?: boolean
    Status?: boolean
    CreateDate?: boolean
    LastUpdate?: boolean
  }

  export type em_notifikasiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"NotifyId" | "UserId" | "GroupId" | "Note" | "Status" | "CreateDate" | "LastUpdate", ExtArgs["result"]["em_notifikasi"]>

  export type $em_notifikasiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_notifikasi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      NotifyId: number
      UserId: number | null
      GroupId: number | null
      Note: string | null
      Status: string | null
      CreateDate: Date | null
      LastUpdate: Date | null
    }, ExtArgs["result"]["em_notifikasi"]>
    composites: {}
  }

  type em_notifikasiGetPayload<S extends boolean | null | undefined | em_notifikasiDefaultArgs> = $Result.GetResult<Prisma.$em_notifikasiPayload, S>

  type em_notifikasiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_notifikasiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_notifikasiCountAggregateInputType | true
    }

  export interface em_notifikasiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_notifikasi'], meta: { name: 'em_notifikasi' } }
    /**
     * Find zero or one Em_notifikasi that matches the filter.
     * @param {em_notifikasiFindUniqueArgs} args - Arguments to find a Em_notifikasi
     * @example
     * // Get one Em_notifikasi
     * const em_notifikasi = await prisma.em_notifikasi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_notifikasiFindUniqueArgs>(args: SelectSubset<T, em_notifikasiFindUniqueArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_notifikasi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_notifikasiFindUniqueOrThrowArgs} args - Arguments to find a Em_notifikasi
     * @example
     * // Get one Em_notifikasi
     * const em_notifikasi = await prisma.em_notifikasi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_notifikasiFindUniqueOrThrowArgs>(args: SelectSubset<T, em_notifikasiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_notifikasi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasiFindFirstArgs} args - Arguments to find a Em_notifikasi
     * @example
     * // Get one Em_notifikasi
     * const em_notifikasi = await prisma.em_notifikasi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_notifikasiFindFirstArgs>(args?: SelectSubset<T, em_notifikasiFindFirstArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_notifikasi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasiFindFirstOrThrowArgs} args - Arguments to find a Em_notifikasi
     * @example
     * // Get one Em_notifikasi
     * const em_notifikasi = await prisma.em_notifikasi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_notifikasiFindFirstOrThrowArgs>(args?: SelectSubset<T, em_notifikasiFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_notifikasis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_notifikasis
     * const em_notifikasis = await prisma.em_notifikasi.findMany()
     * 
     * // Get first 10 Em_notifikasis
     * const em_notifikasis = await prisma.em_notifikasi.findMany({ take: 10 })
     * 
     * // Only select the `NotifyId`
     * const em_notifikasiWithNotifyIdOnly = await prisma.em_notifikasi.findMany({ select: { NotifyId: true } })
     * 
     */
    findMany<T extends em_notifikasiFindManyArgs>(args?: SelectSubset<T, em_notifikasiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_notifikasi.
     * @param {em_notifikasiCreateArgs} args - Arguments to create a Em_notifikasi.
     * @example
     * // Create one Em_notifikasi
     * const Em_notifikasi = await prisma.em_notifikasi.create({
     *   data: {
     *     // ... data to create a Em_notifikasi
     *   }
     * })
     * 
     */
    create<T extends em_notifikasiCreateArgs>(args: SelectSubset<T, em_notifikasiCreateArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_notifikasis.
     * @param {em_notifikasiCreateManyArgs} args - Arguments to create many Em_notifikasis.
     * @example
     * // Create many Em_notifikasis
     * const em_notifikasi = await prisma.em_notifikasi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_notifikasiCreateManyArgs>(args?: SelectSubset<T, em_notifikasiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_notifikasi.
     * @param {em_notifikasiDeleteArgs} args - Arguments to delete one Em_notifikasi.
     * @example
     * // Delete one Em_notifikasi
     * const Em_notifikasi = await prisma.em_notifikasi.delete({
     *   where: {
     *     // ... filter to delete one Em_notifikasi
     *   }
     * })
     * 
     */
    delete<T extends em_notifikasiDeleteArgs>(args: SelectSubset<T, em_notifikasiDeleteArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_notifikasi.
     * @param {em_notifikasiUpdateArgs} args - Arguments to update one Em_notifikasi.
     * @example
     * // Update one Em_notifikasi
     * const em_notifikasi = await prisma.em_notifikasi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_notifikasiUpdateArgs>(args: SelectSubset<T, em_notifikasiUpdateArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_notifikasis.
     * @param {em_notifikasiDeleteManyArgs} args - Arguments to filter Em_notifikasis to delete.
     * @example
     * // Delete a few Em_notifikasis
     * const { count } = await prisma.em_notifikasi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_notifikasiDeleteManyArgs>(args?: SelectSubset<T, em_notifikasiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_notifikasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_notifikasis
     * const em_notifikasi = await prisma.em_notifikasi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_notifikasiUpdateManyArgs>(args: SelectSubset<T, em_notifikasiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_notifikasi.
     * @param {em_notifikasiUpsertArgs} args - Arguments to update or create a Em_notifikasi.
     * @example
     * // Update or create a Em_notifikasi
     * const em_notifikasi = await prisma.em_notifikasi.upsert({
     *   create: {
     *     // ... data to create a Em_notifikasi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_notifikasi we want to update
     *   }
     * })
     */
    upsert<T extends em_notifikasiUpsertArgs>(args: SelectSubset<T, em_notifikasiUpsertArgs<ExtArgs>>): Prisma__em_notifikasiClient<$Result.GetResult<Prisma.$em_notifikasiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_notifikasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasiCountArgs} args - Arguments to filter Em_notifikasis to count.
     * @example
     * // Count the number of Em_notifikasis
     * const count = await prisma.em_notifikasi.count({
     *   where: {
     *     // ... the filter for the Em_notifikasis we want to count
     *   }
     * })
    **/
    count<T extends em_notifikasiCountArgs>(
      args?: Subset<T, em_notifikasiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_notifikasiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_notifikasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_notifikasiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_notifikasiAggregateArgs>(args: Subset<T, Em_notifikasiAggregateArgs>): Prisma.PrismaPromise<GetEm_notifikasiAggregateType<T>>

    /**
     * Group by Em_notifikasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_notifikasiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_notifikasiGroupByArgs['orderBy'] }
        : { orderBy?: em_notifikasiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_notifikasiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_notifikasiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_notifikasi model
   */
  readonly fields: em_notifikasiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_notifikasi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_notifikasiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_notifikasi model
   */
  interface em_notifikasiFieldRefs {
    readonly NotifyId: FieldRef<"em_notifikasi", 'Int'>
    readonly UserId: FieldRef<"em_notifikasi", 'Int'>
    readonly GroupId: FieldRef<"em_notifikasi", 'Int'>
    readonly Note: FieldRef<"em_notifikasi", 'String'>
    readonly Status: FieldRef<"em_notifikasi", 'String'>
    readonly CreateDate: FieldRef<"em_notifikasi", 'DateTime'>
    readonly LastUpdate: FieldRef<"em_notifikasi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_notifikasi findUnique
   */
  export type em_notifikasiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi to fetch.
     */
    where: em_notifikasiWhereUniqueInput
  }

  /**
   * em_notifikasi findUniqueOrThrow
   */
  export type em_notifikasiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi to fetch.
     */
    where: em_notifikasiWhereUniqueInput
  }

  /**
   * em_notifikasi findFirst
   */
  export type em_notifikasiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi to fetch.
     */
    where?: em_notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasis to fetch.
     */
    orderBy?: em_notifikasiOrderByWithRelationInput | em_notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_notifikasis.
     */
    cursor?: em_notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_notifikasis.
     */
    distinct?: Em_notifikasiScalarFieldEnum | Em_notifikasiScalarFieldEnum[]
  }

  /**
   * em_notifikasi findFirstOrThrow
   */
  export type em_notifikasiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi to fetch.
     */
    where?: em_notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasis to fetch.
     */
    orderBy?: em_notifikasiOrderByWithRelationInput | em_notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_notifikasis.
     */
    cursor?: em_notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_notifikasis.
     */
    distinct?: Em_notifikasiScalarFieldEnum | Em_notifikasiScalarFieldEnum[]
  }

  /**
   * em_notifikasi findMany
   */
  export type em_notifikasiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasis to fetch.
     */
    where?: em_notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasis to fetch.
     */
    orderBy?: em_notifikasiOrderByWithRelationInput | em_notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_notifikasis.
     */
    cursor?: em_notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasis.
     */
    skip?: number
    distinct?: Em_notifikasiScalarFieldEnum | Em_notifikasiScalarFieldEnum[]
  }

  /**
   * em_notifikasi create
   */
  export type em_notifikasiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * The data needed to create a em_notifikasi.
     */
    data?: XOR<em_notifikasiCreateInput, em_notifikasiUncheckedCreateInput>
  }

  /**
   * em_notifikasi createMany
   */
  export type em_notifikasiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_notifikasis.
     */
    data: em_notifikasiCreateManyInput | em_notifikasiCreateManyInput[]
  }

  /**
   * em_notifikasi update
   */
  export type em_notifikasiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * The data needed to update a em_notifikasi.
     */
    data: XOR<em_notifikasiUpdateInput, em_notifikasiUncheckedUpdateInput>
    /**
     * Choose, which em_notifikasi to update.
     */
    where: em_notifikasiWhereUniqueInput
  }

  /**
   * em_notifikasi updateMany
   */
  export type em_notifikasiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_notifikasis.
     */
    data: XOR<em_notifikasiUpdateManyMutationInput, em_notifikasiUncheckedUpdateManyInput>
    /**
     * Filter which em_notifikasis to update
     */
    where?: em_notifikasiWhereInput
    /**
     * Limit how many em_notifikasis to update.
     */
    limit?: number
  }

  /**
   * em_notifikasi upsert
   */
  export type em_notifikasiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * The filter to search for the em_notifikasi to update in case it exists.
     */
    where: em_notifikasiWhereUniqueInput
    /**
     * In case the em_notifikasi found by the `where` argument doesn't exist, create a new em_notifikasi with this data.
     */
    create: XOR<em_notifikasiCreateInput, em_notifikasiUncheckedCreateInput>
    /**
     * In case the em_notifikasi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_notifikasiUpdateInput, em_notifikasiUncheckedUpdateInput>
  }

  /**
   * em_notifikasi delete
   */
  export type em_notifikasiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
    /**
     * Filter which em_notifikasi to delete.
     */
    where: em_notifikasiWhereUniqueInput
  }

  /**
   * em_notifikasi deleteMany
   */
  export type em_notifikasiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_notifikasis to delete
     */
    where?: em_notifikasiWhereInput
    /**
     * Limit how many em_notifikasis to delete.
     */
    limit?: number
  }

  /**
   * em_notifikasi without action
   */
  export type em_notifikasiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi
     */
    select?: em_notifikasiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi
     */
    omit?: em_notifikasiOmit<ExtArgs> | null
  }


  /**
   * Model em_notifikasi_read
   */

  export type AggregateEm_notifikasi_read = {
    _count: Em_notifikasi_readCountAggregateOutputType | null
    _avg: Em_notifikasi_readAvgAggregateOutputType | null
    _sum: Em_notifikasi_readSumAggregateOutputType | null
    _min: Em_notifikasi_readMinAggregateOutputType | null
    _max: Em_notifikasi_readMaxAggregateOutputType | null
  }

  export type Em_notifikasi_readAvgAggregateOutputType = {
    ReadId: number | null
    NotifyId: number | null
    UserId: number | null
  }

  export type Em_notifikasi_readSumAggregateOutputType = {
    ReadId: number | null
    NotifyId: number | null
    UserId: number | null
  }

  export type Em_notifikasi_readMinAggregateOutputType = {
    ReadId: number | null
    NotifyId: number | null
    UserId: number | null
    ReadDate: Date | null
  }

  export type Em_notifikasi_readMaxAggregateOutputType = {
    ReadId: number | null
    NotifyId: number | null
    UserId: number | null
    ReadDate: Date | null
  }

  export type Em_notifikasi_readCountAggregateOutputType = {
    ReadId: number
    NotifyId: number
    UserId: number
    ReadDate: number
    _all: number
  }


  export type Em_notifikasi_readAvgAggregateInputType = {
    ReadId?: true
    NotifyId?: true
    UserId?: true
  }

  export type Em_notifikasi_readSumAggregateInputType = {
    ReadId?: true
    NotifyId?: true
    UserId?: true
  }

  export type Em_notifikasi_readMinAggregateInputType = {
    ReadId?: true
    NotifyId?: true
    UserId?: true
    ReadDate?: true
  }

  export type Em_notifikasi_readMaxAggregateInputType = {
    ReadId?: true
    NotifyId?: true
    UserId?: true
    ReadDate?: true
  }

  export type Em_notifikasi_readCountAggregateInputType = {
    ReadId?: true
    NotifyId?: true
    UserId?: true
    ReadDate?: true
    _all?: true
  }

  export type Em_notifikasi_readAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_notifikasi_read to aggregate.
     */
    where?: em_notifikasi_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasi_reads to fetch.
     */
    orderBy?: em_notifikasi_readOrderByWithRelationInput | em_notifikasi_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_notifikasi_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasi_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasi_reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_notifikasi_reads
    **/
    _count?: true | Em_notifikasi_readCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_notifikasi_readAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_notifikasi_readSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_notifikasi_readMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_notifikasi_readMaxAggregateInputType
  }

  export type GetEm_notifikasi_readAggregateType<T extends Em_notifikasi_readAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_notifikasi_read]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_notifikasi_read[P]>
      : GetScalarType<T[P], AggregateEm_notifikasi_read[P]>
  }




  export type em_notifikasi_readGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_notifikasi_readWhereInput
    orderBy?: em_notifikasi_readOrderByWithAggregationInput | em_notifikasi_readOrderByWithAggregationInput[]
    by: Em_notifikasi_readScalarFieldEnum[] | Em_notifikasi_readScalarFieldEnum
    having?: em_notifikasi_readScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_notifikasi_readCountAggregateInputType | true
    _avg?: Em_notifikasi_readAvgAggregateInputType
    _sum?: Em_notifikasi_readSumAggregateInputType
    _min?: Em_notifikasi_readMinAggregateInputType
    _max?: Em_notifikasi_readMaxAggregateInputType
  }

  export type Em_notifikasi_readGroupByOutputType = {
    ReadId: number
    NotifyId: number | null
    UserId: number | null
    ReadDate: Date | null
    _count: Em_notifikasi_readCountAggregateOutputType | null
    _avg: Em_notifikasi_readAvgAggregateOutputType | null
    _sum: Em_notifikasi_readSumAggregateOutputType | null
    _min: Em_notifikasi_readMinAggregateOutputType | null
    _max: Em_notifikasi_readMaxAggregateOutputType | null
  }

  type GetEm_notifikasi_readGroupByPayload<T extends em_notifikasi_readGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_notifikasi_readGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_notifikasi_readGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_notifikasi_readGroupByOutputType[P]>
            : GetScalarType<T[P], Em_notifikasi_readGroupByOutputType[P]>
        }
      >
    >


  export type em_notifikasi_readSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ReadId?: boolean
    NotifyId?: boolean
    UserId?: boolean
    ReadDate?: boolean
  }, ExtArgs["result"]["em_notifikasi_read"]>



  export type em_notifikasi_readSelectScalar = {
    ReadId?: boolean
    NotifyId?: boolean
    UserId?: boolean
    ReadDate?: boolean
  }

  export type em_notifikasi_readOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ReadId" | "NotifyId" | "UserId" | "ReadDate", ExtArgs["result"]["em_notifikasi_read"]>

  export type $em_notifikasi_readPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_notifikasi_read"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ReadId: number
      NotifyId: number | null
      UserId: number | null
      ReadDate: Date | null
    }, ExtArgs["result"]["em_notifikasi_read"]>
    composites: {}
  }

  type em_notifikasi_readGetPayload<S extends boolean | null | undefined | em_notifikasi_readDefaultArgs> = $Result.GetResult<Prisma.$em_notifikasi_readPayload, S>

  type em_notifikasi_readCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_notifikasi_readFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_notifikasi_readCountAggregateInputType | true
    }

  export interface em_notifikasi_readDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_notifikasi_read'], meta: { name: 'em_notifikasi_read' } }
    /**
     * Find zero or one Em_notifikasi_read that matches the filter.
     * @param {em_notifikasi_readFindUniqueArgs} args - Arguments to find a Em_notifikasi_read
     * @example
     * // Get one Em_notifikasi_read
     * const em_notifikasi_read = await prisma.em_notifikasi_read.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_notifikasi_readFindUniqueArgs>(args: SelectSubset<T, em_notifikasi_readFindUniqueArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_notifikasi_read that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_notifikasi_readFindUniqueOrThrowArgs} args - Arguments to find a Em_notifikasi_read
     * @example
     * // Get one Em_notifikasi_read
     * const em_notifikasi_read = await prisma.em_notifikasi_read.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_notifikasi_readFindUniqueOrThrowArgs>(args: SelectSubset<T, em_notifikasi_readFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_notifikasi_read that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasi_readFindFirstArgs} args - Arguments to find a Em_notifikasi_read
     * @example
     * // Get one Em_notifikasi_read
     * const em_notifikasi_read = await prisma.em_notifikasi_read.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_notifikasi_readFindFirstArgs>(args?: SelectSubset<T, em_notifikasi_readFindFirstArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_notifikasi_read that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasi_readFindFirstOrThrowArgs} args - Arguments to find a Em_notifikasi_read
     * @example
     * // Get one Em_notifikasi_read
     * const em_notifikasi_read = await prisma.em_notifikasi_read.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_notifikasi_readFindFirstOrThrowArgs>(args?: SelectSubset<T, em_notifikasi_readFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_notifikasi_reads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasi_readFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_notifikasi_reads
     * const em_notifikasi_reads = await prisma.em_notifikasi_read.findMany()
     * 
     * // Get first 10 Em_notifikasi_reads
     * const em_notifikasi_reads = await prisma.em_notifikasi_read.findMany({ take: 10 })
     * 
     * // Only select the `ReadId`
     * const em_notifikasi_readWithReadIdOnly = await prisma.em_notifikasi_read.findMany({ select: { ReadId: true } })
     * 
     */
    findMany<T extends em_notifikasi_readFindManyArgs>(args?: SelectSubset<T, em_notifikasi_readFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_notifikasi_read.
     * @param {em_notifikasi_readCreateArgs} args - Arguments to create a Em_notifikasi_read.
     * @example
     * // Create one Em_notifikasi_read
     * const Em_notifikasi_read = await prisma.em_notifikasi_read.create({
     *   data: {
     *     // ... data to create a Em_notifikasi_read
     *   }
     * })
     * 
     */
    create<T extends em_notifikasi_readCreateArgs>(args: SelectSubset<T, em_notifikasi_readCreateArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_notifikasi_reads.
     * @param {em_notifikasi_readCreateManyArgs} args - Arguments to create many Em_notifikasi_reads.
     * @example
     * // Create many Em_notifikasi_reads
     * const em_notifikasi_read = await prisma.em_notifikasi_read.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_notifikasi_readCreateManyArgs>(args?: SelectSubset<T, em_notifikasi_readCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_notifikasi_read.
     * @param {em_notifikasi_readDeleteArgs} args - Arguments to delete one Em_notifikasi_read.
     * @example
     * // Delete one Em_notifikasi_read
     * const Em_notifikasi_read = await prisma.em_notifikasi_read.delete({
     *   where: {
     *     // ... filter to delete one Em_notifikasi_read
     *   }
     * })
     * 
     */
    delete<T extends em_notifikasi_readDeleteArgs>(args: SelectSubset<T, em_notifikasi_readDeleteArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_notifikasi_read.
     * @param {em_notifikasi_readUpdateArgs} args - Arguments to update one Em_notifikasi_read.
     * @example
     * // Update one Em_notifikasi_read
     * const em_notifikasi_read = await prisma.em_notifikasi_read.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_notifikasi_readUpdateArgs>(args: SelectSubset<T, em_notifikasi_readUpdateArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_notifikasi_reads.
     * @param {em_notifikasi_readDeleteManyArgs} args - Arguments to filter Em_notifikasi_reads to delete.
     * @example
     * // Delete a few Em_notifikasi_reads
     * const { count } = await prisma.em_notifikasi_read.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_notifikasi_readDeleteManyArgs>(args?: SelectSubset<T, em_notifikasi_readDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_notifikasi_reads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasi_readUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_notifikasi_reads
     * const em_notifikasi_read = await prisma.em_notifikasi_read.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_notifikasi_readUpdateManyArgs>(args: SelectSubset<T, em_notifikasi_readUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_notifikasi_read.
     * @param {em_notifikasi_readUpsertArgs} args - Arguments to update or create a Em_notifikasi_read.
     * @example
     * // Update or create a Em_notifikasi_read
     * const em_notifikasi_read = await prisma.em_notifikasi_read.upsert({
     *   create: {
     *     // ... data to create a Em_notifikasi_read
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_notifikasi_read we want to update
     *   }
     * })
     */
    upsert<T extends em_notifikasi_readUpsertArgs>(args: SelectSubset<T, em_notifikasi_readUpsertArgs<ExtArgs>>): Prisma__em_notifikasi_readClient<$Result.GetResult<Prisma.$em_notifikasi_readPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_notifikasi_reads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasi_readCountArgs} args - Arguments to filter Em_notifikasi_reads to count.
     * @example
     * // Count the number of Em_notifikasi_reads
     * const count = await prisma.em_notifikasi_read.count({
     *   where: {
     *     // ... the filter for the Em_notifikasi_reads we want to count
     *   }
     * })
    **/
    count<T extends em_notifikasi_readCountArgs>(
      args?: Subset<T, em_notifikasi_readCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_notifikasi_readCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_notifikasi_read.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_notifikasi_readAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_notifikasi_readAggregateArgs>(args: Subset<T, Em_notifikasi_readAggregateArgs>): Prisma.PrismaPromise<GetEm_notifikasi_readAggregateType<T>>

    /**
     * Group by Em_notifikasi_read.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_notifikasi_readGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_notifikasi_readGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_notifikasi_readGroupByArgs['orderBy'] }
        : { orderBy?: em_notifikasi_readGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_notifikasi_readGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_notifikasi_readGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_notifikasi_read model
   */
  readonly fields: em_notifikasi_readFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_notifikasi_read.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_notifikasi_readClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_notifikasi_read model
   */
  interface em_notifikasi_readFieldRefs {
    readonly ReadId: FieldRef<"em_notifikasi_read", 'Int'>
    readonly NotifyId: FieldRef<"em_notifikasi_read", 'Int'>
    readonly UserId: FieldRef<"em_notifikasi_read", 'Int'>
    readonly ReadDate: FieldRef<"em_notifikasi_read", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_notifikasi_read findUnique
   */
  export type em_notifikasi_readFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi_read to fetch.
     */
    where: em_notifikasi_readWhereUniqueInput
  }

  /**
   * em_notifikasi_read findUniqueOrThrow
   */
  export type em_notifikasi_readFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi_read to fetch.
     */
    where: em_notifikasi_readWhereUniqueInput
  }

  /**
   * em_notifikasi_read findFirst
   */
  export type em_notifikasi_readFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi_read to fetch.
     */
    where?: em_notifikasi_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasi_reads to fetch.
     */
    orderBy?: em_notifikasi_readOrderByWithRelationInput | em_notifikasi_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_notifikasi_reads.
     */
    cursor?: em_notifikasi_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasi_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasi_reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_notifikasi_reads.
     */
    distinct?: Em_notifikasi_readScalarFieldEnum | Em_notifikasi_readScalarFieldEnum[]
  }

  /**
   * em_notifikasi_read findFirstOrThrow
   */
  export type em_notifikasi_readFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi_read to fetch.
     */
    where?: em_notifikasi_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasi_reads to fetch.
     */
    orderBy?: em_notifikasi_readOrderByWithRelationInput | em_notifikasi_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_notifikasi_reads.
     */
    cursor?: em_notifikasi_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasi_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasi_reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_notifikasi_reads.
     */
    distinct?: Em_notifikasi_readScalarFieldEnum | Em_notifikasi_readScalarFieldEnum[]
  }

  /**
   * em_notifikasi_read findMany
   */
  export type em_notifikasi_readFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * Filter, which em_notifikasi_reads to fetch.
     */
    where?: em_notifikasi_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_notifikasi_reads to fetch.
     */
    orderBy?: em_notifikasi_readOrderByWithRelationInput | em_notifikasi_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_notifikasi_reads.
     */
    cursor?: em_notifikasi_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_notifikasi_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_notifikasi_reads.
     */
    skip?: number
    distinct?: Em_notifikasi_readScalarFieldEnum | Em_notifikasi_readScalarFieldEnum[]
  }

  /**
   * em_notifikasi_read create
   */
  export type em_notifikasi_readCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * The data needed to create a em_notifikasi_read.
     */
    data?: XOR<em_notifikasi_readCreateInput, em_notifikasi_readUncheckedCreateInput>
  }

  /**
   * em_notifikasi_read createMany
   */
  export type em_notifikasi_readCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_notifikasi_reads.
     */
    data: em_notifikasi_readCreateManyInput | em_notifikasi_readCreateManyInput[]
  }

  /**
   * em_notifikasi_read update
   */
  export type em_notifikasi_readUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * The data needed to update a em_notifikasi_read.
     */
    data: XOR<em_notifikasi_readUpdateInput, em_notifikasi_readUncheckedUpdateInput>
    /**
     * Choose, which em_notifikasi_read to update.
     */
    where: em_notifikasi_readWhereUniqueInput
  }

  /**
   * em_notifikasi_read updateMany
   */
  export type em_notifikasi_readUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_notifikasi_reads.
     */
    data: XOR<em_notifikasi_readUpdateManyMutationInput, em_notifikasi_readUncheckedUpdateManyInput>
    /**
     * Filter which em_notifikasi_reads to update
     */
    where?: em_notifikasi_readWhereInput
    /**
     * Limit how many em_notifikasi_reads to update.
     */
    limit?: number
  }

  /**
   * em_notifikasi_read upsert
   */
  export type em_notifikasi_readUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * The filter to search for the em_notifikasi_read to update in case it exists.
     */
    where: em_notifikasi_readWhereUniqueInput
    /**
     * In case the em_notifikasi_read found by the `where` argument doesn't exist, create a new em_notifikasi_read with this data.
     */
    create: XOR<em_notifikasi_readCreateInput, em_notifikasi_readUncheckedCreateInput>
    /**
     * In case the em_notifikasi_read was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_notifikasi_readUpdateInput, em_notifikasi_readUncheckedUpdateInput>
  }

  /**
   * em_notifikasi_read delete
   */
  export type em_notifikasi_readDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
    /**
     * Filter which em_notifikasi_read to delete.
     */
    where: em_notifikasi_readWhereUniqueInput
  }

  /**
   * em_notifikasi_read deleteMany
   */
  export type em_notifikasi_readDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_notifikasi_reads to delete
     */
    where?: em_notifikasi_readWhereInput
    /**
     * Limit how many em_notifikasi_reads to delete.
     */
    limit?: number
  }

  /**
   * em_notifikasi_read without action
   */
  export type em_notifikasi_readDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_notifikasi_read
     */
    select?: em_notifikasi_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_notifikasi_read
     */
    omit?: em_notifikasi_readOmit<ExtArgs> | null
  }


  /**
   * Model em_onboarding
   */

  export type AggregateEm_onboarding = {
    _count: Em_onboardingCountAggregateOutputType | null
    _avg: Em_onboardingAvgAggregateOutputType | null
    _sum: Em_onboardingSumAggregateOutputType | null
    _min: Em_onboardingMinAggregateOutputType | null
    _max: Em_onboardingMaxAggregateOutputType | null
  }

  export type Em_onboardingAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    current_step: number | null
  }

  export type Em_onboardingSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    current_step: number | null
  }

  export type Em_onboardingMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    status: string | null
    current_step: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Em_onboardingMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    status: string | null
    current_step: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Em_onboardingCountAggregateOutputType = {
    id: number
    user_id: number
    status: number
    current_step: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Em_onboardingAvgAggregateInputType = {
    id?: true
    user_id?: true
    current_step?: true
  }

  export type Em_onboardingSumAggregateInputType = {
    id?: true
    user_id?: true
    current_step?: true
  }

  export type Em_onboardingMinAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
    current_step?: true
    created_at?: true
    updated_at?: true
  }

  export type Em_onboardingMaxAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
    current_step?: true
    created_at?: true
    updated_at?: true
  }

  export type Em_onboardingCountAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
    current_step?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Em_onboardingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_onboarding to aggregate.
     */
    where?: em_onboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_onboardings to fetch.
     */
    orderBy?: em_onboardingOrderByWithRelationInput | em_onboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_onboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_onboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_onboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_onboardings
    **/
    _count?: true | Em_onboardingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_onboardingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_onboardingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_onboardingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_onboardingMaxAggregateInputType
  }

  export type GetEm_onboardingAggregateType<T extends Em_onboardingAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_onboarding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_onboarding[P]>
      : GetScalarType<T[P], AggregateEm_onboarding[P]>
  }




  export type em_onboardingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_onboardingWhereInput
    orderBy?: em_onboardingOrderByWithAggregationInput | em_onboardingOrderByWithAggregationInput[]
    by: Em_onboardingScalarFieldEnum[] | Em_onboardingScalarFieldEnum
    having?: em_onboardingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_onboardingCountAggregateInputType | true
    _avg?: Em_onboardingAvgAggregateInputType
    _sum?: Em_onboardingSumAggregateInputType
    _min?: Em_onboardingMinAggregateInputType
    _max?: Em_onboardingMaxAggregateInputType
  }

  export type Em_onboardingGroupByOutputType = {
    id: number
    user_id: number
    status: string | null
    current_step: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Em_onboardingCountAggregateOutputType | null
    _avg: Em_onboardingAvgAggregateOutputType | null
    _sum: Em_onboardingSumAggregateOutputType | null
    _min: Em_onboardingMinAggregateOutputType | null
    _max: Em_onboardingMaxAggregateOutputType | null
  }

  type GetEm_onboardingGroupByPayload<T extends em_onboardingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_onboardingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_onboardingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_onboardingGroupByOutputType[P]>
            : GetScalarType<T[P], Em_onboardingGroupByOutputType[P]>
        }
      >
    >


  export type em_onboardingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    status?: boolean
    current_step?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["em_onboarding"]>



  export type em_onboardingSelectScalar = {
    id?: boolean
    user_id?: boolean
    status?: boolean
    current_step?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type em_onboardingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "status" | "current_step" | "created_at" | "updated_at", ExtArgs["result"]["em_onboarding"]>

  export type $em_onboardingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_onboarding"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      status: string | null
      current_step: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["em_onboarding"]>
    composites: {}
  }

  type em_onboardingGetPayload<S extends boolean | null | undefined | em_onboardingDefaultArgs> = $Result.GetResult<Prisma.$em_onboardingPayload, S>

  type em_onboardingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_onboardingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_onboardingCountAggregateInputType | true
    }

  export interface em_onboardingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_onboarding'], meta: { name: 'em_onboarding' } }
    /**
     * Find zero or one Em_onboarding that matches the filter.
     * @param {em_onboardingFindUniqueArgs} args - Arguments to find a Em_onboarding
     * @example
     * // Get one Em_onboarding
     * const em_onboarding = await prisma.em_onboarding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_onboardingFindUniqueArgs>(args: SelectSubset<T, em_onboardingFindUniqueArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_onboarding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_onboardingFindUniqueOrThrowArgs} args - Arguments to find a Em_onboarding
     * @example
     * // Get one Em_onboarding
     * const em_onboarding = await prisma.em_onboarding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_onboardingFindUniqueOrThrowArgs>(args: SelectSubset<T, em_onboardingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_onboarding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_onboardingFindFirstArgs} args - Arguments to find a Em_onboarding
     * @example
     * // Get one Em_onboarding
     * const em_onboarding = await prisma.em_onboarding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_onboardingFindFirstArgs>(args?: SelectSubset<T, em_onboardingFindFirstArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_onboarding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_onboardingFindFirstOrThrowArgs} args - Arguments to find a Em_onboarding
     * @example
     * // Get one Em_onboarding
     * const em_onboarding = await prisma.em_onboarding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_onboardingFindFirstOrThrowArgs>(args?: SelectSubset<T, em_onboardingFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_onboardings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_onboardingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_onboardings
     * const em_onboardings = await prisma.em_onboarding.findMany()
     * 
     * // Get first 10 Em_onboardings
     * const em_onboardings = await prisma.em_onboarding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_onboardingWithIdOnly = await prisma.em_onboarding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_onboardingFindManyArgs>(args?: SelectSubset<T, em_onboardingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_onboarding.
     * @param {em_onboardingCreateArgs} args - Arguments to create a Em_onboarding.
     * @example
     * // Create one Em_onboarding
     * const Em_onboarding = await prisma.em_onboarding.create({
     *   data: {
     *     // ... data to create a Em_onboarding
     *   }
     * })
     * 
     */
    create<T extends em_onboardingCreateArgs>(args: SelectSubset<T, em_onboardingCreateArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_onboardings.
     * @param {em_onboardingCreateManyArgs} args - Arguments to create many Em_onboardings.
     * @example
     * // Create many Em_onboardings
     * const em_onboarding = await prisma.em_onboarding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_onboardingCreateManyArgs>(args?: SelectSubset<T, em_onboardingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_onboarding.
     * @param {em_onboardingDeleteArgs} args - Arguments to delete one Em_onboarding.
     * @example
     * // Delete one Em_onboarding
     * const Em_onboarding = await prisma.em_onboarding.delete({
     *   where: {
     *     // ... filter to delete one Em_onboarding
     *   }
     * })
     * 
     */
    delete<T extends em_onboardingDeleteArgs>(args: SelectSubset<T, em_onboardingDeleteArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_onboarding.
     * @param {em_onboardingUpdateArgs} args - Arguments to update one Em_onboarding.
     * @example
     * // Update one Em_onboarding
     * const em_onboarding = await prisma.em_onboarding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_onboardingUpdateArgs>(args: SelectSubset<T, em_onboardingUpdateArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_onboardings.
     * @param {em_onboardingDeleteManyArgs} args - Arguments to filter Em_onboardings to delete.
     * @example
     * // Delete a few Em_onboardings
     * const { count } = await prisma.em_onboarding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_onboardingDeleteManyArgs>(args?: SelectSubset<T, em_onboardingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_onboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_onboardingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_onboardings
     * const em_onboarding = await prisma.em_onboarding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_onboardingUpdateManyArgs>(args: SelectSubset<T, em_onboardingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_onboarding.
     * @param {em_onboardingUpsertArgs} args - Arguments to update or create a Em_onboarding.
     * @example
     * // Update or create a Em_onboarding
     * const em_onboarding = await prisma.em_onboarding.upsert({
     *   create: {
     *     // ... data to create a Em_onboarding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_onboarding we want to update
     *   }
     * })
     */
    upsert<T extends em_onboardingUpsertArgs>(args: SelectSubset<T, em_onboardingUpsertArgs<ExtArgs>>): Prisma__em_onboardingClient<$Result.GetResult<Prisma.$em_onboardingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_onboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_onboardingCountArgs} args - Arguments to filter Em_onboardings to count.
     * @example
     * // Count the number of Em_onboardings
     * const count = await prisma.em_onboarding.count({
     *   where: {
     *     // ... the filter for the Em_onboardings we want to count
     *   }
     * })
    **/
    count<T extends em_onboardingCountArgs>(
      args?: Subset<T, em_onboardingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_onboardingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_onboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_onboardingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_onboardingAggregateArgs>(args: Subset<T, Em_onboardingAggregateArgs>): Prisma.PrismaPromise<GetEm_onboardingAggregateType<T>>

    /**
     * Group by Em_onboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_onboardingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_onboardingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_onboardingGroupByArgs['orderBy'] }
        : { orderBy?: em_onboardingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_onboardingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_onboardingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_onboarding model
   */
  readonly fields: em_onboardingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_onboarding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_onboardingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_onboarding model
   */
  interface em_onboardingFieldRefs {
    readonly id: FieldRef<"em_onboarding", 'Int'>
    readonly user_id: FieldRef<"em_onboarding", 'Int'>
    readonly status: FieldRef<"em_onboarding", 'String'>
    readonly current_step: FieldRef<"em_onboarding", 'Int'>
    readonly created_at: FieldRef<"em_onboarding", 'DateTime'>
    readonly updated_at: FieldRef<"em_onboarding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_onboarding findUnique
   */
  export type em_onboardingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * Filter, which em_onboarding to fetch.
     */
    where: em_onboardingWhereUniqueInput
  }

  /**
   * em_onboarding findUniqueOrThrow
   */
  export type em_onboardingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * Filter, which em_onboarding to fetch.
     */
    where: em_onboardingWhereUniqueInput
  }

  /**
   * em_onboarding findFirst
   */
  export type em_onboardingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * Filter, which em_onboarding to fetch.
     */
    where?: em_onboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_onboardings to fetch.
     */
    orderBy?: em_onboardingOrderByWithRelationInput | em_onboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_onboardings.
     */
    cursor?: em_onboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_onboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_onboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_onboardings.
     */
    distinct?: Em_onboardingScalarFieldEnum | Em_onboardingScalarFieldEnum[]
  }

  /**
   * em_onboarding findFirstOrThrow
   */
  export type em_onboardingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * Filter, which em_onboarding to fetch.
     */
    where?: em_onboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_onboardings to fetch.
     */
    orderBy?: em_onboardingOrderByWithRelationInput | em_onboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_onboardings.
     */
    cursor?: em_onboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_onboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_onboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_onboardings.
     */
    distinct?: Em_onboardingScalarFieldEnum | Em_onboardingScalarFieldEnum[]
  }

  /**
   * em_onboarding findMany
   */
  export type em_onboardingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * Filter, which em_onboardings to fetch.
     */
    where?: em_onboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_onboardings to fetch.
     */
    orderBy?: em_onboardingOrderByWithRelationInput | em_onboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_onboardings.
     */
    cursor?: em_onboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_onboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_onboardings.
     */
    skip?: number
    distinct?: Em_onboardingScalarFieldEnum | Em_onboardingScalarFieldEnum[]
  }

  /**
   * em_onboarding create
   */
  export type em_onboardingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * The data needed to create a em_onboarding.
     */
    data: XOR<em_onboardingCreateInput, em_onboardingUncheckedCreateInput>
  }

  /**
   * em_onboarding createMany
   */
  export type em_onboardingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_onboardings.
     */
    data: em_onboardingCreateManyInput | em_onboardingCreateManyInput[]
  }

  /**
   * em_onboarding update
   */
  export type em_onboardingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * The data needed to update a em_onboarding.
     */
    data: XOR<em_onboardingUpdateInput, em_onboardingUncheckedUpdateInput>
    /**
     * Choose, which em_onboarding to update.
     */
    where: em_onboardingWhereUniqueInput
  }

  /**
   * em_onboarding updateMany
   */
  export type em_onboardingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_onboardings.
     */
    data: XOR<em_onboardingUpdateManyMutationInput, em_onboardingUncheckedUpdateManyInput>
    /**
     * Filter which em_onboardings to update
     */
    where?: em_onboardingWhereInput
    /**
     * Limit how many em_onboardings to update.
     */
    limit?: number
  }

  /**
   * em_onboarding upsert
   */
  export type em_onboardingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * The filter to search for the em_onboarding to update in case it exists.
     */
    where: em_onboardingWhereUniqueInput
    /**
     * In case the em_onboarding found by the `where` argument doesn't exist, create a new em_onboarding with this data.
     */
    create: XOR<em_onboardingCreateInput, em_onboardingUncheckedCreateInput>
    /**
     * In case the em_onboarding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_onboardingUpdateInput, em_onboardingUncheckedUpdateInput>
  }

  /**
   * em_onboarding delete
   */
  export type em_onboardingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
    /**
     * Filter which em_onboarding to delete.
     */
    where: em_onboardingWhereUniqueInput
  }

  /**
   * em_onboarding deleteMany
   */
  export type em_onboardingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_onboardings to delete
     */
    where?: em_onboardingWhereInput
    /**
     * Limit how many em_onboardings to delete.
     */
    limit?: number
  }

  /**
   * em_onboarding without action
   */
  export type em_onboardingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_onboarding
     */
    select?: em_onboardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_onboarding
     */
    omit?: em_onboardingOmit<ExtArgs> | null
  }


  /**
   * Model em_pilar
   */

  export type AggregateEm_pilar = {
    _count: Em_pilarCountAggregateOutputType | null
    _avg: Em_pilarAvgAggregateOutputType | null
    _sum: Em_pilarSumAggregateOutputType | null
    _min: Em_pilarMinAggregateOutputType | null
    _max: Em_pilarMaxAggregateOutputType | null
  }

  export type Em_pilarAvgAggregateOutputType = {
    id: number | null
    pic: number | null
  }

  export type Em_pilarSumAggregateOutputType = {
    id: number | null
    pic: number | null
  }

  export type Em_pilarMinAggregateOutputType = {
    id: number | null
    pilar_name: string | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
  }

  export type Em_pilarMaxAggregateOutputType = {
    id: number | null
    pilar_name: string | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
  }

  export type Em_pilarCountAggregateOutputType = {
    id: number
    pilar_name: number
    status: number
    add_by: number
    created_at: number
    lastupdate: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    description: number
    pic: number
    _all: number
  }


  export type Em_pilarAvgAggregateInputType = {
    id?: true
    pic?: true
  }

  export type Em_pilarSumAggregateInputType = {
    id?: true
    pic?: true
  }

  export type Em_pilarMinAggregateInputType = {
    id?: true
    pilar_name?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
  }

  export type Em_pilarMaxAggregateInputType = {
    id?: true
    pilar_name?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
  }

  export type Em_pilarCountAggregateInputType = {
    id?: true
    pilar_name?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
    _all?: true
  }

  export type Em_pilarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_pilar to aggregate.
     */
    where?: em_pilarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_pilars to fetch.
     */
    orderBy?: em_pilarOrderByWithRelationInput | em_pilarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_pilarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_pilars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_pilars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_pilars
    **/
    _count?: true | Em_pilarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_pilarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_pilarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_pilarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_pilarMaxAggregateInputType
  }

  export type GetEm_pilarAggregateType<T extends Em_pilarAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_pilar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_pilar[P]>
      : GetScalarType<T[P], AggregateEm_pilar[P]>
  }




  export type em_pilarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_pilarWhereInput
    orderBy?: em_pilarOrderByWithAggregationInput | em_pilarOrderByWithAggregationInput[]
    by: Em_pilarScalarFieldEnum[] | Em_pilarScalarFieldEnum
    having?: em_pilarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_pilarCountAggregateInputType | true
    _avg?: Em_pilarAvgAggregateInputType
    _sum?: Em_pilarSumAggregateInputType
    _min?: Em_pilarMinAggregateInputType
    _max?: Em_pilarMaxAggregateInputType
  }

  export type Em_pilarGroupByOutputType = {
    id: number
    pilar_name: string
    status: string
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
    _count: Em_pilarCountAggregateOutputType | null
    _avg: Em_pilarAvgAggregateOutputType | null
    _sum: Em_pilarSumAggregateOutputType | null
    _min: Em_pilarMinAggregateOutputType | null
    _max: Em_pilarMaxAggregateOutputType | null
  }

  type GetEm_pilarGroupByPayload<T extends em_pilarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_pilarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_pilarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_pilarGroupByOutputType[P]>
            : GetScalarType<T[P], Em_pilarGroupByOutputType[P]>
        }
      >
    >


  export type em_pilarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pilar_name?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    description?: boolean
    pic?: boolean
  }, ExtArgs["result"]["em_pilar"]>



  export type em_pilarSelectScalar = {
    id?: boolean
    pilar_name?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    description?: boolean
    pic?: boolean
  }

  export type em_pilarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pilar_name" | "status" | "add_by" | "created_at" | "lastupdate" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy" | "description" | "pic", ExtArgs["result"]["em_pilar"]>

  export type $em_pilarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_pilar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pilar_name: string
      status: string
      add_by: string | null
      created_at: Date | null
      lastupdate: Date | null
      createdAt: Date | null
      createdBy: string | null
      updatedAt: Date | null
      updatedBy: string | null
      isDeleted: boolean | null
      deletedAt: Date | null
      deletedBy: string | null
      description: string | null
      pic: number | null
    }, ExtArgs["result"]["em_pilar"]>
    composites: {}
  }

  type em_pilarGetPayload<S extends boolean | null | undefined | em_pilarDefaultArgs> = $Result.GetResult<Prisma.$em_pilarPayload, S>

  type em_pilarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_pilarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_pilarCountAggregateInputType | true
    }

  export interface em_pilarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_pilar'], meta: { name: 'em_pilar' } }
    /**
     * Find zero or one Em_pilar that matches the filter.
     * @param {em_pilarFindUniqueArgs} args - Arguments to find a Em_pilar
     * @example
     * // Get one Em_pilar
     * const em_pilar = await prisma.em_pilar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_pilarFindUniqueArgs>(args: SelectSubset<T, em_pilarFindUniqueArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_pilar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_pilarFindUniqueOrThrowArgs} args - Arguments to find a Em_pilar
     * @example
     * // Get one Em_pilar
     * const em_pilar = await prisma.em_pilar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_pilarFindUniqueOrThrowArgs>(args: SelectSubset<T, em_pilarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_pilar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_pilarFindFirstArgs} args - Arguments to find a Em_pilar
     * @example
     * // Get one Em_pilar
     * const em_pilar = await prisma.em_pilar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_pilarFindFirstArgs>(args?: SelectSubset<T, em_pilarFindFirstArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_pilar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_pilarFindFirstOrThrowArgs} args - Arguments to find a Em_pilar
     * @example
     * // Get one Em_pilar
     * const em_pilar = await prisma.em_pilar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_pilarFindFirstOrThrowArgs>(args?: SelectSubset<T, em_pilarFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_pilars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_pilarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_pilars
     * const em_pilars = await prisma.em_pilar.findMany()
     * 
     * // Get first 10 Em_pilars
     * const em_pilars = await prisma.em_pilar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_pilarWithIdOnly = await prisma.em_pilar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_pilarFindManyArgs>(args?: SelectSubset<T, em_pilarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_pilar.
     * @param {em_pilarCreateArgs} args - Arguments to create a Em_pilar.
     * @example
     * // Create one Em_pilar
     * const Em_pilar = await prisma.em_pilar.create({
     *   data: {
     *     // ... data to create a Em_pilar
     *   }
     * })
     * 
     */
    create<T extends em_pilarCreateArgs>(args: SelectSubset<T, em_pilarCreateArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_pilars.
     * @param {em_pilarCreateManyArgs} args - Arguments to create many Em_pilars.
     * @example
     * // Create many Em_pilars
     * const em_pilar = await prisma.em_pilar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_pilarCreateManyArgs>(args?: SelectSubset<T, em_pilarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_pilar.
     * @param {em_pilarDeleteArgs} args - Arguments to delete one Em_pilar.
     * @example
     * // Delete one Em_pilar
     * const Em_pilar = await prisma.em_pilar.delete({
     *   where: {
     *     // ... filter to delete one Em_pilar
     *   }
     * })
     * 
     */
    delete<T extends em_pilarDeleteArgs>(args: SelectSubset<T, em_pilarDeleteArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_pilar.
     * @param {em_pilarUpdateArgs} args - Arguments to update one Em_pilar.
     * @example
     * // Update one Em_pilar
     * const em_pilar = await prisma.em_pilar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_pilarUpdateArgs>(args: SelectSubset<T, em_pilarUpdateArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_pilars.
     * @param {em_pilarDeleteManyArgs} args - Arguments to filter Em_pilars to delete.
     * @example
     * // Delete a few Em_pilars
     * const { count } = await prisma.em_pilar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_pilarDeleteManyArgs>(args?: SelectSubset<T, em_pilarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_pilars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_pilarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_pilars
     * const em_pilar = await prisma.em_pilar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_pilarUpdateManyArgs>(args: SelectSubset<T, em_pilarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_pilar.
     * @param {em_pilarUpsertArgs} args - Arguments to update or create a Em_pilar.
     * @example
     * // Update or create a Em_pilar
     * const em_pilar = await prisma.em_pilar.upsert({
     *   create: {
     *     // ... data to create a Em_pilar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_pilar we want to update
     *   }
     * })
     */
    upsert<T extends em_pilarUpsertArgs>(args: SelectSubset<T, em_pilarUpsertArgs<ExtArgs>>): Prisma__em_pilarClient<$Result.GetResult<Prisma.$em_pilarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_pilars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_pilarCountArgs} args - Arguments to filter Em_pilars to count.
     * @example
     * // Count the number of Em_pilars
     * const count = await prisma.em_pilar.count({
     *   where: {
     *     // ... the filter for the Em_pilars we want to count
     *   }
     * })
    **/
    count<T extends em_pilarCountArgs>(
      args?: Subset<T, em_pilarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_pilarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_pilar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_pilarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_pilarAggregateArgs>(args: Subset<T, Em_pilarAggregateArgs>): Prisma.PrismaPromise<GetEm_pilarAggregateType<T>>

    /**
     * Group by Em_pilar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_pilarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_pilarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_pilarGroupByArgs['orderBy'] }
        : { orderBy?: em_pilarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_pilarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_pilarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_pilar model
   */
  readonly fields: em_pilarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_pilar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_pilarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_pilar model
   */
  interface em_pilarFieldRefs {
    readonly id: FieldRef<"em_pilar", 'Int'>
    readonly pilar_name: FieldRef<"em_pilar", 'String'>
    readonly status: FieldRef<"em_pilar", 'String'>
    readonly add_by: FieldRef<"em_pilar", 'String'>
    readonly created_at: FieldRef<"em_pilar", 'DateTime'>
    readonly lastupdate: FieldRef<"em_pilar", 'DateTime'>
    readonly createdAt: FieldRef<"em_pilar", 'DateTime'>
    readonly createdBy: FieldRef<"em_pilar", 'String'>
    readonly updatedAt: FieldRef<"em_pilar", 'DateTime'>
    readonly updatedBy: FieldRef<"em_pilar", 'String'>
    readonly isDeleted: FieldRef<"em_pilar", 'Boolean'>
    readonly deletedAt: FieldRef<"em_pilar", 'DateTime'>
    readonly deletedBy: FieldRef<"em_pilar", 'String'>
    readonly description: FieldRef<"em_pilar", 'String'>
    readonly pic: FieldRef<"em_pilar", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_pilar findUnique
   */
  export type em_pilarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * Filter, which em_pilar to fetch.
     */
    where: em_pilarWhereUniqueInput
  }

  /**
   * em_pilar findUniqueOrThrow
   */
  export type em_pilarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * Filter, which em_pilar to fetch.
     */
    where: em_pilarWhereUniqueInput
  }

  /**
   * em_pilar findFirst
   */
  export type em_pilarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * Filter, which em_pilar to fetch.
     */
    where?: em_pilarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_pilars to fetch.
     */
    orderBy?: em_pilarOrderByWithRelationInput | em_pilarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_pilars.
     */
    cursor?: em_pilarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_pilars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_pilars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_pilars.
     */
    distinct?: Em_pilarScalarFieldEnum | Em_pilarScalarFieldEnum[]
  }

  /**
   * em_pilar findFirstOrThrow
   */
  export type em_pilarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * Filter, which em_pilar to fetch.
     */
    where?: em_pilarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_pilars to fetch.
     */
    orderBy?: em_pilarOrderByWithRelationInput | em_pilarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_pilars.
     */
    cursor?: em_pilarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_pilars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_pilars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_pilars.
     */
    distinct?: Em_pilarScalarFieldEnum | Em_pilarScalarFieldEnum[]
  }

  /**
   * em_pilar findMany
   */
  export type em_pilarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * Filter, which em_pilars to fetch.
     */
    where?: em_pilarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_pilars to fetch.
     */
    orderBy?: em_pilarOrderByWithRelationInput | em_pilarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_pilars.
     */
    cursor?: em_pilarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_pilars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_pilars.
     */
    skip?: number
    distinct?: Em_pilarScalarFieldEnum | Em_pilarScalarFieldEnum[]
  }

  /**
   * em_pilar create
   */
  export type em_pilarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * The data needed to create a em_pilar.
     */
    data: XOR<em_pilarCreateInput, em_pilarUncheckedCreateInput>
  }

  /**
   * em_pilar createMany
   */
  export type em_pilarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_pilars.
     */
    data: em_pilarCreateManyInput | em_pilarCreateManyInput[]
  }

  /**
   * em_pilar update
   */
  export type em_pilarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * The data needed to update a em_pilar.
     */
    data: XOR<em_pilarUpdateInput, em_pilarUncheckedUpdateInput>
    /**
     * Choose, which em_pilar to update.
     */
    where: em_pilarWhereUniqueInput
  }

  /**
   * em_pilar updateMany
   */
  export type em_pilarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_pilars.
     */
    data: XOR<em_pilarUpdateManyMutationInput, em_pilarUncheckedUpdateManyInput>
    /**
     * Filter which em_pilars to update
     */
    where?: em_pilarWhereInput
    /**
     * Limit how many em_pilars to update.
     */
    limit?: number
  }

  /**
   * em_pilar upsert
   */
  export type em_pilarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * The filter to search for the em_pilar to update in case it exists.
     */
    where: em_pilarWhereUniqueInput
    /**
     * In case the em_pilar found by the `where` argument doesn't exist, create a new em_pilar with this data.
     */
    create: XOR<em_pilarCreateInput, em_pilarUncheckedCreateInput>
    /**
     * In case the em_pilar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_pilarUpdateInput, em_pilarUncheckedUpdateInput>
  }

  /**
   * em_pilar delete
   */
  export type em_pilarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
    /**
     * Filter which em_pilar to delete.
     */
    where: em_pilarWhereUniqueInput
  }

  /**
   * em_pilar deleteMany
   */
  export type em_pilarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_pilars to delete
     */
    where?: em_pilarWhereInput
    /**
     * Limit how many em_pilars to delete.
     */
    limit?: number
  }

  /**
   * em_pilar without action
   */
  export type em_pilarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_pilar
     */
    select?: em_pilarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_pilar
     */
    omit?: em_pilarOmit<ExtArgs> | null
  }


  /**
   * Model em_profesi
   */

  export type AggregateEm_profesi = {
    _count: Em_profesiCountAggregateOutputType | null
    _avg: Em_profesiAvgAggregateOutputType | null
    _sum: Em_profesiSumAggregateOutputType | null
    _min: Em_profesiMinAggregateOutputType | null
    _max: Em_profesiMaxAggregateOutputType | null
  }

  export type Em_profesiAvgAggregateOutputType = {
    profesi_id: number | null
  }

  export type Em_profesiSumAggregateOutputType = {
    profesi_id: number | null
  }

  export type Em_profesiMinAggregateOutputType = {
    profesi_id: number | null
    profesi_name: string | null
    status: string | null
    created_date: Date | null
    last_update: Date | null
  }

  export type Em_profesiMaxAggregateOutputType = {
    profesi_id: number | null
    profesi_name: string | null
    status: string | null
    created_date: Date | null
    last_update: Date | null
  }

  export type Em_profesiCountAggregateOutputType = {
    profesi_id: number
    profesi_name: number
    status: number
    created_date: number
    last_update: number
    _all: number
  }


  export type Em_profesiAvgAggregateInputType = {
    profesi_id?: true
  }

  export type Em_profesiSumAggregateInputType = {
    profesi_id?: true
  }

  export type Em_profesiMinAggregateInputType = {
    profesi_id?: true
    profesi_name?: true
    status?: true
    created_date?: true
    last_update?: true
  }

  export type Em_profesiMaxAggregateInputType = {
    profesi_id?: true
    profesi_name?: true
    status?: true
    created_date?: true
    last_update?: true
  }

  export type Em_profesiCountAggregateInputType = {
    profesi_id?: true
    profesi_name?: true
    status?: true
    created_date?: true
    last_update?: true
    _all?: true
  }

  export type Em_profesiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_profesi to aggregate.
     */
    where?: em_profesiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_profesis to fetch.
     */
    orderBy?: em_profesiOrderByWithRelationInput | em_profesiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_profesiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_profesis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_profesis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_profesis
    **/
    _count?: true | Em_profesiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_profesiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_profesiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_profesiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_profesiMaxAggregateInputType
  }

  export type GetEm_profesiAggregateType<T extends Em_profesiAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_profesi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_profesi[P]>
      : GetScalarType<T[P], AggregateEm_profesi[P]>
  }




  export type em_profesiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_profesiWhereInput
    orderBy?: em_profesiOrderByWithAggregationInput | em_profesiOrderByWithAggregationInput[]
    by: Em_profesiScalarFieldEnum[] | Em_profesiScalarFieldEnum
    having?: em_profesiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_profesiCountAggregateInputType | true
    _avg?: Em_profesiAvgAggregateInputType
    _sum?: Em_profesiSumAggregateInputType
    _min?: Em_profesiMinAggregateInputType
    _max?: Em_profesiMaxAggregateInputType
  }

  export type Em_profesiGroupByOutputType = {
    profesi_id: number
    profesi_name: string | null
    status: string | null
    created_date: Date | null
    last_update: Date | null
    _count: Em_profesiCountAggregateOutputType | null
    _avg: Em_profesiAvgAggregateOutputType | null
    _sum: Em_profesiSumAggregateOutputType | null
    _min: Em_profesiMinAggregateOutputType | null
    _max: Em_profesiMaxAggregateOutputType | null
  }

  type GetEm_profesiGroupByPayload<T extends em_profesiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_profesiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_profesiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_profesiGroupByOutputType[P]>
            : GetScalarType<T[P], Em_profesiGroupByOutputType[P]>
        }
      >
    >


  export type em_profesiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profesi_id?: boolean
    profesi_name?: boolean
    status?: boolean
    created_date?: boolean
    last_update?: boolean
  }, ExtArgs["result"]["em_profesi"]>



  export type em_profesiSelectScalar = {
    profesi_id?: boolean
    profesi_name?: boolean
    status?: boolean
    created_date?: boolean
    last_update?: boolean
  }

  export type em_profesiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profesi_id" | "profesi_name" | "status" | "created_date" | "last_update", ExtArgs["result"]["em_profesi"]>

  export type $em_profesiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_profesi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      profesi_id: number
      profesi_name: string | null
      status: string | null
      created_date: Date | null
      last_update: Date | null
    }, ExtArgs["result"]["em_profesi"]>
    composites: {}
  }

  type em_profesiGetPayload<S extends boolean | null | undefined | em_profesiDefaultArgs> = $Result.GetResult<Prisma.$em_profesiPayload, S>

  type em_profesiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_profesiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_profesiCountAggregateInputType | true
    }

  export interface em_profesiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_profesi'], meta: { name: 'em_profesi' } }
    /**
     * Find zero or one Em_profesi that matches the filter.
     * @param {em_profesiFindUniqueArgs} args - Arguments to find a Em_profesi
     * @example
     * // Get one Em_profesi
     * const em_profesi = await prisma.em_profesi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_profesiFindUniqueArgs>(args: SelectSubset<T, em_profesiFindUniqueArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_profesi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_profesiFindUniqueOrThrowArgs} args - Arguments to find a Em_profesi
     * @example
     * // Get one Em_profesi
     * const em_profesi = await prisma.em_profesi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_profesiFindUniqueOrThrowArgs>(args: SelectSubset<T, em_profesiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_profesi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_profesiFindFirstArgs} args - Arguments to find a Em_profesi
     * @example
     * // Get one Em_profesi
     * const em_profesi = await prisma.em_profesi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_profesiFindFirstArgs>(args?: SelectSubset<T, em_profesiFindFirstArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_profesi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_profesiFindFirstOrThrowArgs} args - Arguments to find a Em_profesi
     * @example
     * // Get one Em_profesi
     * const em_profesi = await prisma.em_profesi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_profesiFindFirstOrThrowArgs>(args?: SelectSubset<T, em_profesiFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_profesis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_profesiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_profesis
     * const em_profesis = await prisma.em_profesi.findMany()
     * 
     * // Get first 10 Em_profesis
     * const em_profesis = await prisma.em_profesi.findMany({ take: 10 })
     * 
     * // Only select the `profesi_id`
     * const em_profesiWithProfesi_idOnly = await prisma.em_profesi.findMany({ select: { profesi_id: true } })
     * 
     */
    findMany<T extends em_profesiFindManyArgs>(args?: SelectSubset<T, em_profesiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_profesi.
     * @param {em_profesiCreateArgs} args - Arguments to create a Em_profesi.
     * @example
     * // Create one Em_profesi
     * const Em_profesi = await prisma.em_profesi.create({
     *   data: {
     *     // ... data to create a Em_profesi
     *   }
     * })
     * 
     */
    create<T extends em_profesiCreateArgs>(args: SelectSubset<T, em_profesiCreateArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_profesis.
     * @param {em_profesiCreateManyArgs} args - Arguments to create many Em_profesis.
     * @example
     * // Create many Em_profesis
     * const em_profesi = await prisma.em_profesi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_profesiCreateManyArgs>(args?: SelectSubset<T, em_profesiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_profesi.
     * @param {em_profesiDeleteArgs} args - Arguments to delete one Em_profesi.
     * @example
     * // Delete one Em_profesi
     * const Em_profesi = await prisma.em_profesi.delete({
     *   where: {
     *     // ... filter to delete one Em_profesi
     *   }
     * })
     * 
     */
    delete<T extends em_profesiDeleteArgs>(args: SelectSubset<T, em_profesiDeleteArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_profesi.
     * @param {em_profesiUpdateArgs} args - Arguments to update one Em_profesi.
     * @example
     * // Update one Em_profesi
     * const em_profesi = await prisma.em_profesi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_profesiUpdateArgs>(args: SelectSubset<T, em_profesiUpdateArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_profesis.
     * @param {em_profesiDeleteManyArgs} args - Arguments to filter Em_profesis to delete.
     * @example
     * // Delete a few Em_profesis
     * const { count } = await prisma.em_profesi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_profesiDeleteManyArgs>(args?: SelectSubset<T, em_profesiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_profesis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_profesiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_profesis
     * const em_profesi = await prisma.em_profesi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_profesiUpdateManyArgs>(args: SelectSubset<T, em_profesiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_profesi.
     * @param {em_profesiUpsertArgs} args - Arguments to update or create a Em_profesi.
     * @example
     * // Update or create a Em_profesi
     * const em_profesi = await prisma.em_profesi.upsert({
     *   create: {
     *     // ... data to create a Em_profesi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_profesi we want to update
     *   }
     * })
     */
    upsert<T extends em_profesiUpsertArgs>(args: SelectSubset<T, em_profesiUpsertArgs<ExtArgs>>): Prisma__em_profesiClient<$Result.GetResult<Prisma.$em_profesiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_profesis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_profesiCountArgs} args - Arguments to filter Em_profesis to count.
     * @example
     * // Count the number of Em_profesis
     * const count = await prisma.em_profesi.count({
     *   where: {
     *     // ... the filter for the Em_profesis we want to count
     *   }
     * })
    **/
    count<T extends em_profesiCountArgs>(
      args?: Subset<T, em_profesiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_profesiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_profesi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_profesiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_profesiAggregateArgs>(args: Subset<T, Em_profesiAggregateArgs>): Prisma.PrismaPromise<GetEm_profesiAggregateType<T>>

    /**
     * Group by Em_profesi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_profesiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_profesiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_profesiGroupByArgs['orderBy'] }
        : { orderBy?: em_profesiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_profesiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_profesiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_profesi model
   */
  readonly fields: em_profesiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_profesi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_profesiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_profesi model
   */
  interface em_profesiFieldRefs {
    readonly profesi_id: FieldRef<"em_profesi", 'Int'>
    readonly profesi_name: FieldRef<"em_profesi", 'String'>
    readonly status: FieldRef<"em_profesi", 'String'>
    readonly created_date: FieldRef<"em_profesi", 'DateTime'>
    readonly last_update: FieldRef<"em_profesi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_profesi findUnique
   */
  export type em_profesiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * Filter, which em_profesi to fetch.
     */
    where: em_profesiWhereUniqueInput
  }

  /**
   * em_profesi findUniqueOrThrow
   */
  export type em_profesiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * Filter, which em_profesi to fetch.
     */
    where: em_profesiWhereUniqueInput
  }

  /**
   * em_profesi findFirst
   */
  export type em_profesiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * Filter, which em_profesi to fetch.
     */
    where?: em_profesiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_profesis to fetch.
     */
    orderBy?: em_profesiOrderByWithRelationInput | em_profesiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_profesis.
     */
    cursor?: em_profesiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_profesis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_profesis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_profesis.
     */
    distinct?: Em_profesiScalarFieldEnum | Em_profesiScalarFieldEnum[]
  }

  /**
   * em_profesi findFirstOrThrow
   */
  export type em_profesiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * Filter, which em_profesi to fetch.
     */
    where?: em_profesiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_profesis to fetch.
     */
    orderBy?: em_profesiOrderByWithRelationInput | em_profesiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_profesis.
     */
    cursor?: em_profesiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_profesis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_profesis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_profesis.
     */
    distinct?: Em_profesiScalarFieldEnum | Em_profesiScalarFieldEnum[]
  }

  /**
   * em_profesi findMany
   */
  export type em_profesiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * Filter, which em_profesis to fetch.
     */
    where?: em_profesiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_profesis to fetch.
     */
    orderBy?: em_profesiOrderByWithRelationInput | em_profesiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_profesis.
     */
    cursor?: em_profesiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_profesis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_profesis.
     */
    skip?: number
    distinct?: Em_profesiScalarFieldEnum | Em_profesiScalarFieldEnum[]
  }

  /**
   * em_profesi create
   */
  export type em_profesiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * The data needed to create a em_profesi.
     */
    data?: XOR<em_profesiCreateInput, em_profesiUncheckedCreateInput>
  }

  /**
   * em_profesi createMany
   */
  export type em_profesiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_profesis.
     */
    data: em_profesiCreateManyInput | em_profesiCreateManyInput[]
  }

  /**
   * em_profesi update
   */
  export type em_profesiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * The data needed to update a em_profesi.
     */
    data: XOR<em_profesiUpdateInput, em_profesiUncheckedUpdateInput>
    /**
     * Choose, which em_profesi to update.
     */
    where: em_profesiWhereUniqueInput
  }

  /**
   * em_profesi updateMany
   */
  export type em_profesiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_profesis.
     */
    data: XOR<em_profesiUpdateManyMutationInput, em_profesiUncheckedUpdateManyInput>
    /**
     * Filter which em_profesis to update
     */
    where?: em_profesiWhereInput
    /**
     * Limit how many em_profesis to update.
     */
    limit?: number
  }

  /**
   * em_profesi upsert
   */
  export type em_profesiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * The filter to search for the em_profesi to update in case it exists.
     */
    where: em_profesiWhereUniqueInput
    /**
     * In case the em_profesi found by the `where` argument doesn't exist, create a new em_profesi with this data.
     */
    create: XOR<em_profesiCreateInput, em_profesiUncheckedCreateInput>
    /**
     * In case the em_profesi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_profesiUpdateInput, em_profesiUncheckedUpdateInput>
  }

  /**
   * em_profesi delete
   */
  export type em_profesiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
    /**
     * Filter which em_profesi to delete.
     */
    where: em_profesiWhereUniqueInput
  }

  /**
   * em_profesi deleteMany
   */
  export type em_profesiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_profesis to delete
     */
    where?: em_profesiWhereInput
    /**
     * Limit how many em_profesis to delete.
     */
    limit?: number
  }

  /**
   * em_profesi without action
   */
  export type em_profesiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_profesi
     */
    select?: em_profesiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_profesi
     */
    omit?: em_profesiOmit<ExtArgs> | null
  }


  /**
   * Model em_questions1
   */

  export type AggregateEm_questions1 = {
    _count: Em_questions1CountAggregateOutputType | null
    _avg: Em_questions1AvgAggregateOutputType | null
    _sum: Em_questions1SumAggregateOutputType | null
    _min: Em_questions1MinAggregateOutputType | null
    _max: Em_questions1MaxAggregateOutputType | null
  }

  export type Em_questions1AvgAggregateOutputType = {
    id: number | null
    question_type: number | null
    exam_id: number | null
    time_limit: number | null
    score: number | null
    isLevel: number | null
  }

  export type Em_questions1SumAggregateOutputType = {
    id: number | null
    question_type: number | null
    exam_id: number | null
    time_limit: number | null
    score: number | null
    isLevel: number | null
  }

  export type Em_questions1MinAggregateOutputType = {
    id: number | null
    question_text: string | null
    question_type: number | null
    correct_answer: string | null
    correct_answer2: string | null
    exam_id: number | null
    time_limit: number | null
    score: number | null
    status: string | null
    userid: string | null
    qdate: Date | null
    lastupdate: Date | null
    fileimage: string | null
    isExams: string | null
    isLevel: number | null
  }

  export type Em_questions1MaxAggregateOutputType = {
    id: number | null
    question_text: string | null
    question_type: number | null
    correct_answer: string | null
    correct_answer2: string | null
    exam_id: number | null
    time_limit: number | null
    score: number | null
    status: string | null
    userid: string | null
    qdate: Date | null
    lastupdate: Date | null
    fileimage: string | null
    isExams: string | null
    isLevel: number | null
  }

  export type Em_questions1CountAggregateOutputType = {
    id: number
    question_text: number
    question_type: number
    correct_answer: number
    correct_answer2: number
    exam_id: number
    time_limit: number
    score: number
    status: number
    userid: number
    qdate: number
    lastupdate: number
    fileimage: number
    isExams: number
    isLevel: number
    _all: number
  }


  export type Em_questions1AvgAggregateInputType = {
    id?: true
    question_type?: true
    exam_id?: true
    time_limit?: true
    score?: true
    isLevel?: true
  }

  export type Em_questions1SumAggregateInputType = {
    id?: true
    question_type?: true
    exam_id?: true
    time_limit?: true
    score?: true
    isLevel?: true
  }

  export type Em_questions1MinAggregateInputType = {
    id?: true
    question_text?: true
    question_type?: true
    correct_answer?: true
    correct_answer2?: true
    exam_id?: true
    time_limit?: true
    score?: true
    status?: true
    userid?: true
    qdate?: true
    lastupdate?: true
    fileimage?: true
    isExams?: true
    isLevel?: true
  }

  export type Em_questions1MaxAggregateInputType = {
    id?: true
    question_text?: true
    question_type?: true
    correct_answer?: true
    correct_answer2?: true
    exam_id?: true
    time_limit?: true
    score?: true
    status?: true
    userid?: true
    qdate?: true
    lastupdate?: true
    fileimage?: true
    isExams?: true
    isLevel?: true
  }

  export type Em_questions1CountAggregateInputType = {
    id?: true
    question_text?: true
    question_type?: true
    correct_answer?: true
    correct_answer2?: true
    exam_id?: true
    time_limit?: true
    score?: true
    status?: true
    userid?: true
    qdate?: true
    lastupdate?: true
    fileimage?: true
    isExams?: true
    isLevel?: true
    _all?: true
  }

  export type Em_questions1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_questions1 to aggregate.
     */
    where?: em_questions1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions1s to fetch.
     */
    orderBy?: em_questions1OrderByWithRelationInput | em_questions1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_questions1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_questions1s
    **/
    _count?: true | Em_questions1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_questions1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_questions1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_questions1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_questions1MaxAggregateInputType
  }

  export type GetEm_questions1AggregateType<T extends Em_questions1AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_questions1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_questions1[P]>
      : GetScalarType<T[P], AggregateEm_questions1[P]>
  }




  export type em_questions1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_questions1WhereInput
    orderBy?: em_questions1OrderByWithAggregationInput | em_questions1OrderByWithAggregationInput[]
    by: Em_questions1ScalarFieldEnum[] | Em_questions1ScalarFieldEnum
    having?: em_questions1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_questions1CountAggregateInputType | true
    _avg?: Em_questions1AvgAggregateInputType
    _sum?: Em_questions1SumAggregateInputType
    _min?: Em_questions1MinAggregateInputType
    _max?: Em_questions1MaxAggregateInputType
  }

  export type Em_questions1GroupByOutputType = {
    id: number
    question_text: string
    question_type: number | null
    correct_answer: string | null
    correct_answer2: string | null
    exam_id: number | null
    time_limit: number
    score: number
    status: string | null
    userid: string | null
    qdate: Date | null
    lastupdate: Date | null
    fileimage: string | null
    isExams: string | null
    isLevel: number | null
    _count: Em_questions1CountAggregateOutputType | null
    _avg: Em_questions1AvgAggregateOutputType | null
    _sum: Em_questions1SumAggregateOutputType | null
    _min: Em_questions1MinAggregateOutputType | null
    _max: Em_questions1MaxAggregateOutputType | null
  }

  type GetEm_questions1GroupByPayload<T extends em_questions1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_questions1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_questions1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_questions1GroupByOutputType[P]>
            : GetScalarType<T[P], Em_questions1GroupByOutputType[P]>
        }
      >
    >


  export type em_questions1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question_text?: boolean
    question_type?: boolean
    correct_answer?: boolean
    correct_answer2?: boolean
    exam_id?: boolean
    time_limit?: boolean
    score?: boolean
    status?: boolean
    userid?: boolean
    qdate?: boolean
    lastupdate?: boolean
    fileimage?: boolean
    isExams?: boolean
    isLevel?: boolean
    em_questions2?: boolean | em_questions1$em_questions2Args<ExtArgs>
    _count?: boolean | Em_questions1CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_questions1"]>



  export type em_questions1SelectScalar = {
    id?: boolean
    question_text?: boolean
    question_type?: boolean
    correct_answer?: boolean
    correct_answer2?: boolean
    exam_id?: boolean
    time_limit?: boolean
    score?: boolean
    status?: boolean
    userid?: boolean
    qdate?: boolean
    lastupdate?: boolean
    fileimage?: boolean
    isExams?: boolean
    isLevel?: boolean
  }

  export type em_questions1Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question_text" | "question_type" | "correct_answer" | "correct_answer2" | "exam_id" | "time_limit" | "score" | "status" | "userid" | "qdate" | "lastupdate" | "fileimage" | "isExams" | "isLevel", ExtArgs["result"]["em_questions1"]>
  export type em_questions1Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_questions2?: boolean | em_questions1$em_questions2Args<ExtArgs>
    _count?: boolean | Em_questions1CountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_questions1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_questions1"
    objects: {
      em_questions2: Prisma.$em_questions2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question_text: string
      question_type: number | null
      correct_answer: string | null
      correct_answer2: string | null
      exam_id: number | null
      time_limit: number
      score: number
      status: string | null
      userid: string | null
      qdate: Date | null
      lastupdate: Date | null
      fileimage: string | null
      isExams: string | null
      isLevel: number | null
    }, ExtArgs["result"]["em_questions1"]>
    composites: {}
  }

  type em_questions1GetPayload<S extends boolean | null | undefined | em_questions1DefaultArgs> = $Result.GetResult<Prisma.$em_questions1Payload, S>

  type em_questions1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_questions1FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_questions1CountAggregateInputType | true
    }

  export interface em_questions1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_questions1'], meta: { name: 'em_questions1' } }
    /**
     * Find zero or one Em_questions1 that matches the filter.
     * @param {em_questions1FindUniqueArgs} args - Arguments to find a Em_questions1
     * @example
     * // Get one Em_questions1
     * const em_questions1 = await prisma.em_questions1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_questions1FindUniqueArgs>(args: SelectSubset<T, em_questions1FindUniqueArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_questions1 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_questions1FindUniqueOrThrowArgs} args - Arguments to find a Em_questions1
     * @example
     * // Get one Em_questions1
     * const em_questions1 = await prisma.em_questions1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_questions1FindUniqueOrThrowArgs>(args: SelectSubset<T, em_questions1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_questions1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions1FindFirstArgs} args - Arguments to find a Em_questions1
     * @example
     * // Get one Em_questions1
     * const em_questions1 = await prisma.em_questions1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_questions1FindFirstArgs>(args?: SelectSubset<T, em_questions1FindFirstArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_questions1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions1FindFirstOrThrowArgs} args - Arguments to find a Em_questions1
     * @example
     * // Get one Em_questions1
     * const em_questions1 = await prisma.em_questions1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_questions1FindFirstOrThrowArgs>(args?: SelectSubset<T, em_questions1FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_questions1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_questions1s
     * const em_questions1s = await prisma.em_questions1.findMany()
     * 
     * // Get first 10 Em_questions1s
     * const em_questions1s = await prisma.em_questions1.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_questions1WithIdOnly = await prisma.em_questions1.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_questions1FindManyArgs>(args?: SelectSubset<T, em_questions1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_questions1.
     * @param {em_questions1CreateArgs} args - Arguments to create a Em_questions1.
     * @example
     * // Create one Em_questions1
     * const Em_questions1 = await prisma.em_questions1.create({
     *   data: {
     *     // ... data to create a Em_questions1
     *   }
     * })
     * 
     */
    create<T extends em_questions1CreateArgs>(args: SelectSubset<T, em_questions1CreateArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_questions1s.
     * @param {em_questions1CreateManyArgs} args - Arguments to create many Em_questions1s.
     * @example
     * // Create many Em_questions1s
     * const em_questions1 = await prisma.em_questions1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_questions1CreateManyArgs>(args?: SelectSubset<T, em_questions1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_questions1.
     * @param {em_questions1DeleteArgs} args - Arguments to delete one Em_questions1.
     * @example
     * // Delete one Em_questions1
     * const Em_questions1 = await prisma.em_questions1.delete({
     *   where: {
     *     // ... filter to delete one Em_questions1
     *   }
     * })
     * 
     */
    delete<T extends em_questions1DeleteArgs>(args: SelectSubset<T, em_questions1DeleteArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_questions1.
     * @param {em_questions1UpdateArgs} args - Arguments to update one Em_questions1.
     * @example
     * // Update one Em_questions1
     * const em_questions1 = await prisma.em_questions1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_questions1UpdateArgs>(args: SelectSubset<T, em_questions1UpdateArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_questions1s.
     * @param {em_questions1DeleteManyArgs} args - Arguments to filter Em_questions1s to delete.
     * @example
     * // Delete a few Em_questions1s
     * const { count } = await prisma.em_questions1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_questions1DeleteManyArgs>(args?: SelectSubset<T, em_questions1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_questions1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_questions1s
     * const em_questions1 = await prisma.em_questions1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_questions1UpdateManyArgs>(args: SelectSubset<T, em_questions1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_questions1.
     * @param {em_questions1UpsertArgs} args - Arguments to update or create a Em_questions1.
     * @example
     * // Update or create a Em_questions1
     * const em_questions1 = await prisma.em_questions1.upsert({
     *   create: {
     *     // ... data to create a Em_questions1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_questions1 we want to update
     *   }
     * })
     */
    upsert<T extends em_questions1UpsertArgs>(args: SelectSubset<T, em_questions1UpsertArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_questions1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions1CountArgs} args - Arguments to filter Em_questions1s to count.
     * @example
     * // Count the number of Em_questions1s
     * const count = await prisma.em_questions1.count({
     *   where: {
     *     // ... the filter for the Em_questions1s we want to count
     *   }
     * })
    **/
    count<T extends em_questions1CountArgs>(
      args?: Subset<T, em_questions1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_questions1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_questions1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_questions1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_questions1AggregateArgs>(args: Subset<T, Em_questions1AggregateArgs>): Prisma.PrismaPromise<GetEm_questions1AggregateType<T>>

    /**
     * Group by Em_questions1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_questions1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_questions1GroupByArgs['orderBy'] }
        : { orderBy?: em_questions1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_questions1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_questions1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_questions1 model
   */
  readonly fields: em_questions1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_questions1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_questions1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_questions2<T extends em_questions1$em_questions2Args<ExtArgs> = {}>(args?: Subset<T, em_questions1$em_questions2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_questions1 model
   */
  interface em_questions1FieldRefs {
    readonly id: FieldRef<"em_questions1", 'Int'>
    readonly question_text: FieldRef<"em_questions1", 'String'>
    readonly question_type: FieldRef<"em_questions1", 'Int'>
    readonly correct_answer: FieldRef<"em_questions1", 'String'>
    readonly correct_answer2: FieldRef<"em_questions1", 'String'>
    readonly exam_id: FieldRef<"em_questions1", 'Int'>
    readonly time_limit: FieldRef<"em_questions1", 'Int'>
    readonly score: FieldRef<"em_questions1", 'Float'>
    readonly status: FieldRef<"em_questions1", 'String'>
    readonly userid: FieldRef<"em_questions1", 'String'>
    readonly qdate: FieldRef<"em_questions1", 'DateTime'>
    readonly lastupdate: FieldRef<"em_questions1", 'DateTime'>
    readonly fileimage: FieldRef<"em_questions1", 'String'>
    readonly isExams: FieldRef<"em_questions1", 'String'>
    readonly isLevel: FieldRef<"em_questions1", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_questions1 findUnique
   */
  export type em_questions1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * Filter, which em_questions1 to fetch.
     */
    where: em_questions1WhereUniqueInput
  }

  /**
   * em_questions1 findUniqueOrThrow
   */
  export type em_questions1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * Filter, which em_questions1 to fetch.
     */
    where: em_questions1WhereUniqueInput
  }

  /**
   * em_questions1 findFirst
   */
  export type em_questions1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * Filter, which em_questions1 to fetch.
     */
    where?: em_questions1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions1s to fetch.
     */
    orderBy?: em_questions1OrderByWithRelationInput | em_questions1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_questions1s.
     */
    cursor?: em_questions1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_questions1s.
     */
    distinct?: Em_questions1ScalarFieldEnum | Em_questions1ScalarFieldEnum[]
  }

  /**
   * em_questions1 findFirstOrThrow
   */
  export type em_questions1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * Filter, which em_questions1 to fetch.
     */
    where?: em_questions1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions1s to fetch.
     */
    orderBy?: em_questions1OrderByWithRelationInput | em_questions1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_questions1s.
     */
    cursor?: em_questions1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_questions1s.
     */
    distinct?: Em_questions1ScalarFieldEnum | Em_questions1ScalarFieldEnum[]
  }

  /**
   * em_questions1 findMany
   */
  export type em_questions1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * Filter, which em_questions1s to fetch.
     */
    where?: em_questions1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions1s to fetch.
     */
    orderBy?: em_questions1OrderByWithRelationInput | em_questions1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_questions1s.
     */
    cursor?: em_questions1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions1s.
     */
    skip?: number
    distinct?: Em_questions1ScalarFieldEnum | Em_questions1ScalarFieldEnum[]
  }

  /**
   * em_questions1 create
   */
  export type em_questions1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * The data needed to create a em_questions1.
     */
    data: XOR<em_questions1CreateInput, em_questions1UncheckedCreateInput>
  }

  /**
   * em_questions1 createMany
   */
  export type em_questions1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_questions1s.
     */
    data: em_questions1CreateManyInput | em_questions1CreateManyInput[]
  }

  /**
   * em_questions1 update
   */
  export type em_questions1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * The data needed to update a em_questions1.
     */
    data: XOR<em_questions1UpdateInput, em_questions1UncheckedUpdateInput>
    /**
     * Choose, which em_questions1 to update.
     */
    where: em_questions1WhereUniqueInput
  }

  /**
   * em_questions1 updateMany
   */
  export type em_questions1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_questions1s.
     */
    data: XOR<em_questions1UpdateManyMutationInput, em_questions1UncheckedUpdateManyInput>
    /**
     * Filter which em_questions1s to update
     */
    where?: em_questions1WhereInput
    /**
     * Limit how many em_questions1s to update.
     */
    limit?: number
  }

  /**
   * em_questions1 upsert
   */
  export type em_questions1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * The filter to search for the em_questions1 to update in case it exists.
     */
    where: em_questions1WhereUniqueInput
    /**
     * In case the em_questions1 found by the `where` argument doesn't exist, create a new em_questions1 with this data.
     */
    create: XOR<em_questions1CreateInput, em_questions1UncheckedCreateInput>
    /**
     * In case the em_questions1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_questions1UpdateInput, em_questions1UncheckedUpdateInput>
  }

  /**
   * em_questions1 delete
   */
  export type em_questions1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
    /**
     * Filter which em_questions1 to delete.
     */
    where: em_questions1WhereUniqueInput
  }

  /**
   * em_questions1 deleteMany
   */
  export type em_questions1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_questions1s to delete
     */
    where?: em_questions1WhereInput
    /**
     * Limit how many em_questions1s to delete.
     */
    limit?: number
  }

  /**
   * em_questions1.em_questions2
   */
  export type em_questions1$em_questions2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    where?: em_questions2WhereInput
    orderBy?: em_questions2OrderByWithRelationInput | em_questions2OrderByWithRelationInput[]
    cursor?: em_questions2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_questions2ScalarFieldEnum | Em_questions2ScalarFieldEnum[]
  }

  /**
   * em_questions1 without action
   */
  export type em_questions1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions1
     */
    select?: em_questions1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions1
     */
    omit?: em_questions1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions1Include<ExtArgs> | null
  }


  /**
   * Model em_questions2
   */

  export type AggregateEm_questions2 = {
    _count: Em_questions2CountAggregateOutputType | null
    _avg: Em_questions2AvgAggregateOutputType | null
    _sum: Em_questions2SumAggregateOutputType | null
    _min: Em_questions2MinAggregateOutputType | null
    _max: Em_questions2MaxAggregateOutputType | null
  }

  export type Em_questions2AvgAggregateOutputType = {
    Id: number | null
    question_id: number | null
  }

  export type Em_questions2SumAggregateOutputType = {
    Id: bigint | null
    question_id: number | null
  }

  export type Em_questions2MinAggregateOutputType = {
    Id: bigint | null
    question_id: number | null
    option_choices: string | null
    option_text: string | null
  }

  export type Em_questions2MaxAggregateOutputType = {
    Id: bigint | null
    question_id: number | null
    option_choices: string | null
    option_text: string | null
  }

  export type Em_questions2CountAggregateOutputType = {
    Id: number
    question_id: number
    option_choices: number
    option_text: number
    _all: number
  }


  export type Em_questions2AvgAggregateInputType = {
    Id?: true
    question_id?: true
  }

  export type Em_questions2SumAggregateInputType = {
    Id?: true
    question_id?: true
  }

  export type Em_questions2MinAggregateInputType = {
    Id?: true
    question_id?: true
    option_choices?: true
    option_text?: true
  }

  export type Em_questions2MaxAggregateInputType = {
    Id?: true
    question_id?: true
    option_choices?: true
    option_text?: true
  }

  export type Em_questions2CountAggregateInputType = {
    Id?: true
    question_id?: true
    option_choices?: true
    option_text?: true
    _all?: true
  }

  export type Em_questions2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_questions2 to aggregate.
     */
    where?: em_questions2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions2s to fetch.
     */
    orderBy?: em_questions2OrderByWithRelationInput | em_questions2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_questions2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_questions2s
    **/
    _count?: true | Em_questions2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_questions2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_questions2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_questions2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_questions2MaxAggregateInputType
  }

  export type GetEm_questions2AggregateType<T extends Em_questions2AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_questions2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_questions2[P]>
      : GetScalarType<T[P], AggregateEm_questions2[P]>
  }




  export type em_questions2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_questions2WhereInput
    orderBy?: em_questions2OrderByWithAggregationInput | em_questions2OrderByWithAggregationInput[]
    by: Em_questions2ScalarFieldEnum[] | Em_questions2ScalarFieldEnum
    having?: em_questions2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_questions2CountAggregateInputType | true
    _avg?: Em_questions2AvgAggregateInputType
    _sum?: Em_questions2SumAggregateInputType
    _min?: Em_questions2MinAggregateInputType
    _max?: Em_questions2MaxAggregateInputType
  }

  export type Em_questions2GroupByOutputType = {
    Id: bigint
    question_id: number
    option_choices: string
    option_text: string
    _count: Em_questions2CountAggregateOutputType | null
    _avg: Em_questions2AvgAggregateOutputType | null
    _sum: Em_questions2SumAggregateOutputType | null
    _min: Em_questions2MinAggregateOutputType | null
    _max: Em_questions2MaxAggregateOutputType | null
  }

  type GetEm_questions2GroupByPayload<T extends em_questions2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_questions2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_questions2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_questions2GroupByOutputType[P]>
            : GetScalarType<T[P], Em_questions2GroupByOutputType[P]>
        }
      >
    >


  export type em_questions2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    question_id?: boolean
    option_choices?: boolean
    option_text?: boolean
    em_questions1?: boolean | em_questions1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_questions2"]>



  export type em_questions2SelectScalar = {
    Id?: boolean
    question_id?: boolean
    option_choices?: boolean
    option_text?: boolean
  }

  export type em_questions2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "question_id" | "option_choices" | "option_text", ExtArgs["result"]["em_questions2"]>
  export type em_questions2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_questions1?: boolean | em_questions1DefaultArgs<ExtArgs>
  }

  export type $em_questions2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_questions2"
    objects: {
      em_questions1: Prisma.$em_questions1Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: bigint
      question_id: number
      option_choices: string
      option_text: string
    }, ExtArgs["result"]["em_questions2"]>
    composites: {}
  }

  type em_questions2GetPayload<S extends boolean | null | undefined | em_questions2DefaultArgs> = $Result.GetResult<Prisma.$em_questions2Payload, S>

  type em_questions2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_questions2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_questions2CountAggregateInputType | true
    }

  export interface em_questions2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_questions2'], meta: { name: 'em_questions2' } }
    /**
     * Find zero or one Em_questions2 that matches the filter.
     * @param {em_questions2FindUniqueArgs} args - Arguments to find a Em_questions2
     * @example
     * // Get one Em_questions2
     * const em_questions2 = await prisma.em_questions2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_questions2FindUniqueArgs>(args: SelectSubset<T, em_questions2FindUniqueArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_questions2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_questions2FindUniqueOrThrowArgs} args - Arguments to find a Em_questions2
     * @example
     * // Get one Em_questions2
     * const em_questions2 = await prisma.em_questions2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_questions2FindUniqueOrThrowArgs>(args: SelectSubset<T, em_questions2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_questions2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions2FindFirstArgs} args - Arguments to find a Em_questions2
     * @example
     * // Get one Em_questions2
     * const em_questions2 = await prisma.em_questions2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_questions2FindFirstArgs>(args?: SelectSubset<T, em_questions2FindFirstArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_questions2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions2FindFirstOrThrowArgs} args - Arguments to find a Em_questions2
     * @example
     * // Get one Em_questions2
     * const em_questions2 = await prisma.em_questions2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_questions2FindFirstOrThrowArgs>(args?: SelectSubset<T, em_questions2FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_questions2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_questions2s
     * const em_questions2s = await prisma.em_questions2.findMany()
     * 
     * // Get first 10 Em_questions2s
     * const em_questions2s = await prisma.em_questions2.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_questions2WithIdOnly = await prisma.em_questions2.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_questions2FindManyArgs>(args?: SelectSubset<T, em_questions2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_questions2.
     * @param {em_questions2CreateArgs} args - Arguments to create a Em_questions2.
     * @example
     * // Create one Em_questions2
     * const Em_questions2 = await prisma.em_questions2.create({
     *   data: {
     *     // ... data to create a Em_questions2
     *   }
     * })
     * 
     */
    create<T extends em_questions2CreateArgs>(args: SelectSubset<T, em_questions2CreateArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_questions2s.
     * @param {em_questions2CreateManyArgs} args - Arguments to create many Em_questions2s.
     * @example
     * // Create many Em_questions2s
     * const em_questions2 = await prisma.em_questions2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_questions2CreateManyArgs>(args?: SelectSubset<T, em_questions2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_questions2.
     * @param {em_questions2DeleteArgs} args - Arguments to delete one Em_questions2.
     * @example
     * // Delete one Em_questions2
     * const Em_questions2 = await prisma.em_questions2.delete({
     *   where: {
     *     // ... filter to delete one Em_questions2
     *   }
     * })
     * 
     */
    delete<T extends em_questions2DeleteArgs>(args: SelectSubset<T, em_questions2DeleteArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_questions2.
     * @param {em_questions2UpdateArgs} args - Arguments to update one Em_questions2.
     * @example
     * // Update one Em_questions2
     * const em_questions2 = await prisma.em_questions2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_questions2UpdateArgs>(args: SelectSubset<T, em_questions2UpdateArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_questions2s.
     * @param {em_questions2DeleteManyArgs} args - Arguments to filter Em_questions2s to delete.
     * @example
     * // Delete a few Em_questions2s
     * const { count } = await prisma.em_questions2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_questions2DeleteManyArgs>(args?: SelectSubset<T, em_questions2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_questions2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_questions2s
     * const em_questions2 = await prisma.em_questions2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_questions2UpdateManyArgs>(args: SelectSubset<T, em_questions2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_questions2.
     * @param {em_questions2UpsertArgs} args - Arguments to update or create a Em_questions2.
     * @example
     * // Update or create a Em_questions2
     * const em_questions2 = await prisma.em_questions2.upsert({
     *   create: {
     *     // ... data to create a Em_questions2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_questions2 we want to update
     *   }
     * })
     */
    upsert<T extends em_questions2UpsertArgs>(args: SelectSubset<T, em_questions2UpsertArgs<ExtArgs>>): Prisma__em_questions2Client<$Result.GetResult<Prisma.$em_questions2Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_questions2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions2CountArgs} args - Arguments to filter Em_questions2s to count.
     * @example
     * // Count the number of Em_questions2s
     * const count = await prisma.em_questions2.count({
     *   where: {
     *     // ... the filter for the Em_questions2s we want to count
     *   }
     * })
    **/
    count<T extends em_questions2CountArgs>(
      args?: Subset<T, em_questions2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_questions2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_questions2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_questions2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_questions2AggregateArgs>(args: Subset<T, Em_questions2AggregateArgs>): Prisma.PrismaPromise<GetEm_questions2AggregateType<T>>

    /**
     * Group by Em_questions2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questions2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_questions2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_questions2GroupByArgs['orderBy'] }
        : { orderBy?: em_questions2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_questions2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_questions2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_questions2 model
   */
  readonly fields: em_questions2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_questions2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_questions2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_questions1<T extends em_questions1DefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_questions1DefaultArgs<ExtArgs>>): Prisma__em_questions1Client<$Result.GetResult<Prisma.$em_questions1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_questions2 model
   */
  interface em_questions2FieldRefs {
    readonly Id: FieldRef<"em_questions2", 'BigInt'>
    readonly question_id: FieldRef<"em_questions2", 'Int'>
    readonly option_choices: FieldRef<"em_questions2", 'String'>
    readonly option_text: FieldRef<"em_questions2", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_questions2 findUnique
   */
  export type em_questions2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * Filter, which em_questions2 to fetch.
     */
    where: em_questions2WhereUniqueInput
  }

  /**
   * em_questions2 findUniqueOrThrow
   */
  export type em_questions2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * Filter, which em_questions2 to fetch.
     */
    where: em_questions2WhereUniqueInput
  }

  /**
   * em_questions2 findFirst
   */
  export type em_questions2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * Filter, which em_questions2 to fetch.
     */
    where?: em_questions2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions2s to fetch.
     */
    orderBy?: em_questions2OrderByWithRelationInput | em_questions2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_questions2s.
     */
    cursor?: em_questions2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_questions2s.
     */
    distinct?: Em_questions2ScalarFieldEnum | Em_questions2ScalarFieldEnum[]
  }

  /**
   * em_questions2 findFirstOrThrow
   */
  export type em_questions2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * Filter, which em_questions2 to fetch.
     */
    where?: em_questions2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions2s to fetch.
     */
    orderBy?: em_questions2OrderByWithRelationInput | em_questions2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_questions2s.
     */
    cursor?: em_questions2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_questions2s.
     */
    distinct?: Em_questions2ScalarFieldEnum | Em_questions2ScalarFieldEnum[]
  }

  /**
   * em_questions2 findMany
   */
  export type em_questions2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * Filter, which em_questions2s to fetch.
     */
    where?: em_questions2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questions2s to fetch.
     */
    orderBy?: em_questions2OrderByWithRelationInput | em_questions2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_questions2s.
     */
    cursor?: em_questions2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questions2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questions2s.
     */
    skip?: number
    distinct?: Em_questions2ScalarFieldEnum | Em_questions2ScalarFieldEnum[]
  }

  /**
   * em_questions2 create
   */
  export type em_questions2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * The data needed to create a em_questions2.
     */
    data: XOR<em_questions2CreateInput, em_questions2UncheckedCreateInput>
  }

  /**
   * em_questions2 createMany
   */
  export type em_questions2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_questions2s.
     */
    data: em_questions2CreateManyInput | em_questions2CreateManyInput[]
  }

  /**
   * em_questions2 update
   */
  export type em_questions2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * The data needed to update a em_questions2.
     */
    data: XOR<em_questions2UpdateInput, em_questions2UncheckedUpdateInput>
    /**
     * Choose, which em_questions2 to update.
     */
    where: em_questions2WhereUniqueInput
  }

  /**
   * em_questions2 updateMany
   */
  export type em_questions2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_questions2s.
     */
    data: XOR<em_questions2UpdateManyMutationInput, em_questions2UncheckedUpdateManyInput>
    /**
     * Filter which em_questions2s to update
     */
    where?: em_questions2WhereInput
    /**
     * Limit how many em_questions2s to update.
     */
    limit?: number
  }

  /**
   * em_questions2 upsert
   */
  export type em_questions2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * The filter to search for the em_questions2 to update in case it exists.
     */
    where: em_questions2WhereUniqueInput
    /**
     * In case the em_questions2 found by the `where` argument doesn't exist, create a new em_questions2 with this data.
     */
    create: XOR<em_questions2CreateInput, em_questions2UncheckedCreateInput>
    /**
     * In case the em_questions2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_questions2UpdateInput, em_questions2UncheckedUpdateInput>
  }

  /**
   * em_questions2 delete
   */
  export type em_questions2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
    /**
     * Filter which em_questions2 to delete.
     */
    where: em_questions2WhereUniqueInput
  }

  /**
   * em_questions2 deleteMany
   */
  export type em_questions2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_questions2s to delete
     */
    where?: em_questions2WhereInput
    /**
     * Limit how many em_questions2s to delete.
     */
    limit?: number
  }

  /**
   * em_questions2 without action
   */
  export type em_questions2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questions2
     */
    select?: em_questions2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_questions2
     */
    omit?: em_questions2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_questions2Include<ExtArgs> | null
  }


  /**
   * Model em_questtype
   */

  export type AggregateEm_questtype = {
    _count: Em_questtypeCountAggregateOutputType | null
    _avg: Em_questtypeAvgAggregateOutputType | null
    _sum: Em_questtypeSumAggregateOutputType | null
    _min: Em_questtypeMinAggregateOutputType | null
    _max: Em_questtypeMaxAggregateOutputType | null
  }

  export type Em_questtypeAvgAggregateOutputType = {
    Id: number | null
  }

  export type Em_questtypeSumAggregateOutputType = {
    Id: number | null
  }

  export type Em_questtypeMinAggregateOutputType = {
    Id: number | null
    TypeName: string | null
    Status: string | null
  }

  export type Em_questtypeMaxAggregateOutputType = {
    Id: number | null
    TypeName: string | null
    Status: string | null
  }

  export type Em_questtypeCountAggregateOutputType = {
    Id: number
    TypeName: number
    Status: number
    _all: number
  }


  export type Em_questtypeAvgAggregateInputType = {
    Id?: true
  }

  export type Em_questtypeSumAggregateInputType = {
    Id?: true
  }

  export type Em_questtypeMinAggregateInputType = {
    Id?: true
    TypeName?: true
    Status?: true
  }

  export type Em_questtypeMaxAggregateInputType = {
    Id?: true
    TypeName?: true
    Status?: true
  }

  export type Em_questtypeCountAggregateInputType = {
    Id?: true
    TypeName?: true
    Status?: true
    _all?: true
  }

  export type Em_questtypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_questtype to aggregate.
     */
    where?: em_questtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questtypes to fetch.
     */
    orderBy?: em_questtypeOrderByWithRelationInput | em_questtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_questtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_questtypes
    **/
    _count?: true | Em_questtypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_questtypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_questtypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_questtypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_questtypeMaxAggregateInputType
  }

  export type GetEm_questtypeAggregateType<T extends Em_questtypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_questtype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_questtype[P]>
      : GetScalarType<T[P], AggregateEm_questtype[P]>
  }




  export type em_questtypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_questtypeWhereInput
    orderBy?: em_questtypeOrderByWithAggregationInput | em_questtypeOrderByWithAggregationInput[]
    by: Em_questtypeScalarFieldEnum[] | Em_questtypeScalarFieldEnum
    having?: em_questtypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_questtypeCountAggregateInputType | true
    _avg?: Em_questtypeAvgAggregateInputType
    _sum?: Em_questtypeSumAggregateInputType
    _min?: Em_questtypeMinAggregateInputType
    _max?: Em_questtypeMaxAggregateInputType
  }

  export type Em_questtypeGroupByOutputType = {
    Id: number
    TypeName: string | null
    Status: string | null
    _count: Em_questtypeCountAggregateOutputType | null
    _avg: Em_questtypeAvgAggregateOutputType | null
    _sum: Em_questtypeSumAggregateOutputType | null
    _min: Em_questtypeMinAggregateOutputType | null
    _max: Em_questtypeMaxAggregateOutputType | null
  }

  type GetEm_questtypeGroupByPayload<T extends em_questtypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_questtypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_questtypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_questtypeGroupByOutputType[P]>
            : GetScalarType<T[P], Em_questtypeGroupByOutputType[P]>
        }
      >
    >


  export type em_questtypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    TypeName?: boolean
    Status?: boolean
  }, ExtArgs["result"]["em_questtype"]>



  export type em_questtypeSelectScalar = {
    Id?: boolean
    TypeName?: boolean
    Status?: boolean
  }

  export type em_questtypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "TypeName" | "Status", ExtArgs["result"]["em_questtype"]>

  export type $em_questtypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_questtype"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      TypeName: string | null
      Status: string | null
    }, ExtArgs["result"]["em_questtype"]>
    composites: {}
  }

  type em_questtypeGetPayload<S extends boolean | null | undefined | em_questtypeDefaultArgs> = $Result.GetResult<Prisma.$em_questtypePayload, S>

  type em_questtypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_questtypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_questtypeCountAggregateInputType | true
    }

  export interface em_questtypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_questtype'], meta: { name: 'em_questtype' } }
    /**
     * Find zero or one Em_questtype that matches the filter.
     * @param {em_questtypeFindUniqueArgs} args - Arguments to find a Em_questtype
     * @example
     * // Get one Em_questtype
     * const em_questtype = await prisma.em_questtype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_questtypeFindUniqueArgs>(args: SelectSubset<T, em_questtypeFindUniqueArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_questtype that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_questtypeFindUniqueOrThrowArgs} args - Arguments to find a Em_questtype
     * @example
     * // Get one Em_questtype
     * const em_questtype = await prisma.em_questtype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_questtypeFindUniqueOrThrowArgs>(args: SelectSubset<T, em_questtypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_questtype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questtypeFindFirstArgs} args - Arguments to find a Em_questtype
     * @example
     * // Get one Em_questtype
     * const em_questtype = await prisma.em_questtype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_questtypeFindFirstArgs>(args?: SelectSubset<T, em_questtypeFindFirstArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_questtype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questtypeFindFirstOrThrowArgs} args - Arguments to find a Em_questtype
     * @example
     * // Get one Em_questtype
     * const em_questtype = await prisma.em_questtype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_questtypeFindFirstOrThrowArgs>(args?: SelectSubset<T, em_questtypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_questtypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questtypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_questtypes
     * const em_questtypes = await prisma.em_questtype.findMany()
     * 
     * // Get first 10 Em_questtypes
     * const em_questtypes = await prisma.em_questtype.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_questtypeWithIdOnly = await prisma.em_questtype.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_questtypeFindManyArgs>(args?: SelectSubset<T, em_questtypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_questtype.
     * @param {em_questtypeCreateArgs} args - Arguments to create a Em_questtype.
     * @example
     * // Create one Em_questtype
     * const Em_questtype = await prisma.em_questtype.create({
     *   data: {
     *     // ... data to create a Em_questtype
     *   }
     * })
     * 
     */
    create<T extends em_questtypeCreateArgs>(args: SelectSubset<T, em_questtypeCreateArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_questtypes.
     * @param {em_questtypeCreateManyArgs} args - Arguments to create many Em_questtypes.
     * @example
     * // Create many Em_questtypes
     * const em_questtype = await prisma.em_questtype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_questtypeCreateManyArgs>(args?: SelectSubset<T, em_questtypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_questtype.
     * @param {em_questtypeDeleteArgs} args - Arguments to delete one Em_questtype.
     * @example
     * // Delete one Em_questtype
     * const Em_questtype = await prisma.em_questtype.delete({
     *   where: {
     *     // ... filter to delete one Em_questtype
     *   }
     * })
     * 
     */
    delete<T extends em_questtypeDeleteArgs>(args: SelectSubset<T, em_questtypeDeleteArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_questtype.
     * @param {em_questtypeUpdateArgs} args - Arguments to update one Em_questtype.
     * @example
     * // Update one Em_questtype
     * const em_questtype = await prisma.em_questtype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_questtypeUpdateArgs>(args: SelectSubset<T, em_questtypeUpdateArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_questtypes.
     * @param {em_questtypeDeleteManyArgs} args - Arguments to filter Em_questtypes to delete.
     * @example
     * // Delete a few Em_questtypes
     * const { count } = await prisma.em_questtype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_questtypeDeleteManyArgs>(args?: SelectSubset<T, em_questtypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_questtypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questtypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_questtypes
     * const em_questtype = await prisma.em_questtype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_questtypeUpdateManyArgs>(args: SelectSubset<T, em_questtypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_questtype.
     * @param {em_questtypeUpsertArgs} args - Arguments to update or create a Em_questtype.
     * @example
     * // Update or create a Em_questtype
     * const em_questtype = await prisma.em_questtype.upsert({
     *   create: {
     *     // ... data to create a Em_questtype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_questtype we want to update
     *   }
     * })
     */
    upsert<T extends em_questtypeUpsertArgs>(args: SelectSubset<T, em_questtypeUpsertArgs<ExtArgs>>): Prisma__em_questtypeClient<$Result.GetResult<Prisma.$em_questtypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_questtypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questtypeCountArgs} args - Arguments to filter Em_questtypes to count.
     * @example
     * // Count the number of Em_questtypes
     * const count = await prisma.em_questtype.count({
     *   where: {
     *     // ... the filter for the Em_questtypes we want to count
     *   }
     * })
    **/
    count<T extends em_questtypeCountArgs>(
      args?: Subset<T, em_questtypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_questtypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_questtype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_questtypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_questtypeAggregateArgs>(args: Subset<T, Em_questtypeAggregateArgs>): Prisma.PrismaPromise<GetEm_questtypeAggregateType<T>>

    /**
     * Group by Em_questtype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_questtypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_questtypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_questtypeGroupByArgs['orderBy'] }
        : { orderBy?: em_questtypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_questtypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_questtypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_questtype model
   */
  readonly fields: em_questtypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_questtype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_questtypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_questtype model
   */
  interface em_questtypeFieldRefs {
    readonly Id: FieldRef<"em_questtype", 'Int'>
    readonly TypeName: FieldRef<"em_questtype", 'String'>
    readonly Status: FieldRef<"em_questtype", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_questtype findUnique
   */
  export type em_questtypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * Filter, which em_questtype to fetch.
     */
    where: em_questtypeWhereUniqueInput
  }

  /**
   * em_questtype findUniqueOrThrow
   */
  export type em_questtypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * Filter, which em_questtype to fetch.
     */
    where: em_questtypeWhereUniqueInput
  }

  /**
   * em_questtype findFirst
   */
  export type em_questtypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * Filter, which em_questtype to fetch.
     */
    where?: em_questtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questtypes to fetch.
     */
    orderBy?: em_questtypeOrderByWithRelationInput | em_questtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_questtypes.
     */
    cursor?: em_questtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_questtypes.
     */
    distinct?: Em_questtypeScalarFieldEnum | Em_questtypeScalarFieldEnum[]
  }

  /**
   * em_questtype findFirstOrThrow
   */
  export type em_questtypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * Filter, which em_questtype to fetch.
     */
    where?: em_questtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questtypes to fetch.
     */
    orderBy?: em_questtypeOrderByWithRelationInput | em_questtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_questtypes.
     */
    cursor?: em_questtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_questtypes.
     */
    distinct?: Em_questtypeScalarFieldEnum | Em_questtypeScalarFieldEnum[]
  }

  /**
   * em_questtype findMany
   */
  export type em_questtypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * Filter, which em_questtypes to fetch.
     */
    where?: em_questtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_questtypes to fetch.
     */
    orderBy?: em_questtypeOrderByWithRelationInput | em_questtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_questtypes.
     */
    cursor?: em_questtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_questtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_questtypes.
     */
    skip?: number
    distinct?: Em_questtypeScalarFieldEnum | Em_questtypeScalarFieldEnum[]
  }

  /**
   * em_questtype create
   */
  export type em_questtypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * The data needed to create a em_questtype.
     */
    data?: XOR<em_questtypeCreateInput, em_questtypeUncheckedCreateInput>
  }

  /**
   * em_questtype createMany
   */
  export type em_questtypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_questtypes.
     */
    data: em_questtypeCreateManyInput | em_questtypeCreateManyInput[]
  }

  /**
   * em_questtype update
   */
  export type em_questtypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * The data needed to update a em_questtype.
     */
    data: XOR<em_questtypeUpdateInput, em_questtypeUncheckedUpdateInput>
    /**
     * Choose, which em_questtype to update.
     */
    where: em_questtypeWhereUniqueInput
  }

  /**
   * em_questtype updateMany
   */
  export type em_questtypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_questtypes.
     */
    data: XOR<em_questtypeUpdateManyMutationInput, em_questtypeUncheckedUpdateManyInput>
    /**
     * Filter which em_questtypes to update
     */
    where?: em_questtypeWhereInput
    /**
     * Limit how many em_questtypes to update.
     */
    limit?: number
  }

  /**
   * em_questtype upsert
   */
  export type em_questtypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * The filter to search for the em_questtype to update in case it exists.
     */
    where: em_questtypeWhereUniqueInput
    /**
     * In case the em_questtype found by the `where` argument doesn't exist, create a new em_questtype with this data.
     */
    create: XOR<em_questtypeCreateInput, em_questtypeUncheckedCreateInput>
    /**
     * In case the em_questtype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_questtypeUpdateInput, em_questtypeUncheckedUpdateInput>
  }

  /**
   * em_questtype delete
   */
  export type em_questtypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
    /**
     * Filter which em_questtype to delete.
     */
    where: em_questtypeWhereUniqueInput
  }

  /**
   * em_questtype deleteMany
   */
  export type em_questtypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_questtypes to delete
     */
    where?: em_questtypeWhereInput
    /**
     * Limit how many em_questtypes to delete.
     */
    limit?: number
  }

  /**
   * em_questtype without action
   */
  export type em_questtypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_questtype
     */
    select?: em_questtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_questtype
     */
    omit?: em_questtypeOmit<ExtArgs> | null
  }


  /**
   * Model em_regulations
   */

  export type AggregateEm_regulations = {
    _count: Em_regulationsCountAggregateOutputType | null
    _avg: Em_regulationsAvgAggregateOutputType | null
    _sum: Em_regulationsSumAggregateOutputType | null
    _min: Em_regulationsMinAggregateOutputType | null
    _max: Em_regulationsMaxAggregateOutputType | null
  }

  export type Em_regulationsAvgAggregateOutputType = {
    Id: number | null
    chanceId: number | null
    urut: number | null
  }

  export type Em_regulationsSumAggregateOutputType = {
    Id: number | null
    chanceId: number | null
    urut: number | null
  }

  export type Em_regulationsMinAggregateOutputType = {
    Id: number | null
    chanceId: number | null
    regName: string | null
    urut: number | null
    status: string | null
    userid: string | null
    createDate: Date | null
    lastUpdate: Date | null
  }

  export type Em_regulationsMaxAggregateOutputType = {
    Id: number | null
    chanceId: number | null
    regName: string | null
    urut: number | null
    status: string | null
    userid: string | null
    createDate: Date | null
    lastUpdate: Date | null
  }

  export type Em_regulationsCountAggregateOutputType = {
    Id: number
    chanceId: number
    regName: number
    urut: number
    status: number
    userid: number
    createDate: number
    lastUpdate: number
    _all: number
  }


  export type Em_regulationsAvgAggregateInputType = {
    Id?: true
    chanceId?: true
    urut?: true
  }

  export type Em_regulationsSumAggregateInputType = {
    Id?: true
    chanceId?: true
    urut?: true
  }

  export type Em_regulationsMinAggregateInputType = {
    Id?: true
    chanceId?: true
    regName?: true
    urut?: true
    status?: true
    userid?: true
    createDate?: true
    lastUpdate?: true
  }

  export type Em_regulationsMaxAggregateInputType = {
    Id?: true
    chanceId?: true
    regName?: true
    urut?: true
    status?: true
    userid?: true
    createDate?: true
    lastUpdate?: true
  }

  export type Em_regulationsCountAggregateInputType = {
    Id?: true
    chanceId?: true
    regName?: true
    urut?: true
    status?: true
    userid?: true
    createDate?: true
    lastUpdate?: true
    _all?: true
  }

  export type Em_regulationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_regulations to aggregate.
     */
    where?: em_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_regulations to fetch.
     */
    orderBy?: em_regulationsOrderByWithRelationInput | em_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_regulations
    **/
    _count?: true | Em_regulationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_regulationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_regulationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_regulationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_regulationsMaxAggregateInputType
  }

  export type GetEm_regulationsAggregateType<T extends Em_regulationsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_regulations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_regulations[P]>
      : GetScalarType<T[P], AggregateEm_regulations[P]>
  }




  export type em_regulationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_regulationsWhereInput
    orderBy?: em_regulationsOrderByWithAggregationInput | em_regulationsOrderByWithAggregationInput[]
    by: Em_regulationsScalarFieldEnum[] | Em_regulationsScalarFieldEnum
    having?: em_regulationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_regulationsCountAggregateInputType | true
    _avg?: Em_regulationsAvgAggregateInputType
    _sum?: Em_regulationsSumAggregateInputType
    _min?: Em_regulationsMinAggregateInputType
    _max?: Em_regulationsMaxAggregateInputType
  }

  export type Em_regulationsGroupByOutputType = {
    Id: number
    chanceId: number | null
    regName: string | null
    urut: number | null
    status: string | null
    userid: string | null
    createDate: Date | null
    lastUpdate: Date | null
    _count: Em_regulationsCountAggregateOutputType | null
    _avg: Em_regulationsAvgAggregateOutputType | null
    _sum: Em_regulationsSumAggregateOutputType | null
    _min: Em_regulationsMinAggregateOutputType | null
    _max: Em_regulationsMaxAggregateOutputType | null
  }

  type GetEm_regulationsGroupByPayload<T extends em_regulationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_regulationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_regulationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_regulationsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_regulationsGroupByOutputType[P]>
        }
      >
    >


  export type em_regulationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    chanceId?: boolean
    regName?: boolean
    urut?: boolean
    status?: boolean
    userid?: boolean
    createDate?: boolean
    lastUpdate?: boolean
  }, ExtArgs["result"]["em_regulations"]>



  export type em_regulationsSelectScalar = {
    Id?: boolean
    chanceId?: boolean
    regName?: boolean
    urut?: boolean
    status?: boolean
    userid?: boolean
    createDate?: boolean
    lastUpdate?: boolean
  }

  export type em_regulationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "chanceId" | "regName" | "urut" | "status" | "userid" | "createDate" | "lastUpdate", ExtArgs["result"]["em_regulations"]>

  export type $em_regulationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_regulations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      chanceId: number | null
      regName: string | null
      urut: number | null
      status: string | null
      userid: string | null
      createDate: Date | null
      lastUpdate: Date | null
    }, ExtArgs["result"]["em_regulations"]>
    composites: {}
  }

  type em_regulationsGetPayload<S extends boolean | null | undefined | em_regulationsDefaultArgs> = $Result.GetResult<Prisma.$em_regulationsPayload, S>

  type em_regulationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_regulationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_regulationsCountAggregateInputType | true
    }

  export interface em_regulationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_regulations'], meta: { name: 'em_regulations' } }
    /**
     * Find zero or one Em_regulations that matches the filter.
     * @param {em_regulationsFindUniqueArgs} args - Arguments to find a Em_regulations
     * @example
     * // Get one Em_regulations
     * const em_regulations = await prisma.em_regulations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_regulationsFindUniqueArgs>(args: SelectSubset<T, em_regulationsFindUniqueArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_regulations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_regulationsFindUniqueOrThrowArgs} args - Arguments to find a Em_regulations
     * @example
     * // Get one Em_regulations
     * const em_regulations = await prisma.em_regulations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_regulationsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_regulationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_regulationsFindFirstArgs} args - Arguments to find a Em_regulations
     * @example
     * // Get one Em_regulations
     * const em_regulations = await prisma.em_regulations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_regulationsFindFirstArgs>(args?: SelectSubset<T, em_regulationsFindFirstArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_regulations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_regulationsFindFirstOrThrowArgs} args - Arguments to find a Em_regulations
     * @example
     * // Get one Em_regulations
     * const em_regulations = await prisma.em_regulations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_regulationsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_regulationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_regulationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_regulations
     * const em_regulations = await prisma.em_regulations.findMany()
     * 
     * // Get first 10 Em_regulations
     * const em_regulations = await prisma.em_regulations.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_regulationsWithIdOnly = await prisma.em_regulations.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_regulationsFindManyArgs>(args?: SelectSubset<T, em_regulationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_regulations.
     * @param {em_regulationsCreateArgs} args - Arguments to create a Em_regulations.
     * @example
     * // Create one Em_regulations
     * const Em_regulations = await prisma.em_regulations.create({
     *   data: {
     *     // ... data to create a Em_regulations
     *   }
     * })
     * 
     */
    create<T extends em_regulationsCreateArgs>(args: SelectSubset<T, em_regulationsCreateArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_regulations.
     * @param {em_regulationsCreateManyArgs} args - Arguments to create many Em_regulations.
     * @example
     * // Create many Em_regulations
     * const em_regulations = await prisma.em_regulations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_regulationsCreateManyArgs>(args?: SelectSubset<T, em_regulationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_regulations.
     * @param {em_regulationsDeleteArgs} args - Arguments to delete one Em_regulations.
     * @example
     * // Delete one Em_regulations
     * const Em_regulations = await prisma.em_regulations.delete({
     *   where: {
     *     // ... filter to delete one Em_regulations
     *   }
     * })
     * 
     */
    delete<T extends em_regulationsDeleteArgs>(args: SelectSubset<T, em_regulationsDeleteArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_regulations.
     * @param {em_regulationsUpdateArgs} args - Arguments to update one Em_regulations.
     * @example
     * // Update one Em_regulations
     * const em_regulations = await prisma.em_regulations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_regulationsUpdateArgs>(args: SelectSubset<T, em_regulationsUpdateArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_regulations.
     * @param {em_regulationsDeleteManyArgs} args - Arguments to filter Em_regulations to delete.
     * @example
     * // Delete a few Em_regulations
     * const { count } = await prisma.em_regulations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_regulationsDeleteManyArgs>(args?: SelectSubset<T, em_regulationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_regulationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_regulations
     * const em_regulations = await prisma.em_regulations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_regulationsUpdateManyArgs>(args: SelectSubset<T, em_regulationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_regulations.
     * @param {em_regulationsUpsertArgs} args - Arguments to update or create a Em_regulations.
     * @example
     * // Update or create a Em_regulations
     * const em_regulations = await prisma.em_regulations.upsert({
     *   create: {
     *     // ... data to create a Em_regulations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_regulations we want to update
     *   }
     * })
     */
    upsert<T extends em_regulationsUpsertArgs>(args: SelectSubset<T, em_regulationsUpsertArgs<ExtArgs>>): Prisma__em_regulationsClient<$Result.GetResult<Prisma.$em_regulationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_regulationsCountArgs} args - Arguments to filter Em_regulations to count.
     * @example
     * // Count the number of Em_regulations
     * const count = await prisma.em_regulations.count({
     *   where: {
     *     // ... the filter for the Em_regulations we want to count
     *   }
     * })
    **/
    count<T extends em_regulationsCountArgs>(
      args?: Subset<T, em_regulationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_regulationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_regulationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_regulationsAggregateArgs>(args: Subset<T, Em_regulationsAggregateArgs>): Prisma.PrismaPromise<GetEm_regulationsAggregateType<T>>

    /**
     * Group by Em_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_regulationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_regulationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_regulationsGroupByArgs['orderBy'] }
        : { orderBy?: em_regulationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_regulationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_regulationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_regulations model
   */
  readonly fields: em_regulationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_regulations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_regulationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_regulations model
   */
  interface em_regulationsFieldRefs {
    readonly Id: FieldRef<"em_regulations", 'Int'>
    readonly chanceId: FieldRef<"em_regulations", 'Int'>
    readonly regName: FieldRef<"em_regulations", 'String'>
    readonly urut: FieldRef<"em_regulations", 'Int'>
    readonly status: FieldRef<"em_regulations", 'String'>
    readonly userid: FieldRef<"em_regulations", 'String'>
    readonly createDate: FieldRef<"em_regulations", 'DateTime'>
    readonly lastUpdate: FieldRef<"em_regulations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_regulations findUnique
   */
  export type em_regulationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * Filter, which em_regulations to fetch.
     */
    where: em_regulationsWhereUniqueInput
  }

  /**
   * em_regulations findUniqueOrThrow
   */
  export type em_regulationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * Filter, which em_regulations to fetch.
     */
    where: em_regulationsWhereUniqueInput
  }

  /**
   * em_regulations findFirst
   */
  export type em_regulationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * Filter, which em_regulations to fetch.
     */
    where?: em_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_regulations to fetch.
     */
    orderBy?: em_regulationsOrderByWithRelationInput | em_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_regulations.
     */
    cursor?: em_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_regulations.
     */
    distinct?: Em_regulationsScalarFieldEnum | Em_regulationsScalarFieldEnum[]
  }

  /**
   * em_regulations findFirstOrThrow
   */
  export type em_regulationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * Filter, which em_regulations to fetch.
     */
    where?: em_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_regulations to fetch.
     */
    orderBy?: em_regulationsOrderByWithRelationInput | em_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_regulations.
     */
    cursor?: em_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_regulations.
     */
    distinct?: Em_regulationsScalarFieldEnum | Em_regulationsScalarFieldEnum[]
  }

  /**
   * em_regulations findMany
   */
  export type em_regulationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * Filter, which em_regulations to fetch.
     */
    where?: em_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_regulations to fetch.
     */
    orderBy?: em_regulationsOrderByWithRelationInput | em_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_regulations.
     */
    cursor?: em_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_regulations.
     */
    skip?: number
    distinct?: Em_regulationsScalarFieldEnum | Em_regulationsScalarFieldEnum[]
  }

  /**
   * em_regulations create
   */
  export type em_regulationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * The data needed to create a em_regulations.
     */
    data?: XOR<em_regulationsCreateInput, em_regulationsUncheckedCreateInput>
  }

  /**
   * em_regulations createMany
   */
  export type em_regulationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_regulations.
     */
    data: em_regulationsCreateManyInput | em_regulationsCreateManyInput[]
  }

  /**
   * em_regulations update
   */
  export type em_regulationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * The data needed to update a em_regulations.
     */
    data: XOR<em_regulationsUpdateInput, em_regulationsUncheckedUpdateInput>
    /**
     * Choose, which em_regulations to update.
     */
    where: em_regulationsWhereUniqueInput
  }

  /**
   * em_regulations updateMany
   */
  export type em_regulationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_regulations.
     */
    data: XOR<em_regulationsUpdateManyMutationInput, em_regulationsUncheckedUpdateManyInput>
    /**
     * Filter which em_regulations to update
     */
    where?: em_regulationsWhereInput
    /**
     * Limit how many em_regulations to update.
     */
    limit?: number
  }

  /**
   * em_regulations upsert
   */
  export type em_regulationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * The filter to search for the em_regulations to update in case it exists.
     */
    where: em_regulationsWhereUniqueInput
    /**
     * In case the em_regulations found by the `where` argument doesn't exist, create a new em_regulations with this data.
     */
    create: XOR<em_regulationsCreateInput, em_regulationsUncheckedCreateInput>
    /**
     * In case the em_regulations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_regulationsUpdateInput, em_regulationsUncheckedUpdateInput>
  }

  /**
   * em_regulations delete
   */
  export type em_regulationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
    /**
     * Filter which em_regulations to delete.
     */
    where: em_regulationsWhereUniqueInput
  }

  /**
   * em_regulations deleteMany
   */
  export type em_regulationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_regulations to delete
     */
    where?: em_regulationsWhereInput
    /**
     * Limit how many em_regulations to delete.
     */
    limit?: number
  }

  /**
   * em_regulations without action
   */
  export type em_regulationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_regulations
     */
    select?: em_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_regulations
     */
    omit?: em_regulationsOmit<ExtArgs> | null
  }


  /**
   * Model em_sbu
   */

  export type AggregateEm_sbu = {
    _count: Em_sbuCountAggregateOutputType | null
    _avg: Em_sbuAvgAggregateOutputType | null
    _sum: Em_sbuSumAggregateOutputType | null
    _min: Em_sbuMinAggregateOutputType | null
    _max: Em_sbuMaxAggregateOutputType | null
  }

  export type Em_sbuAvgAggregateOutputType = {
    id: number | null
    sbu_pilar: number | null
    pic: number | null
  }

  export type Em_sbuSumAggregateOutputType = {
    id: number | null
    sbu_pilar: number | null
    pic: number | null
  }

  export type Em_sbuMinAggregateOutputType = {
    id: number | null
    sbu_code: string | null
    sbu_name: string | null
    sbu_pilar: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
  }

  export type Em_sbuMaxAggregateOutputType = {
    id: number | null
    sbu_code: string | null
    sbu_name: string | null
    sbu_pilar: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
  }

  export type Em_sbuCountAggregateOutputType = {
    id: number
    sbu_code: number
    sbu_name: number
    sbu_pilar: number
    status: number
    add_by: number
    created_at: number
    lastupdate: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    description: number
    pic: number
    _all: number
  }


  export type Em_sbuAvgAggregateInputType = {
    id?: true
    sbu_pilar?: true
    pic?: true
  }

  export type Em_sbuSumAggregateInputType = {
    id?: true
    sbu_pilar?: true
    pic?: true
  }

  export type Em_sbuMinAggregateInputType = {
    id?: true
    sbu_code?: true
    sbu_name?: true
    sbu_pilar?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
  }

  export type Em_sbuMaxAggregateInputType = {
    id?: true
    sbu_code?: true
    sbu_name?: true
    sbu_pilar?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
  }

  export type Em_sbuCountAggregateInputType = {
    id?: true
    sbu_code?: true
    sbu_name?: true
    sbu_pilar?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
    _all?: true
  }

  export type Em_sbuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_sbu to aggregate.
     */
    where?: em_sbuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbus to fetch.
     */
    orderBy?: em_sbuOrderByWithRelationInput | em_sbuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_sbuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_sbus
    **/
    _count?: true | Em_sbuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_sbuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_sbuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_sbuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_sbuMaxAggregateInputType
  }

  export type GetEm_sbuAggregateType<T extends Em_sbuAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_sbu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_sbu[P]>
      : GetScalarType<T[P], AggregateEm_sbu[P]>
  }




  export type em_sbuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_sbuWhereInput
    orderBy?: em_sbuOrderByWithAggregationInput | em_sbuOrderByWithAggregationInput[]
    by: Em_sbuScalarFieldEnum[] | Em_sbuScalarFieldEnum
    having?: em_sbuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_sbuCountAggregateInputType | true
    _avg?: Em_sbuAvgAggregateInputType
    _sum?: Em_sbuSumAggregateInputType
    _min?: Em_sbuMinAggregateInputType
    _max?: Em_sbuMaxAggregateInputType
  }

  export type Em_sbuGroupByOutputType = {
    id: number
    sbu_code: string
    sbu_name: string
    sbu_pilar: number | null
    status: string
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
    _count: Em_sbuCountAggregateOutputType | null
    _avg: Em_sbuAvgAggregateOutputType | null
    _sum: Em_sbuSumAggregateOutputType | null
    _min: Em_sbuMinAggregateOutputType | null
    _max: Em_sbuMaxAggregateOutputType | null
  }

  type GetEm_sbuGroupByPayload<T extends em_sbuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_sbuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_sbuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_sbuGroupByOutputType[P]>
            : GetScalarType<T[P], Em_sbuGroupByOutputType[P]>
        }
      >
    >


  export type em_sbuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sbu_code?: boolean
    sbu_name?: boolean
    sbu_pilar?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    description?: boolean
    pic?: boolean
  }, ExtArgs["result"]["em_sbu"]>



  export type em_sbuSelectScalar = {
    id?: boolean
    sbu_code?: boolean
    sbu_name?: boolean
    sbu_pilar?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    description?: boolean
    pic?: boolean
  }

  export type em_sbuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sbu_code" | "sbu_name" | "sbu_pilar" | "status" | "add_by" | "created_at" | "lastupdate" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy" | "description" | "pic", ExtArgs["result"]["em_sbu"]>

  export type $em_sbuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_sbu"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sbu_code: string
      sbu_name: string
      sbu_pilar: number | null
      status: string
      add_by: string | null
      created_at: Date | null
      lastupdate: Date | null
      createdAt: Date | null
      createdBy: string | null
      updatedAt: Date | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      description: string | null
      pic: number | null
    }, ExtArgs["result"]["em_sbu"]>
    composites: {}
  }

  type em_sbuGetPayload<S extends boolean | null | undefined | em_sbuDefaultArgs> = $Result.GetResult<Prisma.$em_sbuPayload, S>

  type em_sbuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_sbuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_sbuCountAggregateInputType | true
    }

  export interface em_sbuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_sbu'], meta: { name: 'em_sbu' } }
    /**
     * Find zero or one Em_sbu that matches the filter.
     * @param {em_sbuFindUniqueArgs} args - Arguments to find a Em_sbu
     * @example
     * // Get one Em_sbu
     * const em_sbu = await prisma.em_sbu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_sbuFindUniqueArgs>(args: SelectSubset<T, em_sbuFindUniqueArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_sbu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_sbuFindUniqueOrThrowArgs} args - Arguments to find a Em_sbu
     * @example
     * // Get one Em_sbu
     * const em_sbu = await prisma.em_sbu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_sbuFindUniqueOrThrowArgs>(args: SelectSubset<T, em_sbuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_sbu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbuFindFirstArgs} args - Arguments to find a Em_sbu
     * @example
     * // Get one Em_sbu
     * const em_sbu = await prisma.em_sbu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_sbuFindFirstArgs>(args?: SelectSubset<T, em_sbuFindFirstArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_sbu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbuFindFirstOrThrowArgs} args - Arguments to find a Em_sbu
     * @example
     * // Get one Em_sbu
     * const em_sbu = await prisma.em_sbu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_sbuFindFirstOrThrowArgs>(args?: SelectSubset<T, em_sbuFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_sbus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_sbus
     * const em_sbus = await prisma.em_sbu.findMany()
     * 
     * // Get first 10 Em_sbus
     * const em_sbus = await prisma.em_sbu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_sbuWithIdOnly = await prisma.em_sbu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_sbuFindManyArgs>(args?: SelectSubset<T, em_sbuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_sbu.
     * @param {em_sbuCreateArgs} args - Arguments to create a Em_sbu.
     * @example
     * // Create one Em_sbu
     * const Em_sbu = await prisma.em_sbu.create({
     *   data: {
     *     // ... data to create a Em_sbu
     *   }
     * })
     * 
     */
    create<T extends em_sbuCreateArgs>(args: SelectSubset<T, em_sbuCreateArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_sbus.
     * @param {em_sbuCreateManyArgs} args - Arguments to create many Em_sbus.
     * @example
     * // Create many Em_sbus
     * const em_sbu = await prisma.em_sbu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_sbuCreateManyArgs>(args?: SelectSubset<T, em_sbuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_sbu.
     * @param {em_sbuDeleteArgs} args - Arguments to delete one Em_sbu.
     * @example
     * // Delete one Em_sbu
     * const Em_sbu = await prisma.em_sbu.delete({
     *   where: {
     *     // ... filter to delete one Em_sbu
     *   }
     * })
     * 
     */
    delete<T extends em_sbuDeleteArgs>(args: SelectSubset<T, em_sbuDeleteArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_sbu.
     * @param {em_sbuUpdateArgs} args - Arguments to update one Em_sbu.
     * @example
     * // Update one Em_sbu
     * const em_sbu = await prisma.em_sbu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_sbuUpdateArgs>(args: SelectSubset<T, em_sbuUpdateArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_sbus.
     * @param {em_sbuDeleteManyArgs} args - Arguments to filter Em_sbus to delete.
     * @example
     * // Delete a few Em_sbus
     * const { count } = await prisma.em_sbu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_sbuDeleteManyArgs>(args?: SelectSubset<T, em_sbuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_sbus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_sbus
     * const em_sbu = await prisma.em_sbu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_sbuUpdateManyArgs>(args: SelectSubset<T, em_sbuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_sbu.
     * @param {em_sbuUpsertArgs} args - Arguments to update or create a Em_sbu.
     * @example
     * // Update or create a Em_sbu
     * const em_sbu = await prisma.em_sbu.upsert({
     *   create: {
     *     // ... data to create a Em_sbu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_sbu we want to update
     *   }
     * })
     */
    upsert<T extends em_sbuUpsertArgs>(args: SelectSubset<T, em_sbuUpsertArgs<ExtArgs>>): Prisma__em_sbuClient<$Result.GetResult<Prisma.$em_sbuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_sbus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbuCountArgs} args - Arguments to filter Em_sbus to count.
     * @example
     * // Count the number of Em_sbus
     * const count = await prisma.em_sbu.count({
     *   where: {
     *     // ... the filter for the Em_sbus we want to count
     *   }
     * })
    **/
    count<T extends em_sbuCountArgs>(
      args?: Subset<T, em_sbuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_sbuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_sbu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_sbuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_sbuAggregateArgs>(args: Subset<T, Em_sbuAggregateArgs>): Prisma.PrismaPromise<GetEm_sbuAggregateType<T>>

    /**
     * Group by Em_sbu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_sbuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_sbuGroupByArgs['orderBy'] }
        : { orderBy?: em_sbuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_sbuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_sbuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_sbu model
   */
  readonly fields: em_sbuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_sbu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_sbuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_sbu model
   */
  interface em_sbuFieldRefs {
    readonly id: FieldRef<"em_sbu", 'Int'>
    readonly sbu_code: FieldRef<"em_sbu", 'String'>
    readonly sbu_name: FieldRef<"em_sbu", 'String'>
    readonly sbu_pilar: FieldRef<"em_sbu", 'Int'>
    readonly status: FieldRef<"em_sbu", 'String'>
    readonly add_by: FieldRef<"em_sbu", 'String'>
    readonly created_at: FieldRef<"em_sbu", 'DateTime'>
    readonly lastupdate: FieldRef<"em_sbu", 'DateTime'>
    readonly createdAt: FieldRef<"em_sbu", 'DateTime'>
    readonly createdBy: FieldRef<"em_sbu", 'String'>
    readonly updatedAt: FieldRef<"em_sbu", 'DateTime'>
    readonly updatedBy: FieldRef<"em_sbu", 'String'>
    readonly isDeleted: FieldRef<"em_sbu", 'Boolean'>
    readonly deletedAt: FieldRef<"em_sbu", 'DateTime'>
    readonly deletedBy: FieldRef<"em_sbu", 'String'>
    readonly description: FieldRef<"em_sbu", 'String'>
    readonly pic: FieldRef<"em_sbu", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_sbu findUnique
   */
  export type em_sbuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu to fetch.
     */
    where: em_sbuWhereUniqueInput
  }

  /**
   * em_sbu findUniqueOrThrow
   */
  export type em_sbuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu to fetch.
     */
    where: em_sbuWhereUniqueInput
  }

  /**
   * em_sbu findFirst
   */
  export type em_sbuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu to fetch.
     */
    where?: em_sbuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbus to fetch.
     */
    orderBy?: em_sbuOrderByWithRelationInput | em_sbuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_sbus.
     */
    cursor?: em_sbuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_sbus.
     */
    distinct?: Em_sbuScalarFieldEnum | Em_sbuScalarFieldEnum[]
  }

  /**
   * em_sbu findFirstOrThrow
   */
  export type em_sbuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu to fetch.
     */
    where?: em_sbuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbus to fetch.
     */
    orderBy?: em_sbuOrderByWithRelationInput | em_sbuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_sbus.
     */
    cursor?: em_sbuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_sbus.
     */
    distinct?: Em_sbuScalarFieldEnum | Em_sbuScalarFieldEnum[]
  }

  /**
   * em_sbu findMany
   */
  export type em_sbuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * Filter, which em_sbus to fetch.
     */
    where?: em_sbuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbus to fetch.
     */
    orderBy?: em_sbuOrderByWithRelationInput | em_sbuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_sbus.
     */
    cursor?: em_sbuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbus.
     */
    skip?: number
    distinct?: Em_sbuScalarFieldEnum | Em_sbuScalarFieldEnum[]
  }

  /**
   * em_sbu create
   */
  export type em_sbuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * The data needed to create a em_sbu.
     */
    data: XOR<em_sbuCreateInput, em_sbuUncheckedCreateInput>
  }

  /**
   * em_sbu createMany
   */
  export type em_sbuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_sbus.
     */
    data: em_sbuCreateManyInput | em_sbuCreateManyInput[]
  }

  /**
   * em_sbu update
   */
  export type em_sbuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * The data needed to update a em_sbu.
     */
    data: XOR<em_sbuUpdateInput, em_sbuUncheckedUpdateInput>
    /**
     * Choose, which em_sbu to update.
     */
    where: em_sbuWhereUniqueInput
  }

  /**
   * em_sbu updateMany
   */
  export type em_sbuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_sbus.
     */
    data: XOR<em_sbuUpdateManyMutationInput, em_sbuUncheckedUpdateManyInput>
    /**
     * Filter which em_sbus to update
     */
    where?: em_sbuWhereInput
    /**
     * Limit how many em_sbus to update.
     */
    limit?: number
  }

  /**
   * em_sbu upsert
   */
  export type em_sbuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * The filter to search for the em_sbu to update in case it exists.
     */
    where: em_sbuWhereUniqueInput
    /**
     * In case the em_sbu found by the `where` argument doesn't exist, create a new em_sbu with this data.
     */
    create: XOR<em_sbuCreateInput, em_sbuUncheckedCreateInput>
    /**
     * In case the em_sbu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_sbuUpdateInput, em_sbuUncheckedUpdateInput>
  }

  /**
   * em_sbu delete
   */
  export type em_sbuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
    /**
     * Filter which em_sbu to delete.
     */
    where: em_sbuWhereUniqueInput
  }

  /**
   * em_sbu deleteMany
   */
  export type em_sbuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_sbus to delete
     */
    where?: em_sbuWhereInput
    /**
     * Limit how many em_sbus to delete.
     */
    limit?: number
  }

  /**
   * em_sbu without action
   */
  export type em_sbuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu
     */
    select?: em_sbuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu
     */
    omit?: em_sbuOmit<ExtArgs> | null
  }


  /**
   * Model em_sbu_sub
   */

  export type AggregateEm_sbu_sub = {
    _count: Em_sbu_subCountAggregateOutputType | null
    _avg: Em_sbu_subAvgAggregateOutputType | null
    _sum: Em_sbu_subSumAggregateOutputType | null
    _min: Em_sbu_subMinAggregateOutputType | null
    _max: Em_sbu_subMaxAggregateOutputType | null
  }

  export type Em_sbu_subAvgAggregateOutputType = {
    id: number | null
    sbu_id: number | null
    sbu_pilar: number | null
    pic: number | null
  }

  export type Em_sbu_subSumAggregateOutputType = {
    id: number | null
    sbu_id: number | null
    sbu_pilar: number | null
    pic: number | null
  }

  export type Em_sbu_subMinAggregateOutputType = {
    id: number | null
    sbu_sub_code: string | null
    sbu_sub_name: string | null
    sbu_id: number | null
    sbu_pilar: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
  }

  export type Em_sbu_subMaxAggregateOutputType = {
    id: number | null
    sbu_sub_code: string | null
    sbu_sub_name: string | null
    sbu_id: number | null
    sbu_pilar: number | null
    status: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
  }

  export type Em_sbu_subCountAggregateOutputType = {
    id: number
    sbu_sub_code: number
    sbu_sub_name: number
    sbu_id: number
    sbu_pilar: number
    status: number
    add_by: number
    created_at: number
    lastupdate: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    description: number
    pic: number
    _all: number
  }


  export type Em_sbu_subAvgAggregateInputType = {
    id?: true
    sbu_id?: true
    sbu_pilar?: true
    pic?: true
  }

  export type Em_sbu_subSumAggregateInputType = {
    id?: true
    sbu_id?: true
    sbu_pilar?: true
    pic?: true
  }

  export type Em_sbu_subMinAggregateInputType = {
    id?: true
    sbu_sub_code?: true
    sbu_sub_name?: true
    sbu_id?: true
    sbu_pilar?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
  }

  export type Em_sbu_subMaxAggregateInputType = {
    id?: true
    sbu_sub_code?: true
    sbu_sub_name?: true
    sbu_id?: true
    sbu_pilar?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
  }

  export type Em_sbu_subCountAggregateInputType = {
    id?: true
    sbu_sub_code?: true
    sbu_sub_name?: true
    sbu_id?: true
    sbu_pilar?: true
    status?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    description?: true
    pic?: true
    _all?: true
  }

  export type Em_sbu_subAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_sbu_sub to aggregate.
     */
    where?: em_sbu_subWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbu_subs to fetch.
     */
    orderBy?: em_sbu_subOrderByWithRelationInput | em_sbu_subOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_sbu_subWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbu_subs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbu_subs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_sbu_subs
    **/
    _count?: true | Em_sbu_subCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_sbu_subAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_sbu_subSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_sbu_subMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_sbu_subMaxAggregateInputType
  }

  export type GetEm_sbu_subAggregateType<T extends Em_sbu_subAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_sbu_sub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_sbu_sub[P]>
      : GetScalarType<T[P], AggregateEm_sbu_sub[P]>
  }




  export type em_sbu_subGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_sbu_subWhereInput
    orderBy?: em_sbu_subOrderByWithAggregationInput | em_sbu_subOrderByWithAggregationInput[]
    by: Em_sbu_subScalarFieldEnum[] | Em_sbu_subScalarFieldEnum
    having?: em_sbu_subScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_sbu_subCountAggregateInputType | true
    _avg?: Em_sbu_subAvgAggregateInputType
    _sum?: Em_sbu_subSumAggregateInputType
    _min?: Em_sbu_subMinAggregateInputType
    _max?: Em_sbu_subMaxAggregateInputType
  }

  export type Em_sbu_subGroupByOutputType = {
    id: number
    sbu_sub_code: string
    sbu_sub_name: string
    sbu_id: number | null
    sbu_pilar: number | null
    status: string
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    description: string | null
    pic: number | null
    _count: Em_sbu_subCountAggregateOutputType | null
    _avg: Em_sbu_subAvgAggregateOutputType | null
    _sum: Em_sbu_subSumAggregateOutputType | null
    _min: Em_sbu_subMinAggregateOutputType | null
    _max: Em_sbu_subMaxAggregateOutputType | null
  }

  type GetEm_sbu_subGroupByPayload<T extends em_sbu_subGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_sbu_subGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_sbu_subGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_sbu_subGroupByOutputType[P]>
            : GetScalarType<T[P], Em_sbu_subGroupByOutputType[P]>
        }
      >
    >


  export type em_sbu_subSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sbu_sub_code?: boolean
    sbu_sub_name?: boolean
    sbu_id?: boolean
    sbu_pilar?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    description?: boolean
    pic?: boolean
  }, ExtArgs["result"]["em_sbu_sub"]>



  export type em_sbu_subSelectScalar = {
    id?: boolean
    sbu_sub_code?: boolean
    sbu_sub_name?: boolean
    sbu_id?: boolean
    sbu_pilar?: boolean
    status?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    description?: boolean
    pic?: boolean
  }

  export type em_sbu_subOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sbu_sub_code" | "sbu_sub_name" | "sbu_id" | "sbu_pilar" | "status" | "add_by" | "created_at" | "lastupdate" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy" | "description" | "pic", ExtArgs["result"]["em_sbu_sub"]>

  export type $em_sbu_subPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_sbu_sub"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sbu_sub_code: string
      sbu_sub_name: string
      sbu_id: number | null
      sbu_pilar: number | null
      status: string
      add_by: string | null
      created_at: Date | null
      lastupdate: Date | null
      createdAt: Date | null
      createdBy: string | null
      updatedAt: Date | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      description: string | null
      pic: number | null
    }, ExtArgs["result"]["em_sbu_sub"]>
    composites: {}
  }

  type em_sbu_subGetPayload<S extends boolean | null | undefined | em_sbu_subDefaultArgs> = $Result.GetResult<Prisma.$em_sbu_subPayload, S>

  type em_sbu_subCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_sbu_subFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_sbu_subCountAggregateInputType | true
    }

  export interface em_sbu_subDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_sbu_sub'], meta: { name: 'em_sbu_sub' } }
    /**
     * Find zero or one Em_sbu_sub that matches the filter.
     * @param {em_sbu_subFindUniqueArgs} args - Arguments to find a Em_sbu_sub
     * @example
     * // Get one Em_sbu_sub
     * const em_sbu_sub = await prisma.em_sbu_sub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_sbu_subFindUniqueArgs>(args: SelectSubset<T, em_sbu_subFindUniqueArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_sbu_sub that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_sbu_subFindUniqueOrThrowArgs} args - Arguments to find a Em_sbu_sub
     * @example
     * // Get one Em_sbu_sub
     * const em_sbu_sub = await prisma.em_sbu_sub.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_sbu_subFindUniqueOrThrowArgs>(args: SelectSubset<T, em_sbu_subFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_sbu_sub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbu_subFindFirstArgs} args - Arguments to find a Em_sbu_sub
     * @example
     * // Get one Em_sbu_sub
     * const em_sbu_sub = await prisma.em_sbu_sub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_sbu_subFindFirstArgs>(args?: SelectSubset<T, em_sbu_subFindFirstArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_sbu_sub that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbu_subFindFirstOrThrowArgs} args - Arguments to find a Em_sbu_sub
     * @example
     * // Get one Em_sbu_sub
     * const em_sbu_sub = await prisma.em_sbu_sub.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_sbu_subFindFirstOrThrowArgs>(args?: SelectSubset<T, em_sbu_subFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_sbu_subs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbu_subFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_sbu_subs
     * const em_sbu_subs = await prisma.em_sbu_sub.findMany()
     * 
     * // Get first 10 Em_sbu_subs
     * const em_sbu_subs = await prisma.em_sbu_sub.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_sbu_subWithIdOnly = await prisma.em_sbu_sub.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_sbu_subFindManyArgs>(args?: SelectSubset<T, em_sbu_subFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_sbu_sub.
     * @param {em_sbu_subCreateArgs} args - Arguments to create a Em_sbu_sub.
     * @example
     * // Create one Em_sbu_sub
     * const Em_sbu_sub = await prisma.em_sbu_sub.create({
     *   data: {
     *     // ... data to create a Em_sbu_sub
     *   }
     * })
     * 
     */
    create<T extends em_sbu_subCreateArgs>(args: SelectSubset<T, em_sbu_subCreateArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_sbu_subs.
     * @param {em_sbu_subCreateManyArgs} args - Arguments to create many Em_sbu_subs.
     * @example
     * // Create many Em_sbu_subs
     * const em_sbu_sub = await prisma.em_sbu_sub.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_sbu_subCreateManyArgs>(args?: SelectSubset<T, em_sbu_subCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_sbu_sub.
     * @param {em_sbu_subDeleteArgs} args - Arguments to delete one Em_sbu_sub.
     * @example
     * // Delete one Em_sbu_sub
     * const Em_sbu_sub = await prisma.em_sbu_sub.delete({
     *   where: {
     *     // ... filter to delete one Em_sbu_sub
     *   }
     * })
     * 
     */
    delete<T extends em_sbu_subDeleteArgs>(args: SelectSubset<T, em_sbu_subDeleteArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_sbu_sub.
     * @param {em_sbu_subUpdateArgs} args - Arguments to update one Em_sbu_sub.
     * @example
     * // Update one Em_sbu_sub
     * const em_sbu_sub = await prisma.em_sbu_sub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_sbu_subUpdateArgs>(args: SelectSubset<T, em_sbu_subUpdateArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_sbu_subs.
     * @param {em_sbu_subDeleteManyArgs} args - Arguments to filter Em_sbu_subs to delete.
     * @example
     * // Delete a few Em_sbu_subs
     * const { count } = await prisma.em_sbu_sub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_sbu_subDeleteManyArgs>(args?: SelectSubset<T, em_sbu_subDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_sbu_subs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbu_subUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_sbu_subs
     * const em_sbu_sub = await prisma.em_sbu_sub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_sbu_subUpdateManyArgs>(args: SelectSubset<T, em_sbu_subUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_sbu_sub.
     * @param {em_sbu_subUpsertArgs} args - Arguments to update or create a Em_sbu_sub.
     * @example
     * // Update or create a Em_sbu_sub
     * const em_sbu_sub = await prisma.em_sbu_sub.upsert({
     *   create: {
     *     // ... data to create a Em_sbu_sub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_sbu_sub we want to update
     *   }
     * })
     */
    upsert<T extends em_sbu_subUpsertArgs>(args: SelectSubset<T, em_sbu_subUpsertArgs<ExtArgs>>): Prisma__em_sbu_subClient<$Result.GetResult<Prisma.$em_sbu_subPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_sbu_subs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbu_subCountArgs} args - Arguments to filter Em_sbu_subs to count.
     * @example
     * // Count the number of Em_sbu_subs
     * const count = await prisma.em_sbu_sub.count({
     *   where: {
     *     // ... the filter for the Em_sbu_subs we want to count
     *   }
     * })
    **/
    count<T extends em_sbu_subCountArgs>(
      args?: Subset<T, em_sbu_subCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_sbu_subCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_sbu_sub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_sbu_subAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_sbu_subAggregateArgs>(args: Subset<T, Em_sbu_subAggregateArgs>): Prisma.PrismaPromise<GetEm_sbu_subAggregateType<T>>

    /**
     * Group by Em_sbu_sub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_sbu_subGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_sbu_subGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_sbu_subGroupByArgs['orderBy'] }
        : { orderBy?: em_sbu_subGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_sbu_subGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_sbu_subGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_sbu_sub model
   */
  readonly fields: em_sbu_subFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_sbu_sub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_sbu_subClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_sbu_sub model
   */
  interface em_sbu_subFieldRefs {
    readonly id: FieldRef<"em_sbu_sub", 'Int'>
    readonly sbu_sub_code: FieldRef<"em_sbu_sub", 'String'>
    readonly sbu_sub_name: FieldRef<"em_sbu_sub", 'String'>
    readonly sbu_id: FieldRef<"em_sbu_sub", 'Int'>
    readonly sbu_pilar: FieldRef<"em_sbu_sub", 'Int'>
    readonly status: FieldRef<"em_sbu_sub", 'String'>
    readonly add_by: FieldRef<"em_sbu_sub", 'String'>
    readonly created_at: FieldRef<"em_sbu_sub", 'DateTime'>
    readonly lastupdate: FieldRef<"em_sbu_sub", 'DateTime'>
    readonly createdAt: FieldRef<"em_sbu_sub", 'DateTime'>
    readonly createdBy: FieldRef<"em_sbu_sub", 'String'>
    readonly updatedAt: FieldRef<"em_sbu_sub", 'DateTime'>
    readonly updatedBy: FieldRef<"em_sbu_sub", 'String'>
    readonly isDeleted: FieldRef<"em_sbu_sub", 'Boolean'>
    readonly deletedAt: FieldRef<"em_sbu_sub", 'DateTime'>
    readonly deletedBy: FieldRef<"em_sbu_sub", 'String'>
    readonly description: FieldRef<"em_sbu_sub", 'String'>
    readonly pic: FieldRef<"em_sbu_sub", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_sbu_sub findUnique
   */
  export type em_sbu_subFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu_sub to fetch.
     */
    where: em_sbu_subWhereUniqueInput
  }

  /**
   * em_sbu_sub findUniqueOrThrow
   */
  export type em_sbu_subFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu_sub to fetch.
     */
    where: em_sbu_subWhereUniqueInput
  }

  /**
   * em_sbu_sub findFirst
   */
  export type em_sbu_subFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu_sub to fetch.
     */
    where?: em_sbu_subWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbu_subs to fetch.
     */
    orderBy?: em_sbu_subOrderByWithRelationInput | em_sbu_subOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_sbu_subs.
     */
    cursor?: em_sbu_subWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbu_subs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbu_subs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_sbu_subs.
     */
    distinct?: Em_sbu_subScalarFieldEnum | Em_sbu_subScalarFieldEnum[]
  }

  /**
   * em_sbu_sub findFirstOrThrow
   */
  export type em_sbu_subFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu_sub to fetch.
     */
    where?: em_sbu_subWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbu_subs to fetch.
     */
    orderBy?: em_sbu_subOrderByWithRelationInput | em_sbu_subOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_sbu_subs.
     */
    cursor?: em_sbu_subWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbu_subs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbu_subs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_sbu_subs.
     */
    distinct?: Em_sbu_subScalarFieldEnum | Em_sbu_subScalarFieldEnum[]
  }

  /**
   * em_sbu_sub findMany
   */
  export type em_sbu_subFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * Filter, which em_sbu_subs to fetch.
     */
    where?: em_sbu_subWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_sbu_subs to fetch.
     */
    orderBy?: em_sbu_subOrderByWithRelationInput | em_sbu_subOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_sbu_subs.
     */
    cursor?: em_sbu_subWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_sbu_subs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_sbu_subs.
     */
    skip?: number
    distinct?: Em_sbu_subScalarFieldEnum | Em_sbu_subScalarFieldEnum[]
  }

  /**
   * em_sbu_sub create
   */
  export type em_sbu_subCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * The data needed to create a em_sbu_sub.
     */
    data: XOR<em_sbu_subCreateInput, em_sbu_subUncheckedCreateInput>
  }

  /**
   * em_sbu_sub createMany
   */
  export type em_sbu_subCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_sbu_subs.
     */
    data: em_sbu_subCreateManyInput | em_sbu_subCreateManyInput[]
  }

  /**
   * em_sbu_sub update
   */
  export type em_sbu_subUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * The data needed to update a em_sbu_sub.
     */
    data: XOR<em_sbu_subUpdateInput, em_sbu_subUncheckedUpdateInput>
    /**
     * Choose, which em_sbu_sub to update.
     */
    where: em_sbu_subWhereUniqueInput
  }

  /**
   * em_sbu_sub updateMany
   */
  export type em_sbu_subUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_sbu_subs.
     */
    data: XOR<em_sbu_subUpdateManyMutationInput, em_sbu_subUncheckedUpdateManyInput>
    /**
     * Filter which em_sbu_subs to update
     */
    where?: em_sbu_subWhereInput
    /**
     * Limit how many em_sbu_subs to update.
     */
    limit?: number
  }

  /**
   * em_sbu_sub upsert
   */
  export type em_sbu_subUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * The filter to search for the em_sbu_sub to update in case it exists.
     */
    where: em_sbu_subWhereUniqueInput
    /**
     * In case the em_sbu_sub found by the `where` argument doesn't exist, create a new em_sbu_sub with this data.
     */
    create: XOR<em_sbu_subCreateInput, em_sbu_subUncheckedCreateInput>
    /**
     * In case the em_sbu_sub was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_sbu_subUpdateInput, em_sbu_subUncheckedUpdateInput>
  }

  /**
   * em_sbu_sub delete
   */
  export type em_sbu_subDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
    /**
     * Filter which em_sbu_sub to delete.
     */
    where: em_sbu_subWhereUniqueInput
  }

  /**
   * em_sbu_sub deleteMany
   */
  export type em_sbu_subDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_sbu_subs to delete
     */
    where?: em_sbu_subWhereInput
    /**
     * Limit how many em_sbu_subs to delete.
     */
    limit?: number
  }

  /**
   * em_sbu_sub without action
   */
  export type em_sbu_subDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_sbu_sub
     */
    select?: em_sbu_subSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_sbu_sub
     */
    omit?: em_sbu_subOmit<ExtArgs> | null
  }


  /**
   * Model em_schedule1
   */

  export type AggregateEm_schedule1 = {
    _count: Em_schedule1CountAggregateOutputType | null
    _avg: Em_schedule1AvgAggregateOutputType | null
    _sum: Em_schedule1SumAggregateOutputType | null
    _min: Em_schedule1MinAggregateOutputType | null
    _max: Em_schedule1MaxAggregateOutputType | null
  }

  export type Em_schedule1AvgAggregateOutputType = {
    Id: number | null
    isMateri: number | null
    isQuota: number | null
    sendWA: number | null
    is_wa_template: number | null
    event_id: number | null
  }

  export type Em_schedule1SumAggregateOutputType = {
    Id: number | null
    isMateri: number | null
    isQuota: number | null
    sendWA: number | null
    is_wa_template: number | null
    event_id: number | null
  }

  export type Em_schedule1MinAggregateOutputType = {
    Id: number | null
    scheName: string | null
    scheDeskripsi: string | null
    isMateri: number | null
    isQuota: number | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    isLokasi: string | null
    isTrainer: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    sendWA: number | null
    ujian_stats: string | null
    is_with_soal: string | null
    usr_by: string | null
    is_wa_template: number | null
    is_batch: string | null
    event_id: number | null
  }

  export type Em_schedule1MaxAggregateOutputType = {
    Id: number | null
    scheName: string | null
    scheDeskripsi: string | null
    isMateri: number | null
    isQuota: number | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    isLokasi: string | null
    isTrainer: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    sendWA: number | null
    ujian_stats: string | null
    is_with_soal: string | null
    usr_by: string | null
    is_wa_template: number | null
    is_batch: string | null
    event_id: number | null
  }

  export type Em_schedule1CountAggregateOutputType = {
    Id: number
    scheName: number
    scheDeskripsi: number
    isMateri: number
    isQuota: number
    startDate: number
    endDate: number
    startTime: number
    endTime: number
    isLokasi: number
    isTrainer: number
    status: number
    created_at: number
    lastupdate: number
    sendWA: number
    ujian_stats: number
    is_with_soal: number
    usr_by: number
    is_wa_template: number
    is_batch: number
    event_id: number
    _all: number
  }


  export type Em_schedule1AvgAggregateInputType = {
    Id?: true
    isMateri?: true
    isQuota?: true
    sendWA?: true
    is_wa_template?: true
    event_id?: true
  }

  export type Em_schedule1SumAggregateInputType = {
    Id?: true
    isMateri?: true
    isQuota?: true
    sendWA?: true
    is_wa_template?: true
    event_id?: true
  }

  export type Em_schedule1MinAggregateInputType = {
    Id?: true
    scheName?: true
    scheDeskripsi?: true
    isMateri?: true
    isQuota?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    isLokasi?: true
    isTrainer?: true
    status?: true
    created_at?: true
    lastupdate?: true
    sendWA?: true
    ujian_stats?: true
    is_with_soal?: true
    usr_by?: true
    is_wa_template?: true
    is_batch?: true
    event_id?: true
  }

  export type Em_schedule1MaxAggregateInputType = {
    Id?: true
    scheName?: true
    scheDeskripsi?: true
    isMateri?: true
    isQuota?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    isLokasi?: true
    isTrainer?: true
    status?: true
    created_at?: true
    lastupdate?: true
    sendWA?: true
    ujian_stats?: true
    is_with_soal?: true
    usr_by?: true
    is_wa_template?: true
    is_batch?: true
    event_id?: true
  }

  export type Em_schedule1CountAggregateInputType = {
    Id?: true
    scheName?: true
    scheDeskripsi?: true
    isMateri?: true
    isQuota?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    isLokasi?: true
    isTrainer?: true
    status?: true
    created_at?: true
    lastupdate?: true
    sendWA?: true
    ujian_stats?: true
    is_with_soal?: true
    usr_by?: true
    is_wa_template?: true
    is_batch?: true
    event_id?: true
    _all?: true
  }

  export type Em_schedule1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule1 to aggregate.
     */
    where?: em_schedule1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule1s to fetch.
     */
    orderBy?: em_schedule1OrderByWithRelationInput | em_schedule1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_schedule1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_schedule1s
    **/
    _count?: true | Em_schedule1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_schedule1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_schedule1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_schedule1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_schedule1MaxAggregateInputType
  }

  export type GetEm_schedule1AggregateType<T extends Em_schedule1AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_schedule1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_schedule1[P]>
      : GetScalarType<T[P], AggregateEm_schedule1[P]>
  }




  export type em_schedule1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule1WhereInput
    orderBy?: em_schedule1OrderByWithAggregationInput | em_schedule1OrderByWithAggregationInput[]
    by: Em_schedule1ScalarFieldEnum[] | Em_schedule1ScalarFieldEnum
    having?: em_schedule1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_schedule1CountAggregateInputType | true
    _avg?: Em_schedule1AvgAggregateInputType
    _sum?: Em_schedule1SumAggregateInputType
    _min?: Em_schedule1MinAggregateInputType
    _max?: Em_schedule1MaxAggregateInputType
  }

  export type Em_schedule1GroupByOutputType = {
    Id: number
    scheName: string | null
    scheDeskripsi: string | null
    isMateri: number | null
    isQuota: number | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    isLokasi: string | null
    isTrainer: string | null
    status: string | null
    created_at: Date | null
    lastupdate: Date | null
    sendWA: number | null
    ujian_stats: string | null
    is_with_soal: string | null
    usr_by: string | null
    is_wa_template: number | null
    is_batch: string | null
    event_id: number | null
    _count: Em_schedule1CountAggregateOutputType | null
    _avg: Em_schedule1AvgAggregateOutputType | null
    _sum: Em_schedule1SumAggregateOutputType | null
    _min: Em_schedule1MinAggregateOutputType | null
    _max: Em_schedule1MaxAggregateOutputType | null
  }

  type GetEm_schedule1GroupByPayload<T extends em_schedule1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_schedule1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_schedule1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_schedule1GroupByOutputType[P]>
            : GetScalarType<T[P], Em_schedule1GroupByOutputType[P]>
        }
      >
    >


  export type em_schedule1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    scheName?: boolean
    scheDeskripsi?: boolean
    isMateri?: boolean
    isQuota?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isLokasi?: boolean
    isTrainer?: boolean
    status?: boolean
    created_at?: boolean
    lastupdate?: boolean
    sendWA?: boolean
    ujian_stats?: boolean
    is_with_soal?: boolean
    usr_by?: boolean
    is_wa_template?: boolean
    is_batch?: boolean
    event_id?: boolean
    em_schedule2?: boolean | em_schedule1$em_schedule2Args<ExtArgs>
    em_schedule3?: boolean | em_schedule1$em_schedule3Args<ExtArgs>
    em_schedule4?: boolean | em_schedule1$em_schedule4Args<ExtArgs>
    _count?: boolean | Em_schedule1CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_schedule1"]>



  export type em_schedule1SelectScalar = {
    Id?: boolean
    scheName?: boolean
    scheDeskripsi?: boolean
    isMateri?: boolean
    isQuota?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isLokasi?: boolean
    isTrainer?: boolean
    status?: boolean
    created_at?: boolean
    lastupdate?: boolean
    sendWA?: boolean
    ujian_stats?: boolean
    is_with_soal?: boolean
    usr_by?: boolean
    is_wa_template?: boolean
    is_batch?: boolean
    event_id?: boolean
  }

  export type em_schedule1Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "scheName" | "scheDeskripsi" | "isMateri" | "isQuota" | "startDate" | "endDate" | "startTime" | "endTime" | "isLokasi" | "isTrainer" | "status" | "created_at" | "lastupdate" | "sendWA" | "ujian_stats" | "is_with_soal" | "usr_by" | "is_wa_template" | "is_batch" | "event_id", ExtArgs["result"]["em_schedule1"]>
  export type em_schedule1Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_schedule2?: boolean | em_schedule1$em_schedule2Args<ExtArgs>
    em_schedule3?: boolean | em_schedule1$em_schedule3Args<ExtArgs>
    em_schedule4?: boolean | em_schedule1$em_schedule4Args<ExtArgs>
    _count?: boolean | Em_schedule1CountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_schedule1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_schedule1"
    objects: {
      em_schedule2: Prisma.$em_schedule2Payload<ExtArgs>[]
      em_schedule3: Prisma.$em_schedule3Payload<ExtArgs>[]
      em_schedule4: Prisma.$em_schedule4Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      scheName: string | null
      scheDeskripsi: string | null
      isMateri: number | null
      isQuota: number | null
      startDate: Date | null
      endDate: Date | null
      startTime: string | null
      endTime: string | null
      isLokasi: string | null
      isTrainer: string | null
      status: string | null
      created_at: Date | null
      lastupdate: Date | null
      sendWA: number | null
      ujian_stats: string | null
      is_with_soal: string | null
      usr_by: string | null
      is_wa_template: number | null
      is_batch: string | null
      event_id: number | null
    }, ExtArgs["result"]["em_schedule1"]>
    composites: {}
  }

  type em_schedule1GetPayload<S extends boolean | null | undefined | em_schedule1DefaultArgs> = $Result.GetResult<Prisma.$em_schedule1Payload, S>

  type em_schedule1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_schedule1FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_schedule1CountAggregateInputType | true
    }

  export interface em_schedule1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_schedule1'], meta: { name: 'em_schedule1' } }
    /**
     * Find zero or one Em_schedule1 that matches the filter.
     * @param {em_schedule1FindUniqueArgs} args - Arguments to find a Em_schedule1
     * @example
     * // Get one Em_schedule1
     * const em_schedule1 = await prisma.em_schedule1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_schedule1FindUniqueArgs>(args: SelectSubset<T, em_schedule1FindUniqueArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_schedule1 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_schedule1FindUniqueOrThrowArgs} args - Arguments to find a Em_schedule1
     * @example
     * // Get one Em_schedule1
     * const em_schedule1 = await prisma.em_schedule1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_schedule1FindUniqueOrThrowArgs>(args: SelectSubset<T, em_schedule1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule1FindFirstArgs} args - Arguments to find a Em_schedule1
     * @example
     * // Get one Em_schedule1
     * const em_schedule1 = await prisma.em_schedule1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_schedule1FindFirstArgs>(args?: SelectSubset<T, em_schedule1FindFirstArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule1FindFirstOrThrowArgs} args - Arguments to find a Em_schedule1
     * @example
     * // Get one Em_schedule1
     * const em_schedule1 = await prisma.em_schedule1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_schedule1FindFirstOrThrowArgs>(args?: SelectSubset<T, em_schedule1FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_schedule1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_schedule1s
     * const em_schedule1s = await prisma.em_schedule1.findMany()
     * 
     * // Get first 10 Em_schedule1s
     * const em_schedule1s = await prisma.em_schedule1.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_schedule1WithIdOnly = await prisma.em_schedule1.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_schedule1FindManyArgs>(args?: SelectSubset<T, em_schedule1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_schedule1.
     * @param {em_schedule1CreateArgs} args - Arguments to create a Em_schedule1.
     * @example
     * // Create one Em_schedule1
     * const Em_schedule1 = await prisma.em_schedule1.create({
     *   data: {
     *     // ... data to create a Em_schedule1
     *   }
     * })
     * 
     */
    create<T extends em_schedule1CreateArgs>(args: SelectSubset<T, em_schedule1CreateArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_schedule1s.
     * @param {em_schedule1CreateManyArgs} args - Arguments to create many Em_schedule1s.
     * @example
     * // Create many Em_schedule1s
     * const em_schedule1 = await prisma.em_schedule1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_schedule1CreateManyArgs>(args?: SelectSubset<T, em_schedule1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_schedule1.
     * @param {em_schedule1DeleteArgs} args - Arguments to delete one Em_schedule1.
     * @example
     * // Delete one Em_schedule1
     * const Em_schedule1 = await prisma.em_schedule1.delete({
     *   where: {
     *     // ... filter to delete one Em_schedule1
     *   }
     * })
     * 
     */
    delete<T extends em_schedule1DeleteArgs>(args: SelectSubset<T, em_schedule1DeleteArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_schedule1.
     * @param {em_schedule1UpdateArgs} args - Arguments to update one Em_schedule1.
     * @example
     * // Update one Em_schedule1
     * const em_schedule1 = await prisma.em_schedule1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_schedule1UpdateArgs>(args: SelectSubset<T, em_schedule1UpdateArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_schedule1s.
     * @param {em_schedule1DeleteManyArgs} args - Arguments to filter Em_schedule1s to delete.
     * @example
     * // Delete a few Em_schedule1s
     * const { count } = await prisma.em_schedule1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_schedule1DeleteManyArgs>(args?: SelectSubset<T, em_schedule1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_schedule1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_schedule1s
     * const em_schedule1 = await prisma.em_schedule1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_schedule1UpdateManyArgs>(args: SelectSubset<T, em_schedule1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_schedule1.
     * @param {em_schedule1UpsertArgs} args - Arguments to update or create a Em_schedule1.
     * @example
     * // Update or create a Em_schedule1
     * const em_schedule1 = await prisma.em_schedule1.upsert({
     *   create: {
     *     // ... data to create a Em_schedule1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_schedule1 we want to update
     *   }
     * })
     */
    upsert<T extends em_schedule1UpsertArgs>(args: SelectSubset<T, em_schedule1UpsertArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_schedule1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule1CountArgs} args - Arguments to filter Em_schedule1s to count.
     * @example
     * // Count the number of Em_schedule1s
     * const count = await prisma.em_schedule1.count({
     *   where: {
     *     // ... the filter for the Em_schedule1s we want to count
     *   }
     * })
    **/
    count<T extends em_schedule1CountArgs>(
      args?: Subset<T, em_schedule1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_schedule1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_schedule1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_schedule1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_schedule1AggregateArgs>(args: Subset<T, Em_schedule1AggregateArgs>): Prisma.PrismaPromise<GetEm_schedule1AggregateType<T>>

    /**
     * Group by Em_schedule1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_schedule1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_schedule1GroupByArgs['orderBy'] }
        : { orderBy?: em_schedule1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_schedule1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_schedule1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_schedule1 model
   */
  readonly fields: em_schedule1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_schedule1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_schedule1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_schedule2<T extends em_schedule1$em_schedule2Args<ExtArgs> = {}>(args?: Subset<T, em_schedule1$em_schedule2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_schedule3<T extends em_schedule1$em_schedule3Args<ExtArgs> = {}>(args?: Subset<T, em_schedule1$em_schedule3Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_schedule4<T extends em_schedule1$em_schedule4Args<ExtArgs> = {}>(args?: Subset<T, em_schedule1$em_schedule4Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_schedule1 model
   */
  interface em_schedule1FieldRefs {
    readonly Id: FieldRef<"em_schedule1", 'Int'>
    readonly scheName: FieldRef<"em_schedule1", 'String'>
    readonly scheDeskripsi: FieldRef<"em_schedule1", 'String'>
    readonly isMateri: FieldRef<"em_schedule1", 'Int'>
    readonly isQuota: FieldRef<"em_schedule1", 'Int'>
    readonly startDate: FieldRef<"em_schedule1", 'DateTime'>
    readonly endDate: FieldRef<"em_schedule1", 'DateTime'>
    readonly startTime: FieldRef<"em_schedule1", 'String'>
    readonly endTime: FieldRef<"em_schedule1", 'String'>
    readonly isLokasi: FieldRef<"em_schedule1", 'String'>
    readonly isTrainer: FieldRef<"em_schedule1", 'String'>
    readonly status: FieldRef<"em_schedule1", 'String'>
    readonly created_at: FieldRef<"em_schedule1", 'DateTime'>
    readonly lastupdate: FieldRef<"em_schedule1", 'DateTime'>
    readonly sendWA: FieldRef<"em_schedule1", 'Int'>
    readonly ujian_stats: FieldRef<"em_schedule1", 'String'>
    readonly is_with_soal: FieldRef<"em_schedule1", 'String'>
    readonly usr_by: FieldRef<"em_schedule1", 'String'>
    readonly is_wa_template: FieldRef<"em_schedule1", 'Int'>
    readonly is_batch: FieldRef<"em_schedule1", 'String'>
    readonly event_id: FieldRef<"em_schedule1", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_schedule1 findUnique
   */
  export type em_schedule1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * Filter, which em_schedule1 to fetch.
     */
    where: em_schedule1WhereUniqueInput
  }

  /**
   * em_schedule1 findUniqueOrThrow
   */
  export type em_schedule1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * Filter, which em_schedule1 to fetch.
     */
    where: em_schedule1WhereUniqueInput
  }

  /**
   * em_schedule1 findFirst
   */
  export type em_schedule1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * Filter, which em_schedule1 to fetch.
     */
    where?: em_schedule1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule1s to fetch.
     */
    orderBy?: em_schedule1OrderByWithRelationInput | em_schedule1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule1s.
     */
    cursor?: em_schedule1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule1s.
     */
    distinct?: Em_schedule1ScalarFieldEnum | Em_schedule1ScalarFieldEnum[]
  }

  /**
   * em_schedule1 findFirstOrThrow
   */
  export type em_schedule1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * Filter, which em_schedule1 to fetch.
     */
    where?: em_schedule1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule1s to fetch.
     */
    orderBy?: em_schedule1OrderByWithRelationInput | em_schedule1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule1s.
     */
    cursor?: em_schedule1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule1s.
     */
    distinct?: Em_schedule1ScalarFieldEnum | Em_schedule1ScalarFieldEnum[]
  }

  /**
   * em_schedule1 findMany
   */
  export type em_schedule1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * Filter, which em_schedule1s to fetch.
     */
    where?: em_schedule1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule1s to fetch.
     */
    orderBy?: em_schedule1OrderByWithRelationInput | em_schedule1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_schedule1s.
     */
    cursor?: em_schedule1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule1s.
     */
    skip?: number
    distinct?: Em_schedule1ScalarFieldEnum | Em_schedule1ScalarFieldEnum[]
  }

  /**
   * em_schedule1 create
   */
  export type em_schedule1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * The data needed to create a em_schedule1.
     */
    data?: XOR<em_schedule1CreateInput, em_schedule1UncheckedCreateInput>
  }

  /**
   * em_schedule1 createMany
   */
  export type em_schedule1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_schedule1s.
     */
    data: em_schedule1CreateManyInput | em_schedule1CreateManyInput[]
  }

  /**
   * em_schedule1 update
   */
  export type em_schedule1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * The data needed to update a em_schedule1.
     */
    data: XOR<em_schedule1UpdateInput, em_schedule1UncheckedUpdateInput>
    /**
     * Choose, which em_schedule1 to update.
     */
    where: em_schedule1WhereUniqueInput
  }

  /**
   * em_schedule1 updateMany
   */
  export type em_schedule1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_schedule1s.
     */
    data: XOR<em_schedule1UpdateManyMutationInput, em_schedule1UncheckedUpdateManyInput>
    /**
     * Filter which em_schedule1s to update
     */
    where?: em_schedule1WhereInput
    /**
     * Limit how many em_schedule1s to update.
     */
    limit?: number
  }

  /**
   * em_schedule1 upsert
   */
  export type em_schedule1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * The filter to search for the em_schedule1 to update in case it exists.
     */
    where: em_schedule1WhereUniqueInput
    /**
     * In case the em_schedule1 found by the `where` argument doesn't exist, create a new em_schedule1 with this data.
     */
    create: XOR<em_schedule1CreateInput, em_schedule1UncheckedCreateInput>
    /**
     * In case the em_schedule1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_schedule1UpdateInput, em_schedule1UncheckedUpdateInput>
  }

  /**
   * em_schedule1 delete
   */
  export type em_schedule1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    /**
     * Filter which em_schedule1 to delete.
     */
    where: em_schedule1WhereUniqueInput
  }

  /**
   * em_schedule1 deleteMany
   */
  export type em_schedule1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule1s to delete
     */
    where?: em_schedule1WhereInput
    /**
     * Limit how many em_schedule1s to delete.
     */
    limit?: number
  }

  /**
   * em_schedule1.em_schedule2
   */
  export type em_schedule1$em_schedule2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    where?: em_schedule2WhereInput
    orderBy?: em_schedule2OrderByWithRelationInput | em_schedule2OrderByWithRelationInput[]
    cursor?: em_schedule2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_schedule2ScalarFieldEnum | Em_schedule2ScalarFieldEnum[]
  }

  /**
   * em_schedule1.em_schedule3
   */
  export type em_schedule1$em_schedule3Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    where?: em_schedule3WhereInput
    orderBy?: em_schedule3OrderByWithRelationInput | em_schedule3OrderByWithRelationInput[]
    cursor?: em_schedule3WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_schedule3ScalarFieldEnum | Em_schedule3ScalarFieldEnum[]
  }

  /**
   * em_schedule1.em_schedule4
   */
  export type em_schedule1$em_schedule4Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    where?: em_schedule4WhereInput
    orderBy?: em_schedule4OrderByWithRelationInput | em_schedule4OrderByWithRelationInput[]
    cursor?: em_schedule4WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_schedule4ScalarFieldEnum | Em_schedule4ScalarFieldEnum[]
  }

  /**
   * em_schedule1 without action
   */
  export type em_schedule1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
  }


  /**
   * Model em_schedule2
   */

  export type AggregateEm_schedule2 = {
    _count: Em_schedule2CountAggregateOutputType | null
    _avg: Em_schedule2AvgAggregateOutputType | null
    _sum: Em_schedule2SumAggregateOutputType | null
    _min: Em_schedule2MinAggregateOutputType | null
    _max: Em_schedule2MaxAggregateOutputType | null
  }

  export type Em_schedule2AvgAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    employeeId: number | null
    is_send_wa_stats: number | null
  }

  export type Em_schedule2SumAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    employeeId: number | null
    is_send_wa_stats: number | null
  }

  export type Em_schedule2MinAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    employeeId: number | null
    Regid: string | null
    is_send_wa_stats: number | null
    send_date: Date | null
    is_code_send: string | null
  }

  export type Em_schedule2MaxAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    employeeId: number | null
    Regid: string | null
    is_send_wa_stats: number | null
    send_date: Date | null
    is_code_send: string | null
  }

  export type Em_schedule2CountAggregateOutputType = {
    Id: number
    scheduleId: number
    employeeId: number
    Regid: number
    is_send_wa_stats: number
    send_date: number
    is_code_send: number
    _all: number
  }


  export type Em_schedule2AvgAggregateInputType = {
    Id?: true
    scheduleId?: true
    employeeId?: true
    is_send_wa_stats?: true
  }

  export type Em_schedule2SumAggregateInputType = {
    Id?: true
    scheduleId?: true
    employeeId?: true
    is_send_wa_stats?: true
  }

  export type Em_schedule2MinAggregateInputType = {
    Id?: true
    scheduleId?: true
    employeeId?: true
    Regid?: true
    is_send_wa_stats?: true
    send_date?: true
    is_code_send?: true
  }

  export type Em_schedule2MaxAggregateInputType = {
    Id?: true
    scheduleId?: true
    employeeId?: true
    Regid?: true
    is_send_wa_stats?: true
    send_date?: true
    is_code_send?: true
  }

  export type Em_schedule2CountAggregateInputType = {
    Id?: true
    scheduleId?: true
    employeeId?: true
    Regid?: true
    is_send_wa_stats?: true
    send_date?: true
    is_code_send?: true
    _all?: true
  }

  export type Em_schedule2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule2 to aggregate.
     */
    where?: em_schedule2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule2s to fetch.
     */
    orderBy?: em_schedule2OrderByWithRelationInput | em_schedule2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_schedule2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_schedule2s
    **/
    _count?: true | Em_schedule2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_schedule2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_schedule2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_schedule2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_schedule2MaxAggregateInputType
  }

  export type GetEm_schedule2AggregateType<T extends Em_schedule2AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_schedule2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_schedule2[P]>
      : GetScalarType<T[P], AggregateEm_schedule2[P]>
  }




  export type em_schedule2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule2WhereInput
    orderBy?: em_schedule2OrderByWithAggregationInput | em_schedule2OrderByWithAggregationInput[]
    by: Em_schedule2ScalarFieldEnum[] | Em_schedule2ScalarFieldEnum
    having?: em_schedule2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_schedule2CountAggregateInputType | true
    _avg?: Em_schedule2AvgAggregateInputType
    _sum?: Em_schedule2SumAggregateInputType
    _min?: Em_schedule2MinAggregateInputType
    _max?: Em_schedule2MaxAggregateInputType
  }

  export type Em_schedule2GroupByOutputType = {
    Id: number
    scheduleId: number | null
    employeeId: number | null
    Regid: string | null
    is_send_wa_stats: number | null
    send_date: Date | null
    is_code_send: string | null
    _count: Em_schedule2CountAggregateOutputType | null
    _avg: Em_schedule2AvgAggregateOutputType | null
    _sum: Em_schedule2SumAggregateOutputType | null
    _min: Em_schedule2MinAggregateOutputType | null
    _max: Em_schedule2MaxAggregateOutputType | null
  }

  type GetEm_schedule2GroupByPayload<T extends em_schedule2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_schedule2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_schedule2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_schedule2GroupByOutputType[P]>
            : GetScalarType<T[P], Em_schedule2GroupByOutputType[P]>
        }
      >
    >


  export type em_schedule2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    scheduleId?: boolean
    employeeId?: boolean
    Regid?: boolean
    is_send_wa_stats?: boolean
    send_date?: boolean
    is_code_send?: boolean
    em_schedule1?: boolean | em_schedule2$em_schedule1Args<ExtArgs>
  }, ExtArgs["result"]["em_schedule2"]>



  export type em_schedule2SelectScalar = {
    Id?: boolean
    scheduleId?: boolean
    employeeId?: boolean
    Regid?: boolean
    is_send_wa_stats?: boolean
    send_date?: boolean
    is_code_send?: boolean
  }

  export type em_schedule2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "scheduleId" | "employeeId" | "Regid" | "is_send_wa_stats" | "send_date" | "is_code_send", ExtArgs["result"]["em_schedule2"]>
  export type em_schedule2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_schedule1?: boolean | em_schedule2$em_schedule1Args<ExtArgs>
  }

  export type $em_schedule2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_schedule2"
    objects: {
      em_schedule1: Prisma.$em_schedule1Payload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      scheduleId: number | null
      employeeId: number | null
      Regid: string | null
      is_send_wa_stats: number | null
      send_date: Date | null
      is_code_send: string | null
    }, ExtArgs["result"]["em_schedule2"]>
    composites: {}
  }

  type em_schedule2GetPayload<S extends boolean | null | undefined | em_schedule2DefaultArgs> = $Result.GetResult<Prisma.$em_schedule2Payload, S>

  type em_schedule2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_schedule2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_schedule2CountAggregateInputType | true
    }

  export interface em_schedule2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_schedule2'], meta: { name: 'em_schedule2' } }
    /**
     * Find zero or one Em_schedule2 that matches the filter.
     * @param {em_schedule2FindUniqueArgs} args - Arguments to find a Em_schedule2
     * @example
     * // Get one Em_schedule2
     * const em_schedule2 = await prisma.em_schedule2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_schedule2FindUniqueArgs>(args: SelectSubset<T, em_schedule2FindUniqueArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_schedule2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_schedule2FindUniqueOrThrowArgs} args - Arguments to find a Em_schedule2
     * @example
     * // Get one Em_schedule2
     * const em_schedule2 = await prisma.em_schedule2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_schedule2FindUniqueOrThrowArgs>(args: SelectSubset<T, em_schedule2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule2FindFirstArgs} args - Arguments to find a Em_schedule2
     * @example
     * // Get one Em_schedule2
     * const em_schedule2 = await prisma.em_schedule2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_schedule2FindFirstArgs>(args?: SelectSubset<T, em_schedule2FindFirstArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule2FindFirstOrThrowArgs} args - Arguments to find a Em_schedule2
     * @example
     * // Get one Em_schedule2
     * const em_schedule2 = await prisma.em_schedule2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_schedule2FindFirstOrThrowArgs>(args?: SelectSubset<T, em_schedule2FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_schedule2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_schedule2s
     * const em_schedule2s = await prisma.em_schedule2.findMany()
     * 
     * // Get first 10 Em_schedule2s
     * const em_schedule2s = await prisma.em_schedule2.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_schedule2WithIdOnly = await prisma.em_schedule2.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_schedule2FindManyArgs>(args?: SelectSubset<T, em_schedule2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_schedule2.
     * @param {em_schedule2CreateArgs} args - Arguments to create a Em_schedule2.
     * @example
     * // Create one Em_schedule2
     * const Em_schedule2 = await prisma.em_schedule2.create({
     *   data: {
     *     // ... data to create a Em_schedule2
     *   }
     * })
     * 
     */
    create<T extends em_schedule2CreateArgs>(args: SelectSubset<T, em_schedule2CreateArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_schedule2s.
     * @param {em_schedule2CreateManyArgs} args - Arguments to create many Em_schedule2s.
     * @example
     * // Create many Em_schedule2s
     * const em_schedule2 = await prisma.em_schedule2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_schedule2CreateManyArgs>(args?: SelectSubset<T, em_schedule2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_schedule2.
     * @param {em_schedule2DeleteArgs} args - Arguments to delete one Em_schedule2.
     * @example
     * // Delete one Em_schedule2
     * const Em_schedule2 = await prisma.em_schedule2.delete({
     *   where: {
     *     // ... filter to delete one Em_schedule2
     *   }
     * })
     * 
     */
    delete<T extends em_schedule2DeleteArgs>(args: SelectSubset<T, em_schedule2DeleteArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_schedule2.
     * @param {em_schedule2UpdateArgs} args - Arguments to update one Em_schedule2.
     * @example
     * // Update one Em_schedule2
     * const em_schedule2 = await prisma.em_schedule2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_schedule2UpdateArgs>(args: SelectSubset<T, em_schedule2UpdateArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_schedule2s.
     * @param {em_schedule2DeleteManyArgs} args - Arguments to filter Em_schedule2s to delete.
     * @example
     * // Delete a few Em_schedule2s
     * const { count } = await prisma.em_schedule2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_schedule2DeleteManyArgs>(args?: SelectSubset<T, em_schedule2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_schedule2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_schedule2s
     * const em_schedule2 = await prisma.em_schedule2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_schedule2UpdateManyArgs>(args: SelectSubset<T, em_schedule2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_schedule2.
     * @param {em_schedule2UpsertArgs} args - Arguments to update or create a Em_schedule2.
     * @example
     * // Update or create a Em_schedule2
     * const em_schedule2 = await prisma.em_schedule2.upsert({
     *   create: {
     *     // ... data to create a Em_schedule2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_schedule2 we want to update
     *   }
     * })
     */
    upsert<T extends em_schedule2UpsertArgs>(args: SelectSubset<T, em_schedule2UpsertArgs<ExtArgs>>): Prisma__em_schedule2Client<$Result.GetResult<Prisma.$em_schedule2Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_schedule2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule2CountArgs} args - Arguments to filter Em_schedule2s to count.
     * @example
     * // Count the number of Em_schedule2s
     * const count = await prisma.em_schedule2.count({
     *   where: {
     *     // ... the filter for the Em_schedule2s we want to count
     *   }
     * })
    **/
    count<T extends em_schedule2CountArgs>(
      args?: Subset<T, em_schedule2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_schedule2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_schedule2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_schedule2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_schedule2AggregateArgs>(args: Subset<T, Em_schedule2AggregateArgs>): Prisma.PrismaPromise<GetEm_schedule2AggregateType<T>>

    /**
     * Group by Em_schedule2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_schedule2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_schedule2GroupByArgs['orderBy'] }
        : { orderBy?: em_schedule2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_schedule2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_schedule2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_schedule2 model
   */
  readonly fields: em_schedule2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_schedule2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_schedule2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_schedule1<T extends em_schedule2$em_schedule1Args<ExtArgs> = {}>(args?: Subset<T, em_schedule2$em_schedule1Args<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_schedule2 model
   */
  interface em_schedule2FieldRefs {
    readonly Id: FieldRef<"em_schedule2", 'Int'>
    readonly scheduleId: FieldRef<"em_schedule2", 'Int'>
    readonly employeeId: FieldRef<"em_schedule2", 'Int'>
    readonly Regid: FieldRef<"em_schedule2", 'String'>
    readonly is_send_wa_stats: FieldRef<"em_schedule2", 'Int'>
    readonly send_date: FieldRef<"em_schedule2", 'DateTime'>
    readonly is_code_send: FieldRef<"em_schedule2", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_schedule2 findUnique
   */
  export type em_schedule2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * Filter, which em_schedule2 to fetch.
     */
    where: em_schedule2WhereUniqueInput
  }

  /**
   * em_schedule2 findUniqueOrThrow
   */
  export type em_schedule2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * Filter, which em_schedule2 to fetch.
     */
    where: em_schedule2WhereUniqueInput
  }

  /**
   * em_schedule2 findFirst
   */
  export type em_schedule2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * Filter, which em_schedule2 to fetch.
     */
    where?: em_schedule2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule2s to fetch.
     */
    orderBy?: em_schedule2OrderByWithRelationInput | em_schedule2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule2s.
     */
    cursor?: em_schedule2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule2s.
     */
    distinct?: Em_schedule2ScalarFieldEnum | Em_schedule2ScalarFieldEnum[]
  }

  /**
   * em_schedule2 findFirstOrThrow
   */
  export type em_schedule2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * Filter, which em_schedule2 to fetch.
     */
    where?: em_schedule2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule2s to fetch.
     */
    orderBy?: em_schedule2OrderByWithRelationInput | em_schedule2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule2s.
     */
    cursor?: em_schedule2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule2s.
     */
    distinct?: Em_schedule2ScalarFieldEnum | Em_schedule2ScalarFieldEnum[]
  }

  /**
   * em_schedule2 findMany
   */
  export type em_schedule2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * Filter, which em_schedule2s to fetch.
     */
    where?: em_schedule2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule2s to fetch.
     */
    orderBy?: em_schedule2OrderByWithRelationInput | em_schedule2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_schedule2s.
     */
    cursor?: em_schedule2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule2s.
     */
    skip?: number
    distinct?: Em_schedule2ScalarFieldEnum | Em_schedule2ScalarFieldEnum[]
  }

  /**
   * em_schedule2 create
   */
  export type em_schedule2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * The data needed to create a em_schedule2.
     */
    data?: XOR<em_schedule2CreateInput, em_schedule2UncheckedCreateInput>
  }

  /**
   * em_schedule2 createMany
   */
  export type em_schedule2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_schedule2s.
     */
    data: em_schedule2CreateManyInput | em_schedule2CreateManyInput[]
  }

  /**
   * em_schedule2 update
   */
  export type em_schedule2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * The data needed to update a em_schedule2.
     */
    data: XOR<em_schedule2UpdateInput, em_schedule2UncheckedUpdateInput>
    /**
     * Choose, which em_schedule2 to update.
     */
    where: em_schedule2WhereUniqueInput
  }

  /**
   * em_schedule2 updateMany
   */
  export type em_schedule2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_schedule2s.
     */
    data: XOR<em_schedule2UpdateManyMutationInput, em_schedule2UncheckedUpdateManyInput>
    /**
     * Filter which em_schedule2s to update
     */
    where?: em_schedule2WhereInput
    /**
     * Limit how many em_schedule2s to update.
     */
    limit?: number
  }

  /**
   * em_schedule2 upsert
   */
  export type em_schedule2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * The filter to search for the em_schedule2 to update in case it exists.
     */
    where: em_schedule2WhereUniqueInput
    /**
     * In case the em_schedule2 found by the `where` argument doesn't exist, create a new em_schedule2 with this data.
     */
    create: XOR<em_schedule2CreateInput, em_schedule2UncheckedCreateInput>
    /**
     * In case the em_schedule2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_schedule2UpdateInput, em_schedule2UncheckedUpdateInput>
  }

  /**
   * em_schedule2 delete
   */
  export type em_schedule2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
    /**
     * Filter which em_schedule2 to delete.
     */
    where: em_schedule2WhereUniqueInput
  }

  /**
   * em_schedule2 deleteMany
   */
  export type em_schedule2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule2s to delete
     */
    where?: em_schedule2WhereInput
    /**
     * Limit how many em_schedule2s to delete.
     */
    limit?: number
  }

  /**
   * em_schedule2.em_schedule1
   */
  export type em_schedule2$em_schedule1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    where?: em_schedule1WhereInput
  }

  /**
   * em_schedule2 without action
   */
  export type em_schedule2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule2
     */
    select?: em_schedule2Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule2
     */
    omit?: em_schedule2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule2Include<ExtArgs> | null
  }


  /**
   * Model em_schedule3
   */

  export type AggregateEm_schedule3 = {
    _count: Em_schedule3CountAggregateOutputType | null
    _avg: Em_schedule3AvgAggregateOutputType | null
    _sum: Em_schedule3SumAggregateOutputType | null
    _min: Em_schedule3MinAggregateOutputType | null
    _max: Em_schedule3MaxAggregateOutputType | null
  }

  export type Em_schedule3AvgAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    soalId: number | null
    urutanSoal: number | null
    materiId: number | null
    urutanTipeSoal: number | null
    tipeSoal: number | null
  }

  export type Em_schedule3SumAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    soalId: number | null
    urutanSoal: number | null
    materiId: number | null
    urutanTipeSoal: number | null
    tipeSoal: number | null
  }

  export type Em_schedule3MinAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    soalId: number | null
    urutanSoal: number | null
    materiId: number | null
    urutanTipeSoal: number | null
    tipeSoal: number | null
  }

  export type Em_schedule3MaxAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    soalId: number | null
    urutanSoal: number | null
    materiId: number | null
    urutanTipeSoal: number | null
    tipeSoal: number | null
  }

  export type Em_schedule3CountAggregateOutputType = {
    Id: number
    scheduleId: number
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
    _all: number
  }


  export type Em_schedule3AvgAggregateInputType = {
    Id?: true
    scheduleId?: true
    soalId?: true
    urutanSoal?: true
    materiId?: true
    urutanTipeSoal?: true
    tipeSoal?: true
  }

  export type Em_schedule3SumAggregateInputType = {
    Id?: true
    scheduleId?: true
    soalId?: true
    urutanSoal?: true
    materiId?: true
    urutanTipeSoal?: true
    tipeSoal?: true
  }

  export type Em_schedule3MinAggregateInputType = {
    Id?: true
    scheduleId?: true
    soalId?: true
    urutanSoal?: true
    materiId?: true
    urutanTipeSoal?: true
    tipeSoal?: true
  }

  export type Em_schedule3MaxAggregateInputType = {
    Id?: true
    scheduleId?: true
    soalId?: true
    urutanSoal?: true
    materiId?: true
    urutanTipeSoal?: true
    tipeSoal?: true
  }

  export type Em_schedule3CountAggregateInputType = {
    Id?: true
    scheduleId?: true
    soalId?: true
    urutanSoal?: true
    materiId?: true
    urutanTipeSoal?: true
    tipeSoal?: true
    _all?: true
  }

  export type Em_schedule3AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule3 to aggregate.
     */
    where?: em_schedule3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule3s to fetch.
     */
    orderBy?: em_schedule3OrderByWithRelationInput | em_schedule3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_schedule3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule3s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_schedule3s
    **/
    _count?: true | Em_schedule3CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_schedule3AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_schedule3SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_schedule3MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_schedule3MaxAggregateInputType
  }

  export type GetEm_schedule3AggregateType<T extends Em_schedule3AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_schedule3]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_schedule3[P]>
      : GetScalarType<T[P], AggregateEm_schedule3[P]>
  }




  export type em_schedule3GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule3WhereInput
    orderBy?: em_schedule3OrderByWithAggregationInput | em_schedule3OrderByWithAggregationInput[]
    by: Em_schedule3ScalarFieldEnum[] | Em_schedule3ScalarFieldEnum
    having?: em_schedule3ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_schedule3CountAggregateInputType | true
    _avg?: Em_schedule3AvgAggregateInputType
    _sum?: Em_schedule3SumAggregateInputType
    _min?: Em_schedule3MinAggregateInputType
    _max?: Em_schedule3MaxAggregateInputType
  }

  export type Em_schedule3GroupByOutputType = {
    Id: number
    scheduleId: number
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
    _count: Em_schedule3CountAggregateOutputType | null
    _avg: Em_schedule3AvgAggregateOutputType | null
    _sum: Em_schedule3SumAggregateOutputType | null
    _min: Em_schedule3MinAggregateOutputType | null
    _max: Em_schedule3MaxAggregateOutputType | null
  }

  type GetEm_schedule3GroupByPayload<T extends em_schedule3GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_schedule3GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_schedule3GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_schedule3GroupByOutputType[P]>
            : GetScalarType<T[P], Em_schedule3GroupByOutputType[P]>
        }
      >
    >


  export type em_schedule3Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    scheduleId?: boolean
    soalId?: boolean
    urutanSoal?: boolean
    materiId?: boolean
    urutanTipeSoal?: boolean
    tipeSoal?: boolean
    em_schedule1?: boolean | em_schedule1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_schedule3"]>



  export type em_schedule3SelectScalar = {
    Id?: boolean
    scheduleId?: boolean
    soalId?: boolean
    urutanSoal?: boolean
    materiId?: boolean
    urutanTipeSoal?: boolean
    tipeSoal?: boolean
  }

  export type em_schedule3Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "scheduleId" | "soalId" | "urutanSoal" | "materiId" | "urutanTipeSoal" | "tipeSoal", ExtArgs["result"]["em_schedule3"]>
  export type em_schedule3Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_schedule1?: boolean | em_schedule1DefaultArgs<ExtArgs>
  }

  export type $em_schedule3Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_schedule3"
    objects: {
      em_schedule1: Prisma.$em_schedule1Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      scheduleId: number
      soalId: number
      urutanSoal: number
      materiId: number
      urutanTipeSoal: number
      tipeSoal: number
    }, ExtArgs["result"]["em_schedule3"]>
    composites: {}
  }

  type em_schedule3GetPayload<S extends boolean | null | undefined | em_schedule3DefaultArgs> = $Result.GetResult<Prisma.$em_schedule3Payload, S>

  type em_schedule3CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_schedule3FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_schedule3CountAggregateInputType | true
    }

  export interface em_schedule3Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_schedule3'], meta: { name: 'em_schedule3' } }
    /**
     * Find zero or one Em_schedule3 that matches the filter.
     * @param {em_schedule3FindUniqueArgs} args - Arguments to find a Em_schedule3
     * @example
     * // Get one Em_schedule3
     * const em_schedule3 = await prisma.em_schedule3.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_schedule3FindUniqueArgs>(args: SelectSubset<T, em_schedule3FindUniqueArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_schedule3 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_schedule3FindUniqueOrThrowArgs} args - Arguments to find a Em_schedule3
     * @example
     * // Get one Em_schedule3
     * const em_schedule3 = await prisma.em_schedule3.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_schedule3FindUniqueOrThrowArgs>(args: SelectSubset<T, em_schedule3FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule3 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule3FindFirstArgs} args - Arguments to find a Em_schedule3
     * @example
     * // Get one Em_schedule3
     * const em_schedule3 = await prisma.em_schedule3.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_schedule3FindFirstArgs>(args?: SelectSubset<T, em_schedule3FindFirstArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule3 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule3FindFirstOrThrowArgs} args - Arguments to find a Em_schedule3
     * @example
     * // Get one Em_schedule3
     * const em_schedule3 = await prisma.em_schedule3.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_schedule3FindFirstOrThrowArgs>(args?: SelectSubset<T, em_schedule3FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_schedule3s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule3FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_schedule3s
     * const em_schedule3s = await prisma.em_schedule3.findMany()
     * 
     * // Get first 10 Em_schedule3s
     * const em_schedule3s = await prisma.em_schedule3.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_schedule3WithIdOnly = await prisma.em_schedule3.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_schedule3FindManyArgs>(args?: SelectSubset<T, em_schedule3FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_schedule3.
     * @param {em_schedule3CreateArgs} args - Arguments to create a Em_schedule3.
     * @example
     * // Create one Em_schedule3
     * const Em_schedule3 = await prisma.em_schedule3.create({
     *   data: {
     *     // ... data to create a Em_schedule3
     *   }
     * })
     * 
     */
    create<T extends em_schedule3CreateArgs>(args: SelectSubset<T, em_schedule3CreateArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_schedule3s.
     * @param {em_schedule3CreateManyArgs} args - Arguments to create many Em_schedule3s.
     * @example
     * // Create many Em_schedule3s
     * const em_schedule3 = await prisma.em_schedule3.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_schedule3CreateManyArgs>(args?: SelectSubset<T, em_schedule3CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_schedule3.
     * @param {em_schedule3DeleteArgs} args - Arguments to delete one Em_schedule3.
     * @example
     * // Delete one Em_schedule3
     * const Em_schedule3 = await prisma.em_schedule3.delete({
     *   where: {
     *     // ... filter to delete one Em_schedule3
     *   }
     * })
     * 
     */
    delete<T extends em_schedule3DeleteArgs>(args: SelectSubset<T, em_schedule3DeleteArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_schedule3.
     * @param {em_schedule3UpdateArgs} args - Arguments to update one Em_schedule3.
     * @example
     * // Update one Em_schedule3
     * const em_schedule3 = await prisma.em_schedule3.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_schedule3UpdateArgs>(args: SelectSubset<T, em_schedule3UpdateArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_schedule3s.
     * @param {em_schedule3DeleteManyArgs} args - Arguments to filter Em_schedule3s to delete.
     * @example
     * // Delete a few Em_schedule3s
     * const { count } = await prisma.em_schedule3.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_schedule3DeleteManyArgs>(args?: SelectSubset<T, em_schedule3DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_schedule3s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule3UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_schedule3s
     * const em_schedule3 = await prisma.em_schedule3.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_schedule3UpdateManyArgs>(args: SelectSubset<T, em_schedule3UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_schedule3.
     * @param {em_schedule3UpsertArgs} args - Arguments to update or create a Em_schedule3.
     * @example
     * // Update or create a Em_schedule3
     * const em_schedule3 = await prisma.em_schedule3.upsert({
     *   create: {
     *     // ... data to create a Em_schedule3
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_schedule3 we want to update
     *   }
     * })
     */
    upsert<T extends em_schedule3UpsertArgs>(args: SelectSubset<T, em_schedule3UpsertArgs<ExtArgs>>): Prisma__em_schedule3Client<$Result.GetResult<Prisma.$em_schedule3Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_schedule3s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule3CountArgs} args - Arguments to filter Em_schedule3s to count.
     * @example
     * // Count the number of Em_schedule3s
     * const count = await prisma.em_schedule3.count({
     *   where: {
     *     // ... the filter for the Em_schedule3s we want to count
     *   }
     * })
    **/
    count<T extends em_schedule3CountArgs>(
      args?: Subset<T, em_schedule3CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_schedule3CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_schedule3.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_schedule3AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_schedule3AggregateArgs>(args: Subset<T, Em_schedule3AggregateArgs>): Prisma.PrismaPromise<GetEm_schedule3AggregateType<T>>

    /**
     * Group by Em_schedule3.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule3GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_schedule3GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_schedule3GroupByArgs['orderBy'] }
        : { orderBy?: em_schedule3GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_schedule3GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_schedule3GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_schedule3 model
   */
  readonly fields: em_schedule3FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_schedule3.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_schedule3Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_schedule1<T extends em_schedule1DefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_schedule1DefaultArgs<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_schedule3 model
   */
  interface em_schedule3FieldRefs {
    readonly Id: FieldRef<"em_schedule3", 'Int'>
    readonly scheduleId: FieldRef<"em_schedule3", 'Int'>
    readonly soalId: FieldRef<"em_schedule3", 'Int'>
    readonly urutanSoal: FieldRef<"em_schedule3", 'Int'>
    readonly materiId: FieldRef<"em_schedule3", 'Int'>
    readonly urutanTipeSoal: FieldRef<"em_schedule3", 'Int'>
    readonly tipeSoal: FieldRef<"em_schedule3", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_schedule3 findUnique
   */
  export type em_schedule3FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * Filter, which em_schedule3 to fetch.
     */
    where: em_schedule3WhereUniqueInput
  }

  /**
   * em_schedule3 findUniqueOrThrow
   */
  export type em_schedule3FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * Filter, which em_schedule3 to fetch.
     */
    where: em_schedule3WhereUniqueInput
  }

  /**
   * em_schedule3 findFirst
   */
  export type em_schedule3FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * Filter, which em_schedule3 to fetch.
     */
    where?: em_schedule3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule3s to fetch.
     */
    orderBy?: em_schedule3OrderByWithRelationInput | em_schedule3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule3s.
     */
    cursor?: em_schedule3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule3s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule3s.
     */
    distinct?: Em_schedule3ScalarFieldEnum | Em_schedule3ScalarFieldEnum[]
  }

  /**
   * em_schedule3 findFirstOrThrow
   */
  export type em_schedule3FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * Filter, which em_schedule3 to fetch.
     */
    where?: em_schedule3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule3s to fetch.
     */
    orderBy?: em_schedule3OrderByWithRelationInput | em_schedule3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule3s.
     */
    cursor?: em_schedule3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule3s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule3s.
     */
    distinct?: Em_schedule3ScalarFieldEnum | Em_schedule3ScalarFieldEnum[]
  }

  /**
   * em_schedule3 findMany
   */
  export type em_schedule3FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * Filter, which em_schedule3s to fetch.
     */
    where?: em_schedule3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule3s to fetch.
     */
    orderBy?: em_schedule3OrderByWithRelationInput | em_schedule3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_schedule3s.
     */
    cursor?: em_schedule3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule3s.
     */
    skip?: number
    distinct?: Em_schedule3ScalarFieldEnum | Em_schedule3ScalarFieldEnum[]
  }

  /**
   * em_schedule3 create
   */
  export type em_schedule3CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * The data needed to create a em_schedule3.
     */
    data: XOR<em_schedule3CreateInput, em_schedule3UncheckedCreateInput>
  }

  /**
   * em_schedule3 createMany
   */
  export type em_schedule3CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_schedule3s.
     */
    data: em_schedule3CreateManyInput | em_schedule3CreateManyInput[]
  }

  /**
   * em_schedule3 update
   */
  export type em_schedule3UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * The data needed to update a em_schedule3.
     */
    data: XOR<em_schedule3UpdateInput, em_schedule3UncheckedUpdateInput>
    /**
     * Choose, which em_schedule3 to update.
     */
    where: em_schedule3WhereUniqueInput
  }

  /**
   * em_schedule3 updateMany
   */
  export type em_schedule3UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_schedule3s.
     */
    data: XOR<em_schedule3UpdateManyMutationInput, em_schedule3UncheckedUpdateManyInput>
    /**
     * Filter which em_schedule3s to update
     */
    where?: em_schedule3WhereInput
    /**
     * Limit how many em_schedule3s to update.
     */
    limit?: number
  }

  /**
   * em_schedule3 upsert
   */
  export type em_schedule3UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * The filter to search for the em_schedule3 to update in case it exists.
     */
    where: em_schedule3WhereUniqueInput
    /**
     * In case the em_schedule3 found by the `where` argument doesn't exist, create a new em_schedule3 with this data.
     */
    create: XOR<em_schedule3CreateInput, em_schedule3UncheckedCreateInput>
    /**
     * In case the em_schedule3 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_schedule3UpdateInput, em_schedule3UncheckedUpdateInput>
  }

  /**
   * em_schedule3 delete
   */
  export type em_schedule3DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
    /**
     * Filter which em_schedule3 to delete.
     */
    where: em_schedule3WhereUniqueInput
  }

  /**
   * em_schedule3 deleteMany
   */
  export type em_schedule3DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule3s to delete
     */
    where?: em_schedule3WhereInput
    /**
     * Limit how many em_schedule3s to delete.
     */
    limit?: number
  }

  /**
   * em_schedule3 without action
   */
  export type em_schedule3DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule3
     */
    select?: em_schedule3Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule3
     */
    omit?: em_schedule3Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule3Include<ExtArgs> | null
  }


  /**
   * Model em_schedule4
   */

  export type AggregateEm_schedule4 = {
    _count: Em_schedule4CountAggregateOutputType | null
    _avg: Em_schedule4AvgAggregateOutputType | null
    _sum: Em_schedule4SumAggregateOutputType | null
    _min: Em_schedule4MinAggregateOutputType | null
    _max: Em_schedule4MaxAggregateOutputType | null
  }

  export type Em_schedule4AvgAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    tipeSoal: number | null
    jumlahSoal: number | null
    durasiPerTipe: number | null
  }

  export type Em_schedule4SumAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    tipeSoal: number | null
    jumlahSoal: number | null
    durasiPerTipe: number | null
  }

  export type Em_schedule4MinAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    tipeSoal: number | null
    jumlahSoal: number | null
    durasiPerTipe: number | null
  }

  export type Em_schedule4MaxAggregateOutputType = {
    Id: number | null
    scheduleId: number | null
    tipeSoal: number | null
    jumlahSoal: number | null
    durasiPerTipe: number | null
  }

  export type Em_schedule4CountAggregateOutputType = {
    Id: number
    scheduleId: number
    tipeSoal: number
    jumlahSoal: number
    durasiPerTipe: number
    _all: number
  }


  export type Em_schedule4AvgAggregateInputType = {
    Id?: true
    scheduleId?: true
    tipeSoal?: true
    jumlahSoal?: true
    durasiPerTipe?: true
  }

  export type Em_schedule4SumAggregateInputType = {
    Id?: true
    scheduleId?: true
    tipeSoal?: true
    jumlahSoal?: true
    durasiPerTipe?: true
  }

  export type Em_schedule4MinAggregateInputType = {
    Id?: true
    scheduleId?: true
    tipeSoal?: true
    jumlahSoal?: true
    durasiPerTipe?: true
  }

  export type Em_schedule4MaxAggregateInputType = {
    Id?: true
    scheduleId?: true
    tipeSoal?: true
    jumlahSoal?: true
    durasiPerTipe?: true
  }

  export type Em_schedule4CountAggregateInputType = {
    Id?: true
    scheduleId?: true
    tipeSoal?: true
    jumlahSoal?: true
    durasiPerTipe?: true
    _all?: true
  }

  export type Em_schedule4AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule4 to aggregate.
     */
    where?: em_schedule4WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule4s to fetch.
     */
    orderBy?: em_schedule4OrderByWithRelationInput | em_schedule4OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_schedule4WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule4s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule4s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_schedule4s
    **/
    _count?: true | Em_schedule4CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_schedule4AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_schedule4SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_schedule4MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_schedule4MaxAggregateInputType
  }

  export type GetEm_schedule4AggregateType<T extends Em_schedule4AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_schedule4]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_schedule4[P]>
      : GetScalarType<T[P], AggregateEm_schedule4[P]>
  }




  export type em_schedule4GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_schedule4WhereInput
    orderBy?: em_schedule4OrderByWithAggregationInput | em_schedule4OrderByWithAggregationInput[]
    by: Em_schedule4ScalarFieldEnum[] | Em_schedule4ScalarFieldEnum
    having?: em_schedule4ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_schedule4CountAggregateInputType | true
    _avg?: Em_schedule4AvgAggregateInputType
    _sum?: Em_schedule4SumAggregateInputType
    _min?: Em_schedule4MinAggregateInputType
    _max?: Em_schedule4MaxAggregateInputType
  }

  export type Em_schedule4GroupByOutputType = {
    Id: number
    scheduleId: number | null
    tipeSoal: number | null
    jumlahSoal: number | null
    durasiPerTipe: number | null
    _count: Em_schedule4CountAggregateOutputType | null
    _avg: Em_schedule4AvgAggregateOutputType | null
    _sum: Em_schedule4SumAggregateOutputType | null
    _min: Em_schedule4MinAggregateOutputType | null
    _max: Em_schedule4MaxAggregateOutputType | null
  }

  type GetEm_schedule4GroupByPayload<T extends em_schedule4GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_schedule4GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_schedule4GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_schedule4GroupByOutputType[P]>
            : GetScalarType<T[P], Em_schedule4GroupByOutputType[P]>
        }
      >
    >


  export type em_schedule4Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    scheduleId?: boolean
    tipeSoal?: boolean
    jumlahSoal?: boolean
    durasiPerTipe?: boolean
    em_schedule1?: boolean | em_schedule4$em_schedule1Args<ExtArgs>
  }, ExtArgs["result"]["em_schedule4"]>



  export type em_schedule4SelectScalar = {
    Id?: boolean
    scheduleId?: boolean
    tipeSoal?: boolean
    jumlahSoal?: boolean
    durasiPerTipe?: boolean
  }

  export type em_schedule4Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "scheduleId" | "tipeSoal" | "jumlahSoal" | "durasiPerTipe", ExtArgs["result"]["em_schedule4"]>
  export type em_schedule4Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_schedule1?: boolean | em_schedule4$em_schedule1Args<ExtArgs>
  }

  export type $em_schedule4Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_schedule4"
    objects: {
      em_schedule1: Prisma.$em_schedule1Payload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      scheduleId: number | null
      tipeSoal: number | null
      jumlahSoal: number | null
      durasiPerTipe: number | null
    }, ExtArgs["result"]["em_schedule4"]>
    composites: {}
  }

  type em_schedule4GetPayload<S extends boolean | null | undefined | em_schedule4DefaultArgs> = $Result.GetResult<Prisma.$em_schedule4Payload, S>

  type em_schedule4CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_schedule4FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_schedule4CountAggregateInputType | true
    }

  export interface em_schedule4Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_schedule4'], meta: { name: 'em_schedule4' } }
    /**
     * Find zero or one Em_schedule4 that matches the filter.
     * @param {em_schedule4FindUniqueArgs} args - Arguments to find a Em_schedule4
     * @example
     * // Get one Em_schedule4
     * const em_schedule4 = await prisma.em_schedule4.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_schedule4FindUniqueArgs>(args: SelectSubset<T, em_schedule4FindUniqueArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_schedule4 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_schedule4FindUniqueOrThrowArgs} args - Arguments to find a Em_schedule4
     * @example
     * // Get one Em_schedule4
     * const em_schedule4 = await prisma.em_schedule4.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_schedule4FindUniqueOrThrowArgs>(args: SelectSubset<T, em_schedule4FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule4 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule4FindFirstArgs} args - Arguments to find a Em_schedule4
     * @example
     * // Get one Em_schedule4
     * const em_schedule4 = await prisma.em_schedule4.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_schedule4FindFirstArgs>(args?: SelectSubset<T, em_schedule4FindFirstArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_schedule4 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule4FindFirstOrThrowArgs} args - Arguments to find a Em_schedule4
     * @example
     * // Get one Em_schedule4
     * const em_schedule4 = await prisma.em_schedule4.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_schedule4FindFirstOrThrowArgs>(args?: SelectSubset<T, em_schedule4FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_schedule4s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule4FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_schedule4s
     * const em_schedule4s = await prisma.em_schedule4.findMany()
     * 
     * // Get first 10 Em_schedule4s
     * const em_schedule4s = await prisma.em_schedule4.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_schedule4WithIdOnly = await prisma.em_schedule4.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_schedule4FindManyArgs>(args?: SelectSubset<T, em_schedule4FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_schedule4.
     * @param {em_schedule4CreateArgs} args - Arguments to create a Em_schedule4.
     * @example
     * // Create one Em_schedule4
     * const Em_schedule4 = await prisma.em_schedule4.create({
     *   data: {
     *     // ... data to create a Em_schedule4
     *   }
     * })
     * 
     */
    create<T extends em_schedule4CreateArgs>(args: SelectSubset<T, em_schedule4CreateArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_schedule4s.
     * @param {em_schedule4CreateManyArgs} args - Arguments to create many Em_schedule4s.
     * @example
     * // Create many Em_schedule4s
     * const em_schedule4 = await prisma.em_schedule4.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_schedule4CreateManyArgs>(args?: SelectSubset<T, em_schedule4CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_schedule4.
     * @param {em_schedule4DeleteArgs} args - Arguments to delete one Em_schedule4.
     * @example
     * // Delete one Em_schedule4
     * const Em_schedule4 = await prisma.em_schedule4.delete({
     *   where: {
     *     // ... filter to delete one Em_schedule4
     *   }
     * })
     * 
     */
    delete<T extends em_schedule4DeleteArgs>(args: SelectSubset<T, em_schedule4DeleteArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_schedule4.
     * @param {em_schedule4UpdateArgs} args - Arguments to update one Em_schedule4.
     * @example
     * // Update one Em_schedule4
     * const em_schedule4 = await prisma.em_schedule4.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_schedule4UpdateArgs>(args: SelectSubset<T, em_schedule4UpdateArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_schedule4s.
     * @param {em_schedule4DeleteManyArgs} args - Arguments to filter Em_schedule4s to delete.
     * @example
     * // Delete a few Em_schedule4s
     * const { count } = await prisma.em_schedule4.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_schedule4DeleteManyArgs>(args?: SelectSubset<T, em_schedule4DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_schedule4s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule4UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_schedule4s
     * const em_schedule4 = await prisma.em_schedule4.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_schedule4UpdateManyArgs>(args: SelectSubset<T, em_schedule4UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_schedule4.
     * @param {em_schedule4UpsertArgs} args - Arguments to update or create a Em_schedule4.
     * @example
     * // Update or create a Em_schedule4
     * const em_schedule4 = await prisma.em_schedule4.upsert({
     *   create: {
     *     // ... data to create a Em_schedule4
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_schedule4 we want to update
     *   }
     * })
     */
    upsert<T extends em_schedule4UpsertArgs>(args: SelectSubset<T, em_schedule4UpsertArgs<ExtArgs>>): Prisma__em_schedule4Client<$Result.GetResult<Prisma.$em_schedule4Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_schedule4s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule4CountArgs} args - Arguments to filter Em_schedule4s to count.
     * @example
     * // Count the number of Em_schedule4s
     * const count = await prisma.em_schedule4.count({
     *   where: {
     *     // ... the filter for the Em_schedule4s we want to count
     *   }
     * })
    **/
    count<T extends em_schedule4CountArgs>(
      args?: Subset<T, em_schedule4CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_schedule4CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_schedule4.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_schedule4AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_schedule4AggregateArgs>(args: Subset<T, Em_schedule4AggregateArgs>): Prisma.PrismaPromise<GetEm_schedule4AggregateType<T>>

    /**
     * Group by Em_schedule4.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_schedule4GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_schedule4GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_schedule4GroupByArgs['orderBy'] }
        : { orderBy?: em_schedule4GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_schedule4GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_schedule4GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_schedule4 model
   */
  readonly fields: em_schedule4FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_schedule4.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_schedule4Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_schedule1<T extends em_schedule4$em_schedule1Args<ExtArgs> = {}>(args?: Subset<T, em_schedule4$em_schedule1Args<ExtArgs>>): Prisma__em_schedule1Client<$Result.GetResult<Prisma.$em_schedule1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_schedule4 model
   */
  interface em_schedule4FieldRefs {
    readonly Id: FieldRef<"em_schedule4", 'Int'>
    readonly scheduleId: FieldRef<"em_schedule4", 'Int'>
    readonly tipeSoal: FieldRef<"em_schedule4", 'Int'>
    readonly jumlahSoal: FieldRef<"em_schedule4", 'Float'>
    readonly durasiPerTipe: FieldRef<"em_schedule4", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_schedule4 findUnique
   */
  export type em_schedule4FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * Filter, which em_schedule4 to fetch.
     */
    where: em_schedule4WhereUniqueInput
  }

  /**
   * em_schedule4 findUniqueOrThrow
   */
  export type em_schedule4FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * Filter, which em_schedule4 to fetch.
     */
    where: em_schedule4WhereUniqueInput
  }

  /**
   * em_schedule4 findFirst
   */
  export type em_schedule4FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * Filter, which em_schedule4 to fetch.
     */
    where?: em_schedule4WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule4s to fetch.
     */
    orderBy?: em_schedule4OrderByWithRelationInput | em_schedule4OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule4s.
     */
    cursor?: em_schedule4WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule4s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule4s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule4s.
     */
    distinct?: Em_schedule4ScalarFieldEnum | Em_schedule4ScalarFieldEnum[]
  }

  /**
   * em_schedule4 findFirstOrThrow
   */
  export type em_schedule4FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * Filter, which em_schedule4 to fetch.
     */
    where?: em_schedule4WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule4s to fetch.
     */
    orderBy?: em_schedule4OrderByWithRelationInput | em_schedule4OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_schedule4s.
     */
    cursor?: em_schedule4WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule4s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule4s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_schedule4s.
     */
    distinct?: Em_schedule4ScalarFieldEnum | Em_schedule4ScalarFieldEnum[]
  }

  /**
   * em_schedule4 findMany
   */
  export type em_schedule4FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * Filter, which em_schedule4s to fetch.
     */
    where?: em_schedule4WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_schedule4s to fetch.
     */
    orderBy?: em_schedule4OrderByWithRelationInput | em_schedule4OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_schedule4s.
     */
    cursor?: em_schedule4WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_schedule4s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_schedule4s.
     */
    skip?: number
    distinct?: Em_schedule4ScalarFieldEnum | Em_schedule4ScalarFieldEnum[]
  }

  /**
   * em_schedule4 create
   */
  export type em_schedule4CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * The data needed to create a em_schedule4.
     */
    data?: XOR<em_schedule4CreateInput, em_schedule4UncheckedCreateInput>
  }

  /**
   * em_schedule4 createMany
   */
  export type em_schedule4CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_schedule4s.
     */
    data: em_schedule4CreateManyInput | em_schedule4CreateManyInput[]
  }

  /**
   * em_schedule4 update
   */
  export type em_schedule4UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * The data needed to update a em_schedule4.
     */
    data: XOR<em_schedule4UpdateInput, em_schedule4UncheckedUpdateInput>
    /**
     * Choose, which em_schedule4 to update.
     */
    where: em_schedule4WhereUniqueInput
  }

  /**
   * em_schedule4 updateMany
   */
  export type em_schedule4UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_schedule4s.
     */
    data: XOR<em_schedule4UpdateManyMutationInput, em_schedule4UncheckedUpdateManyInput>
    /**
     * Filter which em_schedule4s to update
     */
    where?: em_schedule4WhereInput
    /**
     * Limit how many em_schedule4s to update.
     */
    limit?: number
  }

  /**
   * em_schedule4 upsert
   */
  export type em_schedule4UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * The filter to search for the em_schedule4 to update in case it exists.
     */
    where: em_schedule4WhereUniqueInput
    /**
     * In case the em_schedule4 found by the `where` argument doesn't exist, create a new em_schedule4 with this data.
     */
    create: XOR<em_schedule4CreateInput, em_schedule4UncheckedCreateInput>
    /**
     * In case the em_schedule4 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_schedule4UpdateInput, em_schedule4UncheckedUpdateInput>
  }

  /**
   * em_schedule4 delete
   */
  export type em_schedule4DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
    /**
     * Filter which em_schedule4 to delete.
     */
    where: em_schedule4WhereUniqueInput
  }

  /**
   * em_schedule4 deleteMany
   */
  export type em_schedule4DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_schedule4s to delete
     */
    where?: em_schedule4WhereInput
    /**
     * Limit how many em_schedule4s to delete.
     */
    limit?: number
  }

  /**
   * em_schedule4.em_schedule1
   */
  export type em_schedule4$em_schedule1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule1
     */
    select?: em_schedule1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule1
     */
    omit?: em_schedule1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule1Include<ExtArgs> | null
    where?: em_schedule1WhereInput
  }

  /**
   * em_schedule4 without action
   */
  export type em_schedule4DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_schedule4
     */
    select?: em_schedule4Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_schedule4
     */
    omit?: em_schedule4Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_schedule4Include<ExtArgs> | null
  }


  /**
   * Model em_session_exams
   */

  export type AggregateEm_session_exams = {
    _count: Em_session_examsCountAggregateOutputType | null
    _avg: Em_session_examsAvgAggregateOutputType | null
    _sum: Em_session_examsSumAggregateOutputType | null
    _min: Em_session_examsMinAggregateOutputType | null
    _max: Em_session_examsMaxAggregateOutputType | null
  }

  export type Em_session_examsAvgAggregateOutputType = {
    Id: number | null
    schedule_id: number | null
    empl_id: number | null
    durasi: number | null
    is_correct: number | null
    is_score_akhir: number | null
  }

  export type Em_session_examsSumAggregateOutputType = {
    Id: number | null
    schedule_id: number | null
    empl_id: number | null
    durasi: number | null
    is_correct: number | null
    is_score_akhir: number | null
  }

  export type Em_session_examsMinAggregateOutputType = {
    Id: number | null
    schedule_id: number | null
    exams_id: string | null
    empl_id: number | null
    soal_urut: string | null
    start_time: Date | null
    end_time: Date | null
    is_selesai: string | null
    is_token: string | null
    is_token_expr: Date | null
    durasi: number | null
    is_correct: number | null
    is_notes: string | null
    is_score_akhir: number | null
  }

  export type Em_session_examsMaxAggregateOutputType = {
    Id: number | null
    schedule_id: number | null
    exams_id: string | null
    empl_id: number | null
    soal_urut: string | null
    start_time: Date | null
    end_time: Date | null
    is_selesai: string | null
    is_token: string | null
    is_token_expr: Date | null
    durasi: number | null
    is_correct: number | null
    is_notes: string | null
    is_score_akhir: number | null
  }

  export type Em_session_examsCountAggregateOutputType = {
    Id: number
    schedule_id: number
    exams_id: number
    empl_id: number
    soal_urut: number
    start_time: number
    end_time: number
    is_selesai: number
    is_token: number
    is_token_expr: number
    durasi: number
    is_correct: number
    is_notes: number
    is_score_akhir: number
    _all: number
  }


  export type Em_session_examsAvgAggregateInputType = {
    Id?: true
    schedule_id?: true
    empl_id?: true
    durasi?: true
    is_correct?: true
    is_score_akhir?: true
  }

  export type Em_session_examsSumAggregateInputType = {
    Id?: true
    schedule_id?: true
    empl_id?: true
    durasi?: true
    is_correct?: true
    is_score_akhir?: true
  }

  export type Em_session_examsMinAggregateInputType = {
    Id?: true
    schedule_id?: true
    exams_id?: true
    empl_id?: true
    soal_urut?: true
    start_time?: true
    end_time?: true
    is_selesai?: true
    is_token?: true
    is_token_expr?: true
    durasi?: true
    is_correct?: true
    is_notes?: true
    is_score_akhir?: true
  }

  export type Em_session_examsMaxAggregateInputType = {
    Id?: true
    schedule_id?: true
    exams_id?: true
    empl_id?: true
    soal_urut?: true
    start_time?: true
    end_time?: true
    is_selesai?: true
    is_token?: true
    is_token_expr?: true
    durasi?: true
    is_correct?: true
    is_notes?: true
    is_score_akhir?: true
  }

  export type Em_session_examsCountAggregateInputType = {
    Id?: true
    schedule_id?: true
    exams_id?: true
    empl_id?: true
    soal_urut?: true
    start_time?: true
    end_time?: true
    is_selesai?: true
    is_token?: true
    is_token_expr?: true
    durasi?: true
    is_correct?: true
    is_notes?: true
    is_score_akhir?: true
    _all?: true
  }

  export type Em_session_examsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_session_exams to aggregate.
     */
    where?: em_session_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams to fetch.
     */
    orderBy?: em_session_examsOrderByWithRelationInput | em_session_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_session_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_session_exams
    **/
    _count?: true | Em_session_examsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_session_examsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_session_examsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_session_examsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_session_examsMaxAggregateInputType
  }

  export type GetEm_session_examsAggregateType<T extends Em_session_examsAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_session_exams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_session_exams[P]>
      : GetScalarType<T[P], AggregateEm_session_exams[P]>
  }




  export type em_session_examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_session_examsWhereInput
    orderBy?: em_session_examsOrderByWithAggregationInput | em_session_examsOrderByWithAggregationInput[]
    by: Em_session_examsScalarFieldEnum[] | Em_session_examsScalarFieldEnum
    having?: em_session_examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_session_examsCountAggregateInputType | true
    _avg?: Em_session_examsAvgAggregateInputType
    _sum?: Em_session_examsSumAggregateInputType
    _min?: Em_session_examsMinAggregateInputType
    _max?: Em_session_examsMaxAggregateInputType
  }

  export type Em_session_examsGroupByOutputType = {
    Id: number
    schedule_id: number | null
    exams_id: string | null
    empl_id: number | null
    soal_urut: string | null
    start_time: Date | null
    end_time: Date | null
    is_selesai: string | null
    is_token: string | null
    is_token_expr: Date | null
    durasi: number | null
    is_correct: number | null
    is_notes: string | null
    is_score_akhir: number | null
    _count: Em_session_examsCountAggregateOutputType | null
    _avg: Em_session_examsAvgAggregateOutputType | null
    _sum: Em_session_examsSumAggregateOutputType | null
    _min: Em_session_examsMinAggregateOutputType | null
    _max: Em_session_examsMaxAggregateOutputType | null
  }

  type GetEm_session_examsGroupByPayload<T extends em_session_examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_session_examsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_session_examsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_session_examsGroupByOutputType[P]>
            : GetScalarType<T[P], Em_session_examsGroupByOutputType[P]>
        }
      >
    >


  export type em_session_examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    schedule_id?: boolean
    exams_id?: boolean
    empl_id?: boolean
    soal_urut?: boolean
    start_time?: boolean
    end_time?: boolean
    is_selesai?: boolean
    is_token?: boolean
    is_token_expr?: boolean
    durasi?: boolean
    is_correct?: boolean
    is_notes?: boolean
    is_score_akhir?: boolean
    em_jawaban_peserta?: boolean | em_session_exams$em_jawaban_pesertaArgs<ExtArgs>
    _count?: boolean | Em_session_examsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_session_exams"]>



  export type em_session_examsSelectScalar = {
    Id?: boolean
    schedule_id?: boolean
    exams_id?: boolean
    empl_id?: boolean
    soal_urut?: boolean
    start_time?: boolean
    end_time?: boolean
    is_selesai?: boolean
    is_token?: boolean
    is_token_expr?: boolean
    durasi?: boolean
    is_correct?: boolean
    is_notes?: boolean
    is_score_akhir?: boolean
  }

  export type em_session_examsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "schedule_id" | "exams_id" | "empl_id" | "soal_urut" | "start_time" | "end_time" | "is_selesai" | "is_token" | "is_token_expr" | "durasi" | "is_correct" | "is_notes" | "is_score_akhir", ExtArgs["result"]["em_session_exams"]>
  export type em_session_examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_jawaban_peserta?: boolean | em_session_exams$em_jawaban_pesertaArgs<ExtArgs>
    _count?: boolean | Em_session_examsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_session_examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_session_exams"
    objects: {
      em_jawaban_peserta: Prisma.$em_jawaban_pesertaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      schedule_id: number | null
      exams_id: string | null
      empl_id: number | null
      soal_urut: string | null
      start_time: Date | null
      end_time: Date | null
      is_selesai: string | null
      is_token: string | null
      is_token_expr: Date | null
      durasi: number | null
      is_correct: number | null
      is_notes: string | null
      is_score_akhir: number | null
    }, ExtArgs["result"]["em_session_exams"]>
    composites: {}
  }

  type em_session_examsGetPayload<S extends boolean | null | undefined | em_session_examsDefaultArgs> = $Result.GetResult<Prisma.$em_session_examsPayload, S>

  type em_session_examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_session_examsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_session_examsCountAggregateInputType | true
    }

  export interface em_session_examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_session_exams'], meta: { name: 'em_session_exams' } }
    /**
     * Find zero or one Em_session_exams that matches the filter.
     * @param {em_session_examsFindUniqueArgs} args - Arguments to find a Em_session_exams
     * @example
     * // Get one Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_session_examsFindUniqueArgs>(args: SelectSubset<T, em_session_examsFindUniqueArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_session_exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_session_examsFindUniqueOrThrowArgs} args - Arguments to find a Em_session_exams
     * @example
     * // Get one Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_session_examsFindUniqueOrThrowArgs>(args: SelectSubset<T, em_session_examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_session_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_examsFindFirstArgs} args - Arguments to find a Em_session_exams
     * @example
     * // Get one Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_session_examsFindFirstArgs>(args?: SelectSubset<T, em_session_examsFindFirstArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_session_exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_examsFindFirstOrThrowArgs} args - Arguments to find a Em_session_exams
     * @example
     * // Get one Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_session_examsFindFirstOrThrowArgs>(args?: SelectSubset<T, em_session_examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_session_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.findMany()
     * 
     * // Get first 10 Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_session_examsWithIdOnly = await prisma.em_session_exams.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_session_examsFindManyArgs>(args?: SelectSubset<T, em_session_examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_session_exams.
     * @param {em_session_examsCreateArgs} args - Arguments to create a Em_session_exams.
     * @example
     * // Create one Em_session_exams
     * const Em_session_exams = await prisma.em_session_exams.create({
     *   data: {
     *     // ... data to create a Em_session_exams
     *   }
     * })
     * 
     */
    create<T extends em_session_examsCreateArgs>(args: SelectSubset<T, em_session_examsCreateArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_session_exams.
     * @param {em_session_examsCreateManyArgs} args - Arguments to create many Em_session_exams.
     * @example
     * // Create many Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_session_examsCreateManyArgs>(args?: SelectSubset<T, em_session_examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_session_exams.
     * @param {em_session_examsDeleteArgs} args - Arguments to delete one Em_session_exams.
     * @example
     * // Delete one Em_session_exams
     * const Em_session_exams = await prisma.em_session_exams.delete({
     *   where: {
     *     // ... filter to delete one Em_session_exams
     *   }
     * })
     * 
     */
    delete<T extends em_session_examsDeleteArgs>(args: SelectSubset<T, em_session_examsDeleteArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_session_exams.
     * @param {em_session_examsUpdateArgs} args - Arguments to update one Em_session_exams.
     * @example
     * // Update one Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_session_examsUpdateArgs>(args: SelectSubset<T, em_session_examsUpdateArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_session_exams.
     * @param {em_session_examsDeleteManyArgs} args - Arguments to filter Em_session_exams to delete.
     * @example
     * // Delete a few Em_session_exams
     * const { count } = await prisma.em_session_exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_session_examsDeleteManyArgs>(args?: SelectSubset<T, em_session_examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_session_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_session_examsUpdateManyArgs>(args: SelectSubset<T, em_session_examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_session_exams.
     * @param {em_session_examsUpsertArgs} args - Arguments to update or create a Em_session_exams.
     * @example
     * // Update or create a Em_session_exams
     * const em_session_exams = await prisma.em_session_exams.upsert({
     *   create: {
     *     // ... data to create a Em_session_exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_session_exams we want to update
     *   }
     * })
     */
    upsert<T extends em_session_examsUpsertArgs>(args: SelectSubset<T, em_session_examsUpsertArgs<ExtArgs>>): Prisma__em_session_examsClient<$Result.GetResult<Prisma.$em_session_examsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_session_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_examsCountArgs} args - Arguments to filter Em_session_exams to count.
     * @example
     * // Count the number of Em_session_exams
     * const count = await prisma.em_session_exams.count({
     *   where: {
     *     // ... the filter for the Em_session_exams we want to count
     *   }
     * })
    **/
    count<T extends em_session_examsCountArgs>(
      args?: Subset<T, em_session_examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_session_examsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_session_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_session_examsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_session_examsAggregateArgs>(args: Subset<T, Em_session_examsAggregateArgs>): Prisma.PrismaPromise<GetEm_session_examsAggregateType<T>>

    /**
     * Group by Em_session_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_session_examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_session_examsGroupByArgs['orderBy'] }
        : { orderBy?: em_session_examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_session_examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_session_examsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_session_exams model
   */
  readonly fields: em_session_examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_session_exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_session_examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_jawaban_peserta<T extends em_session_exams$em_jawaban_pesertaArgs<ExtArgs> = {}>(args?: Subset<T, em_session_exams$em_jawaban_pesertaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_jawaban_pesertaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_session_exams model
   */
  interface em_session_examsFieldRefs {
    readonly Id: FieldRef<"em_session_exams", 'Int'>
    readonly schedule_id: FieldRef<"em_session_exams", 'Int'>
    readonly exams_id: FieldRef<"em_session_exams", 'String'>
    readonly empl_id: FieldRef<"em_session_exams", 'Int'>
    readonly soal_urut: FieldRef<"em_session_exams", 'String'>
    readonly start_time: FieldRef<"em_session_exams", 'DateTime'>
    readonly end_time: FieldRef<"em_session_exams", 'DateTime'>
    readonly is_selesai: FieldRef<"em_session_exams", 'String'>
    readonly is_token: FieldRef<"em_session_exams", 'String'>
    readonly is_token_expr: FieldRef<"em_session_exams", 'DateTime'>
    readonly durasi: FieldRef<"em_session_exams", 'Int'>
    readonly is_correct: FieldRef<"em_session_exams", 'Int'>
    readonly is_notes: FieldRef<"em_session_exams", 'String'>
    readonly is_score_akhir: FieldRef<"em_session_exams", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * em_session_exams findUnique
   */
  export type em_session_examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams to fetch.
     */
    where: em_session_examsWhereUniqueInput
  }

  /**
   * em_session_exams findUniqueOrThrow
   */
  export type em_session_examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams to fetch.
     */
    where: em_session_examsWhereUniqueInput
  }

  /**
   * em_session_exams findFirst
   */
  export type em_session_examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams to fetch.
     */
    where?: em_session_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams to fetch.
     */
    orderBy?: em_session_examsOrderByWithRelationInput | em_session_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_session_exams.
     */
    cursor?: em_session_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_session_exams.
     */
    distinct?: Em_session_examsScalarFieldEnum | Em_session_examsScalarFieldEnum[]
  }

  /**
   * em_session_exams findFirstOrThrow
   */
  export type em_session_examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams to fetch.
     */
    where?: em_session_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams to fetch.
     */
    orderBy?: em_session_examsOrderByWithRelationInput | em_session_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_session_exams.
     */
    cursor?: em_session_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_session_exams.
     */
    distinct?: Em_session_examsScalarFieldEnum | Em_session_examsScalarFieldEnum[]
  }

  /**
   * em_session_exams findMany
   */
  export type em_session_examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams to fetch.
     */
    where?: em_session_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams to fetch.
     */
    orderBy?: em_session_examsOrderByWithRelationInput | em_session_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_session_exams.
     */
    cursor?: em_session_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams.
     */
    skip?: number
    distinct?: Em_session_examsScalarFieldEnum | Em_session_examsScalarFieldEnum[]
  }

  /**
   * em_session_exams create
   */
  export type em_session_examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * The data needed to create a em_session_exams.
     */
    data?: XOR<em_session_examsCreateInput, em_session_examsUncheckedCreateInput>
  }

  /**
   * em_session_exams createMany
   */
  export type em_session_examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_session_exams.
     */
    data: em_session_examsCreateManyInput | em_session_examsCreateManyInput[]
  }

  /**
   * em_session_exams update
   */
  export type em_session_examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * The data needed to update a em_session_exams.
     */
    data: XOR<em_session_examsUpdateInput, em_session_examsUncheckedUpdateInput>
    /**
     * Choose, which em_session_exams to update.
     */
    where: em_session_examsWhereUniqueInput
  }

  /**
   * em_session_exams updateMany
   */
  export type em_session_examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_session_exams.
     */
    data: XOR<em_session_examsUpdateManyMutationInput, em_session_examsUncheckedUpdateManyInput>
    /**
     * Filter which em_session_exams to update
     */
    where?: em_session_examsWhereInput
    /**
     * Limit how many em_session_exams to update.
     */
    limit?: number
  }

  /**
   * em_session_exams upsert
   */
  export type em_session_examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * The filter to search for the em_session_exams to update in case it exists.
     */
    where: em_session_examsWhereUniqueInput
    /**
     * In case the em_session_exams found by the `where` argument doesn't exist, create a new em_session_exams with this data.
     */
    create: XOR<em_session_examsCreateInput, em_session_examsUncheckedCreateInput>
    /**
     * In case the em_session_exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_session_examsUpdateInput, em_session_examsUncheckedUpdateInput>
  }

  /**
   * em_session_exams delete
   */
  export type em_session_examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
    /**
     * Filter which em_session_exams to delete.
     */
    where: em_session_examsWhereUniqueInput
  }

  /**
   * em_session_exams deleteMany
   */
  export type em_session_examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_session_exams to delete
     */
    where?: em_session_examsWhereInput
    /**
     * Limit how many em_session_exams to delete.
     */
    limit?: number
  }

  /**
   * em_session_exams.em_jawaban_peserta
   */
  export type em_session_exams$em_jawaban_pesertaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta
     */
    select?: em_jawaban_pesertaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta
     */
    omit?: em_jawaban_pesertaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_pesertaInclude<ExtArgs> | null
    where?: em_jawaban_pesertaWhereInput
    orderBy?: em_jawaban_pesertaOrderByWithRelationInput | em_jawaban_pesertaOrderByWithRelationInput[]
    cursor?: em_jawaban_pesertaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_jawaban_pesertaScalarFieldEnum | Em_jawaban_pesertaScalarFieldEnum[]
  }

  /**
   * em_session_exams without action
   */
  export type em_session_examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams
     */
    select?: em_session_examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams
     */
    omit?: em_session_examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_examsInclude<ExtArgs> | null
  }


  /**
   * Model em_session_exams_apc
   */

  export type AggregateEm_session_exams_apc = {
    _count: Em_session_exams_apcCountAggregateOutputType | null
    _avg: Em_session_exams_apcAvgAggregateOutputType | null
    _sum: Em_session_exams_apcSumAggregateOutputType | null
    _min: Em_session_exams_apcMinAggregateOutputType | null
    _max: Em_session_exams_apcMaxAggregateOutputType | null
  }

  export type Em_session_exams_apcAvgAggregateOutputType = {
    Id: number | null
    lokerid: number | null
    apcid: number | null
    durasi: number | null
    is_correct: number | null
    is_score_akhir: number | null
    curr_topic_index: number | null
    curr_soal_index: number | null
    is_jawaban_kosong: number | null
  }

  export type Em_session_exams_apcSumAggregateOutputType = {
    Id: number | null
    lokerid: number | null
    apcid: number | null
    durasi: number | null
    is_correct: number | null
    is_score_akhir: number | null
    curr_topic_index: number | null
    curr_soal_index: number | null
    is_jawaban_kosong: number | null
  }

  export type Em_session_exams_apcMinAggregateOutputType = {
    Id: number | null
    lokerid: number | null
    exams_id: string | null
    apcid: number | null
    soal_urut: string | null
    start_time: Date | null
    end_time: Date | null
    is_selesai: string | null
    is_token: string | null
    is_token_expr: Date | null
    durasi: number | null
    is_correct: number | null
    is_notes: string | null
    is_score_akhir: number | null
    curr_topic_index: number | null
    curr_soal_index: number | null
    is_intro_topic: boolean | null
    is_jawaban_kosong: number | null
  }

  export type Em_session_exams_apcMaxAggregateOutputType = {
    Id: number | null
    lokerid: number | null
    exams_id: string | null
    apcid: number | null
    soal_urut: string | null
    start_time: Date | null
    end_time: Date | null
    is_selesai: string | null
    is_token: string | null
    is_token_expr: Date | null
    durasi: number | null
    is_correct: number | null
    is_notes: string | null
    is_score_akhir: number | null
    curr_topic_index: number | null
    curr_soal_index: number | null
    is_intro_topic: boolean | null
    is_jawaban_kosong: number | null
  }

  export type Em_session_exams_apcCountAggregateOutputType = {
    Id: number
    lokerid: number
    exams_id: number
    apcid: number
    soal_urut: number
    start_time: number
    end_time: number
    is_selesai: number
    is_token: number
    is_token_expr: number
    durasi: number
    is_correct: number
    is_notes: number
    is_score_akhir: number
    curr_topic_index: number
    curr_soal_index: number
    is_intro_topic: number
    is_jawaban_kosong: number
    _all: number
  }


  export type Em_session_exams_apcAvgAggregateInputType = {
    Id?: true
    lokerid?: true
    apcid?: true
    durasi?: true
    is_correct?: true
    is_score_akhir?: true
    curr_topic_index?: true
    curr_soal_index?: true
    is_jawaban_kosong?: true
  }

  export type Em_session_exams_apcSumAggregateInputType = {
    Id?: true
    lokerid?: true
    apcid?: true
    durasi?: true
    is_correct?: true
    is_score_akhir?: true
    curr_topic_index?: true
    curr_soal_index?: true
    is_jawaban_kosong?: true
  }

  export type Em_session_exams_apcMinAggregateInputType = {
    Id?: true
    lokerid?: true
    exams_id?: true
    apcid?: true
    soal_urut?: true
    start_time?: true
    end_time?: true
    is_selesai?: true
    is_token?: true
    is_token_expr?: true
    durasi?: true
    is_correct?: true
    is_notes?: true
    is_score_akhir?: true
    curr_topic_index?: true
    curr_soal_index?: true
    is_intro_topic?: true
    is_jawaban_kosong?: true
  }

  export type Em_session_exams_apcMaxAggregateInputType = {
    Id?: true
    lokerid?: true
    exams_id?: true
    apcid?: true
    soal_urut?: true
    start_time?: true
    end_time?: true
    is_selesai?: true
    is_token?: true
    is_token_expr?: true
    durasi?: true
    is_correct?: true
    is_notes?: true
    is_score_akhir?: true
    curr_topic_index?: true
    curr_soal_index?: true
    is_intro_topic?: true
    is_jawaban_kosong?: true
  }

  export type Em_session_exams_apcCountAggregateInputType = {
    Id?: true
    lokerid?: true
    exams_id?: true
    apcid?: true
    soal_urut?: true
    start_time?: true
    end_time?: true
    is_selesai?: true
    is_token?: true
    is_token_expr?: true
    durasi?: true
    is_correct?: true
    is_notes?: true
    is_score_akhir?: true
    curr_topic_index?: true
    curr_soal_index?: true
    is_intro_topic?: true
    is_jawaban_kosong?: true
    _all?: true
  }

  export type Em_session_exams_apcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_session_exams_apc to aggregate.
     */
    where?: em_session_exams_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams_apcs to fetch.
     */
    orderBy?: em_session_exams_apcOrderByWithRelationInput | em_session_exams_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_session_exams_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams_apcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_session_exams_apcs
    **/
    _count?: true | Em_session_exams_apcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_session_exams_apcAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_session_exams_apcSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_session_exams_apcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_session_exams_apcMaxAggregateInputType
  }

  export type GetEm_session_exams_apcAggregateType<T extends Em_session_exams_apcAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_session_exams_apc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_session_exams_apc[P]>
      : GetScalarType<T[P], AggregateEm_session_exams_apc[P]>
  }




  export type em_session_exams_apcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_session_exams_apcWhereInput
    orderBy?: em_session_exams_apcOrderByWithAggregationInput | em_session_exams_apcOrderByWithAggregationInput[]
    by: Em_session_exams_apcScalarFieldEnum[] | Em_session_exams_apcScalarFieldEnum
    having?: em_session_exams_apcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_session_exams_apcCountAggregateInputType | true
    _avg?: Em_session_exams_apcAvgAggregateInputType
    _sum?: Em_session_exams_apcSumAggregateInputType
    _min?: Em_session_exams_apcMinAggregateInputType
    _max?: Em_session_exams_apcMaxAggregateInputType
  }

  export type Em_session_exams_apcGroupByOutputType = {
    Id: number
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut: string | null
    start_time: Date | null
    end_time: Date | null
    is_selesai: string | null
    is_token: string | null
    is_token_expr: Date | null
    durasi: number | null
    is_correct: number | null
    is_notes: string | null
    is_score_akhir: number | null
    curr_topic_index: number | null
    curr_soal_index: number | null
    is_intro_topic: boolean | null
    is_jawaban_kosong: number | null
    _count: Em_session_exams_apcCountAggregateOutputType | null
    _avg: Em_session_exams_apcAvgAggregateOutputType | null
    _sum: Em_session_exams_apcSumAggregateOutputType | null
    _min: Em_session_exams_apcMinAggregateOutputType | null
    _max: Em_session_exams_apcMaxAggregateOutputType | null
  }

  type GetEm_session_exams_apcGroupByPayload<T extends em_session_exams_apcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_session_exams_apcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_session_exams_apcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_session_exams_apcGroupByOutputType[P]>
            : GetScalarType<T[P], Em_session_exams_apcGroupByOutputType[P]>
        }
      >
    >


  export type em_session_exams_apcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    lokerid?: boolean
    exams_id?: boolean
    apcid?: boolean
    soal_urut?: boolean
    start_time?: boolean
    end_time?: boolean
    is_selesai?: boolean
    is_token?: boolean
    is_token_expr?: boolean
    durasi?: boolean
    is_correct?: boolean
    is_notes?: boolean
    is_score_akhir?: boolean
    curr_topic_index?: boolean
    curr_soal_index?: boolean
    is_intro_topic?: boolean
    is_jawaban_kosong?: boolean
    em_jawaban_peserta_apc?: boolean | em_session_exams_apc$em_jawaban_peserta_apcArgs<ExtArgs>
    em_topic_selesai?: boolean | em_session_exams_apc$em_topic_selesaiArgs<ExtArgs>
    _count?: boolean | Em_session_exams_apcCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_session_exams_apc"]>



  export type em_session_exams_apcSelectScalar = {
    Id?: boolean
    lokerid?: boolean
    exams_id?: boolean
    apcid?: boolean
    soal_urut?: boolean
    start_time?: boolean
    end_time?: boolean
    is_selesai?: boolean
    is_token?: boolean
    is_token_expr?: boolean
    durasi?: boolean
    is_correct?: boolean
    is_notes?: boolean
    is_score_akhir?: boolean
    curr_topic_index?: boolean
    curr_soal_index?: boolean
    is_intro_topic?: boolean
    is_jawaban_kosong?: boolean
  }

  export type em_session_exams_apcOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "lokerid" | "exams_id" | "apcid" | "soal_urut" | "start_time" | "end_time" | "is_selesai" | "is_token" | "is_token_expr" | "durasi" | "is_correct" | "is_notes" | "is_score_akhir" | "curr_topic_index" | "curr_soal_index" | "is_intro_topic" | "is_jawaban_kosong", ExtArgs["result"]["em_session_exams_apc"]>
  export type em_session_exams_apcInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_jawaban_peserta_apc?: boolean | em_session_exams_apc$em_jawaban_peserta_apcArgs<ExtArgs>
    em_topic_selesai?: boolean | em_session_exams_apc$em_topic_selesaiArgs<ExtArgs>
    _count?: boolean | Em_session_exams_apcCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $em_session_exams_apcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_session_exams_apc"
    objects: {
      em_jawaban_peserta_apc: Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>[]
      em_topic_selesai: Prisma.$em_topic_selesaiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      lokerid: number
      exams_id: string
      apcid: number
      soal_urut: string | null
      start_time: Date | null
      end_time: Date | null
      is_selesai: string | null
      is_token: string | null
      is_token_expr: Date | null
      durasi: number | null
      is_correct: number | null
      is_notes: string | null
      is_score_akhir: number | null
      curr_topic_index: number | null
      curr_soal_index: number | null
      is_intro_topic: boolean | null
      is_jawaban_kosong: number | null
    }, ExtArgs["result"]["em_session_exams_apc"]>
    composites: {}
  }

  type em_session_exams_apcGetPayload<S extends boolean | null | undefined | em_session_exams_apcDefaultArgs> = $Result.GetResult<Prisma.$em_session_exams_apcPayload, S>

  type em_session_exams_apcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_session_exams_apcFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_session_exams_apcCountAggregateInputType | true
    }

  export interface em_session_exams_apcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_session_exams_apc'], meta: { name: 'em_session_exams_apc' } }
    /**
     * Find zero or one Em_session_exams_apc that matches the filter.
     * @param {em_session_exams_apcFindUniqueArgs} args - Arguments to find a Em_session_exams_apc
     * @example
     * // Get one Em_session_exams_apc
     * const em_session_exams_apc = await prisma.em_session_exams_apc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_session_exams_apcFindUniqueArgs>(args: SelectSubset<T, em_session_exams_apcFindUniqueArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_session_exams_apc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_session_exams_apcFindUniqueOrThrowArgs} args - Arguments to find a Em_session_exams_apc
     * @example
     * // Get one Em_session_exams_apc
     * const em_session_exams_apc = await prisma.em_session_exams_apc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_session_exams_apcFindUniqueOrThrowArgs>(args: SelectSubset<T, em_session_exams_apcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_session_exams_apc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_exams_apcFindFirstArgs} args - Arguments to find a Em_session_exams_apc
     * @example
     * // Get one Em_session_exams_apc
     * const em_session_exams_apc = await prisma.em_session_exams_apc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_session_exams_apcFindFirstArgs>(args?: SelectSubset<T, em_session_exams_apcFindFirstArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_session_exams_apc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_exams_apcFindFirstOrThrowArgs} args - Arguments to find a Em_session_exams_apc
     * @example
     * // Get one Em_session_exams_apc
     * const em_session_exams_apc = await prisma.em_session_exams_apc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_session_exams_apcFindFirstOrThrowArgs>(args?: SelectSubset<T, em_session_exams_apcFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_session_exams_apcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_exams_apcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_session_exams_apcs
     * const em_session_exams_apcs = await prisma.em_session_exams_apc.findMany()
     * 
     * // Get first 10 Em_session_exams_apcs
     * const em_session_exams_apcs = await prisma.em_session_exams_apc.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_session_exams_apcWithIdOnly = await prisma.em_session_exams_apc.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_session_exams_apcFindManyArgs>(args?: SelectSubset<T, em_session_exams_apcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_session_exams_apc.
     * @param {em_session_exams_apcCreateArgs} args - Arguments to create a Em_session_exams_apc.
     * @example
     * // Create one Em_session_exams_apc
     * const Em_session_exams_apc = await prisma.em_session_exams_apc.create({
     *   data: {
     *     // ... data to create a Em_session_exams_apc
     *   }
     * })
     * 
     */
    create<T extends em_session_exams_apcCreateArgs>(args: SelectSubset<T, em_session_exams_apcCreateArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_session_exams_apcs.
     * @param {em_session_exams_apcCreateManyArgs} args - Arguments to create many Em_session_exams_apcs.
     * @example
     * // Create many Em_session_exams_apcs
     * const em_session_exams_apc = await prisma.em_session_exams_apc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_session_exams_apcCreateManyArgs>(args?: SelectSubset<T, em_session_exams_apcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_session_exams_apc.
     * @param {em_session_exams_apcDeleteArgs} args - Arguments to delete one Em_session_exams_apc.
     * @example
     * // Delete one Em_session_exams_apc
     * const Em_session_exams_apc = await prisma.em_session_exams_apc.delete({
     *   where: {
     *     // ... filter to delete one Em_session_exams_apc
     *   }
     * })
     * 
     */
    delete<T extends em_session_exams_apcDeleteArgs>(args: SelectSubset<T, em_session_exams_apcDeleteArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_session_exams_apc.
     * @param {em_session_exams_apcUpdateArgs} args - Arguments to update one Em_session_exams_apc.
     * @example
     * // Update one Em_session_exams_apc
     * const em_session_exams_apc = await prisma.em_session_exams_apc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_session_exams_apcUpdateArgs>(args: SelectSubset<T, em_session_exams_apcUpdateArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_session_exams_apcs.
     * @param {em_session_exams_apcDeleteManyArgs} args - Arguments to filter Em_session_exams_apcs to delete.
     * @example
     * // Delete a few Em_session_exams_apcs
     * const { count } = await prisma.em_session_exams_apc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_session_exams_apcDeleteManyArgs>(args?: SelectSubset<T, em_session_exams_apcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_session_exams_apcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_exams_apcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_session_exams_apcs
     * const em_session_exams_apc = await prisma.em_session_exams_apc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_session_exams_apcUpdateManyArgs>(args: SelectSubset<T, em_session_exams_apcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_session_exams_apc.
     * @param {em_session_exams_apcUpsertArgs} args - Arguments to update or create a Em_session_exams_apc.
     * @example
     * // Update or create a Em_session_exams_apc
     * const em_session_exams_apc = await prisma.em_session_exams_apc.upsert({
     *   create: {
     *     // ... data to create a Em_session_exams_apc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_session_exams_apc we want to update
     *   }
     * })
     */
    upsert<T extends em_session_exams_apcUpsertArgs>(args: SelectSubset<T, em_session_exams_apcUpsertArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_session_exams_apcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_exams_apcCountArgs} args - Arguments to filter Em_session_exams_apcs to count.
     * @example
     * // Count the number of Em_session_exams_apcs
     * const count = await prisma.em_session_exams_apc.count({
     *   where: {
     *     // ... the filter for the Em_session_exams_apcs we want to count
     *   }
     * })
    **/
    count<T extends em_session_exams_apcCountArgs>(
      args?: Subset<T, em_session_exams_apcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_session_exams_apcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_session_exams_apc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_session_exams_apcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_session_exams_apcAggregateArgs>(args: Subset<T, Em_session_exams_apcAggregateArgs>): Prisma.PrismaPromise<GetEm_session_exams_apcAggregateType<T>>

    /**
     * Group by Em_session_exams_apc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_session_exams_apcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_session_exams_apcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_session_exams_apcGroupByArgs['orderBy'] }
        : { orderBy?: em_session_exams_apcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_session_exams_apcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_session_exams_apcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_session_exams_apc model
   */
  readonly fields: em_session_exams_apcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_session_exams_apc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_session_exams_apcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_jawaban_peserta_apc<T extends em_session_exams_apc$em_jawaban_peserta_apcArgs<ExtArgs> = {}>(args?: Subset<T, em_session_exams_apc$em_jawaban_peserta_apcArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_jawaban_peserta_apcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_topic_selesai<T extends em_session_exams_apc$em_topic_selesaiArgs<ExtArgs> = {}>(args?: Subset<T, em_session_exams_apc$em_topic_selesaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_session_exams_apc model
   */
  interface em_session_exams_apcFieldRefs {
    readonly Id: FieldRef<"em_session_exams_apc", 'Int'>
    readonly lokerid: FieldRef<"em_session_exams_apc", 'Int'>
    readonly exams_id: FieldRef<"em_session_exams_apc", 'String'>
    readonly apcid: FieldRef<"em_session_exams_apc", 'Int'>
    readonly soal_urut: FieldRef<"em_session_exams_apc", 'String'>
    readonly start_time: FieldRef<"em_session_exams_apc", 'DateTime'>
    readonly end_time: FieldRef<"em_session_exams_apc", 'DateTime'>
    readonly is_selesai: FieldRef<"em_session_exams_apc", 'String'>
    readonly is_token: FieldRef<"em_session_exams_apc", 'String'>
    readonly is_token_expr: FieldRef<"em_session_exams_apc", 'DateTime'>
    readonly durasi: FieldRef<"em_session_exams_apc", 'Int'>
    readonly is_correct: FieldRef<"em_session_exams_apc", 'Int'>
    readonly is_notes: FieldRef<"em_session_exams_apc", 'String'>
    readonly is_score_akhir: FieldRef<"em_session_exams_apc", 'Float'>
    readonly curr_topic_index: FieldRef<"em_session_exams_apc", 'Int'>
    readonly curr_soal_index: FieldRef<"em_session_exams_apc", 'Int'>
    readonly is_intro_topic: FieldRef<"em_session_exams_apc", 'Boolean'>
    readonly is_jawaban_kosong: FieldRef<"em_session_exams_apc", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_session_exams_apc findUnique
   */
  export type em_session_exams_apcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams_apc to fetch.
     */
    where: em_session_exams_apcWhereUniqueInput
  }

  /**
   * em_session_exams_apc findUniqueOrThrow
   */
  export type em_session_exams_apcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams_apc to fetch.
     */
    where: em_session_exams_apcWhereUniqueInput
  }

  /**
   * em_session_exams_apc findFirst
   */
  export type em_session_exams_apcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams_apc to fetch.
     */
    where?: em_session_exams_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams_apcs to fetch.
     */
    orderBy?: em_session_exams_apcOrderByWithRelationInput | em_session_exams_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_session_exams_apcs.
     */
    cursor?: em_session_exams_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams_apcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_session_exams_apcs.
     */
    distinct?: Em_session_exams_apcScalarFieldEnum | Em_session_exams_apcScalarFieldEnum[]
  }

  /**
   * em_session_exams_apc findFirstOrThrow
   */
  export type em_session_exams_apcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams_apc to fetch.
     */
    where?: em_session_exams_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams_apcs to fetch.
     */
    orderBy?: em_session_exams_apcOrderByWithRelationInput | em_session_exams_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_session_exams_apcs.
     */
    cursor?: em_session_exams_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams_apcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_session_exams_apcs.
     */
    distinct?: Em_session_exams_apcScalarFieldEnum | Em_session_exams_apcScalarFieldEnum[]
  }

  /**
   * em_session_exams_apc findMany
   */
  export type em_session_exams_apcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * Filter, which em_session_exams_apcs to fetch.
     */
    where?: em_session_exams_apcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_session_exams_apcs to fetch.
     */
    orderBy?: em_session_exams_apcOrderByWithRelationInput | em_session_exams_apcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_session_exams_apcs.
     */
    cursor?: em_session_exams_apcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_session_exams_apcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_session_exams_apcs.
     */
    skip?: number
    distinct?: Em_session_exams_apcScalarFieldEnum | Em_session_exams_apcScalarFieldEnum[]
  }

  /**
   * em_session_exams_apc create
   */
  export type em_session_exams_apcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * The data needed to create a em_session_exams_apc.
     */
    data: XOR<em_session_exams_apcCreateInput, em_session_exams_apcUncheckedCreateInput>
  }

  /**
   * em_session_exams_apc createMany
   */
  export type em_session_exams_apcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_session_exams_apcs.
     */
    data: em_session_exams_apcCreateManyInput | em_session_exams_apcCreateManyInput[]
  }

  /**
   * em_session_exams_apc update
   */
  export type em_session_exams_apcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * The data needed to update a em_session_exams_apc.
     */
    data: XOR<em_session_exams_apcUpdateInput, em_session_exams_apcUncheckedUpdateInput>
    /**
     * Choose, which em_session_exams_apc to update.
     */
    where: em_session_exams_apcWhereUniqueInput
  }

  /**
   * em_session_exams_apc updateMany
   */
  export type em_session_exams_apcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_session_exams_apcs.
     */
    data: XOR<em_session_exams_apcUpdateManyMutationInput, em_session_exams_apcUncheckedUpdateManyInput>
    /**
     * Filter which em_session_exams_apcs to update
     */
    where?: em_session_exams_apcWhereInput
    /**
     * Limit how many em_session_exams_apcs to update.
     */
    limit?: number
  }

  /**
   * em_session_exams_apc upsert
   */
  export type em_session_exams_apcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * The filter to search for the em_session_exams_apc to update in case it exists.
     */
    where: em_session_exams_apcWhereUniqueInput
    /**
     * In case the em_session_exams_apc found by the `where` argument doesn't exist, create a new em_session_exams_apc with this data.
     */
    create: XOR<em_session_exams_apcCreateInput, em_session_exams_apcUncheckedCreateInput>
    /**
     * In case the em_session_exams_apc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_session_exams_apcUpdateInput, em_session_exams_apcUncheckedUpdateInput>
  }

  /**
   * em_session_exams_apc delete
   */
  export type em_session_exams_apcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
    /**
     * Filter which em_session_exams_apc to delete.
     */
    where: em_session_exams_apcWhereUniqueInput
  }

  /**
   * em_session_exams_apc deleteMany
   */
  export type em_session_exams_apcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_session_exams_apcs to delete
     */
    where?: em_session_exams_apcWhereInput
    /**
     * Limit how many em_session_exams_apcs to delete.
     */
    limit?: number
  }

  /**
   * em_session_exams_apc.em_jawaban_peserta_apc
   */
  export type em_session_exams_apc$em_jawaban_peserta_apcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_jawaban_peserta_apc
     */
    select?: em_jawaban_peserta_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_jawaban_peserta_apc
     */
    omit?: em_jawaban_peserta_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_jawaban_peserta_apcInclude<ExtArgs> | null
    where?: em_jawaban_peserta_apcWhereInput
    orderBy?: em_jawaban_peserta_apcOrderByWithRelationInput | em_jawaban_peserta_apcOrderByWithRelationInput[]
    cursor?: em_jawaban_peserta_apcWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_jawaban_peserta_apcScalarFieldEnum | Em_jawaban_peserta_apcScalarFieldEnum[]
  }

  /**
   * em_session_exams_apc.em_topic_selesai
   */
  export type em_session_exams_apc$em_topic_selesaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    where?: em_topic_selesaiWhereInput
    orderBy?: em_topic_selesaiOrderByWithRelationInput | em_topic_selesaiOrderByWithRelationInput[]
    cursor?: em_topic_selesaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_topic_selesaiScalarFieldEnum | Em_topic_selesaiScalarFieldEnum[]
  }

  /**
   * em_session_exams_apc without action
   */
  export type em_session_exams_apcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_session_exams_apc
     */
    select?: em_session_exams_apcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_session_exams_apc
     */
    omit?: em_session_exams_apcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_session_exams_apcInclude<ExtArgs> | null
  }


  /**
   * Model em_subscribe
   */

  export type AggregateEm_subscribe = {
    _count: Em_subscribeCountAggregateOutputType | null
    _avg: Em_subscribeAvgAggregateOutputType | null
    _sum: Em_subscribeSumAggregateOutputType | null
    _min: Em_subscribeMinAggregateOutputType | null
    _max: Em_subscribeMaxAggregateOutputType | null
  }

  export type Em_subscribeAvgAggregateOutputType = {
    Id: number | null
  }

  export type Em_subscribeSumAggregateOutputType = {
    Id: number | null
  }

  export type Em_subscribeMinAggregateOutputType = {
    Id: number | null
    UserId: string | null
    Name: string | null
    Status: string | null
    Endpoint: string | null
    P256dh: string | null
    Auth: string | null
    Created_at: Date | null
    LastUpdate: Date | null
  }

  export type Em_subscribeMaxAggregateOutputType = {
    Id: number | null
    UserId: string | null
    Name: string | null
    Status: string | null
    Endpoint: string | null
    P256dh: string | null
    Auth: string | null
    Created_at: Date | null
    LastUpdate: Date | null
  }

  export type Em_subscribeCountAggregateOutputType = {
    Id: number
    UserId: number
    Name: number
    Status: number
    Endpoint: number
    P256dh: number
    Auth: number
    Created_at: number
    LastUpdate: number
    _all: number
  }


  export type Em_subscribeAvgAggregateInputType = {
    Id?: true
  }

  export type Em_subscribeSumAggregateInputType = {
    Id?: true
  }

  export type Em_subscribeMinAggregateInputType = {
    Id?: true
    UserId?: true
    Name?: true
    Status?: true
    Endpoint?: true
    P256dh?: true
    Auth?: true
    Created_at?: true
    LastUpdate?: true
  }

  export type Em_subscribeMaxAggregateInputType = {
    Id?: true
    UserId?: true
    Name?: true
    Status?: true
    Endpoint?: true
    P256dh?: true
    Auth?: true
    Created_at?: true
    LastUpdate?: true
  }

  export type Em_subscribeCountAggregateInputType = {
    Id?: true
    UserId?: true
    Name?: true
    Status?: true
    Endpoint?: true
    P256dh?: true
    Auth?: true
    Created_at?: true
    LastUpdate?: true
    _all?: true
  }

  export type Em_subscribeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_subscribe to aggregate.
     */
    where?: em_subscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscribes to fetch.
     */
    orderBy?: em_subscribeOrderByWithRelationInput | em_subscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_subscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_subscribes
    **/
    _count?: true | Em_subscribeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_subscribeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_subscribeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_subscribeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_subscribeMaxAggregateInputType
  }

  export type GetEm_subscribeAggregateType<T extends Em_subscribeAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_subscribe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_subscribe[P]>
      : GetScalarType<T[P], AggregateEm_subscribe[P]>
  }




  export type em_subscribeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_subscribeWhereInput
    orderBy?: em_subscribeOrderByWithAggregationInput | em_subscribeOrderByWithAggregationInput[]
    by: Em_subscribeScalarFieldEnum[] | Em_subscribeScalarFieldEnum
    having?: em_subscribeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_subscribeCountAggregateInputType | true
    _avg?: Em_subscribeAvgAggregateInputType
    _sum?: Em_subscribeSumAggregateInputType
    _min?: Em_subscribeMinAggregateInputType
    _max?: Em_subscribeMaxAggregateInputType
  }

  export type Em_subscribeGroupByOutputType = {
    Id: number
    UserId: string | null
    Name: string | null
    Status: string | null
    Endpoint: string | null
    P256dh: string | null
    Auth: string | null
    Created_at: Date | null
    LastUpdate: Date | null
    _count: Em_subscribeCountAggregateOutputType | null
    _avg: Em_subscribeAvgAggregateOutputType | null
    _sum: Em_subscribeSumAggregateOutputType | null
    _min: Em_subscribeMinAggregateOutputType | null
    _max: Em_subscribeMaxAggregateOutputType | null
  }

  type GetEm_subscribeGroupByPayload<T extends em_subscribeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_subscribeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_subscribeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_subscribeGroupByOutputType[P]>
            : GetScalarType<T[P], Em_subscribeGroupByOutputType[P]>
        }
      >
    >


  export type em_subscribeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    Name?: boolean
    Status?: boolean
    Endpoint?: boolean
    P256dh?: boolean
    Auth?: boolean
    Created_at?: boolean
    LastUpdate?: boolean
  }, ExtArgs["result"]["em_subscribe"]>



  export type em_subscribeSelectScalar = {
    Id?: boolean
    UserId?: boolean
    Name?: boolean
    Status?: boolean
    Endpoint?: boolean
    P256dh?: boolean
    Auth?: boolean
    Created_at?: boolean
    LastUpdate?: boolean
  }

  export type em_subscribeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UserId" | "Name" | "Status" | "Endpoint" | "P256dh" | "Auth" | "Created_at" | "LastUpdate", ExtArgs["result"]["em_subscribe"]>

  export type $em_subscribePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_subscribe"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserId: string | null
      Name: string | null
      Status: string | null
      Endpoint: string | null
      P256dh: string | null
      Auth: string | null
      Created_at: Date | null
      LastUpdate: Date | null
    }, ExtArgs["result"]["em_subscribe"]>
    composites: {}
  }

  type em_subscribeGetPayload<S extends boolean | null | undefined | em_subscribeDefaultArgs> = $Result.GetResult<Prisma.$em_subscribePayload, S>

  type em_subscribeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_subscribeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_subscribeCountAggregateInputType | true
    }

  export interface em_subscribeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_subscribe'], meta: { name: 'em_subscribe' } }
    /**
     * Find zero or one Em_subscribe that matches the filter.
     * @param {em_subscribeFindUniqueArgs} args - Arguments to find a Em_subscribe
     * @example
     * // Get one Em_subscribe
     * const em_subscribe = await prisma.em_subscribe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_subscribeFindUniqueArgs>(args: SelectSubset<T, em_subscribeFindUniqueArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_subscribe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_subscribeFindUniqueOrThrowArgs} args - Arguments to find a Em_subscribe
     * @example
     * // Get one Em_subscribe
     * const em_subscribe = await prisma.em_subscribe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_subscribeFindUniqueOrThrowArgs>(args: SelectSubset<T, em_subscribeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_subscribe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscribeFindFirstArgs} args - Arguments to find a Em_subscribe
     * @example
     * // Get one Em_subscribe
     * const em_subscribe = await prisma.em_subscribe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_subscribeFindFirstArgs>(args?: SelectSubset<T, em_subscribeFindFirstArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_subscribe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscribeFindFirstOrThrowArgs} args - Arguments to find a Em_subscribe
     * @example
     * // Get one Em_subscribe
     * const em_subscribe = await prisma.em_subscribe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_subscribeFindFirstOrThrowArgs>(args?: SelectSubset<T, em_subscribeFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_subscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscribeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_subscribes
     * const em_subscribes = await prisma.em_subscribe.findMany()
     * 
     * // Get first 10 Em_subscribes
     * const em_subscribes = await prisma.em_subscribe.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_subscribeWithIdOnly = await prisma.em_subscribe.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_subscribeFindManyArgs>(args?: SelectSubset<T, em_subscribeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_subscribe.
     * @param {em_subscribeCreateArgs} args - Arguments to create a Em_subscribe.
     * @example
     * // Create one Em_subscribe
     * const Em_subscribe = await prisma.em_subscribe.create({
     *   data: {
     *     // ... data to create a Em_subscribe
     *   }
     * })
     * 
     */
    create<T extends em_subscribeCreateArgs>(args: SelectSubset<T, em_subscribeCreateArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_subscribes.
     * @param {em_subscribeCreateManyArgs} args - Arguments to create many Em_subscribes.
     * @example
     * // Create many Em_subscribes
     * const em_subscribe = await prisma.em_subscribe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_subscribeCreateManyArgs>(args?: SelectSubset<T, em_subscribeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_subscribe.
     * @param {em_subscribeDeleteArgs} args - Arguments to delete one Em_subscribe.
     * @example
     * // Delete one Em_subscribe
     * const Em_subscribe = await prisma.em_subscribe.delete({
     *   where: {
     *     // ... filter to delete one Em_subscribe
     *   }
     * })
     * 
     */
    delete<T extends em_subscribeDeleteArgs>(args: SelectSubset<T, em_subscribeDeleteArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_subscribe.
     * @param {em_subscribeUpdateArgs} args - Arguments to update one Em_subscribe.
     * @example
     * // Update one Em_subscribe
     * const em_subscribe = await prisma.em_subscribe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_subscribeUpdateArgs>(args: SelectSubset<T, em_subscribeUpdateArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_subscribes.
     * @param {em_subscribeDeleteManyArgs} args - Arguments to filter Em_subscribes to delete.
     * @example
     * // Delete a few Em_subscribes
     * const { count } = await prisma.em_subscribe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_subscribeDeleteManyArgs>(args?: SelectSubset<T, em_subscribeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscribeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_subscribes
     * const em_subscribe = await prisma.em_subscribe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_subscribeUpdateManyArgs>(args: SelectSubset<T, em_subscribeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_subscribe.
     * @param {em_subscribeUpsertArgs} args - Arguments to update or create a Em_subscribe.
     * @example
     * // Update or create a Em_subscribe
     * const em_subscribe = await prisma.em_subscribe.upsert({
     *   create: {
     *     // ... data to create a Em_subscribe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_subscribe we want to update
     *   }
     * })
     */
    upsert<T extends em_subscribeUpsertArgs>(args: SelectSubset<T, em_subscribeUpsertArgs<ExtArgs>>): Prisma__em_subscribeClient<$Result.GetResult<Prisma.$em_subscribePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscribeCountArgs} args - Arguments to filter Em_subscribes to count.
     * @example
     * // Count the number of Em_subscribes
     * const count = await prisma.em_subscribe.count({
     *   where: {
     *     // ... the filter for the Em_subscribes we want to count
     *   }
     * })
    **/
    count<T extends em_subscribeCountArgs>(
      args?: Subset<T, em_subscribeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_subscribeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_subscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_subscribeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_subscribeAggregateArgs>(args: Subset<T, Em_subscribeAggregateArgs>): Prisma.PrismaPromise<GetEm_subscribeAggregateType<T>>

    /**
     * Group by Em_subscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscribeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_subscribeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_subscribeGroupByArgs['orderBy'] }
        : { orderBy?: em_subscribeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_subscribeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_subscribeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_subscribe model
   */
  readonly fields: em_subscribeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_subscribe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_subscribeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_subscribe model
   */
  interface em_subscribeFieldRefs {
    readonly Id: FieldRef<"em_subscribe", 'Int'>
    readonly UserId: FieldRef<"em_subscribe", 'String'>
    readonly Name: FieldRef<"em_subscribe", 'String'>
    readonly Status: FieldRef<"em_subscribe", 'String'>
    readonly Endpoint: FieldRef<"em_subscribe", 'String'>
    readonly P256dh: FieldRef<"em_subscribe", 'String'>
    readonly Auth: FieldRef<"em_subscribe", 'String'>
    readonly Created_at: FieldRef<"em_subscribe", 'DateTime'>
    readonly LastUpdate: FieldRef<"em_subscribe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_subscribe findUnique
   */
  export type em_subscribeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * Filter, which em_subscribe to fetch.
     */
    where: em_subscribeWhereUniqueInput
  }

  /**
   * em_subscribe findUniqueOrThrow
   */
  export type em_subscribeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * Filter, which em_subscribe to fetch.
     */
    where: em_subscribeWhereUniqueInput
  }

  /**
   * em_subscribe findFirst
   */
  export type em_subscribeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * Filter, which em_subscribe to fetch.
     */
    where?: em_subscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscribes to fetch.
     */
    orderBy?: em_subscribeOrderByWithRelationInput | em_subscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_subscribes.
     */
    cursor?: em_subscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_subscribes.
     */
    distinct?: Em_subscribeScalarFieldEnum | Em_subscribeScalarFieldEnum[]
  }

  /**
   * em_subscribe findFirstOrThrow
   */
  export type em_subscribeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * Filter, which em_subscribe to fetch.
     */
    where?: em_subscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscribes to fetch.
     */
    orderBy?: em_subscribeOrderByWithRelationInput | em_subscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_subscribes.
     */
    cursor?: em_subscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_subscribes.
     */
    distinct?: Em_subscribeScalarFieldEnum | Em_subscribeScalarFieldEnum[]
  }

  /**
   * em_subscribe findMany
   */
  export type em_subscribeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * Filter, which em_subscribes to fetch.
     */
    where?: em_subscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscribes to fetch.
     */
    orderBy?: em_subscribeOrderByWithRelationInput | em_subscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_subscribes.
     */
    cursor?: em_subscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscribes.
     */
    skip?: number
    distinct?: Em_subscribeScalarFieldEnum | Em_subscribeScalarFieldEnum[]
  }

  /**
   * em_subscribe create
   */
  export type em_subscribeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * The data needed to create a em_subscribe.
     */
    data?: XOR<em_subscribeCreateInput, em_subscribeUncheckedCreateInput>
  }

  /**
   * em_subscribe createMany
   */
  export type em_subscribeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_subscribes.
     */
    data: em_subscribeCreateManyInput | em_subscribeCreateManyInput[]
  }

  /**
   * em_subscribe update
   */
  export type em_subscribeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * The data needed to update a em_subscribe.
     */
    data: XOR<em_subscribeUpdateInput, em_subscribeUncheckedUpdateInput>
    /**
     * Choose, which em_subscribe to update.
     */
    where: em_subscribeWhereUniqueInput
  }

  /**
   * em_subscribe updateMany
   */
  export type em_subscribeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_subscribes.
     */
    data: XOR<em_subscribeUpdateManyMutationInput, em_subscribeUncheckedUpdateManyInput>
    /**
     * Filter which em_subscribes to update
     */
    where?: em_subscribeWhereInput
    /**
     * Limit how many em_subscribes to update.
     */
    limit?: number
  }

  /**
   * em_subscribe upsert
   */
  export type em_subscribeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * The filter to search for the em_subscribe to update in case it exists.
     */
    where: em_subscribeWhereUniqueInput
    /**
     * In case the em_subscribe found by the `where` argument doesn't exist, create a new em_subscribe with this data.
     */
    create: XOR<em_subscribeCreateInput, em_subscribeUncheckedCreateInput>
    /**
     * In case the em_subscribe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_subscribeUpdateInput, em_subscribeUncheckedUpdateInput>
  }

  /**
   * em_subscribe delete
   */
  export type em_subscribeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
    /**
     * Filter which em_subscribe to delete.
     */
    where: em_subscribeWhereUniqueInput
  }

  /**
   * em_subscribe deleteMany
   */
  export type em_subscribeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_subscribes to delete
     */
    where?: em_subscribeWhereInput
    /**
     * Limit how many em_subscribes to delete.
     */
    limit?: number
  }

  /**
   * em_subscribe without action
   */
  export type em_subscribeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscribe
     */
    select?: em_subscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscribe
     */
    omit?: em_subscribeOmit<ExtArgs> | null
  }


  /**
   * Model em_subscription
   */

  export type AggregateEm_subscription = {
    _count: Em_subscriptionCountAggregateOutputType | null
    _avg: Em_subscriptionAvgAggregateOutputType | null
    _sum: Em_subscriptionSumAggregateOutputType | null
    _min: Em_subscriptionMinAggregateOutputType | null
    _max: Em_subscriptionMaxAggregateOutputType | null
  }

  export type Em_subscriptionAvgAggregateOutputType = {
    Id: number | null
  }

  export type Em_subscriptionSumAggregateOutputType = {
    Id: number | null
  }

  export type Em_subscriptionMinAggregateOutputType = {
    Id: number | null
    username: string | null
    subscription: string | null
    status: string | null
    createdat: Date | null
  }

  export type Em_subscriptionMaxAggregateOutputType = {
    Id: number | null
    username: string | null
    subscription: string | null
    status: string | null
    createdat: Date | null
  }

  export type Em_subscriptionCountAggregateOutputType = {
    Id: number
    username: number
    subscription: number
    status: number
    createdat: number
    _all: number
  }


  export type Em_subscriptionAvgAggregateInputType = {
    Id?: true
  }

  export type Em_subscriptionSumAggregateInputType = {
    Id?: true
  }

  export type Em_subscriptionMinAggregateInputType = {
    Id?: true
    username?: true
    subscription?: true
    status?: true
    createdat?: true
  }

  export type Em_subscriptionMaxAggregateInputType = {
    Id?: true
    username?: true
    subscription?: true
    status?: true
    createdat?: true
  }

  export type Em_subscriptionCountAggregateInputType = {
    Id?: true
    username?: true
    subscription?: true
    status?: true
    createdat?: true
    _all?: true
  }

  export type Em_subscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_subscription to aggregate.
     */
    where?: em_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscriptions to fetch.
     */
    orderBy?: em_subscriptionOrderByWithRelationInput | em_subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_subscriptions
    **/
    _count?: true | Em_subscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_subscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_subscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_subscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_subscriptionMaxAggregateInputType
  }

  export type GetEm_subscriptionAggregateType<T extends Em_subscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_subscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_subscription[P]>
      : GetScalarType<T[P], AggregateEm_subscription[P]>
  }




  export type em_subscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_subscriptionWhereInput
    orderBy?: em_subscriptionOrderByWithAggregationInput | em_subscriptionOrderByWithAggregationInput[]
    by: Em_subscriptionScalarFieldEnum[] | Em_subscriptionScalarFieldEnum
    having?: em_subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_subscriptionCountAggregateInputType | true
    _avg?: Em_subscriptionAvgAggregateInputType
    _sum?: Em_subscriptionSumAggregateInputType
    _min?: Em_subscriptionMinAggregateInputType
    _max?: Em_subscriptionMaxAggregateInputType
  }

  export type Em_subscriptionGroupByOutputType = {
    Id: number
    username: string
    subscription: string | null
    status: string | null
    createdat: Date | null
    _count: Em_subscriptionCountAggregateOutputType | null
    _avg: Em_subscriptionAvgAggregateOutputType | null
    _sum: Em_subscriptionSumAggregateOutputType | null
    _min: Em_subscriptionMinAggregateOutputType | null
    _max: Em_subscriptionMaxAggregateOutputType | null
  }

  type GetEm_subscriptionGroupByPayload<T extends em_subscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_subscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_subscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_subscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], Em_subscriptionGroupByOutputType[P]>
        }
      >
    >


  export type em_subscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    username?: boolean
    subscription?: boolean
    status?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["em_subscription"]>



  export type em_subscriptionSelectScalar = {
    Id?: boolean
    username?: boolean
    subscription?: boolean
    status?: boolean
    createdat?: boolean
  }

  export type em_subscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "username" | "subscription" | "status" | "createdat", ExtArgs["result"]["em_subscription"]>

  export type $em_subscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_subscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      username: string
      subscription: string | null
      status: string | null
      createdat: Date | null
    }, ExtArgs["result"]["em_subscription"]>
    composites: {}
  }

  type em_subscriptionGetPayload<S extends boolean | null | undefined | em_subscriptionDefaultArgs> = $Result.GetResult<Prisma.$em_subscriptionPayload, S>

  type em_subscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_subscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_subscriptionCountAggregateInputType | true
    }

  export interface em_subscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_subscription'], meta: { name: 'em_subscription' } }
    /**
     * Find zero or one Em_subscription that matches the filter.
     * @param {em_subscriptionFindUniqueArgs} args - Arguments to find a Em_subscription
     * @example
     * // Get one Em_subscription
     * const em_subscription = await prisma.em_subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_subscriptionFindUniqueArgs>(args: SelectSubset<T, em_subscriptionFindUniqueArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Em_subscription
     * @example
     * // Get one Em_subscription
     * const em_subscription = await prisma.em_subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_subscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, em_subscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscriptionFindFirstArgs} args - Arguments to find a Em_subscription
     * @example
     * // Get one Em_subscription
     * const em_subscription = await prisma.em_subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_subscriptionFindFirstArgs>(args?: SelectSubset<T, em_subscriptionFindFirstArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscriptionFindFirstOrThrowArgs} args - Arguments to find a Em_subscription
     * @example
     * // Get one Em_subscription
     * const em_subscription = await prisma.em_subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_subscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, em_subscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_subscriptions
     * const em_subscriptions = await prisma.em_subscription.findMany()
     * 
     * // Get first 10 Em_subscriptions
     * const em_subscriptions = await prisma.em_subscription.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_subscriptionWithIdOnly = await prisma.em_subscription.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_subscriptionFindManyArgs>(args?: SelectSubset<T, em_subscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_subscription.
     * @param {em_subscriptionCreateArgs} args - Arguments to create a Em_subscription.
     * @example
     * // Create one Em_subscription
     * const Em_subscription = await prisma.em_subscription.create({
     *   data: {
     *     // ... data to create a Em_subscription
     *   }
     * })
     * 
     */
    create<T extends em_subscriptionCreateArgs>(args: SelectSubset<T, em_subscriptionCreateArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_subscriptions.
     * @param {em_subscriptionCreateManyArgs} args - Arguments to create many Em_subscriptions.
     * @example
     * // Create many Em_subscriptions
     * const em_subscription = await prisma.em_subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_subscriptionCreateManyArgs>(args?: SelectSubset<T, em_subscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_subscription.
     * @param {em_subscriptionDeleteArgs} args - Arguments to delete one Em_subscription.
     * @example
     * // Delete one Em_subscription
     * const Em_subscription = await prisma.em_subscription.delete({
     *   where: {
     *     // ... filter to delete one Em_subscription
     *   }
     * })
     * 
     */
    delete<T extends em_subscriptionDeleteArgs>(args: SelectSubset<T, em_subscriptionDeleteArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_subscription.
     * @param {em_subscriptionUpdateArgs} args - Arguments to update one Em_subscription.
     * @example
     * // Update one Em_subscription
     * const em_subscription = await prisma.em_subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_subscriptionUpdateArgs>(args: SelectSubset<T, em_subscriptionUpdateArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_subscriptions.
     * @param {em_subscriptionDeleteManyArgs} args - Arguments to filter Em_subscriptions to delete.
     * @example
     * // Delete a few Em_subscriptions
     * const { count } = await prisma.em_subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_subscriptionDeleteManyArgs>(args?: SelectSubset<T, em_subscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_subscriptions
     * const em_subscription = await prisma.em_subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_subscriptionUpdateManyArgs>(args: SelectSubset<T, em_subscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_subscription.
     * @param {em_subscriptionUpsertArgs} args - Arguments to update or create a Em_subscription.
     * @example
     * // Update or create a Em_subscription
     * const em_subscription = await prisma.em_subscription.upsert({
     *   create: {
     *     // ... data to create a Em_subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_subscription we want to update
     *   }
     * })
     */
    upsert<T extends em_subscriptionUpsertArgs>(args: SelectSubset<T, em_subscriptionUpsertArgs<ExtArgs>>): Prisma__em_subscriptionClient<$Result.GetResult<Prisma.$em_subscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscriptionCountArgs} args - Arguments to filter Em_subscriptions to count.
     * @example
     * // Count the number of Em_subscriptions
     * const count = await prisma.em_subscription.count({
     *   where: {
     *     // ... the filter for the Em_subscriptions we want to count
     *   }
     * })
    **/
    count<T extends em_subscriptionCountArgs>(
      args?: Subset<T, em_subscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_subscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_subscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_subscriptionAggregateArgs>(args: Subset<T, Em_subscriptionAggregateArgs>): Prisma.PrismaPromise<GetEm_subscriptionAggregateType<T>>

    /**
     * Group by Em_subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: em_subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_subscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_subscription model
   */
  readonly fields: em_subscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_subscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_subscription model
   */
  interface em_subscriptionFieldRefs {
    readonly Id: FieldRef<"em_subscription", 'Int'>
    readonly username: FieldRef<"em_subscription", 'String'>
    readonly subscription: FieldRef<"em_subscription", 'String'>
    readonly status: FieldRef<"em_subscription", 'String'>
    readonly createdat: FieldRef<"em_subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_subscription findUnique
   */
  export type em_subscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which em_subscription to fetch.
     */
    where: em_subscriptionWhereUniqueInput
  }

  /**
   * em_subscription findUniqueOrThrow
   */
  export type em_subscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which em_subscription to fetch.
     */
    where: em_subscriptionWhereUniqueInput
  }

  /**
   * em_subscription findFirst
   */
  export type em_subscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which em_subscription to fetch.
     */
    where?: em_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscriptions to fetch.
     */
    orderBy?: em_subscriptionOrderByWithRelationInput | em_subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_subscriptions.
     */
    cursor?: em_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_subscriptions.
     */
    distinct?: Em_subscriptionScalarFieldEnum | Em_subscriptionScalarFieldEnum[]
  }

  /**
   * em_subscription findFirstOrThrow
   */
  export type em_subscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which em_subscription to fetch.
     */
    where?: em_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscriptions to fetch.
     */
    orderBy?: em_subscriptionOrderByWithRelationInput | em_subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_subscriptions.
     */
    cursor?: em_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_subscriptions.
     */
    distinct?: Em_subscriptionScalarFieldEnum | Em_subscriptionScalarFieldEnum[]
  }

  /**
   * em_subscription findMany
   */
  export type em_subscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which em_subscriptions to fetch.
     */
    where?: em_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_subscriptions to fetch.
     */
    orderBy?: em_subscriptionOrderByWithRelationInput | em_subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_subscriptions.
     */
    cursor?: em_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_subscriptions.
     */
    skip?: number
    distinct?: Em_subscriptionScalarFieldEnum | Em_subscriptionScalarFieldEnum[]
  }

  /**
   * em_subscription create
   */
  export type em_subscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a em_subscription.
     */
    data: XOR<em_subscriptionCreateInput, em_subscriptionUncheckedCreateInput>
  }

  /**
   * em_subscription createMany
   */
  export type em_subscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_subscriptions.
     */
    data: em_subscriptionCreateManyInput | em_subscriptionCreateManyInput[]
  }

  /**
   * em_subscription update
   */
  export type em_subscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a em_subscription.
     */
    data: XOR<em_subscriptionUpdateInput, em_subscriptionUncheckedUpdateInput>
    /**
     * Choose, which em_subscription to update.
     */
    where: em_subscriptionWhereUniqueInput
  }

  /**
   * em_subscription updateMany
   */
  export type em_subscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_subscriptions.
     */
    data: XOR<em_subscriptionUpdateManyMutationInput, em_subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which em_subscriptions to update
     */
    where?: em_subscriptionWhereInput
    /**
     * Limit how many em_subscriptions to update.
     */
    limit?: number
  }

  /**
   * em_subscription upsert
   */
  export type em_subscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the em_subscription to update in case it exists.
     */
    where: em_subscriptionWhereUniqueInput
    /**
     * In case the em_subscription found by the `where` argument doesn't exist, create a new em_subscription with this data.
     */
    create: XOR<em_subscriptionCreateInput, em_subscriptionUncheckedCreateInput>
    /**
     * In case the em_subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_subscriptionUpdateInput, em_subscriptionUncheckedUpdateInput>
  }

  /**
   * em_subscription delete
   */
  export type em_subscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
    /**
     * Filter which em_subscription to delete.
     */
    where: em_subscriptionWhereUniqueInput
  }

  /**
   * em_subscription deleteMany
   */
  export type em_subscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_subscriptions to delete
     */
    where?: em_subscriptionWhereInput
    /**
     * Limit how many em_subscriptions to delete.
     */
    limit?: number
  }

  /**
   * em_subscription without action
   */
  export type em_subscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_subscription
     */
    select?: em_subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_subscription
     */
    omit?: em_subscriptionOmit<ExtArgs> | null
  }


  /**
   * Model em_topic_selesai
   */

  export type AggregateEm_topic_selesai = {
    _count: Em_topic_selesaiCountAggregateOutputType | null
    _avg: Em_topic_selesaiAvgAggregateOutputType | null
    _sum: Em_topic_selesaiSumAggregateOutputType | null
    _min: Em_topic_selesaiMinAggregateOutputType | null
    _max: Em_topic_selesaiMaxAggregateOutputType | null
  }

  export type Em_topic_selesaiAvgAggregateOutputType = {
    id: number | null
    apc_id: number | null
    topic_id: number | null
  }

  export type Em_topic_selesaiSumAggregateOutputType = {
    id: number | null
    apc_id: number | null
    topic_id: number | null
  }

  export type Em_topic_selesaiMinAggregateOutputType = {
    id: number | null
    session_exams_id: string | null
    apc_id: number | null
    topic_id: number | null
    selesai_at: Date | null
  }

  export type Em_topic_selesaiMaxAggregateOutputType = {
    id: number | null
    session_exams_id: string | null
    apc_id: number | null
    topic_id: number | null
    selesai_at: Date | null
  }

  export type Em_topic_selesaiCountAggregateOutputType = {
    id: number
    session_exams_id: number
    apc_id: number
    topic_id: number
    selesai_at: number
    _all: number
  }


  export type Em_topic_selesaiAvgAggregateInputType = {
    id?: true
    apc_id?: true
    topic_id?: true
  }

  export type Em_topic_selesaiSumAggregateInputType = {
    id?: true
    apc_id?: true
    topic_id?: true
  }

  export type Em_topic_selesaiMinAggregateInputType = {
    id?: true
    session_exams_id?: true
    apc_id?: true
    topic_id?: true
    selesai_at?: true
  }

  export type Em_topic_selesaiMaxAggregateInputType = {
    id?: true
    session_exams_id?: true
    apc_id?: true
    topic_id?: true
    selesai_at?: true
  }

  export type Em_topic_selesaiCountAggregateInputType = {
    id?: true
    session_exams_id?: true
    apc_id?: true
    topic_id?: true
    selesai_at?: true
    _all?: true
  }

  export type Em_topic_selesaiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_topic_selesai to aggregate.
     */
    where?: em_topic_selesaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_topic_selesais to fetch.
     */
    orderBy?: em_topic_selesaiOrderByWithRelationInput | em_topic_selesaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_topic_selesaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_topic_selesais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_topic_selesais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_topic_selesais
    **/
    _count?: true | Em_topic_selesaiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_topic_selesaiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_topic_selesaiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_topic_selesaiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_topic_selesaiMaxAggregateInputType
  }

  export type GetEm_topic_selesaiAggregateType<T extends Em_topic_selesaiAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_topic_selesai]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_topic_selesai[P]>
      : GetScalarType<T[P], AggregateEm_topic_selesai[P]>
  }




  export type em_topic_selesaiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_topic_selesaiWhereInput
    orderBy?: em_topic_selesaiOrderByWithAggregationInput | em_topic_selesaiOrderByWithAggregationInput[]
    by: Em_topic_selesaiScalarFieldEnum[] | Em_topic_selesaiScalarFieldEnum
    having?: em_topic_selesaiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_topic_selesaiCountAggregateInputType | true
    _avg?: Em_topic_selesaiAvgAggregateInputType
    _sum?: Em_topic_selesaiSumAggregateInputType
    _min?: Em_topic_selesaiMinAggregateInputType
    _max?: Em_topic_selesaiMaxAggregateInputType
  }

  export type Em_topic_selesaiGroupByOutputType = {
    id: number
    session_exams_id: string
    apc_id: number
    topic_id: number
    selesai_at: Date | null
    _count: Em_topic_selesaiCountAggregateOutputType | null
    _avg: Em_topic_selesaiAvgAggregateOutputType | null
    _sum: Em_topic_selesaiSumAggregateOutputType | null
    _min: Em_topic_selesaiMinAggregateOutputType | null
    _max: Em_topic_selesaiMaxAggregateOutputType | null
  }

  type GetEm_topic_selesaiGroupByPayload<T extends em_topic_selesaiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_topic_selesaiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_topic_selesaiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_topic_selesaiGroupByOutputType[P]>
            : GetScalarType<T[P], Em_topic_selesaiGroupByOutputType[P]>
        }
      >
    >


  export type em_topic_selesaiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_exams_id?: boolean
    apc_id?: boolean
    topic_id?: boolean
    selesai_at?: boolean
    em_session_exams_apc?: boolean | em_session_exams_apcDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["em_topic_selesai"]>



  export type em_topic_selesaiSelectScalar = {
    id?: boolean
    session_exams_id?: boolean
    apc_id?: boolean
    topic_id?: boolean
    selesai_at?: boolean
  }

  export type em_topic_selesaiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "session_exams_id" | "apc_id" | "topic_id" | "selesai_at", ExtArgs["result"]["em_topic_selesai"]>
  export type em_topic_selesaiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_session_exams_apc?: boolean | em_session_exams_apcDefaultArgs<ExtArgs>
  }

  export type $em_topic_selesaiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_topic_selesai"
    objects: {
      em_session_exams_apc: Prisma.$em_session_exams_apcPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_exams_id: string
      apc_id: number
      topic_id: number
      selesai_at: Date | null
    }, ExtArgs["result"]["em_topic_selesai"]>
    composites: {}
  }

  type em_topic_selesaiGetPayload<S extends boolean | null | undefined | em_topic_selesaiDefaultArgs> = $Result.GetResult<Prisma.$em_topic_selesaiPayload, S>

  type em_topic_selesaiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_topic_selesaiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_topic_selesaiCountAggregateInputType | true
    }

  export interface em_topic_selesaiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_topic_selesai'], meta: { name: 'em_topic_selesai' } }
    /**
     * Find zero or one Em_topic_selesai that matches the filter.
     * @param {em_topic_selesaiFindUniqueArgs} args - Arguments to find a Em_topic_selesai
     * @example
     * // Get one Em_topic_selesai
     * const em_topic_selesai = await prisma.em_topic_selesai.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_topic_selesaiFindUniqueArgs>(args: SelectSubset<T, em_topic_selesaiFindUniqueArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_topic_selesai that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_topic_selesaiFindUniqueOrThrowArgs} args - Arguments to find a Em_topic_selesai
     * @example
     * // Get one Em_topic_selesai
     * const em_topic_selesai = await prisma.em_topic_selesai.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_topic_selesaiFindUniqueOrThrowArgs>(args: SelectSubset<T, em_topic_selesaiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_topic_selesai that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_topic_selesaiFindFirstArgs} args - Arguments to find a Em_topic_selesai
     * @example
     * // Get one Em_topic_selesai
     * const em_topic_selesai = await prisma.em_topic_selesai.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_topic_selesaiFindFirstArgs>(args?: SelectSubset<T, em_topic_selesaiFindFirstArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_topic_selesai that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_topic_selesaiFindFirstOrThrowArgs} args - Arguments to find a Em_topic_selesai
     * @example
     * // Get one Em_topic_selesai
     * const em_topic_selesai = await prisma.em_topic_selesai.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_topic_selesaiFindFirstOrThrowArgs>(args?: SelectSubset<T, em_topic_selesaiFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_topic_selesais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_topic_selesaiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_topic_selesais
     * const em_topic_selesais = await prisma.em_topic_selesai.findMany()
     * 
     * // Get first 10 Em_topic_selesais
     * const em_topic_selesais = await prisma.em_topic_selesai.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_topic_selesaiWithIdOnly = await prisma.em_topic_selesai.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_topic_selesaiFindManyArgs>(args?: SelectSubset<T, em_topic_selesaiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_topic_selesai.
     * @param {em_topic_selesaiCreateArgs} args - Arguments to create a Em_topic_selesai.
     * @example
     * // Create one Em_topic_selesai
     * const Em_topic_selesai = await prisma.em_topic_selesai.create({
     *   data: {
     *     // ... data to create a Em_topic_selesai
     *   }
     * })
     * 
     */
    create<T extends em_topic_selesaiCreateArgs>(args: SelectSubset<T, em_topic_selesaiCreateArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_topic_selesais.
     * @param {em_topic_selesaiCreateManyArgs} args - Arguments to create many Em_topic_selesais.
     * @example
     * // Create many Em_topic_selesais
     * const em_topic_selesai = await prisma.em_topic_selesai.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_topic_selesaiCreateManyArgs>(args?: SelectSubset<T, em_topic_selesaiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_topic_selesai.
     * @param {em_topic_selesaiDeleteArgs} args - Arguments to delete one Em_topic_selesai.
     * @example
     * // Delete one Em_topic_selesai
     * const Em_topic_selesai = await prisma.em_topic_selesai.delete({
     *   where: {
     *     // ... filter to delete one Em_topic_selesai
     *   }
     * })
     * 
     */
    delete<T extends em_topic_selesaiDeleteArgs>(args: SelectSubset<T, em_topic_selesaiDeleteArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_topic_selesai.
     * @param {em_topic_selesaiUpdateArgs} args - Arguments to update one Em_topic_selesai.
     * @example
     * // Update one Em_topic_selesai
     * const em_topic_selesai = await prisma.em_topic_selesai.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_topic_selesaiUpdateArgs>(args: SelectSubset<T, em_topic_selesaiUpdateArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_topic_selesais.
     * @param {em_topic_selesaiDeleteManyArgs} args - Arguments to filter Em_topic_selesais to delete.
     * @example
     * // Delete a few Em_topic_selesais
     * const { count } = await prisma.em_topic_selesai.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_topic_selesaiDeleteManyArgs>(args?: SelectSubset<T, em_topic_selesaiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_topic_selesais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_topic_selesaiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_topic_selesais
     * const em_topic_selesai = await prisma.em_topic_selesai.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_topic_selesaiUpdateManyArgs>(args: SelectSubset<T, em_topic_selesaiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_topic_selesai.
     * @param {em_topic_selesaiUpsertArgs} args - Arguments to update or create a Em_topic_selesai.
     * @example
     * // Update or create a Em_topic_selesai
     * const em_topic_selesai = await prisma.em_topic_selesai.upsert({
     *   create: {
     *     // ... data to create a Em_topic_selesai
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_topic_selesai we want to update
     *   }
     * })
     */
    upsert<T extends em_topic_selesaiUpsertArgs>(args: SelectSubset<T, em_topic_selesaiUpsertArgs<ExtArgs>>): Prisma__em_topic_selesaiClient<$Result.GetResult<Prisma.$em_topic_selesaiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_topic_selesais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_topic_selesaiCountArgs} args - Arguments to filter Em_topic_selesais to count.
     * @example
     * // Count the number of Em_topic_selesais
     * const count = await prisma.em_topic_selesai.count({
     *   where: {
     *     // ... the filter for the Em_topic_selesais we want to count
     *   }
     * })
    **/
    count<T extends em_topic_selesaiCountArgs>(
      args?: Subset<T, em_topic_selesaiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_topic_selesaiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_topic_selesai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_topic_selesaiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_topic_selesaiAggregateArgs>(args: Subset<T, Em_topic_selesaiAggregateArgs>): Prisma.PrismaPromise<GetEm_topic_selesaiAggregateType<T>>

    /**
     * Group by Em_topic_selesai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_topic_selesaiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_topic_selesaiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_topic_selesaiGroupByArgs['orderBy'] }
        : { orderBy?: em_topic_selesaiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_topic_selesaiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_topic_selesaiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_topic_selesai model
   */
  readonly fields: em_topic_selesaiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_topic_selesai.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_topic_selesaiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_session_exams_apc<T extends em_session_exams_apcDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_session_exams_apcDefaultArgs<ExtArgs>>): Prisma__em_session_exams_apcClient<$Result.GetResult<Prisma.$em_session_exams_apcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_topic_selesai model
   */
  interface em_topic_selesaiFieldRefs {
    readonly id: FieldRef<"em_topic_selesai", 'Int'>
    readonly session_exams_id: FieldRef<"em_topic_selesai", 'String'>
    readonly apc_id: FieldRef<"em_topic_selesai", 'Int'>
    readonly topic_id: FieldRef<"em_topic_selesai", 'Int'>
    readonly selesai_at: FieldRef<"em_topic_selesai", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_topic_selesai findUnique
   */
  export type em_topic_selesaiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * Filter, which em_topic_selesai to fetch.
     */
    where: em_topic_selesaiWhereUniqueInput
  }

  /**
   * em_topic_selesai findUniqueOrThrow
   */
  export type em_topic_selesaiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * Filter, which em_topic_selesai to fetch.
     */
    where: em_topic_selesaiWhereUniqueInput
  }

  /**
   * em_topic_selesai findFirst
   */
  export type em_topic_selesaiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * Filter, which em_topic_selesai to fetch.
     */
    where?: em_topic_selesaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_topic_selesais to fetch.
     */
    orderBy?: em_topic_selesaiOrderByWithRelationInput | em_topic_selesaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_topic_selesais.
     */
    cursor?: em_topic_selesaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_topic_selesais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_topic_selesais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_topic_selesais.
     */
    distinct?: Em_topic_selesaiScalarFieldEnum | Em_topic_selesaiScalarFieldEnum[]
  }

  /**
   * em_topic_selesai findFirstOrThrow
   */
  export type em_topic_selesaiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * Filter, which em_topic_selesai to fetch.
     */
    where?: em_topic_selesaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_topic_selesais to fetch.
     */
    orderBy?: em_topic_selesaiOrderByWithRelationInput | em_topic_selesaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_topic_selesais.
     */
    cursor?: em_topic_selesaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_topic_selesais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_topic_selesais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_topic_selesais.
     */
    distinct?: Em_topic_selesaiScalarFieldEnum | Em_topic_selesaiScalarFieldEnum[]
  }

  /**
   * em_topic_selesai findMany
   */
  export type em_topic_selesaiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * Filter, which em_topic_selesais to fetch.
     */
    where?: em_topic_selesaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_topic_selesais to fetch.
     */
    orderBy?: em_topic_selesaiOrderByWithRelationInput | em_topic_selesaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_topic_selesais.
     */
    cursor?: em_topic_selesaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_topic_selesais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_topic_selesais.
     */
    skip?: number
    distinct?: Em_topic_selesaiScalarFieldEnum | Em_topic_selesaiScalarFieldEnum[]
  }

  /**
   * em_topic_selesai create
   */
  export type em_topic_selesaiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * The data needed to create a em_topic_selesai.
     */
    data: XOR<em_topic_selesaiCreateInput, em_topic_selesaiUncheckedCreateInput>
  }

  /**
   * em_topic_selesai createMany
   */
  export type em_topic_selesaiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_topic_selesais.
     */
    data: em_topic_selesaiCreateManyInput | em_topic_selesaiCreateManyInput[]
  }

  /**
   * em_topic_selesai update
   */
  export type em_topic_selesaiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * The data needed to update a em_topic_selesai.
     */
    data: XOR<em_topic_selesaiUpdateInput, em_topic_selesaiUncheckedUpdateInput>
    /**
     * Choose, which em_topic_selesai to update.
     */
    where: em_topic_selesaiWhereUniqueInput
  }

  /**
   * em_topic_selesai updateMany
   */
  export type em_topic_selesaiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_topic_selesais.
     */
    data: XOR<em_topic_selesaiUpdateManyMutationInput, em_topic_selesaiUncheckedUpdateManyInput>
    /**
     * Filter which em_topic_selesais to update
     */
    where?: em_topic_selesaiWhereInput
    /**
     * Limit how many em_topic_selesais to update.
     */
    limit?: number
  }

  /**
   * em_topic_selesai upsert
   */
  export type em_topic_selesaiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * The filter to search for the em_topic_selesai to update in case it exists.
     */
    where: em_topic_selesaiWhereUniqueInput
    /**
     * In case the em_topic_selesai found by the `where` argument doesn't exist, create a new em_topic_selesai with this data.
     */
    create: XOR<em_topic_selesaiCreateInput, em_topic_selesaiUncheckedCreateInput>
    /**
     * In case the em_topic_selesai was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_topic_selesaiUpdateInput, em_topic_selesaiUncheckedUpdateInput>
  }

  /**
   * em_topic_selesai delete
   */
  export type em_topic_selesaiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
    /**
     * Filter which em_topic_selesai to delete.
     */
    where: em_topic_selesaiWhereUniqueInput
  }

  /**
   * em_topic_selesai deleteMany
   */
  export type em_topic_selesaiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_topic_selesais to delete
     */
    where?: em_topic_selesaiWhereInput
    /**
     * Limit how many em_topic_selesais to delete.
     */
    limit?: number
  }

  /**
   * em_topic_selesai without action
   */
  export type em_topic_selesaiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_topic_selesai
     */
    select?: em_topic_selesaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_topic_selesai
     */
    omit?: em_topic_selesaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_topic_selesaiInclude<ExtArgs> | null
  }


  /**
   * Model em_user_answers1
   */

  export type AggregateEm_user_answers1 = {
    _count: Em_user_answers1CountAggregateOutputType | null
    _avg: Em_user_answers1AvgAggregateOutputType | null
    _sum: Em_user_answers1SumAggregateOutputType | null
    _min: Em_user_answers1MinAggregateOutputType | null
    _max: Em_user_answers1MaxAggregateOutputType | null
  }

  export type Em_user_answers1AvgAggregateOutputType = {
    Id: number | null
    apcid: number | null
    topic_id: number | null
  }

  export type Em_user_answers1SumAggregateOutputType = {
    Id: number | null
    apcid: number | null
    topic_id: number | null
  }

  export type Em_user_answers1MinAggregateOutputType = {
    Id: number | null
    apcid: number | null
    topic_id: number | null
    status: string | null
    startdate: Date | null
  }

  export type Em_user_answers1MaxAggregateOutputType = {
    Id: number | null
    apcid: number | null
    topic_id: number | null
    status: string | null
    startdate: Date | null
  }

  export type Em_user_answers1CountAggregateOutputType = {
    Id: number
    apcid: number
    topic_id: number
    status: number
    startdate: number
    _all: number
  }


  export type Em_user_answers1AvgAggregateInputType = {
    Id?: true
    apcid?: true
    topic_id?: true
  }

  export type Em_user_answers1SumAggregateInputType = {
    Id?: true
    apcid?: true
    topic_id?: true
  }

  export type Em_user_answers1MinAggregateInputType = {
    Id?: true
    apcid?: true
    topic_id?: true
    status?: true
    startdate?: true
  }

  export type Em_user_answers1MaxAggregateInputType = {
    Id?: true
    apcid?: true
    topic_id?: true
    status?: true
    startdate?: true
  }

  export type Em_user_answers1CountAggregateInputType = {
    Id?: true
    apcid?: true
    topic_id?: true
    status?: true
    startdate?: true
    _all?: true
  }

  export type Em_user_answers1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_user_answers1 to aggregate.
     */
    where?: em_user_answers1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_answers1s to fetch.
     */
    orderBy?: em_user_answers1OrderByWithRelationInput | em_user_answers1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_user_answers1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_answers1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_answers1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_user_answers1s
    **/
    _count?: true | Em_user_answers1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_user_answers1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_user_answers1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_user_answers1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_user_answers1MaxAggregateInputType
  }

  export type GetEm_user_answers1AggregateType<T extends Em_user_answers1AggregateArgs> = {
        [P in keyof T & keyof AggregateEm_user_answers1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_user_answers1[P]>
      : GetScalarType<T[P], AggregateEm_user_answers1[P]>
  }




  export type em_user_answers1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_user_answers1WhereInput
    orderBy?: em_user_answers1OrderByWithAggregationInput | em_user_answers1OrderByWithAggregationInput[]
    by: Em_user_answers1ScalarFieldEnum[] | Em_user_answers1ScalarFieldEnum
    having?: em_user_answers1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_user_answers1CountAggregateInputType | true
    _avg?: Em_user_answers1AvgAggregateInputType
    _sum?: Em_user_answers1SumAggregateInputType
    _min?: Em_user_answers1MinAggregateInputType
    _max?: Em_user_answers1MaxAggregateInputType
  }

  export type Em_user_answers1GroupByOutputType = {
    Id: number
    apcid: number
    topic_id: number
    status: string | null
    startdate: Date | null
    _count: Em_user_answers1CountAggregateOutputType | null
    _avg: Em_user_answers1AvgAggregateOutputType | null
    _sum: Em_user_answers1SumAggregateOutputType | null
    _min: Em_user_answers1MinAggregateOutputType | null
    _max: Em_user_answers1MaxAggregateOutputType | null
  }

  type GetEm_user_answers1GroupByPayload<T extends em_user_answers1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_user_answers1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_user_answers1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_user_answers1GroupByOutputType[P]>
            : GetScalarType<T[P], Em_user_answers1GroupByOutputType[P]>
        }
      >
    >


  export type em_user_answers1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    apcid?: boolean
    topic_id?: boolean
    status?: boolean
    startdate?: boolean
  }, ExtArgs["result"]["em_user_answers1"]>



  export type em_user_answers1SelectScalar = {
    Id?: boolean
    apcid?: boolean
    topic_id?: boolean
    status?: boolean
    startdate?: boolean
  }

  export type em_user_answers1Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "apcid" | "topic_id" | "status" | "startdate", ExtArgs["result"]["em_user_answers1"]>

  export type $em_user_answers1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_user_answers1"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      apcid: number
      topic_id: number
      status: string | null
      startdate: Date | null
    }, ExtArgs["result"]["em_user_answers1"]>
    composites: {}
  }

  type em_user_answers1GetPayload<S extends boolean | null | undefined | em_user_answers1DefaultArgs> = $Result.GetResult<Prisma.$em_user_answers1Payload, S>

  type em_user_answers1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_user_answers1FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_user_answers1CountAggregateInputType | true
    }

  export interface em_user_answers1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_user_answers1'], meta: { name: 'em_user_answers1' } }
    /**
     * Find zero or one Em_user_answers1 that matches the filter.
     * @param {em_user_answers1FindUniqueArgs} args - Arguments to find a Em_user_answers1
     * @example
     * // Get one Em_user_answers1
     * const em_user_answers1 = await prisma.em_user_answers1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_user_answers1FindUniqueArgs>(args: SelectSubset<T, em_user_answers1FindUniqueArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_user_answers1 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_user_answers1FindUniqueOrThrowArgs} args - Arguments to find a Em_user_answers1
     * @example
     * // Get one Em_user_answers1
     * const em_user_answers1 = await prisma.em_user_answers1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_user_answers1FindUniqueOrThrowArgs>(args: SelectSubset<T, em_user_answers1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_user_answers1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_answers1FindFirstArgs} args - Arguments to find a Em_user_answers1
     * @example
     * // Get one Em_user_answers1
     * const em_user_answers1 = await prisma.em_user_answers1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_user_answers1FindFirstArgs>(args?: SelectSubset<T, em_user_answers1FindFirstArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_user_answers1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_answers1FindFirstOrThrowArgs} args - Arguments to find a Em_user_answers1
     * @example
     * // Get one Em_user_answers1
     * const em_user_answers1 = await prisma.em_user_answers1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_user_answers1FindFirstOrThrowArgs>(args?: SelectSubset<T, em_user_answers1FindFirstOrThrowArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_user_answers1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_answers1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_user_answers1s
     * const em_user_answers1s = await prisma.em_user_answers1.findMany()
     * 
     * // Get first 10 Em_user_answers1s
     * const em_user_answers1s = await prisma.em_user_answers1.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_user_answers1WithIdOnly = await prisma.em_user_answers1.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_user_answers1FindManyArgs>(args?: SelectSubset<T, em_user_answers1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_user_answers1.
     * @param {em_user_answers1CreateArgs} args - Arguments to create a Em_user_answers1.
     * @example
     * // Create one Em_user_answers1
     * const Em_user_answers1 = await prisma.em_user_answers1.create({
     *   data: {
     *     // ... data to create a Em_user_answers1
     *   }
     * })
     * 
     */
    create<T extends em_user_answers1CreateArgs>(args: SelectSubset<T, em_user_answers1CreateArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_user_answers1s.
     * @param {em_user_answers1CreateManyArgs} args - Arguments to create many Em_user_answers1s.
     * @example
     * // Create many Em_user_answers1s
     * const em_user_answers1 = await prisma.em_user_answers1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_user_answers1CreateManyArgs>(args?: SelectSubset<T, em_user_answers1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_user_answers1.
     * @param {em_user_answers1DeleteArgs} args - Arguments to delete one Em_user_answers1.
     * @example
     * // Delete one Em_user_answers1
     * const Em_user_answers1 = await prisma.em_user_answers1.delete({
     *   where: {
     *     // ... filter to delete one Em_user_answers1
     *   }
     * })
     * 
     */
    delete<T extends em_user_answers1DeleteArgs>(args: SelectSubset<T, em_user_answers1DeleteArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_user_answers1.
     * @param {em_user_answers1UpdateArgs} args - Arguments to update one Em_user_answers1.
     * @example
     * // Update one Em_user_answers1
     * const em_user_answers1 = await prisma.em_user_answers1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_user_answers1UpdateArgs>(args: SelectSubset<T, em_user_answers1UpdateArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_user_answers1s.
     * @param {em_user_answers1DeleteManyArgs} args - Arguments to filter Em_user_answers1s to delete.
     * @example
     * // Delete a few Em_user_answers1s
     * const { count } = await prisma.em_user_answers1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_user_answers1DeleteManyArgs>(args?: SelectSubset<T, em_user_answers1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_user_answers1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_answers1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_user_answers1s
     * const em_user_answers1 = await prisma.em_user_answers1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_user_answers1UpdateManyArgs>(args: SelectSubset<T, em_user_answers1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_user_answers1.
     * @param {em_user_answers1UpsertArgs} args - Arguments to update or create a Em_user_answers1.
     * @example
     * // Update or create a Em_user_answers1
     * const em_user_answers1 = await prisma.em_user_answers1.upsert({
     *   create: {
     *     // ... data to create a Em_user_answers1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_user_answers1 we want to update
     *   }
     * })
     */
    upsert<T extends em_user_answers1UpsertArgs>(args: SelectSubset<T, em_user_answers1UpsertArgs<ExtArgs>>): Prisma__em_user_answers1Client<$Result.GetResult<Prisma.$em_user_answers1Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_user_answers1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_answers1CountArgs} args - Arguments to filter Em_user_answers1s to count.
     * @example
     * // Count the number of Em_user_answers1s
     * const count = await prisma.em_user_answers1.count({
     *   where: {
     *     // ... the filter for the Em_user_answers1s we want to count
     *   }
     * })
    **/
    count<T extends em_user_answers1CountArgs>(
      args?: Subset<T, em_user_answers1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_user_answers1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_user_answers1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_user_answers1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_user_answers1AggregateArgs>(args: Subset<T, Em_user_answers1AggregateArgs>): Prisma.PrismaPromise<GetEm_user_answers1AggregateType<T>>

    /**
     * Group by Em_user_answers1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_answers1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_user_answers1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_user_answers1GroupByArgs['orderBy'] }
        : { orderBy?: em_user_answers1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_user_answers1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_user_answers1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_user_answers1 model
   */
  readonly fields: em_user_answers1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_user_answers1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_user_answers1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_user_answers1 model
   */
  interface em_user_answers1FieldRefs {
    readonly Id: FieldRef<"em_user_answers1", 'Int'>
    readonly apcid: FieldRef<"em_user_answers1", 'Int'>
    readonly topic_id: FieldRef<"em_user_answers1", 'Int'>
    readonly status: FieldRef<"em_user_answers1", 'String'>
    readonly startdate: FieldRef<"em_user_answers1", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_user_answers1 findUnique
   */
  export type em_user_answers1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * Filter, which em_user_answers1 to fetch.
     */
    where: em_user_answers1WhereUniqueInput
  }

  /**
   * em_user_answers1 findUniqueOrThrow
   */
  export type em_user_answers1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * Filter, which em_user_answers1 to fetch.
     */
    where: em_user_answers1WhereUniqueInput
  }

  /**
   * em_user_answers1 findFirst
   */
  export type em_user_answers1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * Filter, which em_user_answers1 to fetch.
     */
    where?: em_user_answers1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_answers1s to fetch.
     */
    orderBy?: em_user_answers1OrderByWithRelationInput | em_user_answers1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_user_answers1s.
     */
    cursor?: em_user_answers1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_answers1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_answers1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_user_answers1s.
     */
    distinct?: Em_user_answers1ScalarFieldEnum | Em_user_answers1ScalarFieldEnum[]
  }

  /**
   * em_user_answers1 findFirstOrThrow
   */
  export type em_user_answers1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * Filter, which em_user_answers1 to fetch.
     */
    where?: em_user_answers1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_answers1s to fetch.
     */
    orderBy?: em_user_answers1OrderByWithRelationInput | em_user_answers1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_user_answers1s.
     */
    cursor?: em_user_answers1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_answers1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_answers1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_user_answers1s.
     */
    distinct?: Em_user_answers1ScalarFieldEnum | Em_user_answers1ScalarFieldEnum[]
  }

  /**
   * em_user_answers1 findMany
   */
  export type em_user_answers1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * Filter, which em_user_answers1s to fetch.
     */
    where?: em_user_answers1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_answers1s to fetch.
     */
    orderBy?: em_user_answers1OrderByWithRelationInput | em_user_answers1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_user_answers1s.
     */
    cursor?: em_user_answers1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_answers1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_answers1s.
     */
    skip?: number
    distinct?: Em_user_answers1ScalarFieldEnum | Em_user_answers1ScalarFieldEnum[]
  }

  /**
   * em_user_answers1 create
   */
  export type em_user_answers1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * The data needed to create a em_user_answers1.
     */
    data: XOR<em_user_answers1CreateInput, em_user_answers1UncheckedCreateInput>
  }

  /**
   * em_user_answers1 createMany
   */
  export type em_user_answers1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_user_answers1s.
     */
    data: em_user_answers1CreateManyInput | em_user_answers1CreateManyInput[]
  }

  /**
   * em_user_answers1 update
   */
  export type em_user_answers1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * The data needed to update a em_user_answers1.
     */
    data: XOR<em_user_answers1UpdateInput, em_user_answers1UncheckedUpdateInput>
    /**
     * Choose, which em_user_answers1 to update.
     */
    where: em_user_answers1WhereUniqueInput
  }

  /**
   * em_user_answers1 updateMany
   */
  export type em_user_answers1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_user_answers1s.
     */
    data: XOR<em_user_answers1UpdateManyMutationInput, em_user_answers1UncheckedUpdateManyInput>
    /**
     * Filter which em_user_answers1s to update
     */
    where?: em_user_answers1WhereInput
    /**
     * Limit how many em_user_answers1s to update.
     */
    limit?: number
  }

  /**
   * em_user_answers1 upsert
   */
  export type em_user_answers1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * The filter to search for the em_user_answers1 to update in case it exists.
     */
    where: em_user_answers1WhereUniqueInput
    /**
     * In case the em_user_answers1 found by the `where` argument doesn't exist, create a new em_user_answers1 with this data.
     */
    create: XOR<em_user_answers1CreateInput, em_user_answers1UncheckedCreateInput>
    /**
     * In case the em_user_answers1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_user_answers1UpdateInput, em_user_answers1UncheckedUpdateInput>
  }

  /**
   * em_user_answers1 delete
   */
  export type em_user_answers1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
    /**
     * Filter which em_user_answers1 to delete.
     */
    where: em_user_answers1WhereUniqueInput
  }

  /**
   * em_user_answers1 deleteMany
   */
  export type em_user_answers1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_user_answers1s to delete
     */
    where?: em_user_answers1WhereInput
    /**
     * Limit how many em_user_answers1s to delete.
     */
    limit?: number
  }

  /**
   * em_user_answers1 without action
   */
  export type em_user_answers1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_answers1
     */
    select?: em_user_answers1Select<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_answers1
     */
    omit?: em_user_answers1Omit<ExtArgs> | null
  }


  /**
   * Model em_user_dashboard
   */

  export type AggregateEm_user_dashboard = {
    _count: Em_user_dashboardCountAggregateOutputType | null
    _avg: Em_user_dashboardAvgAggregateOutputType | null
    _sum: Em_user_dashboardSumAggregateOutputType | null
    _min: Em_user_dashboardMinAggregateOutputType | null
    _max: Em_user_dashboardMaxAggregateOutputType | null
  }

  export type Em_user_dashboardAvgAggregateOutputType = {
    UserId: number | null
    RoleId: number | null
    GroupId: number | null
  }

  export type Em_user_dashboardSumAggregateOutputType = {
    UserId: number | null
    RoleId: number | null
    GroupId: number | null
  }

  export type Em_user_dashboardMinAggregateOutputType = {
    UserId: number | null
    Username: string | null
    Password: string | null
    FullName: string | null
    RoleId: number | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
    GroupId: number | null
  }

  export type Em_user_dashboardMaxAggregateOutputType = {
    UserId: number | null
    Username: string | null
    Password: string | null
    FullName: string | null
    RoleId: number | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
    GroupId: number | null
  }

  export type Em_user_dashboardCountAggregateOutputType = {
    UserId: number
    Username: number
    Password: number
    FullName: number
    RoleId: number
    Status: number
    CreateDate: number
    LastUpdate: number
    GroupId: number
    _all: number
  }


  export type Em_user_dashboardAvgAggregateInputType = {
    UserId?: true
    RoleId?: true
    GroupId?: true
  }

  export type Em_user_dashboardSumAggregateInputType = {
    UserId?: true
    RoleId?: true
    GroupId?: true
  }

  export type Em_user_dashboardMinAggregateInputType = {
    UserId?: true
    Username?: true
    Password?: true
    FullName?: true
    RoleId?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
    GroupId?: true
  }

  export type Em_user_dashboardMaxAggregateInputType = {
    UserId?: true
    Username?: true
    Password?: true
    FullName?: true
    RoleId?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
    GroupId?: true
  }

  export type Em_user_dashboardCountAggregateInputType = {
    UserId?: true
    Username?: true
    Password?: true
    FullName?: true
    RoleId?: true
    Status?: true
    CreateDate?: true
    LastUpdate?: true
    GroupId?: true
    _all?: true
  }

  export type Em_user_dashboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_user_dashboard to aggregate.
     */
    where?: em_user_dashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_dashboards to fetch.
     */
    orderBy?: em_user_dashboardOrderByWithRelationInput | em_user_dashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_user_dashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_user_dashboards
    **/
    _count?: true | Em_user_dashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_user_dashboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_user_dashboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_user_dashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_user_dashboardMaxAggregateInputType
  }

  export type GetEm_user_dashboardAggregateType<T extends Em_user_dashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_user_dashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_user_dashboard[P]>
      : GetScalarType<T[P], AggregateEm_user_dashboard[P]>
  }




  export type em_user_dashboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_user_dashboardWhereInput
    orderBy?: em_user_dashboardOrderByWithAggregationInput | em_user_dashboardOrderByWithAggregationInput[]
    by: Em_user_dashboardScalarFieldEnum[] | Em_user_dashboardScalarFieldEnum
    having?: em_user_dashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_user_dashboardCountAggregateInputType | true
    _avg?: Em_user_dashboardAvgAggregateInputType
    _sum?: Em_user_dashboardSumAggregateInputType
    _min?: Em_user_dashboardMinAggregateInputType
    _max?: Em_user_dashboardMaxAggregateInputType
  }

  export type Em_user_dashboardGroupByOutputType = {
    UserId: number
    Username: string
    Password: string
    FullName: string | null
    RoleId: number | null
    Status: string | null
    CreateDate: Date | null
    LastUpdate: Date | null
    GroupId: number | null
    _count: Em_user_dashboardCountAggregateOutputType | null
    _avg: Em_user_dashboardAvgAggregateOutputType | null
    _sum: Em_user_dashboardSumAggregateOutputType | null
    _min: Em_user_dashboardMinAggregateOutputType | null
    _max: Em_user_dashboardMaxAggregateOutputType | null
  }

  type GetEm_user_dashboardGroupByPayload<T extends em_user_dashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_user_dashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_user_dashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_user_dashboardGroupByOutputType[P]>
            : GetScalarType<T[P], Em_user_dashboardGroupByOutputType[P]>
        }
      >
    >


  export type em_user_dashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    Username?: boolean
    Password?: boolean
    FullName?: boolean
    RoleId?: boolean
    Status?: boolean
    CreateDate?: boolean
    LastUpdate?: boolean
    GroupId?: boolean
  }, ExtArgs["result"]["em_user_dashboard"]>



  export type em_user_dashboardSelectScalar = {
    UserId?: boolean
    Username?: boolean
    Password?: boolean
    FullName?: boolean
    RoleId?: boolean
    Status?: boolean
    CreateDate?: boolean
    LastUpdate?: boolean
    GroupId?: boolean
  }

  export type em_user_dashboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserId" | "Username" | "Password" | "FullName" | "RoleId" | "Status" | "CreateDate" | "LastUpdate" | "GroupId", ExtArgs["result"]["em_user_dashboard"]>

  export type $em_user_dashboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_user_dashboard"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      UserId: number
      Username: string
      Password: string
      FullName: string | null
      RoleId: number | null
      Status: string | null
      CreateDate: Date | null
      LastUpdate: Date | null
      GroupId: number | null
    }, ExtArgs["result"]["em_user_dashboard"]>
    composites: {}
  }

  type em_user_dashboardGetPayload<S extends boolean | null | undefined | em_user_dashboardDefaultArgs> = $Result.GetResult<Prisma.$em_user_dashboardPayload, S>

  type em_user_dashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_user_dashboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_user_dashboardCountAggregateInputType | true
    }

  export interface em_user_dashboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_user_dashboard'], meta: { name: 'em_user_dashboard' } }
    /**
     * Find zero or one Em_user_dashboard that matches the filter.
     * @param {em_user_dashboardFindUniqueArgs} args - Arguments to find a Em_user_dashboard
     * @example
     * // Get one Em_user_dashboard
     * const em_user_dashboard = await prisma.em_user_dashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_user_dashboardFindUniqueArgs>(args: SelectSubset<T, em_user_dashboardFindUniqueArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_user_dashboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_user_dashboardFindUniqueOrThrowArgs} args - Arguments to find a Em_user_dashboard
     * @example
     * // Get one Em_user_dashboard
     * const em_user_dashboard = await prisma.em_user_dashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_user_dashboardFindUniqueOrThrowArgs>(args: SelectSubset<T, em_user_dashboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_user_dashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_dashboardFindFirstArgs} args - Arguments to find a Em_user_dashboard
     * @example
     * // Get one Em_user_dashboard
     * const em_user_dashboard = await prisma.em_user_dashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_user_dashboardFindFirstArgs>(args?: SelectSubset<T, em_user_dashboardFindFirstArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_user_dashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_dashboardFindFirstOrThrowArgs} args - Arguments to find a Em_user_dashboard
     * @example
     * // Get one Em_user_dashboard
     * const em_user_dashboard = await prisma.em_user_dashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_user_dashboardFindFirstOrThrowArgs>(args?: SelectSubset<T, em_user_dashboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_user_dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_dashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_user_dashboards
     * const em_user_dashboards = await prisma.em_user_dashboard.findMany()
     * 
     * // Get first 10 Em_user_dashboards
     * const em_user_dashboards = await prisma.em_user_dashboard.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const em_user_dashboardWithUserIdOnly = await prisma.em_user_dashboard.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends em_user_dashboardFindManyArgs>(args?: SelectSubset<T, em_user_dashboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_user_dashboard.
     * @param {em_user_dashboardCreateArgs} args - Arguments to create a Em_user_dashboard.
     * @example
     * // Create one Em_user_dashboard
     * const Em_user_dashboard = await prisma.em_user_dashboard.create({
     *   data: {
     *     // ... data to create a Em_user_dashboard
     *   }
     * })
     * 
     */
    create<T extends em_user_dashboardCreateArgs>(args: SelectSubset<T, em_user_dashboardCreateArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_user_dashboards.
     * @param {em_user_dashboardCreateManyArgs} args - Arguments to create many Em_user_dashboards.
     * @example
     * // Create many Em_user_dashboards
     * const em_user_dashboard = await prisma.em_user_dashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_user_dashboardCreateManyArgs>(args?: SelectSubset<T, em_user_dashboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_user_dashboard.
     * @param {em_user_dashboardDeleteArgs} args - Arguments to delete one Em_user_dashboard.
     * @example
     * // Delete one Em_user_dashboard
     * const Em_user_dashboard = await prisma.em_user_dashboard.delete({
     *   where: {
     *     // ... filter to delete one Em_user_dashboard
     *   }
     * })
     * 
     */
    delete<T extends em_user_dashboardDeleteArgs>(args: SelectSubset<T, em_user_dashboardDeleteArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_user_dashboard.
     * @param {em_user_dashboardUpdateArgs} args - Arguments to update one Em_user_dashboard.
     * @example
     * // Update one Em_user_dashboard
     * const em_user_dashboard = await prisma.em_user_dashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_user_dashboardUpdateArgs>(args: SelectSubset<T, em_user_dashboardUpdateArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_user_dashboards.
     * @param {em_user_dashboardDeleteManyArgs} args - Arguments to filter Em_user_dashboards to delete.
     * @example
     * // Delete a few Em_user_dashboards
     * const { count } = await prisma.em_user_dashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_user_dashboardDeleteManyArgs>(args?: SelectSubset<T, em_user_dashboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_user_dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_dashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_user_dashboards
     * const em_user_dashboard = await prisma.em_user_dashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_user_dashboardUpdateManyArgs>(args: SelectSubset<T, em_user_dashboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_user_dashboard.
     * @param {em_user_dashboardUpsertArgs} args - Arguments to update or create a Em_user_dashboard.
     * @example
     * // Update or create a Em_user_dashboard
     * const em_user_dashboard = await prisma.em_user_dashboard.upsert({
     *   create: {
     *     // ... data to create a Em_user_dashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_user_dashboard we want to update
     *   }
     * })
     */
    upsert<T extends em_user_dashboardUpsertArgs>(args: SelectSubset<T, em_user_dashboardUpsertArgs<ExtArgs>>): Prisma__em_user_dashboardClient<$Result.GetResult<Prisma.$em_user_dashboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_user_dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_dashboardCountArgs} args - Arguments to filter Em_user_dashboards to count.
     * @example
     * // Count the number of Em_user_dashboards
     * const count = await prisma.em_user_dashboard.count({
     *   where: {
     *     // ... the filter for the Em_user_dashboards we want to count
     *   }
     * })
    **/
    count<T extends em_user_dashboardCountArgs>(
      args?: Subset<T, em_user_dashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_user_dashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_user_dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_user_dashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_user_dashboardAggregateArgs>(args: Subset<T, Em_user_dashboardAggregateArgs>): Prisma.PrismaPromise<GetEm_user_dashboardAggregateType<T>>

    /**
     * Group by Em_user_dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_dashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_user_dashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_user_dashboardGroupByArgs['orderBy'] }
        : { orderBy?: em_user_dashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_user_dashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_user_dashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_user_dashboard model
   */
  readonly fields: em_user_dashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_user_dashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_user_dashboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_user_dashboard model
   */
  interface em_user_dashboardFieldRefs {
    readonly UserId: FieldRef<"em_user_dashboard", 'Int'>
    readonly Username: FieldRef<"em_user_dashboard", 'String'>
    readonly Password: FieldRef<"em_user_dashboard", 'String'>
    readonly FullName: FieldRef<"em_user_dashboard", 'String'>
    readonly RoleId: FieldRef<"em_user_dashboard", 'Int'>
    readonly Status: FieldRef<"em_user_dashboard", 'String'>
    readonly CreateDate: FieldRef<"em_user_dashboard", 'DateTime'>
    readonly LastUpdate: FieldRef<"em_user_dashboard", 'DateTime'>
    readonly GroupId: FieldRef<"em_user_dashboard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_user_dashboard findUnique
   */
  export type em_user_dashboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * Filter, which em_user_dashboard to fetch.
     */
    where: em_user_dashboardWhereUniqueInput
  }

  /**
   * em_user_dashboard findUniqueOrThrow
   */
  export type em_user_dashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * Filter, which em_user_dashboard to fetch.
     */
    where: em_user_dashboardWhereUniqueInput
  }

  /**
   * em_user_dashboard findFirst
   */
  export type em_user_dashboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * Filter, which em_user_dashboard to fetch.
     */
    where?: em_user_dashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_dashboards to fetch.
     */
    orderBy?: em_user_dashboardOrderByWithRelationInput | em_user_dashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_user_dashboards.
     */
    cursor?: em_user_dashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_user_dashboards.
     */
    distinct?: Em_user_dashboardScalarFieldEnum | Em_user_dashboardScalarFieldEnum[]
  }

  /**
   * em_user_dashboard findFirstOrThrow
   */
  export type em_user_dashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * Filter, which em_user_dashboard to fetch.
     */
    where?: em_user_dashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_dashboards to fetch.
     */
    orderBy?: em_user_dashboardOrderByWithRelationInput | em_user_dashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_user_dashboards.
     */
    cursor?: em_user_dashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_user_dashboards.
     */
    distinct?: Em_user_dashboardScalarFieldEnum | Em_user_dashboardScalarFieldEnum[]
  }

  /**
   * em_user_dashboard findMany
   */
  export type em_user_dashboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * Filter, which em_user_dashboards to fetch.
     */
    where?: em_user_dashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_dashboards to fetch.
     */
    orderBy?: em_user_dashboardOrderByWithRelationInput | em_user_dashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_user_dashboards.
     */
    cursor?: em_user_dashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_dashboards.
     */
    skip?: number
    distinct?: Em_user_dashboardScalarFieldEnum | Em_user_dashboardScalarFieldEnum[]
  }

  /**
   * em_user_dashboard create
   */
  export type em_user_dashboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * The data needed to create a em_user_dashboard.
     */
    data: XOR<em_user_dashboardCreateInput, em_user_dashboardUncheckedCreateInput>
  }

  /**
   * em_user_dashboard createMany
   */
  export type em_user_dashboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_user_dashboards.
     */
    data: em_user_dashboardCreateManyInput | em_user_dashboardCreateManyInput[]
  }

  /**
   * em_user_dashboard update
   */
  export type em_user_dashboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * The data needed to update a em_user_dashboard.
     */
    data: XOR<em_user_dashboardUpdateInput, em_user_dashboardUncheckedUpdateInput>
    /**
     * Choose, which em_user_dashboard to update.
     */
    where: em_user_dashboardWhereUniqueInput
  }

  /**
   * em_user_dashboard updateMany
   */
  export type em_user_dashboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_user_dashboards.
     */
    data: XOR<em_user_dashboardUpdateManyMutationInput, em_user_dashboardUncheckedUpdateManyInput>
    /**
     * Filter which em_user_dashboards to update
     */
    where?: em_user_dashboardWhereInput
    /**
     * Limit how many em_user_dashboards to update.
     */
    limit?: number
  }

  /**
   * em_user_dashboard upsert
   */
  export type em_user_dashboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * The filter to search for the em_user_dashboard to update in case it exists.
     */
    where: em_user_dashboardWhereUniqueInput
    /**
     * In case the em_user_dashboard found by the `where` argument doesn't exist, create a new em_user_dashboard with this data.
     */
    create: XOR<em_user_dashboardCreateInput, em_user_dashboardUncheckedCreateInput>
    /**
     * In case the em_user_dashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_user_dashboardUpdateInput, em_user_dashboardUncheckedUpdateInput>
  }

  /**
   * em_user_dashboard delete
   */
  export type em_user_dashboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
    /**
     * Filter which em_user_dashboard to delete.
     */
    where: em_user_dashboardWhereUniqueInput
  }

  /**
   * em_user_dashboard deleteMany
   */
  export type em_user_dashboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_user_dashboards to delete
     */
    where?: em_user_dashboardWhereInput
    /**
     * Limit how many em_user_dashboards to delete.
     */
    limit?: number
  }

  /**
   * em_user_dashboard without action
   */
  export type em_user_dashboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_dashboard
     */
    select?: em_user_dashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_dashboard
     */
    omit?: em_user_dashboardOmit<ExtArgs> | null
  }


  /**
   * Model em_user_list
   */

  export type AggregateEm_user_list = {
    _count: Em_user_listCountAggregateOutputType | null
    _avg: Em_user_listAvgAggregateOutputType | null
    _sum: Em_user_listSumAggregateOutputType | null
    _min: Em_user_listMinAggregateOutputType | null
    _max: Em_user_listMaxAggregateOutputType | null
  }

  export type Em_user_listAvgAggregateOutputType = {
    id: number | null
    menuid: number | null
  }

  export type Em_user_listSumAggregateOutputType = {
    id: number | null
    menuid: number | null
  }

  export type Em_user_listMinAggregateOutputType = {
    id: number | null
    userid: string | null
    menuid: number | null
    visible: boolean | null
    lastupdate: Date | null
  }

  export type Em_user_listMaxAggregateOutputType = {
    id: number | null
    userid: string | null
    menuid: number | null
    visible: boolean | null
    lastupdate: Date | null
  }

  export type Em_user_listCountAggregateOutputType = {
    id: number
    userid: number
    menuid: number
    visible: number
    lastupdate: number
    _all: number
  }


  export type Em_user_listAvgAggregateInputType = {
    id?: true
    menuid?: true
  }

  export type Em_user_listSumAggregateInputType = {
    id?: true
    menuid?: true
  }

  export type Em_user_listMinAggregateInputType = {
    id?: true
    userid?: true
    menuid?: true
    visible?: true
    lastupdate?: true
  }

  export type Em_user_listMaxAggregateInputType = {
    id?: true
    userid?: true
    menuid?: true
    visible?: true
    lastupdate?: true
  }

  export type Em_user_listCountAggregateInputType = {
    id?: true
    userid?: true
    menuid?: true
    visible?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_user_listAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_user_list to aggregate.
     */
    where?: em_user_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_lists to fetch.
     */
    orderBy?: em_user_listOrderByWithRelationInput | em_user_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_user_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_user_lists
    **/
    _count?: true | Em_user_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_user_listAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_user_listSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_user_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_user_listMaxAggregateInputType
  }

  export type GetEm_user_listAggregateType<T extends Em_user_listAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_user_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_user_list[P]>
      : GetScalarType<T[P], AggregateEm_user_list[P]>
  }




  export type em_user_listGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_user_listWhereInput
    orderBy?: em_user_listOrderByWithAggregationInput | em_user_listOrderByWithAggregationInput[]
    by: Em_user_listScalarFieldEnum[] | Em_user_listScalarFieldEnum
    having?: em_user_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_user_listCountAggregateInputType | true
    _avg?: Em_user_listAvgAggregateInputType
    _sum?: Em_user_listSumAggregateInputType
    _min?: Em_user_listMinAggregateInputType
    _max?: Em_user_listMaxAggregateInputType
  }

  export type Em_user_listGroupByOutputType = {
    id: number
    userid: string
    menuid: number | null
    visible: boolean
    lastupdate: Date | null
    _count: Em_user_listCountAggregateOutputType | null
    _avg: Em_user_listAvgAggregateOutputType | null
    _sum: Em_user_listSumAggregateOutputType | null
    _min: Em_user_listMinAggregateOutputType | null
    _max: Em_user_listMaxAggregateOutputType | null
  }

  type GetEm_user_listGroupByPayload<T extends em_user_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_user_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_user_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_user_listGroupByOutputType[P]>
            : GetScalarType<T[P], Em_user_listGroupByOutputType[P]>
        }
      >
    >


  export type em_user_listSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    menuid?: boolean
    visible?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["em_user_list"]>



  export type em_user_listSelectScalar = {
    id?: boolean
    userid?: boolean
    menuid?: boolean
    visible?: boolean
    lastupdate?: boolean
  }

  export type em_user_listOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "menuid" | "visible" | "lastupdate", ExtArgs["result"]["em_user_list"]>

  export type $em_user_listPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_user_list"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userid: string
      menuid: number | null
      visible: boolean
      lastupdate: Date | null
    }, ExtArgs["result"]["em_user_list"]>
    composites: {}
  }

  type em_user_listGetPayload<S extends boolean | null | undefined | em_user_listDefaultArgs> = $Result.GetResult<Prisma.$em_user_listPayload, S>

  type em_user_listCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_user_listFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_user_listCountAggregateInputType | true
    }

  export interface em_user_listDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_user_list'], meta: { name: 'em_user_list' } }
    /**
     * Find zero or one Em_user_list that matches the filter.
     * @param {em_user_listFindUniqueArgs} args - Arguments to find a Em_user_list
     * @example
     * // Get one Em_user_list
     * const em_user_list = await prisma.em_user_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_user_listFindUniqueArgs>(args: SelectSubset<T, em_user_listFindUniqueArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_user_list that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_user_listFindUniqueOrThrowArgs} args - Arguments to find a Em_user_list
     * @example
     * // Get one Em_user_list
     * const em_user_list = await prisma.em_user_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_user_listFindUniqueOrThrowArgs>(args: SelectSubset<T, em_user_listFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_user_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_listFindFirstArgs} args - Arguments to find a Em_user_list
     * @example
     * // Get one Em_user_list
     * const em_user_list = await prisma.em_user_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_user_listFindFirstArgs>(args?: SelectSubset<T, em_user_listFindFirstArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_user_list that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_listFindFirstOrThrowArgs} args - Arguments to find a Em_user_list
     * @example
     * // Get one Em_user_list
     * const em_user_list = await prisma.em_user_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_user_listFindFirstOrThrowArgs>(args?: SelectSubset<T, em_user_listFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_user_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_listFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_user_lists
     * const em_user_lists = await prisma.em_user_list.findMany()
     * 
     * // Get first 10 Em_user_lists
     * const em_user_lists = await prisma.em_user_list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_user_listWithIdOnly = await prisma.em_user_list.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_user_listFindManyArgs>(args?: SelectSubset<T, em_user_listFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_user_list.
     * @param {em_user_listCreateArgs} args - Arguments to create a Em_user_list.
     * @example
     * // Create one Em_user_list
     * const Em_user_list = await prisma.em_user_list.create({
     *   data: {
     *     // ... data to create a Em_user_list
     *   }
     * })
     * 
     */
    create<T extends em_user_listCreateArgs>(args: SelectSubset<T, em_user_listCreateArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_user_lists.
     * @param {em_user_listCreateManyArgs} args - Arguments to create many Em_user_lists.
     * @example
     * // Create many Em_user_lists
     * const em_user_list = await prisma.em_user_list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_user_listCreateManyArgs>(args?: SelectSubset<T, em_user_listCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_user_list.
     * @param {em_user_listDeleteArgs} args - Arguments to delete one Em_user_list.
     * @example
     * // Delete one Em_user_list
     * const Em_user_list = await prisma.em_user_list.delete({
     *   where: {
     *     // ... filter to delete one Em_user_list
     *   }
     * })
     * 
     */
    delete<T extends em_user_listDeleteArgs>(args: SelectSubset<T, em_user_listDeleteArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_user_list.
     * @param {em_user_listUpdateArgs} args - Arguments to update one Em_user_list.
     * @example
     * // Update one Em_user_list
     * const em_user_list = await prisma.em_user_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_user_listUpdateArgs>(args: SelectSubset<T, em_user_listUpdateArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_user_lists.
     * @param {em_user_listDeleteManyArgs} args - Arguments to filter Em_user_lists to delete.
     * @example
     * // Delete a few Em_user_lists
     * const { count } = await prisma.em_user_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_user_listDeleteManyArgs>(args?: SelectSubset<T, em_user_listDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_user_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_user_lists
     * const em_user_list = await prisma.em_user_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_user_listUpdateManyArgs>(args: SelectSubset<T, em_user_listUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_user_list.
     * @param {em_user_listUpsertArgs} args - Arguments to update or create a Em_user_list.
     * @example
     * // Update or create a Em_user_list
     * const em_user_list = await prisma.em_user_list.upsert({
     *   create: {
     *     // ... data to create a Em_user_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_user_list we want to update
     *   }
     * })
     */
    upsert<T extends em_user_listUpsertArgs>(args: SelectSubset<T, em_user_listUpsertArgs<ExtArgs>>): Prisma__em_user_listClient<$Result.GetResult<Prisma.$em_user_listPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_user_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_listCountArgs} args - Arguments to filter Em_user_lists to count.
     * @example
     * // Count the number of Em_user_lists
     * const count = await prisma.em_user_list.count({
     *   where: {
     *     // ... the filter for the Em_user_lists we want to count
     *   }
     * })
    **/
    count<T extends em_user_listCountArgs>(
      args?: Subset<T, em_user_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_user_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_user_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_user_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_user_listAggregateArgs>(args: Subset<T, Em_user_listAggregateArgs>): Prisma.PrismaPromise<GetEm_user_listAggregateType<T>>

    /**
     * Group by Em_user_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_user_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_user_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_user_listGroupByArgs['orderBy'] }
        : { orderBy?: em_user_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_user_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_user_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_user_list model
   */
  readonly fields: em_user_listFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_user_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_user_listClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_user_list model
   */
  interface em_user_listFieldRefs {
    readonly id: FieldRef<"em_user_list", 'Int'>
    readonly userid: FieldRef<"em_user_list", 'String'>
    readonly menuid: FieldRef<"em_user_list", 'Int'>
    readonly visible: FieldRef<"em_user_list", 'Boolean'>
    readonly lastupdate: FieldRef<"em_user_list", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_user_list findUnique
   */
  export type em_user_listFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * Filter, which em_user_list to fetch.
     */
    where: em_user_listWhereUniqueInput
  }

  /**
   * em_user_list findUniqueOrThrow
   */
  export type em_user_listFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * Filter, which em_user_list to fetch.
     */
    where: em_user_listWhereUniqueInput
  }

  /**
   * em_user_list findFirst
   */
  export type em_user_listFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * Filter, which em_user_list to fetch.
     */
    where?: em_user_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_lists to fetch.
     */
    orderBy?: em_user_listOrderByWithRelationInput | em_user_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_user_lists.
     */
    cursor?: em_user_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_user_lists.
     */
    distinct?: Em_user_listScalarFieldEnum | Em_user_listScalarFieldEnum[]
  }

  /**
   * em_user_list findFirstOrThrow
   */
  export type em_user_listFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * Filter, which em_user_list to fetch.
     */
    where?: em_user_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_lists to fetch.
     */
    orderBy?: em_user_listOrderByWithRelationInput | em_user_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_user_lists.
     */
    cursor?: em_user_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_user_lists.
     */
    distinct?: Em_user_listScalarFieldEnum | Em_user_listScalarFieldEnum[]
  }

  /**
   * em_user_list findMany
   */
  export type em_user_listFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * Filter, which em_user_lists to fetch.
     */
    where?: em_user_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_user_lists to fetch.
     */
    orderBy?: em_user_listOrderByWithRelationInput | em_user_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_user_lists.
     */
    cursor?: em_user_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_user_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_user_lists.
     */
    skip?: number
    distinct?: Em_user_listScalarFieldEnum | Em_user_listScalarFieldEnum[]
  }

  /**
   * em_user_list create
   */
  export type em_user_listCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * The data needed to create a em_user_list.
     */
    data: XOR<em_user_listCreateInput, em_user_listUncheckedCreateInput>
  }

  /**
   * em_user_list createMany
   */
  export type em_user_listCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_user_lists.
     */
    data: em_user_listCreateManyInput | em_user_listCreateManyInput[]
  }

  /**
   * em_user_list update
   */
  export type em_user_listUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * The data needed to update a em_user_list.
     */
    data: XOR<em_user_listUpdateInput, em_user_listUncheckedUpdateInput>
    /**
     * Choose, which em_user_list to update.
     */
    where: em_user_listWhereUniqueInput
  }

  /**
   * em_user_list updateMany
   */
  export type em_user_listUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_user_lists.
     */
    data: XOR<em_user_listUpdateManyMutationInput, em_user_listUncheckedUpdateManyInput>
    /**
     * Filter which em_user_lists to update
     */
    where?: em_user_listWhereInput
    /**
     * Limit how many em_user_lists to update.
     */
    limit?: number
  }

  /**
   * em_user_list upsert
   */
  export type em_user_listUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * The filter to search for the em_user_list to update in case it exists.
     */
    where: em_user_listWhereUniqueInput
    /**
     * In case the em_user_list found by the `where` argument doesn't exist, create a new em_user_list with this data.
     */
    create: XOR<em_user_listCreateInput, em_user_listUncheckedCreateInput>
    /**
     * In case the em_user_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_user_listUpdateInput, em_user_listUncheckedUpdateInput>
  }

  /**
   * em_user_list delete
   */
  export type em_user_listDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
    /**
     * Filter which em_user_list to delete.
     */
    where: em_user_listWhereUniqueInput
  }

  /**
   * em_user_list deleteMany
   */
  export type em_user_listDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_user_lists to delete
     */
    where?: em_user_listWhereInput
    /**
     * Limit how many em_user_lists to delete.
     */
    limit?: number
  }

  /**
   * em_user_list without action
   */
  export type em_user_listDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_user_list
     */
    select?: em_user_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_user_list
     */
    omit?: em_user_listOmit<ExtArgs> | null
  }


  /**
   * Model em_users
   */

  export type AggregateEm_users = {
    _count: Em_usersCountAggregateOutputType | null
    _avg: Em_usersAvgAggregateOutputType | null
    _sum: Em_usersSumAggregateOutputType | null
    _min: Em_usersMinAggregateOutputType | null
    _max: Em_usersMaxAggregateOutputType | null
  }

  export type Em_usersAvgAggregateOutputType = {
    Id: number | null
    LevelId: number | null
  }

  export type Em_usersSumAggregateOutputType = {
    Id: number | null
    LevelId: number | null
  }

  export type Em_usersMinAggregateOutputType = {
    Id: number | null
    UserId: string | null
    Username: string | null
    Password: string | null
    LastUpdate: Date | null
    LevelId: number | null
    Name: string | null
    Status: string | null
    imagename: string | null
    Pass_Access_Menu: string | null
  }

  export type Em_usersMaxAggregateOutputType = {
    Id: number | null
    UserId: string | null
    Username: string | null
    Password: string | null
    LastUpdate: Date | null
    LevelId: number | null
    Name: string | null
    Status: string | null
    imagename: string | null
    Pass_Access_Menu: string | null
  }

  export type Em_usersCountAggregateOutputType = {
    Id: number
    UserId: number
    Username: number
    Password: number
    LastUpdate: number
    LevelId: number
    Name: number
    Status: number
    imagename: number
    Pass_Access_Menu: number
    _all: number
  }


  export type Em_usersAvgAggregateInputType = {
    Id?: true
    LevelId?: true
  }

  export type Em_usersSumAggregateInputType = {
    Id?: true
    LevelId?: true
  }

  export type Em_usersMinAggregateInputType = {
    Id?: true
    UserId?: true
    Username?: true
    Password?: true
    LastUpdate?: true
    LevelId?: true
    Name?: true
    Status?: true
    imagename?: true
    Pass_Access_Menu?: true
  }

  export type Em_usersMaxAggregateInputType = {
    Id?: true
    UserId?: true
    Username?: true
    Password?: true
    LastUpdate?: true
    LevelId?: true
    Name?: true
    Status?: true
    imagename?: true
    Pass_Access_Menu?: true
  }

  export type Em_usersCountAggregateInputType = {
    Id?: true
    UserId?: true
    Username?: true
    Password?: true
    LastUpdate?: true
    LevelId?: true
    Name?: true
    Status?: true
    imagename?: true
    Pass_Access_Menu?: true
    _all?: true
  }

  export type Em_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_users to aggregate.
     */
    where?: em_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_users to fetch.
     */
    orderBy?: em_usersOrderByWithRelationInput | em_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_users
    **/
    _count?: true | Em_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_usersMaxAggregateInputType
  }

  export type GetEm_usersAggregateType<T extends Em_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_users[P]>
      : GetScalarType<T[P], AggregateEm_users[P]>
  }




  export type em_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_usersWhereInput
    orderBy?: em_usersOrderByWithAggregationInput | em_usersOrderByWithAggregationInput[]
    by: Em_usersScalarFieldEnum[] | Em_usersScalarFieldEnum
    having?: em_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_usersCountAggregateInputType | true
    _avg?: Em_usersAvgAggregateInputType
    _sum?: Em_usersSumAggregateInputType
    _min?: Em_usersMinAggregateInputType
    _max?: Em_usersMaxAggregateInputType
  }

  export type Em_usersGroupByOutputType = {
    Id: number
    UserId: string
    Username: string
    Password: string
    LastUpdate: Date | null
    LevelId: number | null
    Name: string
    Status: string | null
    imagename: string | null
    Pass_Access_Menu: string | null
    _count: Em_usersCountAggregateOutputType | null
    _avg: Em_usersAvgAggregateOutputType | null
    _sum: Em_usersSumAggregateOutputType | null
    _min: Em_usersMinAggregateOutputType | null
    _max: Em_usersMaxAggregateOutputType | null
  }

  type GetEm_usersGroupByPayload<T extends em_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Em_usersGroupByOutputType[P]>
        }
      >
    >


  export type em_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    Username?: boolean
    Password?: boolean
    LastUpdate?: boolean
    LevelId?: boolean
    Name?: boolean
    Status?: boolean
    imagename?: boolean
    Pass_Access_Menu?: boolean
  }, ExtArgs["result"]["em_users"]>



  export type em_usersSelectScalar = {
    Id?: boolean
    UserId?: boolean
    Username?: boolean
    Password?: boolean
    LastUpdate?: boolean
    LevelId?: boolean
    Name?: boolean
    Status?: boolean
    imagename?: boolean
    Pass_Access_Menu?: boolean
  }

  export type em_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UserId" | "Username" | "Password" | "LastUpdate" | "LevelId" | "Name" | "Status" | "imagename" | "Pass_Access_Menu", ExtArgs["result"]["em_users"]>

  export type $em_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserId: string
      Username: string
      Password: string
      LastUpdate: Date | null
      LevelId: number | null
      Name: string
      Status: string | null
      imagename: string | null
      Pass_Access_Menu: string | null
    }, ExtArgs["result"]["em_users"]>
    composites: {}
  }

  type em_usersGetPayload<S extends boolean | null | undefined | em_usersDefaultArgs> = $Result.GetResult<Prisma.$em_usersPayload, S>

  type em_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_usersCountAggregateInputType | true
    }

  export interface em_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_users'], meta: { name: 'em_users' } }
    /**
     * Find zero or one Em_users that matches the filter.
     * @param {em_usersFindUniqueArgs} args - Arguments to find a Em_users
     * @example
     * // Get one Em_users
     * const em_users = await prisma.em_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_usersFindUniqueArgs>(args: SelectSubset<T, em_usersFindUniqueArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_usersFindUniqueOrThrowArgs} args - Arguments to find a Em_users
     * @example
     * // Get one Em_users
     * const em_users = await prisma.em_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, em_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_usersFindFirstArgs} args - Arguments to find a Em_users
     * @example
     * // Get one Em_users
     * const em_users = await prisma.em_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_usersFindFirstArgs>(args?: SelectSubset<T, em_usersFindFirstArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_usersFindFirstOrThrowArgs} args - Arguments to find a Em_users
     * @example
     * // Get one Em_users
     * const em_users = await prisma.em_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, em_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_users
     * const em_users = await prisma.em_users.findMany()
     * 
     * // Get first 10 Em_users
     * const em_users = await prisma.em_users.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const em_usersWithIdOnly = await prisma.em_users.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends em_usersFindManyArgs>(args?: SelectSubset<T, em_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_users.
     * @param {em_usersCreateArgs} args - Arguments to create a Em_users.
     * @example
     * // Create one Em_users
     * const Em_users = await prisma.em_users.create({
     *   data: {
     *     // ... data to create a Em_users
     *   }
     * })
     * 
     */
    create<T extends em_usersCreateArgs>(args: SelectSubset<T, em_usersCreateArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_users.
     * @param {em_usersCreateManyArgs} args - Arguments to create many Em_users.
     * @example
     * // Create many Em_users
     * const em_users = await prisma.em_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_usersCreateManyArgs>(args?: SelectSubset<T, em_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_users.
     * @param {em_usersDeleteArgs} args - Arguments to delete one Em_users.
     * @example
     * // Delete one Em_users
     * const Em_users = await prisma.em_users.delete({
     *   where: {
     *     // ... filter to delete one Em_users
     *   }
     * })
     * 
     */
    delete<T extends em_usersDeleteArgs>(args: SelectSubset<T, em_usersDeleteArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_users.
     * @param {em_usersUpdateArgs} args - Arguments to update one Em_users.
     * @example
     * // Update one Em_users
     * const em_users = await prisma.em_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_usersUpdateArgs>(args: SelectSubset<T, em_usersUpdateArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_users.
     * @param {em_usersDeleteManyArgs} args - Arguments to filter Em_users to delete.
     * @example
     * // Delete a few Em_users
     * const { count } = await prisma.em_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_usersDeleteManyArgs>(args?: SelectSubset<T, em_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_users
     * const em_users = await prisma.em_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_usersUpdateManyArgs>(args: SelectSubset<T, em_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_users.
     * @param {em_usersUpsertArgs} args - Arguments to update or create a Em_users.
     * @example
     * // Update or create a Em_users
     * const em_users = await prisma.em_users.upsert({
     *   create: {
     *     // ... data to create a Em_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_users we want to update
     *   }
     * })
     */
    upsert<T extends em_usersUpsertArgs>(args: SelectSubset<T, em_usersUpsertArgs<ExtArgs>>): Prisma__em_usersClient<$Result.GetResult<Prisma.$em_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_usersCountArgs} args - Arguments to filter Em_users to count.
     * @example
     * // Count the number of Em_users
     * const count = await prisma.em_users.count({
     *   where: {
     *     // ... the filter for the Em_users we want to count
     *   }
     * })
    **/
    count<T extends em_usersCountArgs>(
      args?: Subset<T, em_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_usersAggregateArgs>(args: Subset<T, Em_usersAggregateArgs>): Prisma.PrismaPromise<GetEm_usersAggregateType<T>>

    /**
     * Group by Em_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_usersGroupByArgs['orderBy'] }
        : { orderBy?: em_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_users model
   */
  readonly fields: em_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_users model
   */
  interface em_usersFieldRefs {
    readonly Id: FieldRef<"em_users", 'Int'>
    readonly UserId: FieldRef<"em_users", 'String'>
    readonly Username: FieldRef<"em_users", 'String'>
    readonly Password: FieldRef<"em_users", 'String'>
    readonly LastUpdate: FieldRef<"em_users", 'DateTime'>
    readonly LevelId: FieldRef<"em_users", 'Int'>
    readonly Name: FieldRef<"em_users", 'String'>
    readonly Status: FieldRef<"em_users", 'String'>
    readonly imagename: FieldRef<"em_users", 'String'>
    readonly Pass_Access_Menu: FieldRef<"em_users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_users findUnique
   */
  export type em_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * Filter, which em_users to fetch.
     */
    where: em_usersWhereUniqueInput
  }

  /**
   * em_users findUniqueOrThrow
   */
  export type em_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * Filter, which em_users to fetch.
     */
    where: em_usersWhereUniqueInput
  }

  /**
   * em_users findFirst
   */
  export type em_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * Filter, which em_users to fetch.
     */
    where?: em_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_users to fetch.
     */
    orderBy?: em_usersOrderByWithRelationInput | em_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_users.
     */
    cursor?: em_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_users.
     */
    distinct?: Em_usersScalarFieldEnum | Em_usersScalarFieldEnum[]
  }

  /**
   * em_users findFirstOrThrow
   */
  export type em_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * Filter, which em_users to fetch.
     */
    where?: em_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_users to fetch.
     */
    orderBy?: em_usersOrderByWithRelationInput | em_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_users.
     */
    cursor?: em_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_users.
     */
    distinct?: Em_usersScalarFieldEnum | Em_usersScalarFieldEnum[]
  }

  /**
   * em_users findMany
   */
  export type em_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * Filter, which em_users to fetch.
     */
    where?: em_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_users to fetch.
     */
    orderBy?: em_usersOrderByWithRelationInput | em_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_users.
     */
    cursor?: em_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_users.
     */
    skip?: number
    distinct?: Em_usersScalarFieldEnum | Em_usersScalarFieldEnum[]
  }

  /**
   * em_users create
   */
  export type em_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * The data needed to create a em_users.
     */
    data: XOR<em_usersCreateInput, em_usersUncheckedCreateInput>
  }

  /**
   * em_users createMany
   */
  export type em_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_users.
     */
    data: em_usersCreateManyInput | em_usersCreateManyInput[]
  }

  /**
   * em_users update
   */
  export type em_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * The data needed to update a em_users.
     */
    data: XOR<em_usersUpdateInput, em_usersUncheckedUpdateInput>
    /**
     * Choose, which em_users to update.
     */
    where: em_usersWhereUniqueInput
  }

  /**
   * em_users updateMany
   */
  export type em_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_users.
     */
    data: XOR<em_usersUpdateManyMutationInput, em_usersUncheckedUpdateManyInput>
    /**
     * Filter which em_users to update
     */
    where?: em_usersWhereInput
    /**
     * Limit how many em_users to update.
     */
    limit?: number
  }

  /**
   * em_users upsert
   */
  export type em_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * The filter to search for the em_users to update in case it exists.
     */
    where: em_usersWhereUniqueInput
    /**
     * In case the em_users found by the `where` argument doesn't exist, create a new em_users with this data.
     */
    create: XOR<em_usersCreateInput, em_usersUncheckedCreateInput>
    /**
     * In case the em_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_usersUpdateInput, em_usersUncheckedUpdateInput>
  }

  /**
   * em_users delete
   */
  export type em_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
    /**
     * Filter which em_users to delete.
     */
    where: em_usersWhereUniqueInput
  }

  /**
   * em_users deleteMany
   */
  export type em_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_users to delete
     */
    where?: em_usersWhereInput
    /**
     * Limit how many em_users to delete.
     */
    limit?: number
  }

  /**
   * em_users without action
   */
  export type em_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_users
     */
    select?: em_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_users
     */
    omit?: em_usersOmit<ExtArgs> | null
  }


  /**
   * Model em_verify_links
   */

  export type AggregateEm_verify_links = {
    _count: Em_verify_linksCountAggregateOutputType | null
    _avg: Em_verify_linksAvgAggregateOutputType | null
    _sum: Em_verify_linksSumAggregateOutputType | null
    _min: Em_verify_linksMinAggregateOutputType | null
    _max: Em_verify_linksMaxAggregateOutputType | null
  }

  export type Em_verify_linksAvgAggregateOutputType = {
    id: number | null
    applicant_id: number | null
  }

  export type Em_verify_linksSumAggregateOutputType = {
    id: number | null
    applicant_id: number | null
  }

  export type Em_verify_linksMinAggregateOutputType = {
    id: number | null
    applicant_id: number | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
    status: string | null
    useragent: string | null
    ipaddress: string | null
    browser: string | null
    platform: string | null
    device: string | null
  }

  export type Em_verify_linksMaxAggregateOutputType = {
    id: number | null
    applicant_id: number | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
    status: string | null
    useragent: string | null
    ipaddress: string | null
    browser: string | null
    platform: string | null
    device: string | null
  }

  export type Em_verify_linksCountAggregateOutputType = {
    id: number
    applicant_id: number
    token: number
    expires_at: number
    created_at: number
    status: number
    useragent: number
    ipaddress: number
    browser: number
    platform: number
    device: number
    _all: number
  }


  export type Em_verify_linksAvgAggregateInputType = {
    id?: true
    applicant_id?: true
  }

  export type Em_verify_linksSumAggregateInputType = {
    id?: true
    applicant_id?: true
  }

  export type Em_verify_linksMinAggregateInputType = {
    id?: true
    applicant_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    status?: true
    useragent?: true
    ipaddress?: true
    browser?: true
    platform?: true
    device?: true
  }

  export type Em_verify_linksMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    status?: true
    useragent?: true
    ipaddress?: true
    browser?: true
    platform?: true
    device?: true
  }

  export type Em_verify_linksCountAggregateInputType = {
    id?: true
    applicant_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    status?: true
    useragent?: true
    ipaddress?: true
    browser?: true
    platform?: true
    device?: true
    _all?: true
  }

  export type Em_verify_linksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_verify_links to aggregate.
     */
    where?: em_verify_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_verify_links to fetch.
     */
    orderBy?: em_verify_linksOrderByWithRelationInput | em_verify_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_verify_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_verify_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_verify_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_verify_links
    **/
    _count?: true | Em_verify_linksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_verify_linksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_verify_linksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_verify_linksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_verify_linksMaxAggregateInputType
  }

  export type GetEm_verify_linksAggregateType<T extends Em_verify_linksAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_verify_links]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_verify_links[P]>
      : GetScalarType<T[P], AggregateEm_verify_links[P]>
  }




  export type em_verify_linksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_verify_linksWhereInput
    orderBy?: em_verify_linksOrderByWithAggregationInput | em_verify_linksOrderByWithAggregationInput[]
    by: Em_verify_linksScalarFieldEnum[] | Em_verify_linksScalarFieldEnum
    having?: em_verify_linksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_verify_linksCountAggregateInputType | true
    _avg?: Em_verify_linksAvgAggregateInputType
    _sum?: Em_verify_linksSumAggregateInputType
    _min?: Em_verify_linksMinAggregateInputType
    _max?: Em_verify_linksMaxAggregateInputType
  }

  export type Em_verify_linksGroupByOutputType = {
    id: number
    applicant_id: number
    token: string | null
    expires_at: Date
    created_at: Date | null
    status: string | null
    useragent: string | null
    ipaddress: string | null
    browser: string | null
    platform: string | null
    device: string | null
    _count: Em_verify_linksCountAggregateOutputType | null
    _avg: Em_verify_linksAvgAggregateOutputType | null
    _sum: Em_verify_linksSumAggregateOutputType | null
    _min: Em_verify_linksMinAggregateOutputType | null
    _max: Em_verify_linksMaxAggregateOutputType | null
  }

  type GetEm_verify_linksGroupByPayload<T extends em_verify_linksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_verify_linksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_verify_linksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_verify_linksGroupByOutputType[P]>
            : GetScalarType<T[P], Em_verify_linksGroupByOutputType[P]>
        }
      >
    >


  export type em_verify_linksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    status?: boolean
    useragent?: boolean
    ipaddress?: boolean
    browser?: boolean
    platform?: boolean
    device?: boolean
  }, ExtArgs["result"]["em_verify_links"]>



  export type em_verify_linksSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    status?: boolean
    useragent?: boolean
    ipaddress?: boolean
    browser?: boolean
    platform?: boolean
    device?: boolean
  }

  export type em_verify_linksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicant_id" | "token" | "expires_at" | "created_at" | "status" | "useragent" | "ipaddress" | "browser" | "platform" | "device", ExtArgs["result"]["em_verify_links"]>

  export type $em_verify_linksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_verify_links"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: number
      token: string | null
      expires_at: Date
      created_at: Date | null
      status: string | null
      useragent: string | null
      ipaddress: string | null
      browser: string | null
      platform: string | null
      device: string | null
    }, ExtArgs["result"]["em_verify_links"]>
    composites: {}
  }

  type em_verify_linksGetPayload<S extends boolean | null | undefined | em_verify_linksDefaultArgs> = $Result.GetResult<Prisma.$em_verify_linksPayload, S>

  type em_verify_linksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_verify_linksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_verify_linksCountAggregateInputType | true
    }

  export interface em_verify_linksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_verify_links'], meta: { name: 'em_verify_links' } }
    /**
     * Find zero or one Em_verify_links that matches the filter.
     * @param {em_verify_linksFindUniqueArgs} args - Arguments to find a Em_verify_links
     * @example
     * // Get one Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_verify_linksFindUniqueArgs>(args: SelectSubset<T, em_verify_linksFindUniqueArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_verify_links that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_verify_linksFindUniqueOrThrowArgs} args - Arguments to find a Em_verify_links
     * @example
     * // Get one Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_verify_linksFindUniqueOrThrowArgs>(args: SelectSubset<T, em_verify_linksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_verify_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_verify_linksFindFirstArgs} args - Arguments to find a Em_verify_links
     * @example
     * // Get one Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_verify_linksFindFirstArgs>(args?: SelectSubset<T, em_verify_linksFindFirstArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_verify_links that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_verify_linksFindFirstOrThrowArgs} args - Arguments to find a Em_verify_links
     * @example
     * // Get one Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_verify_linksFindFirstOrThrowArgs>(args?: SelectSubset<T, em_verify_linksFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_verify_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_verify_linksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.findMany()
     * 
     * // Get first 10 Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_verify_linksWithIdOnly = await prisma.em_verify_links.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_verify_linksFindManyArgs>(args?: SelectSubset<T, em_verify_linksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_verify_links.
     * @param {em_verify_linksCreateArgs} args - Arguments to create a Em_verify_links.
     * @example
     * // Create one Em_verify_links
     * const Em_verify_links = await prisma.em_verify_links.create({
     *   data: {
     *     // ... data to create a Em_verify_links
     *   }
     * })
     * 
     */
    create<T extends em_verify_linksCreateArgs>(args: SelectSubset<T, em_verify_linksCreateArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_verify_links.
     * @param {em_verify_linksCreateManyArgs} args - Arguments to create many Em_verify_links.
     * @example
     * // Create many Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_verify_linksCreateManyArgs>(args?: SelectSubset<T, em_verify_linksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_verify_links.
     * @param {em_verify_linksDeleteArgs} args - Arguments to delete one Em_verify_links.
     * @example
     * // Delete one Em_verify_links
     * const Em_verify_links = await prisma.em_verify_links.delete({
     *   where: {
     *     // ... filter to delete one Em_verify_links
     *   }
     * })
     * 
     */
    delete<T extends em_verify_linksDeleteArgs>(args: SelectSubset<T, em_verify_linksDeleteArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_verify_links.
     * @param {em_verify_linksUpdateArgs} args - Arguments to update one Em_verify_links.
     * @example
     * // Update one Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_verify_linksUpdateArgs>(args: SelectSubset<T, em_verify_linksUpdateArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_verify_links.
     * @param {em_verify_linksDeleteManyArgs} args - Arguments to filter Em_verify_links to delete.
     * @example
     * // Delete a few Em_verify_links
     * const { count } = await prisma.em_verify_links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_verify_linksDeleteManyArgs>(args?: SelectSubset<T, em_verify_linksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_verify_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_verify_linksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_verify_linksUpdateManyArgs>(args: SelectSubset<T, em_verify_linksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_verify_links.
     * @param {em_verify_linksUpsertArgs} args - Arguments to update or create a Em_verify_links.
     * @example
     * // Update or create a Em_verify_links
     * const em_verify_links = await prisma.em_verify_links.upsert({
     *   create: {
     *     // ... data to create a Em_verify_links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_verify_links we want to update
     *   }
     * })
     */
    upsert<T extends em_verify_linksUpsertArgs>(args: SelectSubset<T, em_verify_linksUpsertArgs<ExtArgs>>): Prisma__em_verify_linksClient<$Result.GetResult<Prisma.$em_verify_linksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_verify_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_verify_linksCountArgs} args - Arguments to filter Em_verify_links to count.
     * @example
     * // Count the number of Em_verify_links
     * const count = await prisma.em_verify_links.count({
     *   where: {
     *     // ... the filter for the Em_verify_links we want to count
     *   }
     * })
    **/
    count<T extends em_verify_linksCountArgs>(
      args?: Subset<T, em_verify_linksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_verify_linksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_verify_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_verify_linksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_verify_linksAggregateArgs>(args: Subset<T, Em_verify_linksAggregateArgs>): Prisma.PrismaPromise<GetEm_verify_linksAggregateType<T>>

    /**
     * Group by Em_verify_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_verify_linksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_verify_linksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_verify_linksGroupByArgs['orderBy'] }
        : { orderBy?: em_verify_linksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_verify_linksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_verify_linksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_verify_links model
   */
  readonly fields: em_verify_linksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_verify_links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_verify_linksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_verify_links model
   */
  interface em_verify_linksFieldRefs {
    readonly id: FieldRef<"em_verify_links", 'Int'>
    readonly applicant_id: FieldRef<"em_verify_links", 'Int'>
    readonly token: FieldRef<"em_verify_links", 'String'>
    readonly expires_at: FieldRef<"em_verify_links", 'DateTime'>
    readonly created_at: FieldRef<"em_verify_links", 'DateTime'>
    readonly status: FieldRef<"em_verify_links", 'String'>
    readonly useragent: FieldRef<"em_verify_links", 'String'>
    readonly ipaddress: FieldRef<"em_verify_links", 'String'>
    readonly browser: FieldRef<"em_verify_links", 'String'>
    readonly platform: FieldRef<"em_verify_links", 'String'>
    readonly device: FieldRef<"em_verify_links", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_verify_links findUnique
   */
  export type em_verify_linksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * Filter, which em_verify_links to fetch.
     */
    where: em_verify_linksWhereUniqueInput
  }

  /**
   * em_verify_links findUniqueOrThrow
   */
  export type em_verify_linksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * Filter, which em_verify_links to fetch.
     */
    where: em_verify_linksWhereUniqueInput
  }

  /**
   * em_verify_links findFirst
   */
  export type em_verify_linksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * Filter, which em_verify_links to fetch.
     */
    where?: em_verify_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_verify_links to fetch.
     */
    orderBy?: em_verify_linksOrderByWithRelationInput | em_verify_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_verify_links.
     */
    cursor?: em_verify_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_verify_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_verify_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_verify_links.
     */
    distinct?: Em_verify_linksScalarFieldEnum | Em_verify_linksScalarFieldEnum[]
  }

  /**
   * em_verify_links findFirstOrThrow
   */
  export type em_verify_linksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * Filter, which em_verify_links to fetch.
     */
    where?: em_verify_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_verify_links to fetch.
     */
    orderBy?: em_verify_linksOrderByWithRelationInput | em_verify_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_verify_links.
     */
    cursor?: em_verify_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_verify_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_verify_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_verify_links.
     */
    distinct?: Em_verify_linksScalarFieldEnum | Em_verify_linksScalarFieldEnum[]
  }

  /**
   * em_verify_links findMany
   */
  export type em_verify_linksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * Filter, which em_verify_links to fetch.
     */
    where?: em_verify_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_verify_links to fetch.
     */
    orderBy?: em_verify_linksOrderByWithRelationInput | em_verify_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_verify_links.
     */
    cursor?: em_verify_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_verify_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_verify_links.
     */
    skip?: number
    distinct?: Em_verify_linksScalarFieldEnum | Em_verify_linksScalarFieldEnum[]
  }

  /**
   * em_verify_links create
   */
  export type em_verify_linksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * The data needed to create a em_verify_links.
     */
    data: XOR<em_verify_linksCreateInput, em_verify_linksUncheckedCreateInput>
  }

  /**
   * em_verify_links createMany
   */
  export type em_verify_linksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_verify_links.
     */
    data: em_verify_linksCreateManyInput | em_verify_linksCreateManyInput[]
  }

  /**
   * em_verify_links update
   */
  export type em_verify_linksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * The data needed to update a em_verify_links.
     */
    data: XOR<em_verify_linksUpdateInput, em_verify_linksUncheckedUpdateInput>
    /**
     * Choose, which em_verify_links to update.
     */
    where: em_verify_linksWhereUniqueInput
  }

  /**
   * em_verify_links updateMany
   */
  export type em_verify_linksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_verify_links.
     */
    data: XOR<em_verify_linksUpdateManyMutationInput, em_verify_linksUncheckedUpdateManyInput>
    /**
     * Filter which em_verify_links to update
     */
    where?: em_verify_linksWhereInput
    /**
     * Limit how many em_verify_links to update.
     */
    limit?: number
  }

  /**
   * em_verify_links upsert
   */
  export type em_verify_linksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * The filter to search for the em_verify_links to update in case it exists.
     */
    where: em_verify_linksWhereUniqueInput
    /**
     * In case the em_verify_links found by the `where` argument doesn't exist, create a new em_verify_links with this data.
     */
    create: XOR<em_verify_linksCreateInput, em_verify_linksUncheckedCreateInput>
    /**
     * In case the em_verify_links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_verify_linksUpdateInput, em_verify_linksUncheckedUpdateInput>
  }

  /**
   * em_verify_links delete
   */
  export type em_verify_linksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
    /**
     * Filter which em_verify_links to delete.
     */
    where: em_verify_linksWhereUniqueInput
  }

  /**
   * em_verify_links deleteMany
   */
  export type em_verify_linksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_verify_links to delete
     */
    where?: em_verify_linksWhereInput
    /**
     * Limit how many em_verify_links to delete.
     */
    limit?: number
  }

  /**
   * em_verify_links without action
   */
  export type em_verify_linksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_verify_links
     */
    select?: em_verify_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_verify_links
     */
    omit?: em_verify_linksOmit<ExtArgs> | null
  }


  /**
   * Model em_wa_templates
   */

  export type AggregateEm_wa_templates = {
    _count: Em_wa_templatesCountAggregateOutputType | null
    _avg: Em_wa_templatesAvgAggregateOutputType | null
    _sum: Em_wa_templatesSumAggregateOutputType | null
    _min: Em_wa_templatesMinAggregateOutputType | null
    _max: Em_wa_templatesMaxAggregateOutputType | null
  }

  export type Em_wa_templatesAvgAggregateOutputType = {
    id: number | null
    tpfor: number | null
  }

  export type Em_wa_templatesSumAggregateOutputType = {
    id: number | null
    tpfor: number | null
  }

  export type Em_wa_templatesMinAggregateOutputType = {
    id: number | null
    template_name: string | null
    template_text: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    status: string | null
    tpfor: number | null
  }

  export type Em_wa_templatesMaxAggregateOutputType = {
    id: number | null
    template_name: string | null
    template_text: string | null
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    status: string | null
    tpfor: number | null
  }

  export type Em_wa_templatesCountAggregateOutputType = {
    id: number
    template_name: number
    template_text: number
    add_by: number
    created_at: number
    lastupdate: number
    status: number
    tpfor: number
    _all: number
  }


  export type Em_wa_templatesAvgAggregateInputType = {
    id?: true
    tpfor?: true
  }

  export type Em_wa_templatesSumAggregateInputType = {
    id?: true
    tpfor?: true
  }

  export type Em_wa_templatesMinAggregateInputType = {
    id?: true
    template_name?: true
    template_text?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    status?: true
    tpfor?: true
  }

  export type Em_wa_templatesMaxAggregateInputType = {
    id?: true
    template_name?: true
    template_text?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    status?: true
    tpfor?: true
  }

  export type Em_wa_templatesCountAggregateInputType = {
    id?: true
    template_name?: true
    template_text?: true
    add_by?: true
    created_at?: true
    lastupdate?: true
    status?: true
    tpfor?: true
    _all?: true
  }

  export type Em_wa_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_wa_templates to aggregate.
     */
    where?: em_wa_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_wa_templates to fetch.
     */
    orderBy?: em_wa_templatesOrderByWithRelationInput | em_wa_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_wa_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_wa_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_wa_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_wa_templates
    **/
    _count?: true | Em_wa_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_wa_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_wa_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_wa_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_wa_templatesMaxAggregateInputType
  }

  export type GetEm_wa_templatesAggregateType<T extends Em_wa_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_wa_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_wa_templates[P]>
      : GetScalarType<T[P], AggregateEm_wa_templates[P]>
  }




  export type em_wa_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_wa_templatesWhereInput
    orderBy?: em_wa_templatesOrderByWithAggregationInput | em_wa_templatesOrderByWithAggregationInput[]
    by: Em_wa_templatesScalarFieldEnum[] | Em_wa_templatesScalarFieldEnum
    having?: em_wa_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_wa_templatesCountAggregateInputType | true
    _avg?: Em_wa_templatesAvgAggregateInputType
    _sum?: Em_wa_templatesSumAggregateInputType
    _min?: Em_wa_templatesMinAggregateInputType
    _max?: Em_wa_templatesMaxAggregateInputType
  }

  export type Em_wa_templatesGroupByOutputType = {
    id: number
    template_name: string
    template_text: string
    add_by: string | null
    created_at: Date | null
    lastupdate: Date | null
    status: string | null
    tpfor: number | null
    _count: Em_wa_templatesCountAggregateOutputType | null
    _avg: Em_wa_templatesAvgAggregateOutputType | null
    _sum: Em_wa_templatesSumAggregateOutputType | null
    _min: Em_wa_templatesMinAggregateOutputType | null
    _max: Em_wa_templatesMaxAggregateOutputType | null
  }

  type GetEm_wa_templatesGroupByPayload<T extends em_wa_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_wa_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_wa_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_wa_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Em_wa_templatesGroupByOutputType[P]>
        }
      >
    >


  export type em_wa_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    template_name?: boolean
    template_text?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    status?: boolean
    tpfor?: boolean
  }, ExtArgs["result"]["em_wa_templates"]>



  export type em_wa_templatesSelectScalar = {
    id?: boolean
    template_name?: boolean
    template_text?: boolean
    add_by?: boolean
    created_at?: boolean
    lastupdate?: boolean
    status?: boolean
    tpfor?: boolean
  }

  export type em_wa_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "template_name" | "template_text" | "add_by" | "created_at" | "lastupdate" | "status" | "tpfor", ExtArgs["result"]["em_wa_templates"]>

  export type $em_wa_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_wa_templates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      template_name: string
      template_text: string
      add_by: string | null
      created_at: Date | null
      lastupdate: Date | null
      status: string | null
      tpfor: number | null
    }, ExtArgs["result"]["em_wa_templates"]>
    composites: {}
  }

  type em_wa_templatesGetPayload<S extends boolean | null | undefined | em_wa_templatesDefaultArgs> = $Result.GetResult<Prisma.$em_wa_templatesPayload, S>

  type em_wa_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_wa_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_wa_templatesCountAggregateInputType | true
    }

  export interface em_wa_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_wa_templates'], meta: { name: 'em_wa_templates' } }
    /**
     * Find zero or one Em_wa_templates that matches the filter.
     * @param {em_wa_templatesFindUniqueArgs} args - Arguments to find a Em_wa_templates
     * @example
     * // Get one Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_wa_templatesFindUniqueArgs>(args: SelectSubset<T, em_wa_templatesFindUniqueArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_wa_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_wa_templatesFindUniqueOrThrowArgs} args - Arguments to find a Em_wa_templates
     * @example
     * // Get one Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_wa_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, em_wa_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_wa_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_wa_templatesFindFirstArgs} args - Arguments to find a Em_wa_templates
     * @example
     * // Get one Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_wa_templatesFindFirstArgs>(args?: SelectSubset<T, em_wa_templatesFindFirstArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_wa_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_wa_templatesFindFirstOrThrowArgs} args - Arguments to find a Em_wa_templates
     * @example
     * // Get one Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_wa_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, em_wa_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_wa_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_wa_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.findMany()
     * 
     * // Get first 10 Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_wa_templatesWithIdOnly = await prisma.em_wa_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_wa_templatesFindManyArgs>(args?: SelectSubset<T, em_wa_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_wa_templates.
     * @param {em_wa_templatesCreateArgs} args - Arguments to create a Em_wa_templates.
     * @example
     * // Create one Em_wa_templates
     * const Em_wa_templates = await prisma.em_wa_templates.create({
     *   data: {
     *     // ... data to create a Em_wa_templates
     *   }
     * })
     * 
     */
    create<T extends em_wa_templatesCreateArgs>(args: SelectSubset<T, em_wa_templatesCreateArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_wa_templates.
     * @param {em_wa_templatesCreateManyArgs} args - Arguments to create many Em_wa_templates.
     * @example
     * // Create many Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_wa_templatesCreateManyArgs>(args?: SelectSubset<T, em_wa_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_wa_templates.
     * @param {em_wa_templatesDeleteArgs} args - Arguments to delete one Em_wa_templates.
     * @example
     * // Delete one Em_wa_templates
     * const Em_wa_templates = await prisma.em_wa_templates.delete({
     *   where: {
     *     // ... filter to delete one Em_wa_templates
     *   }
     * })
     * 
     */
    delete<T extends em_wa_templatesDeleteArgs>(args: SelectSubset<T, em_wa_templatesDeleteArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_wa_templates.
     * @param {em_wa_templatesUpdateArgs} args - Arguments to update one Em_wa_templates.
     * @example
     * // Update one Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_wa_templatesUpdateArgs>(args: SelectSubset<T, em_wa_templatesUpdateArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_wa_templates.
     * @param {em_wa_templatesDeleteManyArgs} args - Arguments to filter Em_wa_templates to delete.
     * @example
     * // Delete a few Em_wa_templates
     * const { count } = await prisma.em_wa_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_wa_templatesDeleteManyArgs>(args?: SelectSubset<T, em_wa_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_wa_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_wa_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_wa_templatesUpdateManyArgs>(args: SelectSubset<T, em_wa_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_wa_templates.
     * @param {em_wa_templatesUpsertArgs} args - Arguments to update or create a Em_wa_templates.
     * @example
     * // Update or create a Em_wa_templates
     * const em_wa_templates = await prisma.em_wa_templates.upsert({
     *   create: {
     *     // ... data to create a Em_wa_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_wa_templates we want to update
     *   }
     * })
     */
    upsert<T extends em_wa_templatesUpsertArgs>(args: SelectSubset<T, em_wa_templatesUpsertArgs<ExtArgs>>): Prisma__em_wa_templatesClient<$Result.GetResult<Prisma.$em_wa_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_wa_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_wa_templatesCountArgs} args - Arguments to filter Em_wa_templates to count.
     * @example
     * // Count the number of Em_wa_templates
     * const count = await prisma.em_wa_templates.count({
     *   where: {
     *     // ... the filter for the Em_wa_templates we want to count
     *   }
     * })
    **/
    count<T extends em_wa_templatesCountArgs>(
      args?: Subset<T, em_wa_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_wa_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_wa_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_wa_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_wa_templatesAggregateArgs>(args: Subset<T, Em_wa_templatesAggregateArgs>): Prisma.PrismaPromise<GetEm_wa_templatesAggregateType<T>>

    /**
     * Group by Em_wa_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_wa_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_wa_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_wa_templatesGroupByArgs['orderBy'] }
        : { orderBy?: em_wa_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_wa_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_wa_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_wa_templates model
   */
  readonly fields: em_wa_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_wa_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_wa_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_wa_templates model
   */
  interface em_wa_templatesFieldRefs {
    readonly id: FieldRef<"em_wa_templates", 'Int'>
    readonly template_name: FieldRef<"em_wa_templates", 'String'>
    readonly template_text: FieldRef<"em_wa_templates", 'String'>
    readonly add_by: FieldRef<"em_wa_templates", 'String'>
    readonly created_at: FieldRef<"em_wa_templates", 'DateTime'>
    readonly lastupdate: FieldRef<"em_wa_templates", 'DateTime'>
    readonly status: FieldRef<"em_wa_templates", 'String'>
    readonly tpfor: FieldRef<"em_wa_templates", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * em_wa_templates findUnique
   */
  export type em_wa_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * Filter, which em_wa_templates to fetch.
     */
    where: em_wa_templatesWhereUniqueInput
  }

  /**
   * em_wa_templates findUniqueOrThrow
   */
  export type em_wa_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * Filter, which em_wa_templates to fetch.
     */
    where: em_wa_templatesWhereUniqueInput
  }

  /**
   * em_wa_templates findFirst
   */
  export type em_wa_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * Filter, which em_wa_templates to fetch.
     */
    where?: em_wa_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_wa_templates to fetch.
     */
    orderBy?: em_wa_templatesOrderByWithRelationInput | em_wa_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_wa_templates.
     */
    cursor?: em_wa_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_wa_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_wa_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_wa_templates.
     */
    distinct?: Em_wa_templatesScalarFieldEnum | Em_wa_templatesScalarFieldEnum[]
  }

  /**
   * em_wa_templates findFirstOrThrow
   */
  export type em_wa_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * Filter, which em_wa_templates to fetch.
     */
    where?: em_wa_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_wa_templates to fetch.
     */
    orderBy?: em_wa_templatesOrderByWithRelationInput | em_wa_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_wa_templates.
     */
    cursor?: em_wa_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_wa_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_wa_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_wa_templates.
     */
    distinct?: Em_wa_templatesScalarFieldEnum | Em_wa_templatesScalarFieldEnum[]
  }

  /**
   * em_wa_templates findMany
   */
  export type em_wa_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * Filter, which em_wa_templates to fetch.
     */
    where?: em_wa_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_wa_templates to fetch.
     */
    orderBy?: em_wa_templatesOrderByWithRelationInput | em_wa_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_wa_templates.
     */
    cursor?: em_wa_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_wa_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_wa_templates.
     */
    skip?: number
    distinct?: Em_wa_templatesScalarFieldEnum | Em_wa_templatesScalarFieldEnum[]
  }

  /**
   * em_wa_templates create
   */
  export type em_wa_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * The data needed to create a em_wa_templates.
     */
    data: XOR<em_wa_templatesCreateInput, em_wa_templatesUncheckedCreateInput>
  }

  /**
   * em_wa_templates createMany
   */
  export type em_wa_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_wa_templates.
     */
    data: em_wa_templatesCreateManyInput | em_wa_templatesCreateManyInput[]
  }

  /**
   * em_wa_templates update
   */
  export type em_wa_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * The data needed to update a em_wa_templates.
     */
    data: XOR<em_wa_templatesUpdateInput, em_wa_templatesUncheckedUpdateInput>
    /**
     * Choose, which em_wa_templates to update.
     */
    where: em_wa_templatesWhereUniqueInput
  }

  /**
   * em_wa_templates updateMany
   */
  export type em_wa_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_wa_templates.
     */
    data: XOR<em_wa_templatesUpdateManyMutationInput, em_wa_templatesUncheckedUpdateManyInput>
    /**
     * Filter which em_wa_templates to update
     */
    where?: em_wa_templatesWhereInput
    /**
     * Limit how many em_wa_templates to update.
     */
    limit?: number
  }

  /**
   * em_wa_templates upsert
   */
  export type em_wa_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * The filter to search for the em_wa_templates to update in case it exists.
     */
    where: em_wa_templatesWhereUniqueInput
    /**
     * In case the em_wa_templates found by the `where` argument doesn't exist, create a new em_wa_templates with this data.
     */
    create: XOR<em_wa_templatesCreateInput, em_wa_templatesUncheckedCreateInput>
    /**
     * In case the em_wa_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_wa_templatesUpdateInput, em_wa_templatesUncheckedUpdateInput>
  }

  /**
   * em_wa_templates delete
   */
  export type em_wa_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
    /**
     * Filter which em_wa_templates to delete.
     */
    where: em_wa_templatesWhereUniqueInput
  }

  /**
   * em_wa_templates deleteMany
   */
  export type em_wa_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_wa_templates to delete
     */
    where?: em_wa_templatesWhereInput
    /**
     * Limit how many em_wa_templates to delete.
     */
    limit?: number
  }

  /**
   * em_wa_templates without action
   */
  export type em_wa_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_wa_templates
     */
    select?: em_wa_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_wa_templates
     */
    omit?: em_wa_templatesOmit<ExtArgs> | null
  }


  /**
   * Model em_worktype
   */

  export type AggregateEm_worktype = {
    _count: Em_worktypeCountAggregateOutputType | null
    _avg: Em_worktypeAvgAggregateOutputType | null
    _sum: Em_worktypeSumAggregateOutputType | null
    _min: Em_worktypeMinAggregateOutputType | null
    _max: Em_worktypeMaxAggregateOutputType | null
  }

  export type Em_worktypeAvgAggregateOutputType = {
    id: number | null
  }

  export type Em_worktypeSumAggregateOutputType = {
    id: number | null
  }

  export type Em_worktypeMinAggregateOutputType = {
    id: number | null
    worktype_text: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_worktypeMaxAggregateOutputType = {
    id: number | null
    worktype_text: string | null
    status: string | null
    lastupdate: Date | null
  }

  export type Em_worktypeCountAggregateOutputType = {
    id: number
    worktype_text: number
    status: number
    lastupdate: number
    _all: number
  }


  export type Em_worktypeAvgAggregateInputType = {
    id?: true
  }

  export type Em_worktypeSumAggregateInputType = {
    id?: true
  }

  export type Em_worktypeMinAggregateInputType = {
    id?: true
    worktype_text?: true
    status?: true
    lastupdate?: true
  }

  export type Em_worktypeMaxAggregateInputType = {
    id?: true
    worktype_text?: true
    status?: true
    lastupdate?: true
  }

  export type Em_worktypeCountAggregateInputType = {
    id?: true
    worktype_text?: true
    status?: true
    lastupdate?: true
    _all?: true
  }

  export type Em_worktypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_worktype to aggregate.
     */
    where?: em_worktypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_worktypes to fetch.
     */
    orderBy?: em_worktypeOrderByWithRelationInput | em_worktypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_worktypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_worktypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_worktypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_worktypes
    **/
    _count?: true | Em_worktypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_worktypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_worktypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_worktypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_worktypeMaxAggregateInputType
  }

  export type GetEm_worktypeAggregateType<T extends Em_worktypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_worktype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_worktype[P]>
      : GetScalarType<T[P], AggregateEm_worktype[P]>
  }




  export type em_worktypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_worktypeWhereInput
    orderBy?: em_worktypeOrderByWithAggregationInput | em_worktypeOrderByWithAggregationInput[]
    by: Em_worktypeScalarFieldEnum[] | Em_worktypeScalarFieldEnum
    having?: em_worktypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_worktypeCountAggregateInputType | true
    _avg?: Em_worktypeAvgAggregateInputType
    _sum?: Em_worktypeSumAggregateInputType
    _min?: Em_worktypeMinAggregateInputType
    _max?: Em_worktypeMaxAggregateInputType
  }

  export type Em_worktypeGroupByOutputType = {
    id: number
    worktype_text: string
    status: string | null
    lastupdate: Date | null
    _count: Em_worktypeCountAggregateOutputType | null
    _avg: Em_worktypeAvgAggregateOutputType | null
    _sum: Em_worktypeSumAggregateOutputType | null
    _min: Em_worktypeMinAggregateOutputType | null
    _max: Em_worktypeMaxAggregateOutputType | null
  }

  type GetEm_worktypeGroupByPayload<T extends em_worktypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_worktypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_worktypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_worktypeGroupByOutputType[P]>
            : GetScalarType<T[P], Em_worktypeGroupByOutputType[P]>
        }
      >
    >


  export type em_worktypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    worktype_text?: boolean
    status?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["em_worktype"]>



  export type em_worktypeSelectScalar = {
    id?: boolean
    worktype_text?: boolean
    status?: boolean
    lastupdate?: boolean
  }

  export type em_worktypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "worktype_text" | "status" | "lastupdate", ExtArgs["result"]["em_worktype"]>

  export type $em_worktypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_worktype"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      worktype_text: string
      status: string | null
      lastupdate: Date | null
    }, ExtArgs["result"]["em_worktype"]>
    composites: {}
  }

  type em_worktypeGetPayload<S extends boolean | null | undefined | em_worktypeDefaultArgs> = $Result.GetResult<Prisma.$em_worktypePayload, S>

  type em_worktypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_worktypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_worktypeCountAggregateInputType | true
    }

  export interface em_worktypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_worktype'], meta: { name: 'em_worktype' } }
    /**
     * Find zero or one Em_worktype that matches the filter.
     * @param {em_worktypeFindUniqueArgs} args - Arguments to find a Em_worktype
     * @example
     * // Get one Em_worktype
     * const em_worktype = await prisma.em_worktype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_worktypeFindUniqueArgs>(args: SelectSubset<T, em_worktypeFindUniqueArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_worktype that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_worktypeFindUniqueOrThrowArgs} args - Arguments to find a Em_worktype
     * @example
     * // Get one Em_worktype
     * const em_worktype = await prisma.em_worktype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_worktypeFindUniqueOrThrowArgs>(args: SelectSubset<T, em_worktypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_worktype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_worktypeFindFirstArgs} args - Arguments to find a Em_worktype
     * @example
     * // Get one Em_worktype
     * const em_worktype = await prisma.em_worktype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_worktypeFindFirstArgs>(args?: SelectSubset<T, em_worktypeFindFirstArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_worktype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_worktypeFindFirstOrThrowArgs} args - Arguments to find a Em_worktype
     * @example
     * // Get one Em_worktype
     * const em_worktype = await prisma.em_worktype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_worktypeFindFirstOrThrowArgs>(args?: SelectSubset<T, em_worktypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_worktypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_worktypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_worktypes
     * const em_worktypes = await prisma.em_worktype.findMany()
     * 
     * // Get first 10 Em_worktypes
     * const em_worktypes = await prisma.em_worktype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const em_worktypeWithIdOnly = await prisma.em_worktype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends em_worktypeFindManyArgs>(args?: SelectSubset<T, em_worktypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_worktype.
     * @param {em_worktypeCreateArgs} args - Arguments to create a Em_worktype.
     * @example
     * // Create one Em_worktype
     * const Em_worktype = await prisma.em_worktype.create({
     *   data: {
     *     // ... data to create a Em_worktype
     *   }
     * })
     * 
     */
    create<T extends em_worktypeCreateArgs>(args: SelectSubset<T, em_worktypeCreateArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_worktypes.
     * @param {em_worktypeCreateManyArgs} args - Arguments to create many Em_worktypes.
     * @example
     * // Create many Em_worktypes
     * const em_worktype = await prisma.em_worktype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_worktypeCreateManyArgs>(args?: SelectSubset<T, em_worktypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_worktype.
     * @param {em_worktypeDeleteArgs} args - Arguments to delete one Em_worktype.
     * @example
     * // Delete one Em_worktype
     * const Em_worktype = await prisma.em_worktype.delete({
     *   where: {
     *     // ... filter to delete one Em_worktype
     *   }
     * })
     * 
     */
    delete<T extends em_worktypeDeleteArgs>(args: SelectSubset<T, em_worktypeDeleteArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_worktype.
     * @param {em_worktypeUpdateArgs} args - Arguments to update one Em_worktype.
     * @example
     * // Update one Em_worktype
     * const em_worktype = await prisma.em_worktype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_worktypeUpdateArgs>(args: SelectSubset<T, em_worktypeUpdateArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_worktypes.
     * @param {em_worktypeDeleteManyArgs} args - Arguments to filter Em_worktypes to delete.
     * @example
     * // Delete a few Em_worktypes
     * const { count } = await prisma.em_worktype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_worktypeDeleteManyArgs>(args?: SelectSubset<T, em_worktypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_worktypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_worktypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_worktypes
     * const em_worktype = await prisma.em_worktype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_worktypeUpdateManyArgs>(args: SelectSubset<T, em_worktypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_worktype.
     * @param {em_worktypeUpsertArgs} args - Arguments to update or create a Em_worktype.
     * @example
     * // Update or create a Em_worktype
     * const em_worktype = await prisma.em_worktype.upsert({
     *   create: {
     *     // ... data to create a Em_worktype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_worktype we want to update
     *   }
     * })
     */
    upsert<T extends em_worktypeUpsertArgs>(args: SelectSubset<T, em_worktypeUpsertArgs<ExtArgs>>): Prisma__em_worktypeClient<$Result.GetResult<Prisma.$em_worktypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_worktypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_worktypeCountArgs} args - Arguments to filter Em_worktypes to count.
     * @example
     * // Count the number of Em_worktypes
     * const count = await prisma.em_worktype.count({
     *   where: {
     *     // ... the filter for the Em_worktypes we want to count
     *   }
     * })
    **/
    count<T extends em_worktypeCountArgs>(
      args?: Subset<T, em_worktypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_worktypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_worktype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_worktypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_worktypeAggregateArgs>(args: Subset<T, Em_worktypeAggregateArgs>): Prisma.PrismaPromise<GetEm_worktypeAggregateType<T>>

    /**
     * Group by Em_worktype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_worktypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_worktypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_worktypeGroupByArgs['orderBy'] }
        : { orderBy?: em_worktypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_worktypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_worktypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_worktype model
   */
  readonly fields: em_worktypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_worktype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_worktypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_worktype model
   */
  interface em_worktypeFieldRefs {
    readonly id: FieldRef<"em_worktype", 'Int'>
    readonly worktype_text: FieldRef<"em_worktype", 'String'>
    readonly status: FieldRef<"em_worktype", 'String'>
    readonly lastupdate: FieldRef<"em_worktype", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * em_worktype findUnique
   */
  export type em_worktypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * Filter, which em_worktype to fetch.
     */
    where: em_worktypeWhereUniqueInput
  }

  /**
   * em_worktype findUniqueOrThrow
   */
  export type em_worktypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * Filter, which em_worktype to fetch.
     */
    where: em_worktypeWhereUniqueInput
  }

  /**
   * em_worktype findFirst
   */
  export type em_worktypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * Filter, which em_worktype to fetch.
     */
    where?: em_worktypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_worktypes to fetch.
     */
    orderBy?: em_worktypeOrderByWithRelationInput | em_worktypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_worktypes.
     */
    cursor?: em_worktypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_worktypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_worktypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_worktypes.
     */
    distinct?: Em_worktypeScalarFieldEnum | Em_worktypeScalarFieldEnum[]
  }

  /**
   * em_worktype findFirstOrThrow
   */
  export type em_worktypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * Filter, which em_worktype to fetch.
     */
    where?: em_worktypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_worktypes to fetch.
     */
    orderBy?: em_worktypeOrderByWithRelationInput | em_worktypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_worktypes.
     */
    cursor?: em_worktypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_worktypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_worktypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_worktypes.
     */
    distinct?: Em_worktypeScalarFieldEnum | Em_worktypeScalarFieldEnum[]
  }

  /**
   * em_worktype findMany
   */
  export type em_worktypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * Filter, which em_worktypes to fetch.
     */
    where?: em_worktypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_worktypes to fetch.
     */
    orderBy?: em_worktypeOrderByWithRelationInput | em_worktypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_worktypes.
     */
    cursor?: em_worktypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_worktypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_worktypes.
     */
    skip?: number
    distinct?: Em_worktypeScalarFieldEnum | Em_worktypeScalarFieldEnum[]
  }

  /**
   * em_worktype create
   */
  export type em_worktypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * The data needed to create a em_worktype.
     */
    data: XOR<em_worktypeCreateInput, em_worktypeUncheckedCreateInput>
  }

  /**
   * em_worktype createMany
   */
  export type em_worktypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_worktypes.
     */
    data: em_worktypeCreateManyInput | em_worktypeCreateManyInput[]
  }

  /**
   * em_worktype update
   */
  export type em_worktypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * The data needed to update a em_worktype.
     */
    data: XOR<em_worktypeUpdateInput, em_worktypeUncheckedUpdateInput>
    /**
     * Choose, which em_worktype to update.
     */
    where: em_worktypeWhereUniqueInput
  }

  /**
   * em_worktype updateMany
   */
  export type em_worktypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_worktypes.
     */
    data: XOR<em_worktypeUpdateManyMutationInput, em_worktypeUncheckedUpdateManyInput>
    /**
     * Filter which em_worktypes to update
     */
    where?: em_worktypeWhereInput
    /**
     * Limit how many em_worktypes to update.
     */
    limit?: number
  }

  /**
   * em_worktype upsert
   */
  export type em_worktypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * The filter to search for the em_worktype to update in case it exists.
     */
    where: em_worktypeWhereUniqueInput
    /**
     * In case the em_worktype found by the `where` argument doesn't exist, create a new em_worktype with this data.
     */
    create: XOR<em_worktypeCreateInput, em_worktypeUncheckedCreateInput>
    /**
     * In case the em_worktype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_worktypeUpdateInput, em_worktypeUncheckedUpdateInput>
  }

  /**
   * em_worktype delete
   */
  export type em_worktypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
    /**
     * Filter which em_worktype to delete.
     */
    where: em_worktypeWhereUniqueInput
  }

  /**
   * em_worktype deleteMany
   */
  export type em_worktypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_worktypes to delete
     */
    where?: em_worktypeWhereInput
    /**
     * Limit how many em_worktypes to delete.
     */
    limit?: number
  }

  /**
   * em_worktype without action
   */
  export type em_worktypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_worktype
     */
    select?: em_worktypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_worktype
     */
    omit?: em_worktypeOmit<ExtArgs> | null
  }


  /**
   * Model em_xquetest
   */

  export type AggregateEm_xquetest = {
    _count: Em_xquetestCountAggregateOutputType | null
    _avg: Em_xquetestAvgAggregateOutputType | null
    _sum: Em_xquetestSumAggregateOutputType | null
    _min: Em_xquetestMinAggregateOutputType | null
    _max: Em_xquetestMaxAggregateOutputType | null
  }

  export type Em_xquetestAvgAggregateOutputType = {
    ID: number | null
    q_id: number | null
  }

  export type Em_xquetestSumAggregateOutputType = {
    ID: number | null
    q_id: number | null
  }

  export type Em_xquetestMinAggregateOutputType = {
    ID: number | null
    q_id: number | null
    question_text: string | null
  }

  export type Em_xquetestMaxAggregateOutputType = {
    ID: number | null
    q_id: number | null
    question_text: string | null
  }

  export type Em_xquetestCountAggregateOutputType = {
    ID: number
    q_id: number
    question_text: number
    _all: number
  }


  export type Em_xquetestAvgAggregateInputType = {
    ID?: true
    q_id?: true
  }

  export type Em_xquetestSumAggregateInputType = {
    ID?: true
    q_id?: true
  }

  export type Em_xquetestMinAggregateInputType = {
    ID?: true
    q_id?: true
    question_text?: true
  }

  export type Em_xquetestMaxAggregateInputType = {
    ID?: true
    q_id?: true
    question_text?: true
  }

  export type Em_xquetestCountAggregateInputType = {
    ID?: true
    q_id?: true
    question_text?: true
    _all?: true
  }

  export type Em_xquetestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_xquetest to aggregate.
     */
    where?: em_xquetestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_xquetests to fetch.
     */
    orderBy?: em_xquetestOrderByWithRelationInput | em_xquetestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: em_xquetestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_xquetests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_xquetests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned em_xquetests
    **/
    _count?: true | Em_xquetestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Em_xquetestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Em_xquetestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Em_xquetestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Em_xquetestMaxAggregateInputType
  }

  export type GetEm_xquetestAggregateType<T extends Em_xquetestAggregateArgs> = {
        [P in keyof T & keyof AggregateEm_xquetest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEm_xquetest[P]>
      : GetScalarType<T[P], AggregateEm_xquetest[P]>
  }




  export type em_xquetestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: em_xquetestWhereInput
    orderBy?: em_xquetestOrderByWithAggregationInput | em_xquetestOrderByWithAggregationInput[]
    by: Em_xquetestScalarFieldEnum[] | Em_xquetestScalarFieldEnum
    having?: em_xquetestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Em_xquetestCountAggregateInputType | true
    _avg?: Em_xquetestAvgAggregateInputType
    _sum?: Em_xquetestSumAggregateInputType
    _min?: Em_xquetestMinAggregateInputType
    _max?: Em_xquetestMaxAggregateInputType
  }

  export type Em_xquetestGroupByOutputType = {
    ID: number
    q_id: number
    question_text: string
    _count: Em_xquetestCountAggregateOutputType | null
    _avg: Em_xquetestAvgAggregateOutputType | null
    _sum: Em_xquetestSumAggregateOutputType | null
    _min: Em_xquetestMinAggregateOutputType | null
    _max: Em_xquetestMaxAggregateOutputType | null
  }

  type GetEm_xquetestGroupByPayload<T extends em_xquetestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Em_xquetestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Em_xquetestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Em_xquetestGroupByOutputType[P]>
            : GetScalarType<T[P], Em_xquetestGroupByOutputType[P]>
        }
      >
    >


  export type em_xquetestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    q_id?: boolean
    question_text?: boolean
  }, ExtArgs["result"]["em_xquetest"]>



  export type em_xquetestSelectScalar = {
    ID?: boolean
    q_id?: boolean
    question_text?: boolean
  }

  export type em_xquetestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "q_id" | "question_text", ExtArgs["result"]["em_xquetest"]>

  export type $em_xquetestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "em_xquetest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      q_id: number
      question_text: string
    }, ExtArgs["result"]["em_xquetest"]>
    composites: {}
  }

  type em_xquetestGetPayload<S extends boolean | null | undefined | em_xquetestDefaultArgs> = $Result.GetResult<Prisma.$em_xquetestPayload, S>

  type em_xquetestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<em_xquetestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Em_xquetestCountAggregateInputType | true
    }

  export interface em_xquetestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['em_xquetest'], meta: { name: 'em_xquetest' } }
    /**
     * Find zero or one Em_xquetest that matches the filter.
     * @param {em_xquetestFindUniqueArgs} args - Arguments to find a Em_xquetest
     * @example
     * // Get one Em_xquetest
     * const em_xquetest = await prisma.em_xquetest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends em_xquetestFindUniqueArgs>(args: SelectSubset<T, em_xquetestFindUniqueArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Em_xquetest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {em_xquetestFindUniqueOrThrowArgs} args - Arguments to find a Em_xquetest
     * @example
     * // Get one Em_xquetest
     * const em_xquetest = await prisma.em_xquetest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends em_xquetestFindUniqueOrThrowArgs>(args: SelectSubset<T, em_xquetestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_xquetest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_xquetestFindFirstArgs} args - Arguments to find a Em_xquetest
     * @example
     * // Get one Em_xquetest
     * const em_xquetest = await prisma.em_xquetest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends em_xquetestFindFirstArgs>(args?: SelectSubset<T, em_xquetestFindFirstArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Em_xquetest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_xquetestFindFirstOrThrowArgs} args - Arguments to find a Em_xquetest
     * @example
     * // Get one Em_xquetest
     * const em_xquetest = await prisma.em_xquetest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends em_xquetestFindFirstOrThrowArgs>(args?: SelectSubset<T, em_xquetestFindFirstOrThrowArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Em_xquetests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_xquetestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Em_xquetests
     * const em_xquetests = await prisma.em_xquetest.findMany()
     * 
     * // Get first 10 Em_xquetests
     * const em_xquetests = await prisma.em_xquetest.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const em_xquetestWithIDOnly = await prisma.em_xquetest.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends em_xquetestFindManyArgs>(args?: SelectSubset<T, em_xquetestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Em_xquetest.
     * @param {em_xquetestCreateArgs} args - Arguments to create a Em_xquetest.
     * @example
     * // Create one Em_xquetest
     * const Em_xquetest = await prisma.em_xquetest.create({
     *   data: {
     *     // ... data to create a Em_xquetest
     *   }
     * })
     * 
     */
    create<T extends em_xquetestCreateArgs>(args: SelectSubset<T, em_xquetestCreateArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Em_xquetests.
     * @param {em_xquetestCreateManyArgs} args - Arguments to create many Em_xquetests.
     * @example
     * // Create many Em_xquetests
     * const em_xquetest = await prisma.em_xquetest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends em_xquetestCreateManyArgs>(args?: SelectSubset<T, em_xquetestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Em_xquetest.
     * @param {em_xquetestDeleteArgs} args - Arguments to delete one Em_xquetest.
     * @example
     * // Delete one Em_xquetest
     * const Em_xquetest = await prisma.em_xquetest.delete({
     *   where: {
     *     // ... filter to delete one Em_xquetest
     *   }
     * })
     * 
     */
    delete<T extends em_xquetestDeleteArgs>(args: SelectSubset<T, em_xquetestDeleteArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Em_xquetest.
     * @param {em_xquetestUpdateArgs} args - Arguments to update one Em_xquetest.
     * @example
     * // Update one Em_xquetest
     * const em_xquetest = await prisma.em_xquetest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends em_xquetestUpdateArgs>(args: SelectSubset<T, em_xquetestUpdateArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Em_xquetests.
     * @param {em_xquetestDeleteManyArgs} args - Arguments to filter Em_xquetests to delete.
     * @example
     * // Delete a few Em_xquetests
     * const { count } = await prisma.em_xquetest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends em_xquetestDeleteManyArgs>(args?: SelectSubset<T, em_xquetestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Em_xquetests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_xquetestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Em_xquetests
     * const em_xquetest = await prisma.em_xquetest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends em_xquetestUpdateManyArgs>(args: SelectSubset<T, em_xquetestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Em_xquetest.
     * @param {em_xquetestUpsertArgs} args - Arguments to update or create a Em_xquetest.
     * @example
     * // Update or create a Em_xquetest
     * const em_xquetest = await prisma.em_xquetest.upsert({
     *   create: {
     *     // ... data to create a Em_xquetest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Em_xquetest we want to update
     *   }
     * })
     */
    upsert<T extends em_xquetestUpsertArgs>(args: SelectSubset<T, em_xquetestUpsertArgs<ExtArgs>>): Prisma__em_xquetestClient<$Result.GetResult<Prisma.$em_xquetestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Em_xquetests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_xquetestCountArgs} args - Arguments to filter Em_xquetests to count.
     * @example
     * // Count the number of Em_xquetests
     * const count = await prisma.em_xquetest.count({
     *   where: {
     *     // ... the filter for the Em_xquetests we want to count
     *   }
     * })
    **/
    count<T extends em_xquetestCountArgs>(
      args?: Subset<T, em_xquetestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Em_xquetestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Em_xquetest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Em_xquetestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Em_xquetestAggregateArgs>(args: Subset<T, Em_xquetestAggregateArgs>): Prisma.PrismaPromise<GetEm_xquetestAggregateType<T>>

    /**
     * Group by Em_xquetest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {em_xquetestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends em_xquetestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: em_xquetestGroupByArgs['orderBy'] }
        : { orderBy?: em_xquetestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, em_xquetestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEm_xquetestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the em_xquetest model
   */
  readonly fields: em_xquetestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for em_xquetest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__em_xquetestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the em_xquetest model
   */
  interface em_xquetestFieldRefs {
    readonly ID: FieldRef<"em_xquetest", 'Int'>
    readonly q_id: FieldRef<"em_xquetest", 'Int'>
    readonly question_text: FieldRef<"em_xquetest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * em_xquetest findUnique
   */
  export type em_xquetestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * Filter, which em_xquetest to fetch.
     */
    where: em_xquetestWhereUniqueInput
  }

  /**
   * em_xquetest findUniqueOrThrow
   */
  export type em_xquetestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * Filter, which em_xquetest to fetch.
     */
    where: em_xquetestWhereUniqueInput
  }

  /**
   * em_xquetest findFirst
   */
  export type em_xquetestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * Filter, which em_xquetest to fetch.
     */
    where?: em_xquetestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_xquetests to fetch.
     */
    orderBy?: em_xquetestOrderByWithRelationInput | em_xquetestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_xquetests.
     */
    cursor?: em_xquetestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_xquetests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_xquetests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_xquetests.
     */
    distinct?: Em_xquetestScalarFieldEnum | Em_xquetestScalarFieldEnum[]
  }

  /**
   * em_xquetest findFirstOrThrow
   */
  export type em_xquetestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * Filter, which em_xquetest to fetch.
     */
    where?: em_xquetestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_xquetests to fetch.
     */
    orderBy?: em_xquetestOrderByWithRelationInput | em_xquetestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for em_xquetests.
     */
    cursor?: em_xquetestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_xquetests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_xquetests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of em_xquetests.
     */
    distinct?: Em_xquetestScalarFieldEnum | Em_xquetestScalarFieldEnum[]
  }

  /**
   * em_xquetest findMany
   */
  export type em_xquetestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * Filter, which em_xquetests to fetch.
     */
    where?: em_xquetestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of em_xquetests to fetch.
     */
    orderBy?: em_xquetestOrderByWithRelationInput | em_xquetestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing em_xquetests.
     */
    cursor?: em_xquetestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` em_xquetests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` em_xquetests.
     */
    skip?: number
    distinct?: Em_xquetestScalarFieldEnum | Em_xquetestScalarFieldEnum[]
  }

  /**
   * em_xquetest create
   */
  export type em_xquetestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * The data needed to create a em_xquetest.
     */
    data: XOR<em_xquetestCreateInput, em_xquetestUncheckedCreateInput>
  }

  /**
   * em_xquetest createMany
   */
  export type em_xquetestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many em_xquetests.
     */
    data: em_xquetestCreateManyInput | em_xquetestCreateManyInput[]
  }

  /**
   * em_xquetest update
   */
  export type em_xquetestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * The data needed to update a em_xquetest.
     */
    data: XOR<em_xquetestUpdateInput, em_xquetestUncheckedUpdateInput>
    /**
     * Choose, which em_xquetest to update.
     */
    where: em_xquetestWhereUniqueInput
  }

  /**
   * em_xquetest updateMany
   */
  export type em_xquetestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update em_xquetests.
     */
    data: XOR<em_xquetestUpdateManyMutationInput, em_xquetestUncheckedUpdateManyInput>
    /**
     * Filter which em_xquetests to update
     */
    where?: em_xquetestWhereInput
    /**
     * Limit how many em_xquetests to update.
     */
    limit?: number
  }

  /**
   * em_xquetest upsert
   */
  export type em_xquetestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * The filter to search for the em_xquetest to update in case it exists.
     */
    where: em_xquetestWhereUniqueInput
    /**
     * In case the em_xquetest found by the `where` argument doesn't exist, create a new em_xquetest with this data.
     */
    create: XOR<em_xquetestCreateInput, em_xquetestUncheckedCreateInput>
    /**
     * In case the em_xquetest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<em_xquetestUpdateInput, em_xquetestUncheckedUpdateInput>
  }

  /**
   * em_xquetest delete
   */
  export type em_xquetestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
    /**
     * Filter which em_xquetest to delete.
     */
    where: em_xquetestWhereUniqueInput
  }

  /**
   * em_xquetest deleteMany
   */
  export type em_xquetestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which em_xquetests to delete
     */
    where?: em_xquetestWhereInput
    /**
     * Limit how many em_xquetests to delete.
     */
    limit?: number
  }

  /**
   * em_xquetest without action
   */
  export type em_xquetestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_xquetest
     */
    select?: em_xquetestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_xquetest
     */
    omit?: em_xquetestOmit<ExtArgs> | null
  }


  /**
   * Model emapp
   */

  export type AggregateEmapp = {
    _count: EmappCountAggregateOutputType | null
    _avg: EmappAvgAggregateOutputType | null
    _sum: EmappSumAggregateOutputType | null
    _min: EmappMinAggregateOutputType | null
    _max: EmappMaxAggregateOutputType | null
  }

  export type EmappAvgAggregateOutputType = {
    AppId: number | null
    AppPoss: number | null
    AppAge: number | null
    AppJk: number | null
    IsCall: number | null
    LokasiId: number | null
  }

  export type EmappSumAggregateOutputType = {
    AppId: number | null
    AppPoss: number | null
    AppAge: number | null
    AppJk: number | null
    IsCall: number | null
    LokasiId: number | null
  }

  export type EmappMinAggregateOutputType = {
    AppId: number | null
    AppName: string | null
    AppPoss: number | null
    AppWa: string | null
    AppMail: string | null
    AppAge: number | null
    AppJk: number | null
    AppAddres: string | null
    AppFakt: string | null
    AppFileName: string | null
    AppLastUpdate: Date | null
    AppDate: Date | null
    AppStatus: string | null
    IsCall: number | null
    DateCall: Date | null
    JobsIs: string | null
    JFStats: string | null
    LokasiId: number | null
  }

  export type EmappMaxAggregateOutputType = {
    AppId: number | null
    AppName: string | null
    AppPoss: number | null
    AppWa: string | null
    AppMail: string | null
    AppAge: number | null
    AppJk: number | null
    AppAddres: string | null
    AppFakt: string | null
    AppFileName: string | null
    AppLastUpdate: Date | null
    AppDate: Date | null
    AppStatus: string | null
    IsCall: number | null
    DateCall: Date | null
    JobsIs: string | null
    JFStats: string | null
    LokasiId: number | null
  }

  export type EmappCountAggregateOutputType = {
    AppId: number
    AppName: number
    AppPoss: number
    AppWa: number
    AppMail: number
    AppAge: number
    AppJk: number
    AppAddres: number
    AppFakt: number
    AppFileName: number
    AppLastUpdate: number
    AppDate: number
    AppStatus: number
    IsCall: number
    DateCall: number
    JobsIs: number
    JFStats: number
    LokasiId: number
    _all: number
  }


  export type EmappAvgAggregateInputType = {
    AppId?: true
    AppPoss?: true
    AppAge?: true
    AppJk?: true
    IsCall?: true
    LokasiId?: true
  }

  export type EmappSumAggregateInputType = {
    AppId?: true
    AppPoss?: true
    AppAge?: true
    AppJk?: true
    IsCall?: true
    LokasiId?: true
  }

  export type EmappMinAggregateInputType = {
    AppId?: true
    AppName?: true
    AppPoss?: true
    AppWa?: true
    AppMail?: true
    AppAge?: true
    AppJk?: true
    AppAddres?: true
    AppFakt?: true
    AppFileName?: true
    AppLastUpdate?: true
    AppDate?: true
    AppStatus?: true
    IsCall?: true
    DateCall?: true
    JobsIs?: true
    JFStats?: true
    LokasiId?: true
  }

  export type EmappMaxAggregateInputType = {
    AppId?: true
    AppName?: true
    AppPoss?: true
    AppWa?: true
    AppMail?: true
    AppAge?: true
    AppJk?: true
    AppAddres?: true
    AppFakt?: true
    AppFileName?: true
    AppLastUpdate?: true
    AppDate?: true
    AppStatus?: true
    IsCall?: true
    DateCall?: true
    JobsIs?: true
    JFStats?: true
    LokasiId?: true
  }

  export type EmappCountAggregateInputType = {
    AppId?: true
    AppName?: true
    AppPoss?: true
    AppWa?: true
    AppMail?: true
    AppAge?: true
    AppJk?: true
    AppAddres?: true
    AppFakt?: true
    AppFileName?: true
    AppLastUpdate?: true
    AppDate?: true
    AppStatus?: true
    IsCall?: true
    DateCall?: true
    JobsIs?: true
    JFStats?: true
    LokasiId?: true
    _all?: true
  }

  export type EmappAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emapp to aggregate.
     */
    where?: emappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emapps to fetch.
     */
    orderBy?: emappOrderByWithRelationInput | emappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: emappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned emapps
    **/
    _count?: true | EmappCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmappAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmappSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmappMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmappMaxAggregateInputType
  }

  export type GetEmappAggregateType<T extends EmappAggregateArgs> = {
        [P in keyof T & keyof AggregateEmapp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmapp[P]>
      : GetScalarType<T[P], AggregateEmapp[P]>
  }




  export type emappGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: emappWhereInput
    orderBy?: emappOrderByWithAggregationInput | emappOrderByWithAggregationInput[]
    by: EmappScalarFieldEnum[] | EmappScalarFieldEnum
    having?: emappScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmappCountAggregateInputType | true
    _avg?: EmappAvgAggregateInputType
    _sum?: EmappSumAggregateInputType
    _min?: EmappMinAggregateInputType
    _max?: EmappMaxAggregateInputType
  }

  export type EmappGroupByOutputType = {
    AppId: number
    AppName: string | null
    AppPoss: number | null
    AppWa: string | null
    AppMail: string | null
    AppAge: number | null
    AppJk: number | null
    AppAddres: string | null
    AppFakt: string | null
    AppFileName: string | null
    AppLastUpdate: Date | null
    AppDate: Date | null
    AppStatus: string | null
    IsCall: number | null
    DateCall: Date | null
    JobsIs: string | null
    JFStats: string | null
    LokasiId: number | null
    _count: EmappCountAggregateOutputType | null
    _avg: EmappAvgAggregateOutputType | null
    _sum: EmappSumAggregateOutputType | null
    _min: EmappMinAggregateOutputType | null
    _max: EmappMaxAggregateOutputType | null
  }

  type GetEmappGroupByPayload<T extends emappGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmappGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmappGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmappGroupByOutputType[P]>
            : GetScalarType<T[P], EmappGroupByOutputType[P]>
        }
      >
    >


  export type emappSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AppId?: boolean
    AppName?: boolean
    AppPoss?: boolean
    AppWa?: boolean
    AppMail?: boolean
    AppAge?: boolean
    AppJk?: boolean
    AppAddres?: boolean
    AppFakt?: boolean
    AppFileName?: boolean
    AppLastUpdate?: boolean
    AppDate?: boolean
    AppStatus?: boolean
    IsCall?: boolean
    DateCall?: boolean
    JobsIs?: boolean
    JFStats?: boolean
    LokasiId?: boolean
    scores?: boolean | emapp$scoresArgs<ExtArgs>
    _count?: boolean | EmappCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emapp"]>



  export type emappSelectScalar = {
    AppId?: boolean
    AppName?: boolean
    AppPoss?: boolean
    AppWa?: boolean
    AppMail?: boolean
    AppAge?: boolean
    AppJk?: boolean
    AppAddres?: boolean
    AppFakt?: boolean
    AppFileName?: boolean
    AppLastUpdate?: boolean
    AppDate?: boolean
    AppStatus?: boolean
    IsCall?: boolean
    DateCall?: boolean
    JobsIs?: boolean
    JFStats?: boolean
    LokasiId?: boolean
  }

  export type emappOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AppId" | "AppName" | "AppPoss" | "AppWa" | "AppMail" | "AppAge" | "AppJk" | "AppAddres" | "AppFakt" | "AppFileName" | "AppLastUpdate" | "AppDate" | "AppStatus" | "IsCall" | "DateCall" | "JobsIs" | "JFStats" | "LokasiId", ExtArgs["result"]["emapp"]>
  export type emappInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scores?: boolean | emapp$scoresArgs<ExtArgs>
    _count?: boolean | EmappCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $emappPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "emapp"
    objects: {
      scores: Prisma.$scoresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      AppId: number
      AppName: string | null
      AppPoss: number | null
      AppWa: string | null
      AppMail: string | null
      AppAge: number | null
      AppJk: number | null
      AppAddres: string | null
      AppFakt: string | null
      AppFileName: string | null
      AppLastUpdate: Date | null
      AppDate: Date | null
      AppStatus: string | null
      IsCall: number | null
      DateCall: Date | null
      JobsIs: string | null
      JFStats: string | null
      LokasiId: number | null
    }, ExtArgs["result"]["emapp"]>
    composites: {}
  }

  type emappGetPayload<S extends boolean | null | undefined | emappDefaultArgs> = $Result.GetResult<Prisma.$emappPayload, S>

  type emappCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<emappFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmappCountAggregateInputType | true
    }

  export interface emappDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['emapp'], meta: { name: 'emapp' } }
    /**
     * Find zero or one Emapp that matches the filter.
     * @param {emappFindUniqueArgs} args - Arguments to find a Emapp
     * @example
     * // Get one Emapp
     * const emapp = await prisma.emapp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends emappFindUniqueArgs>(args: SelectSubset<T, emappFindUniqueArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emapp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {emappFindUniqueOrThrowArgs} args - Arguments to find a Emapp
     * @example
     * // Get one Emapp
     * const emapp = await prisma.emapp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends emappFindUniqueOrThrowArgs>(args: SelectSubset<T, emappFindUniqueOrThrowArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emapp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emappFindFirstArgs} args - Arguments to find a Emapp
     * @example
     * // Get one Emapp
     * const emapp = await prisma.emapp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends emappFindFirstArgs>(args?: SelectSubset<T, emappFindFirstArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emapp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emappFindFirstOrThrowArgs} args - Arguments to find a Emapp
     * @example
     * // Get one Emapp
     * const emapp = await prisma.emapp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends emappFindFirstOrThrowArgs>(args?: SelectSubset<T, emappFindFirstOrThrowArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emapps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emappFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emapps
     * const emapps = await prisma.emapp.findMany()
     * 
     * // Get first 10 Emapps
     * const emapps = await prisma.emapp.findMany({ take: 10 })
     * 
     * // Only select the `AppId`
     * const emappWithAppIdOnly = await prisma.emapp.findMany({ select: { AppId: true } })
     * 
     */
    findMany<T extends emappFindManyArgs>(args?: SelectSubset<T, emappFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emapp.
     * @param {emappCreateArgs} args - Arguments to create a Emapp.
     * @example
     * // Create one Emapp
     * const Emapp = await prisma.emapp.create({
     *   data: {
     *     // ... data to create a Emapp
     *   }
     * })
     * 
     */
    create<T extends emappCreateArgs>(args: SelectSubset<T, emappCreateArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emapps.
     * @param {emappCreateManyArgs} args - Arguments to create many Emapps.
     * @example
     * // Create many Emapps
     * const emapp = await prisma.emapp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends emappCreateManyArgs>(args?: SelectSubset<T, emappCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emapp.
     * @param {emappDeleteArgs} args - Arguments to delete one Emapp.
     * @example
     * // Delete one Emapp
     * const Emapp = await prisma.emapp.delete({
     *   where: {
     *     // ... filter to delete one Emapp
     *   }
     * })
     * 
     */
    delete<T extends emappDeleteArgs>(args: SelectSubset<T, emappDeleteArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emapp.
     * @param {emappUpdateArgs} args - Arguments to update one Emapp.
     * @example
     * // Update one Emapp
     * const emapp = await prisma.emapp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends emappUpdateArgs>(args: SelectSubset<T, emappUpdateArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emapps.
     * @param {emappDeleteManyArgs} args - Arguments to filter Emapps to delete.
     * @example
     * // Delete a few Emapps
     * const { count } = await prisma.emapp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends emappDeleteManyArgs>(args?: SelectSubset<T, emappDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emapps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emappUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emapps
     * const emapp = await prisma.emapp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends emappUpdateManyArgs>(args: SelectSubset<T, emappUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emapp.
     * @param {emappUpsertArgs} args - Arguments to update or create a Emapp.
     * @example
     * // Update or create a Emapp
     * const emapp = await prisma.emapp.upsert({
     *   create: {
     *     // ... data to create a Emapp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emapp we want to update
     *   }
     * })
     */
    upsert<T extends emappUpsertArgs>(args: SelectSubset<T, emappUpsertArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emapps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emappCountArgs} args - Arguments to filter Emapps to count.
     * @example
     * // Count the number of Emapps
     * const count = await prisma.emapp.count({
     *   where: {
     *     // ... the filter for the Emapps we want to count
     *   }
     * })
    **/
    count<T extends emappCountArgs>(
      args?: Subset<T, emappCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmappCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emapp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmappAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmappAggregateArgs>(args: Subset<T, EmappAggregateArgs>): Prisma.PrismaPromise<GetEmappAggregateType<T>>

    /**
     * Group by Emapp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emappGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends emappGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: emappGroupByArgs['orderBy'] }
        : { orderBy?: emappGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, emappGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmappGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the emapp model
   */
  readonly fields: emappFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for emapp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__emappClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scores<T extends emapp$scoresArgs<ExtArgs> = {}>(args?: Subset<T, emapp$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the emapp model
   */
  interface emappFieldRefs {
    readonly AppId: FieldRef<"emapp", 'Int'>
    readonly AppName: FieldRef<"emapp", 'String'>
    readonly AppPoss: FieldRef<"emapp", 'Int'>
    readonly AppWa: FieldRef<"emapp", 'String'>
    readonly AppMail: FieldRef<"emapp", 'String'>
    readonly AppAge: FieldRef<"emapp", 'Int'>
    readonly AppJk: FieldRef<"emapp", 'Int'>
    readonly AppAddres: FieldRef<"emapp", 'String'>
    readonly AppFakt: FieldRef<"emapp", 'String'>
    readonly AppFileName: FieldRef<"emapp", 'String'>
    readonly AppLastUpdate: FieldRef<"emapp", 'DateTime'>
    readonly AppDate: FieldRef<"emapp", 'DateTime'>
    readonly AppStatus: FieldRef<"emapp", 'String'>
    readonly IsCall: FieldRef<"emapp", 'Int'>
    readonly DateCall: FieldRef<"emapp", 'DateTime'>
    readonly JobsIs: FieldRef<"emapp", 'String'>
    readonly JFStats: FieldRef<"emapp", 'String'>
    readonly LokasiId: FieldRef<"emapp", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * emapp findUnique
   */
  export type emappFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * Filter, which emapp to fetch.
     */
    where: emappWhereUniqueInput
  }

  /**
   * emapp findUniqueOrThrow
   */
  export type emappFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * Filter, which emapp to fetch.
     */
    where: emappWhereUniqueInput
  }

  /**
   * emapp findFirst
   */
  export type emappFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * Filter, which emapp to fetch.
     */
    where?: emappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emapps to fetch.
     */
    orderBy?: emappOrderByWithRelationInput | emappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emapps.
     */
    cursor?: emappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emapps.
     */
    distinct?: EmappScalarFieldEnum | EmappScalarFieldEnum[]
  }

  /**
   * emapp findFirstOrThrow
   */
  export type emappFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * Filter, which emapp to fetch.
     */
    where?: emappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emapps to fetch.
     */
    orderBy?: emappOrderByWithRelationInput | emappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emapps.
     */
    cursor?: emappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emapps.
     */
    distinct?: EmappScalarFieldEnum | EmappScalarFieldEnum[]
  }

  /**
   * emapp findMany
   */
  export type emappFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * Filter, which emapps to fetch.
     */
    where?: emappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emapps to fetch.
     */
    orderBy?: emappOrderByWithRelationInput | emappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing emapps.
     */
    cursor?: emappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emapps.
     */
    skip?: number
    distinct?: EmappScalarFieldEnum | EmappScalarFieldEnum[]
  }

  /**
   * emapp create
   */
  export type emappCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * The data needed to create a emapp.
     */
    data?: XOR<emappCreateInput, emappUncheckedCreateInput>
  }

  /**
   * emapp createMany
   */
  export type emappCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many emapps.
     */
    data: emappCreateManyInput | emappCreateManyInput[]
  }

  /**
   * emapp update
   */
  export type emappUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * The data needed to update a emapp.
     */
    data: XOR<emappUpdateInput, emappUncheckedUpdateInput>
    /**
     * Choose, which emapp to update.
     */
    where: emappWhereUniqueInput
  }

  /**
   * emapp updateMany
   */
  export type emappUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update emapps.
     */
    data: XOR<emappUpdateManyMutationInput, emappUncheckedUpdateManyInput>
    /**
     * Filter which emapps to update
     */
    where?: emappWhereInput
    /**
     * Limit how many emapps to update.
     */
    limit?: number
  }

  /**
   * emapp upsert
   */
  export type emappUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * The filter to search for the emapp to update in case it exists.
     */
    where: emappWhereUniqueInput
    /**
     * In case the emapp found by the `where` argument doesn't exist, create a new emapp with this data.
     */
    create: XOR<emappCreateInput, emappUncheckedCreateInput>
    /**
     * In case the emapp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<emappUpdateInput, emappUncheckedUpdateInput>
  }

  /**
   * emapp delete
   */
  export type emappDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
    /**
     * Filter which emapp to delete.
     */
    where: emappWhereUniqueInput
  }

  /**
   * emapp deleteMany
   */
  export type emappDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emapps to delete
     */
    where?: emappWhereInput
    /**
     * Limit how many emapps to delete.
     */
    limit?: number
  }

  /**
   * emapp.scores
   */
  export type emapp$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    where?: scoresWhereInput
    orderBy?: scoresOrderByWithRelationInput | scoresOrderByWithRelationInput[]
    cursor?: scoresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoresScalarFieldEnum | ScoresScalarFieldEnum[]
  }

  /**
   * emapp without action
   */
  export type emappDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emapp
     */
    select?: emappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emapp
     */
    omit?: emappOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emappInclude<ExtArgs> | null
  }


  /**
   * Model empassw
   */

  export type AggregateEmpassw = {
    _count: EmpasswCountAggregateOutputType | null
    _avg: EmpasswAvgAggregateOutputType | null
    _sum: EmpasswSumAggregateOutputType | null
    _min: EmpasswMinAggregateOutputType | null
    _max: EmpasswMaxAggregateOutputType | null
  }

  export type EmpasswAvgAggregateOutputType = {
    Id: number | null
    Level: number | null
  }

  export type EmpasswSumAggregateOutputType = {
    Id: number | null
    Level: number | null
  }

  export type EmpasswMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Pass: string | null
    Level: number | null
  }

  export type EmpasswMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Pass: string | null
    Level: number | null
  }

  export type EmpasswCountAggregateOutputType = {
    Id: number
    Name: number
    Pass: number
    Level: number
    _all: number
  }


  export type EmpasswAvgAggregateInputType = {
    Id?: true
    Level?: true
  }

  export type EmpasswSumAggregateInputType = {
    Id?: true
    Level?: true
  }

  export type EmpasswMinAggregateInputType = {
    Id?: true
    Name?: true
    Pass?: true
    Level?: true
  }

  export type EmpasswMaxAggregateInputType = {
    Id?: true
    Name?: true
    Pass?: true
    Level?: true
  }

  export type EmpasswCountAggregateInputType = {
    Id?: true
    Name?: true
    Pass?: true
    Level?: true
    _all?: true
  }

  export type EmpasswAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empassw to aggregate.
     */
    where?: empasswWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empassws to fetch.
     */
    orderBy?: empasswOrderByWithRelationInput | empasswOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empasswWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empassws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empassws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empassws
    **/
    _count?: true | EmpasswCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpasswAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpasswSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpasswMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpasswMaxAggregateInputType
  }

  export type GetEmpasswAggregateType<T extends EmpasswAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpassw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpassw[P]>
      : GetScalarType<T[P], AggregateEmpassw[P]>
  }




  export type empasswGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empasswWhereInput
    orderBy?: empasswOrderByWithAggregationInput | empasswOrderByWithAggregationInput[]
    by: EmpasswScalarFieldEnum[] | EmpasswScalarFieldEnum
    having?: empasswScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpasswCountAggregateInputType | true
    _avg?: EmpasswAvgAggregateInputType
    _sum?: EmpasswSumAggregateInputType
    _min?: EmpasswMinAggregateInputType
    _max?: EmpasswMaxAggregateInputType
  }

  export type EmpasswGroupByOutputType = {
    Id: number
    Name: string | null
    Pass: string | null
    Level: number | null
    _count: EmpasswCountAggregateOutputType | null
    _avg: EmpasswAvgAggregateOutputType | null
    _sum: EmpasswSumAggregateOutputType | null
    _min: EmpasswMinAggregateOutputType | null
    _max: EmpasswMaxAggregateOutputType | null
  }

  type GetEmpasswGroupByPayload<T extends empasswGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpasswGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpasswGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpasswGroupByOutputType[P]>
            : GetScalarType<T[P], EmpasswGroupByOutputType[P]>
        }
      >
    >


  export type empasswSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Pass?: boolean
    Level?: boolean
  }, ExtArgs["result"]["empassw"]>



  export type empasswSelectScalar = {
    Id?: boolean
    Name?: boolean
    Pass?: boolean
    Level?: boolean
  }

  export type empasswOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Name" | "Pass" | "Level", ExtArgs["result"]["empassw"]>

  export type $empasswPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empassw"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Name: string | null
      Pass: string | null
      Level: number | null
    }, ExtArgs["result"]["empassw"]>
    composites: {}
  }

  type empasswGetPayload<S extends boolean | null | undefined | empasswDefaultArgs> = $Result.GetResult<Prisma.$empasswPayload, S>

  type empasswCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<empasswFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmpasswCountAggregateInputType | true
    }

  export interface empasswDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empassw'], meta: { name: 'empassw' } }
    /**
     * Find zero or one Empassw that matches the filter.
     * @param {empasswFindUniqueArgs} args - Arguments to find a Empassw
     * @example
     * // Get one Empassw
     * const empassw = await prisma.empassw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends empasswFindUniqueArgs>(args: SelectSubset<T, empasswFindUniqueArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Empassw that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {empasswFindUniqueOrThrowArgs} args - Arguments to find a Empassw
     * @example
     * // Get one Empassw
     * const empassw = await prisma.empassw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends empasswFindUniqueOrThrowArgs>(args: SelectSubset<T, empasswFindUniqueOrThrowArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empassw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empasswFindFirstArgs} args - Arguments to find a Empassw
     * @example
     * // Get one Empassw
     * const empassw = await prisma.empassw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends empasswFindFirstArgs>(args?: SelectSubset<T, empasswFindFirstArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empassw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empasswFindFirstOrThrowArgs} args - Arguments to find a Empassw
     * @example
     * // Get one Empassw
     * const empassw = await prisma.empassw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends empasswFindFirstOrThrowArgs>(args?: SelectSubset<T, empasswFindFirstOrThrowArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Empassws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empasswFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empassws
     * const empassws = await prisma.empassw.findMany()
     * 
     * // Get first 10 Empassws
     * const empassws = await prisma.empassw.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const empasswWithIdOnly = await prisma.empassw.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends empasswFindManyArgs>(args?: SelectSubset<T, empasswFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Empassw.
     * @param {empasswCreateArgs} args - Arguments to create a Empassw.
     * @example
     * // Create one Empassw
     * const Empassw = await prisma.empassw.create({
     *   data: {
     *     // ... data to create a Empassw
     *   }
     * })
     * 
     */
    create<T extends empasswCreateArgs>(args: SelectSubset<T, empasswCreateArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Empassws.
     * @param {empasswCreateManyArgs} args - Arguments to create many Empassws.
     * @example
     * // Create many Empassws
     * const empassw = await prisma.empassw.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends empasswCreateManyArgs>(args?: SelectSubset<T, empasswCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empassw.
     * @param {empasswDeleteArgs} args - Arguments to delete one Empassw.
     * @example
     * // Delete one Empassw
     * const Empassw = await prisma.empassw.delete({
     *   where: {
     *     // ... filter to delete one Empassw
     *   }
     * })
     * 
     */
    delete<T extends empasswDeleteArgs>(args: SelectSubset<T, empasswDeleteArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Empassw.
     * @param {empasswUpdateArgs} args - Arguments to update one Empassw.
     * @example
     * // Update one Empassw
     * const empassw = await prisma.empassw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends empasswUpdateArgs>(args: SelectSubset<T, empasswUpdateArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Empassws.
     * @param {empasswDeleteManyArgs} args - Arguments to filter Empassws to delete.
     * @example
     * // Delete a few Empassws
     * const { count } = await prisma.empassw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends empasswDeleteManyArgs>(args?: SelectSubset<T, empasswDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empassws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empasswUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empassws
     * const empassw = await prisma.empassw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends empasswUpdateManyArgs>(args: SelectSubset<T, empasswUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empassw.
     * @param {empasswUpsertArgs} args - Arguments to update or create a Empassw.
     * @example
     * // Update or create a Empassw
     * const empassw = await prisma.empassw.upsert({
     *   create: {
     *     // ... data to create a Empassw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empassw we want to update
     *   }
     * })
     */
    upsert<T extends empasswUpsertArgs>(args: SelectSubset<T, empasswUpsertArgs<ExtArgs>>): Prisma__empasswClient<$Result.GetResult<Prisma.$empasswPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Empassws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empasswCountArgs} args - Arguments to filter Empassws to count.
     * @example
     * // Count the number of Empassws
     * const count = await prisma.empassw.count({
     *   where: {
     *     // ... the filter for the Empassws we want to count
     *   }
     * })
    **/
    count<T extends empasswCountArgs>(
      args?: Subset<T, empasswCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpasswCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empassw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpasswAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpasswAggregateArgs>(args: Subset<T, EmpasswAggregateArgs>): Prisma.PrismaPromise<GetEmpasswAggregateType<T>>

    /**
     * Group by Empassw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empasswGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empasswGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empasswGroupByArgs['orderBy'] }
        : { orderBy?: empasswGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empasswGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpasswGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empassw model
   */
  readonly fields: empasswFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empassw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empasswClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the empassw model
   */
  interface empasswFieldRefs {
    readonly Id: FieldRef<"empassw", 'Int'>
    readonly Name: FieldRef<"empassw", 'String'>
    readonly Pass: FieldRef<"empassw", 'String'>
    readonly Level: FieldRef<"empassw", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * empassw findUnique
   */
  export type empasswFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * Filter, which empassw to fetch.
     */
    where: empasswWhereUniqueInput
  }

  /**
   * empassw findUniqueOrThrow
   */
  export type empasswFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * Filter, which empassw to fetch.
     */
    where: empasswWhereUniqueInput
  }

  /**
   * empassw findFirst
   */
  export type empasswFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * Filter, which empassw to fetch.
     */
    where?: empasswWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empassws to fetch.
     */
    orderBy?: empasswOrderByWithRelationInput | empasswOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empassws.
     */
    cursor?: empasswWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empassws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empassws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empassws.
     */
    distinct?: EmpasswScalarFieldEnum | EmpasswScalarFieldEnum[]
  }

  /**
   * empassw findFirstOrThrow
   */
  export type empasswFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * Filter, which empassw to fetch.
     */
    where?: empasswWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empassws to fetch.
     */
    orderBy?: empasswOrderByWithRelationInput | empasswOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empassws.
     */
    cursor?: empasswWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empassws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empassws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empassws.
     */
    distinct?: EmpasswScalarFieldEnum | EmpasswScalarFieldEnum[]
  }

  /**
   * empassw findMany
   */
  export type empasswFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * Filter, which empassws to fetch.
     */
    where?: empasswWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empassws to fetch.
     */
    orderBy?: empasswOrderByWithRelationInput | empasswOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empassws.
     */
    cursor?: empasswWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empassws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empassws.
     */
    skip?: number
    distinct?: EmpasswScalarFieldEnum | EmpasswScalarFieldEnum[]
  }

  /**
   * empassw create
   */
  export type empasswCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * The data needed to create a empassw.
     */
    data?: XOR<empasswCreateInput, empasswUncheckedCreateInput>
  }

  /**
   * empassw createMany
   */
  export type empasswCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empassws.
     */
    data: empasswCreateManyInput | empasswCreateManyInput[]
  }

  /**
   * empassw update
   */
  export type empasswUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * The data needed to update a empassw.
     */
    data: XOR<empasswUpdateInput, empasswUncheckedUpdateInput>
    /**
     * Choose, which empassw to update.
     */
    where: empasswWhereUniqueInput
  }

  /**
   * empassw updateMany
   */
  export type empasswUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empassws.
     */
    data: XOR<empasswUpdateManyMutationInput, empasswUncheckedUpdateManyInput>
    /**
     * Filter which empassws to update
     */
    where?: empasswWhereInput
    /**
     * Limit how many empassws to update.
     */
    limit?: number
  }

  /**
   * empassw upsert
   */
  export type empasswUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * The filter to search for the empassw to update in case it exists.
     */
    where: empasswWhereUniqueInput
    /**
     * In case the empassw found by the `where` argument doesn't exist, create a new empassw with this data.
     */
    create: XOR<empasswCreateInput, empasswUncheckedCreateInput>
    /**
     * In case the empassw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empasswUpdateInput, empasswUncheckedUpdateInput>
  }

  /**
   * empassw delete
   */
  export type empasswDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
    /**
     * Filter which empassw to delete.
     */
    where: empasswWhereUniqueInput
  }

  /**
   * empassw deleteMany
   */
  export type empasswDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empassws to delete
     */
    where?: empasswWhereInput
    /**
     * Limit how many empassws to delete.
     */
    limit?: number
  }

  /**
   * empassw without action
   */
  export type empasswDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empassw
     */
    select?: empasswSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empassw
     */
    omit?: empasswOmit<ExtArgs> | null
  }


  /**
   * Model emposs
   */

  export type AggregateEmposs = {
    _count: EmpossCountAggregateOutputType | null
    _avg: EmpossAvgAggregateOutputType | null
    _sum: EmpossSumAggregateOutputType | null
    _min: EmpossMinAggregateOutputType | null
    _max: EmpossMaxAggregateOutputType | null
  }

  export type EmpossAvgAggregateOutputType = {
    Id: number | null
  }

  export type EmpossSumAggregateOutputType = {
    Id: number | null
  }

  export type EmpossMinAggregateOutputType = {
    Id: number | null
    PossName: string | null
    Status: string | null
    UserId: string | null
    LastUpdate: Date | null
  }

  export type EmpossMaxAggregateOutputType = {
    Id: number | null
    PossName: string | null
    Status: string | null
    UserId: string | null
    LastUpdate: Date | null
  }

  export type EmpossCountAggregateOutputType = {
    Id: number
    PossName: number
    Status: number
    UserId: number
    LastUpdate: number
    _all: number
  }


  export type EmpossAvgAggregateInputType = {
    Id?: true
  }

  export type EmpossSumAggregateInputType = {
    Id?: true
  }

  export type EmpossMinAggregateInputType = {
    Id?: true
    PossName?: true
    Status?: true
    UserId?: true
    LastUpdate?: true
  }

  export type EmpossMaxAggregateInputType = {
    Id?: true
    PossName?: true
    Status?: true
    UserId?: true
    LastUpdate?: true
  }

  export type EmpossCountAggregateInputType = {
    Id?: true
    PossName?: true
    Status?: true
    UserId?: true
    LastUpdate?: true
    _all?: true
  }

  export type EmpossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emposs to aggregate.
     */
    where?: empossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emposses to fetch.
     */
    orderBy?: empossOrderByWithRelationInput | empossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emposses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned emposses
    **/
    _count?: true | EmpossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpossMaxAggregateInputType
  }

  export type GetEmpossAggregateType<T extends EmpossAggregateArgs> = {
        [P in keyof T & keyof AggregateEmposs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmposs[P]>
      : GetScalarType<T[P], AggregateEmposs[P]>
  }




  export type empossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empossWhereInput
    orderBy?: empossOrderByWithAggregationInput | empossOrderByWithAggregationInput[]
    by: EmpossScalarFieldEnum[] | EmpossScalarFieldEnum
    having?: empossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpossCountAggregateInputType | true
    _avg?: EmpossAvgAggregateInputType
    _sum?: EmpossSumAggregateInputType
    _min?: EmpossMinAggregateInputType
    _max?: EmpossMaxAggregateInputType
  }

  export type EmpossGroupByOutputType = {
    Id: number
    PossName: string | null
    Status: string | null
    UserId: string | null
    LastUpdate: Date | null
    _count: EmpossCountAggregateOutputType | null
    _avg: EmpossAvgAggregateOutputType | null
    _sum: EmpossSumAggregateOutputType | null
    _min: EmpossMinAggregateOutputType | null
    _max: EmpossMaxAggregateOutputType | null
  }

  type GetEmpossGroupByPayload<T extends empossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpossGroupByOutputType[P]>
            : GetScalarType<T[P], EmpossGroupByOutputType[P]>
        }
      >
    >


  export type empossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    PossName?: boolean
    Status?: boolean
    UserId?: boolean
    LastUpdate?: boolean
    em_applicant_criteria?: boolean | emposs$em_applicant_criteriaArgs<ExtArgs>
    em_applicant_match?: boolean | emposs$em_applicant_matchArgs<ExtArgs>
    _count?: boolean | EmpossCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emposs"]>



  export type empossSelectScalar = {
    Id?: boolean
    PossName?: boolean
    Status?: boolean
    UserId?: boolean
    LastUpdate?: boolean
  }

  export type empossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "PossName" | "Status" | "UserId" | "LastUpdate", ExtArgs["result"]["emposs"]>
  export type empossInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_applicant_criteria?: boolean | emposs$em_applicant_criteriaArgs<ExtArgs>
    em_applicant_match?: boolean | emposs$em_applicant_matchArgs<ExtArgs>
    _count?: boolean | EmpossCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $empossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "emposs"
    objects: {
      em_applicant_criteria: Prisma.$em_applicant_criteriaPayload<ExtArgs>[]
      em_applicant_match: Prisma.$em_applicant_matchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      PossName: string | null
      Status: string | null
      UserId: string | null
      LastUpdate: Date | null
    }, ExtArgs["result"]["emposs"]>
    composites: {}
  }

  type empossGetPayload<S extends boolean | null | undefined | empossDefaultArgs> = $Result.GetResult<Prisma.$empossPayload, S>

  type empossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<empossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmpossCountAggregateInputType | true
    }

  export interface empossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['emposs'], meta: { name: 'emposs' } }
    /**
     * Find zero or one Emposs that matches the filter.
     * @param {empossFindUniqueArgs} args - Arguments to find a Emposs
     * @example
     * // Get one Emposs
     * const emposs = await prisma.emposs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends empossFindUniqueArgs>(args: SelectSubset<T, empossFindUniqueArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emposs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {empossFindUniqueOrThrowArgs} args - Arguments to find a Emposs
     * @example
     * // Get one Emposs
     * const emposs = await prisma.emposs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends empossFindUniqueOrThrowArgs>(args: SelectSubset<T, empossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emposs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empossFindFirstArgs} args - Arguments to find a Emposs
     * @example
     * // Get one Emposs
     * const emposs = await prisma.emposs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends empossFindFirstArgs>(args?: SelectSubset<T, empossFindFirstArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emposs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empossFindFirstOrThrowArgs} args - Arguments to find a Emposs
     * @example
     * // Get one Emposs
     * const emposs = await prisma.emposs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends empossFindFirstOrThrowArgs>(args?: SelectSubset<T, empossFindFirstOrThrowArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emposses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emposses
     * const emposses = await prisma.emposs.findMany()
     * 
     * // Get first 10 Emposses
     * const emposses = await prisma.emposs.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const empossWithIdOnly = await prisma.emposs.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends empossFindManyArgs>(args?: SelectSubset<T, empossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emposs.
     * @param {empossCreateArgs} args - Arguments to create a Emposs.
     * @example
     * // Create one Emposs
     * const Emposs = await prisma.emposs.create({
     *   data: {
     *     // ... data to create a Emposs
     *   }
     * })
     * 
     */
    create<T extends empossCreateArgs>(args: SelectSubset<T, empossCreateArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emposses.
     * @param {empossCreateManyArgs} args - Arguments to create many Emposses.
     * @example
     * // Create many Emposses
     * const emposs = await prisma.emposs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends empossCreateManyArgs>(args?: SelectSubset<T, empossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emposs.
     * @param {empossDeleteArgs} args - Arguments to delete one Emposs.
     * @example
     * // Delete one Emposs
     * const Emposs = await prisma.emposs.delete({
     *   where: {
     *     // ... filter to delete one Emposs
     *   }
     * })
     * 
     */
    delete<T extends empossDeleteArgs>(args: SelectSubset<T, empossDeleteArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emposs.
     * @param {empossUpdateArgs} args - Arguments to update one Emposs.
     * @example
     * // Update one Emposs
     * const emposs = await prisma.emposs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends empossUpdateArgs>(args: SelectSubset<T, empossUpdateArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emposses.
     * @param {empossDeleteManyArgs} args - Arguments to filter Emposses to delete.
     * @example
     * // Delete a few Emposses
     * const { count } = await prisma.emposs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends empossDeleteManyArgs>(args?: SelectSubset<T, empossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emposses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emposses
     * const emposs = await prisma.emposs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends empossUpdateManyArgs>(args: SelectSubset<T, empossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emposs.
     * @param {empossUpsertArgs} args - Arguments to update or create a Emposs.
     * @example
     * // Update or create a Emposs
     * const emposs = await prisma.emposs.upsert({
     *   create: {
     *     // ... data to create a Emposs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emposs we want to update
     *   }
     * })
     */
    upsert<T extends empossUpsertArgs>(args: SelectSubset<T, empossUpsertArgs<ExtArgs>>): Prisma__empossClient<$Result.GetResult<Prisma.$empossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emposses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empossCountArgs} args - Arguments to filter Emposses to count.
     * @example
     * // Count the number of Emposses
     * const count = await prisma.emposs.count({
     *   where: {
     *     // ... the filter for the Emposses we want to count
     *   }
     * })
    **/
    count<T extends empossCountArgs>(
      args?: Subset<T, empossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emposs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpossAggregateArgs>(args: Subset<T, EmpossAggregateArgs>): Prisma.PrismaPromise<GetEmpossAggregateType<T>>

    /**
     * Group by Emposs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empossGroupByArgs['orderBy'] }
        : { orderBy?: empossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the emposs model
   */
  readonly fields: empossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for emposs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_applicant_criteria<T extends emposs$em_applicant_criteriaArgs<ExtArgs> = {}>(args?: Subset<T, emposs$em_applicant_criteriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_applicant_criteriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    em_applicant_match<T extends emposs$em_applicant_matchArgs<ExtArgs> = {}>(args?: Subset<T, emposs$em_applicant_matchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$em_applicant_matchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the emposs model
   */
  interface empossFieldRefs {
    readonly Id: FieldRef<"emposs", 'Int'>
    readonly PossName: FieldRef<"emposs", 'String'>
    readonly Status: FieldRef<"emposs", 'String'>
    readonly UserId: FieldRef<"emposs", 'String'>
    readonly LastUpdate: FieldRef<"emposs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * emposs findUnique
   */
  export type empossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * Filter, which emposs to fetch.
     */
    where: empossWhereUniqueInput
  }

  /**
   * emposs findUniqueOrThrow
   */
  export type empossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * Filter, which emposs to fetch.
     */
    where: empossWhereUniqueInput
  }

  /**
   * emposs findFirst
   */
  export type empossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * Filter, which emposs to fetch.
     */
    where?: empossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emposses to fetch.
     */
    orderBy?: empossOrderByWithRelationInput | empossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emposses.
     */
    cursor?: empossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emposses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emposses.
     */
    distinct?: EmpossScalarFieldEnum | EmpossScalarFieldEnum[]
  }

  /**
   * emposs findFirstOrThrow
   */
  export type empossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * Filter, which emposs to fetch.
     */
    where?: empossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emposses to fetch.
     */
    orderBy?: empossOrderByWithRelationInput | empossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emposses.
     */
    cursor?: empossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emposses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emposses.
     */
    distinct?: EmpossScalarFieldEnum | EmpossScalarFieldEnum[]
  }

  /**
   * emposs findMany
   */
  export type empossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * Filter, which emposses to fetch.
     */
    where?: empossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emposses to fetch.
     */
    orderBy?: empossOrderByWithRelationInput | empossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing emposses.
     */
    cursor?: empossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emposses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emposses.
     */
    skip?: number
    distinct?: EmpossScalarFieldEnum | EmpossScalarFieldEnum[]
  }

  /**
   * emposs create
   */
  export type empossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * The data needed to create a emposs.
     */
    data?: XOR<empossCreateInput, empossUncheckedCreateInput>
  }

  /**
   * emposs createMany
   */
  export type empossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many emposses.
     */
    data: empossCreateManyInput | empossCreateManyInput[]
  }

  /**
   * emposs update
   */
  export type empossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * The data needed to update a emposs.
     */
    data: XOR<empossUpdateInput, empossUncheckedUpdateInput>
    /**
     * Choose, which emposs to update.
     */
    where: empossWhereUniqueInput
  }

  /**
   * emposs updateMany
   */
  export type empossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update emposses.
     */
    data: XOR<empossUpdateManyMutationInput, empossUncheckedUpdateManyInput>
    /**
     * Filter which emposses to update
     */
    where?: empossWhereInput
    /**
     * Limit how many emposses to update.
     */
    limit?: number
  }

  /**
   * emposs upsert
   */
  export type empossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * The filter to search for the emposs to update in case it exists.
     */
    where: empossWhereUniqueInput
    /**
     * In case the emposs found by the `where` argument doesn't exist, create a new emposs with this data.
     */
    create: XOR<empossCreateInput, empossUncheckedCreateInput>
    /**
     * In case the emposs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empossUpdateInput, empossUncheckedUpdateInput>
  }

  /**
   * emposs delete
   */
  export type empossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
    /**
     * Filter which emposs to delete.
     */
    where: empossWhereUniqueInput
  }

  /**
   * emposs deleteMany
   */
  export type empossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emposses to delete
     */
    where?: empossWhereInput
    /**
     * Limit how many emposses to delete.
     */
    limit?: number
  }

  /**
   * emposs.em_applicant_criteria
   */
  export type emposs$em_applicant_criteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_criteria
     */
    select?: em_applicant_criteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_criteria
     */
    omit?: em_applicant_criteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_criteriaInclude<ExtArgs> | null
    where?: em_applicant_criteriaWhereInput
    orderBy?: em_applicant_criteriaOrderByWithRelationInput | em_applicant_criteriaOrderByWithRelationInput[]
    cursor?: em_applicant_criteriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_applicant_criteriaScalarFieldEnum | Em_applicant_criteriaScalarFieldEnum[]
  }

  /**
   * emposs.em_applicant_match
   */
  export type emposs$em_applicant_matchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the em_applicant_match
     */
    select?: em_applicant_matchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the em_applicant_match
     */
    omit?: em_applicant_matchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: em_applicant_matchInclude<ExtArgs> | null
    where?: em_applicant_matchWhereInput
    orderBy?: em_applicant_matchOrderByWithRelationInput | em_applicant_matchOrderByWithRelationInput[]
    cursor?: em_applicant_matchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Em_applicant_matchScalarFieldEnum | Em_applicant_matchScalarFieldEnum[]
  }

  /**
   * emposs without action
   */
  export type empossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emposs
     */
    select?: empossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emposs
     */
    omit?: empossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empossInclude<ExtArgs> | null
  }


  /**
   * Model faceusers
   */

  export type AggregateFaceusers = {
    _count: FaceusersCountAggregateOutputType | null
    _avg: FaceusersAvgAggregateOutputType | null
    _sum: FaceusersSumAggregateOutputType | null
    _min: FaceusersMinAggregateOutputType | null
    _max: FaceusersMaxAggregateOutputType | null
  }

  export type FaceusersAvgAggregateOutputType = {
    Id: number | null
  }

  export type FaceusersSumAggregateOutputType = {
    Id: number | null
  }

  export type FaceusersMinAggregateOutputType = {
    Id: number | null
    name: string | null
    fileimage: string | null
    descriptor: string | null
    pose: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type FaceusersMaxAggregateOutputType = {
    Id: number | null
    name: string | null
    fileimage: string | null
    descriptor: string | null
    pose: string | null
    created_at: Date | null
    lastupdate: Date | null
  }

  export type FaceusersCountAggregateOutputType = {
    Id: number
    name: number
    fileimage: number
    descriptor: number
    pose: number
    created_at: number
    lastupdate: number
    _all: number
  }


  export type FaceusersAvgAggregateInputType = {
    Id?: true
  }

  export type FaceusersSumAggregateInputType = {
    Id?: true
  }

  export type FaceusersMinAggregateInputType = {
    Id?: true
    name?: true
    fileimage?: true
    descriptor?: true
    pose?: true
    created_at?: true
    lastupdate?: true
  }

  export type FaceusersMaxAggregateInputType = {
    Id?: true
    name?: true
    fileimage?: true
    descriptor?: true
    pose?: true
    created_at?: true
    lastupdate?: true
  }

  export type FaceusersCountAggregateInputType = {
    Id?: true
    name?: true
    fileimage?: true
    descriptor?: true
    pose?: true
    created_at?: true
    lastupdate?: true
    _all?: true
  }

  export type FaceusersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faceusers to aggregate.
     */
    where?: faceusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faceusers to fetch.
     */
    orderBy?: faceusersOrderByWithRelationInput | faceusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faceusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faceusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faceusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faceusers
    **/
    _count?: true | FaceusersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaceusersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaceusersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaceusersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaceusersMaxAggregateInputType
  }

  export type GetFaceusersAggregateType<T extends FaceusersAggregateArgs> = {
        [P in keyof T & keyof AggregateFaceusers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaceusers[P]>
      : GetScalarType<T[P], AggregateFaceusers[P]>
  }




  export type faceusersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faceusersWhereInput
    orderBy?: faceusersOrderByWithAggregationInput | faceusersOrderByWithAggregationInput[]
    by: FaceusersScalarFieldEnum[] | FaceusersScalarFieldEnum
    having?: faceusersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaceusersCountAggregateInputType | true
    _avg?: FaceusersAvgAggregateInputType
    _sum?: FaceusersSumAggregateInputType
    _min?: FaceusersMinAggregateInputType
    _max?: FaceusersMaxAggregateInputType
  }

  export type FaceusersGroupByOutputType = {
    Id: number
    name: string | null
    fileimage: string | null
    descriptor: string | null
    pose: string | null
    created_at: Date | null
    lastupdate: Date | null
    _count: FaceusersCountAggregateOutputType | null
    _avg: FaceusersAvgAggregateOutputType | null
    _sum: FaceusersSumAggregateOutputType | null
    _min: FaceusersMinAggregateOutputType | null
    _max: FaceusersMaxAggregateOutputType | null
  }

  type GetFaceusersGroupByPayload<T extends faceusersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaceusersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaceusersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaceusersGroupByOutputType[P]>
            : GetScalarType<T[P], FaceusersGroupByOutputType[P]>
        }
      >
    >


  export type faceusersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    name?: boolean
    fileimage?: boolean
    descriptor?: boolean
    pose?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }, ExtArgs["result"]["faceusers"]>



  export type faceusersSelectScalar = {
    Id?: boolean
    name?: boolean
    fileimage?: boolean
    descriptor?: boolean
    pose?: boolean
    created_at?: boolean
    lastupdate?: boolean
  }

  export type faceusersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "name" | "fileimage" | "descriptor" | "pose" | "created_at" | "lastupdate", ExtArgs["result"]["faceusers"]>

  export type $faceusersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faceusers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      name: string | null
      fileimage: string | null
      descriptor: string | null
      pose: string | null
      created_at: Date | null
      lastupdate: Date | null
    }, ExtArgs["result"]["faceusers"]>
    composites: {}
  }

  type faceusersGetPayload<S extends boolean | null | undefined | faceusersDefaultArgs> = $Result.GetResult<Prisma.$faceusersPayload, S>

  type faceusersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<faceusersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaceusersCountAggregateInputType | true
    }

  export interface faceusersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faceusers'], meta: { name: 'faceusers' } }
    /**
     * Find zero or one Faceusers that matches the filter.
     * @param {faceusersFindUniqueArgs} args - Arguments to find a Faceusers
     * @example
     * // Get one Faceusers
     * const faceusers = await prisma.faceusers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faceusersFindUniqueArgs>(args: SelectSubset<T, faceusersFindUniqueArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faceusers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faceusersFindUniqueOrThrowArgs} args - Arguments to find a Faceusers
     * @example
     * // Get one Faceusers
     * const faceusers = await prisma.faceusers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faceusersFindUniqueOrThrowArgs>(args: SelectSubset<T, faceusersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faceusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faceusersFindFirstArgs} args - Arguments to find a Faceusers
     * @example
     * // Get one Faceusers
     * const faceusers = await prisma.faceusers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faceusersFindFirstArgs>(args?: SelectSubset<T, faceusersFindFirstArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faceusers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faceusersFindFirstOrThrowArgs} args - Arguments to find a Faceusers
     * @example
     * // Get one Faceusers
     * const faceusers = await prisma.faceusers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faceusersFindFirstOrThrowArgs>(args?: SelectSubset<T, faceusersFindFirstOrThrowArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faceusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faceusersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faceusers
     * const faceusers = await prisma.faceusers.findMany()
     * 
     * // Get first 10 Faceusers
     * const faceusers = await prisma.faceusers.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const faceusersWithIdOnly = await prisma.faceusers.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends faceusersFindManyArgs>(args?: SelectSubset<T, faceusersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faceusers.
     * @param {faceusersCreateArgs} args - Arguments to create a Faceusers.
     * @example
     * // Create one Faceusers
     * const Faceusers = await prisma.faceusers.create({
     *   data: {
     *     // ... data to create a Faceusers
     *   }
     * })
     * 
     */
    create<T extends faceusersCreateArgs>(args: SelectSubset<T, faceusersCreateArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faceusers.
     * @param {faceusersCreateManyArgs} args - Arguments to create many Faceusers.
     * @example
     * // Create many Faceusers
     * const faceusers = await prisma.faceusers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends faceusersCreateManyArgs>(args?: SelectSubset<T, faceusersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faceusers.
     * @param {faceusersDeleteArgs} args - Arguments to delete one Faceusers.
     * @example
     * // Delete one Faceusers
     * const Faceusers = await prisma.faceusers.delete({
     *   where: {
     *     // ... filter to delete one Faceusers
     *   }
     * })
     * 
     */
    delete<T extends faceusersDeleteArgs>(args: SelectSubset<T, faceusersDeleteArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faceusers.
     * @param {faceusersUpdateArgs} args - Arguments to update one Faceusers.
     * @example
     * // Update one Faceusers
     * const faceusers = await prisma.faceusers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends faceusersUpdateArgs>(args: SelectSubset<T, faceusersUpdateArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faceusers.
     * @param {faceusersDeleteManyArgs} args - Arguments to filter Faceusers to delete.
     * @example
     * // Delete a few Faceusers
     * const { count } = await prisma.faceusers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends faceusersDeleteManyArgs>(args?: SelectSubset<T, faceusersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faceusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faceusersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faceusers
     * const faceusers = await prisma.faceusers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends faceusersUpdateManyArgs>(args: SelectSubset<T, faceusersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faceusers.
     * @param {faceusersUpsertArgs} args - Arguments to update or create a Faceusers.
     * @example
     * // Update or create a Faceusers
     * const faceusers = await prisma.faceusers.upsert({
     *   create: {
     *     // ... data to create a Faceusers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faceusers we want to update
     *   }
     * })
     */
    upsert<T extends faceusersUpsertArgs>(args: SelectSubset<T, faceusersUpsertArgs<ExtArgs>>): Prisma__faceusersClient<$Result.GetResult<Prisma.$faceusersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faceusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faceusersCountArgs} args - Arguments to filter Faceusers to count.
     * @example
     * // Count the number of Faceusers
     * const count = await prisma.faceusers.count({
     *   where: {
     *     // ... the filter for the Faceusers we want to count
     *   }
     * })
    **/
    count<T extends faceusersCountArgs>(
      args?: Subset<T, faceusersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaceusersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faceusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaceusersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaceusersAggregateArgs>(args: Subset<T, FaceusersAggregateArgs>): Prisma.PrismaPromise<GetFaceusersAggregateType<T>>

    /**
     * Group by Faceusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faceusersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends faceusersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faceusersGroupByArgs['orderBy'] }
        : { orderBy?: faceusersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, faceusersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaceusersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faceusers model
   */
  readonly fields: faceusersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faceusers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faceusersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the faceusers model
   */
  interface faceusersFieldRefs {
    readonly Id: FieldRef<"faceusers", 'Int'>
    readonly name: FieldRef<"faceusers", 'String'>
    readonly fileimage: FieldRef<"faceusers", 'String'>
    readonly descriptor: FieldRef<"faceusers", 'String'>
    readonly pose: FieldRef<"faceusers", 'String'>
    readonly created_at: FieldRef<"faceusers", 'DateTime'>
    readonly lastupdate: FieldRef<"faceusers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * faceusers findUnique
   */
  export type faceusersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * Filter, which faceusers to fetch.
     */
    where: faceusersWhereUniqueInput
  }

  /**
   * faceusers findUniqueOrThrow
   */
  export type faceusersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * Filter, which faceusers to fetch.
     */
    where: faceusersWhereUniqueInput
  }

  /**
   * faceusers findFirst
   */
  export type faceusersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * Filter, which faceusers to fetch.
     */
    where?: faceusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faceusers to fetch.
     */
    orderBy?: faceusersOrderByWithRelationInput | faceusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faceusers.
     */
    cursor?: faceusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faceusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faceusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faceusers.
     */
    distinct?: FaceusersScalarFieldEnum | FaceusersScalarFieldEnum[]
  }

  /**
   * faceusers findFirstOrThrow
   */
  export type faceusersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * Filter, which faceusers to fetch.
     */
    where?: faceusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faceusers to fetch.
     */
    orderBy?: faceusersOrderByWithRelationInput | faceusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faceusers.
     */
    cursor?: faceusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faceusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faceusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faceusers.
     */
    distinct?: FaceusersScalarFieldEnum | FaceusersScalarFieldEnum[]
  }

  /**
   * faceusers findMany
   */
  export type faceusersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * Filter, which faceusers to fetch.
     */
    where?: faceusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faceusers to fetch.
     */
    orderBy?: faceusersOrderByWithRelationInput | faceusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faceusers.
     */
    cursor?: faceusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faceusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faceusers.
     */
    skip?: number
    distinct?: FaceusersScalarFieldEnum | FaceusersScalarFieldEnum[]
  }

  /**
   * faceusers create
   */
  export type faceusersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * The data needed to create a faceusers.
     */
    data?: XOR<faceusersCreateInput, faceusersUncheckedCreateInput>
  }

  /**
   * faceusers createMany
   */
  export type faceusersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faceusers.
     */
    data: faceusersCreateManyInput | faceusersCreateManyInput[]
  }

  /**
   * faceusers update
   */
  export type faceusersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * The data needed to update a faceusers.
     */
    data: XOR<faceusersUpdateInput, faceusersUncheckedUpdateInput>
    /**
     * Choose, which faceusers to update.
     */
    where: faceusersWhereUniqueInput
  }

  /**
   * faceusers updateMany
   */
  export type faceusersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faceusers.
     */
    data: XOR<faceusersUpdateManyMutationInput, faceusersUncheckedUpdateManyInput>
    /**
     * Filter which faceusers to update
     */
    where?: faceusersWhereInput
    /**
     * Limit how many faceusers to update.
     */
    limit?: number
  }

  /**
   * faceusers upsert
   */
  export type faceusersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * The filter to search for the faceusers to update in case it exists.
     */
    where: faceusersWhereUniqueInput
    /**
     * In case the faceusers found by the `where` argument doesn't exist, create a new faceusers with this data.
     */
    create: XOR<faceusersCreateInput, faceusersUncheckedCreateInput>
    /**
     * In case the faceusers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faceusersUpdateInput, faceusersUncheckedUpdateInput>
  }

  /**
   * faceusers delete
   */
  export type faceusersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
    /**
     * Filter which faceusers to delete.
     */
    where: faceusersWhereUniqueInput
  }

  /**
   * faceusers deleteMany
   */
  export type faceusersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faceusers to delete
     */
    where?: faceusersWhereInput
    /**
     * Limit how many faceusers to delete.
     */
    limit?: number
  }

  /**
   * faceusers without action
   */
  export type faceusersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faceusers
     */
    select?: faceusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faceusers
     */
    omit?: faceusersOmit<ExtArgs> | null
  }


  /**
   * Model menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    parent_id: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    parent_id: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    parent_id: number | null
    link: string | null
    visible: boolean | null
    role: string | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parent_id: number | null
    link: string | null
    visible: boolean | null
    role: string | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    name: number
    parent_id: number
    link: number
    visible: number
    role: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    parent_id?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    parent_id?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    link?: true
    visible?: true
    role?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    link?: true
    visible?: true
    role?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    link?: true
    visible?: true
    role?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu to aggregate.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type menuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menuWhereInput
    orderBy?: menuOrderByWithAggregationInput | menuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: menuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: number
    name: string
    parent_id: number | null
    link: string | null
    visible: boolean
    role: string | null
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends menuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type menuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parent_id?: boolean
    link?: boolean
    visible?: boolean
    role?: boolean
  }, ExtArgs["result"]["menu"]>



  export type menuSelectScalar = {
    id?: boolean
    name?: boolean
    parent_id?: boolean
    link?: boolean
    visible?: boolean
    role?: boolean
  }

  export type menuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parent_id" | "link" | "visible" | "role", ExtArgs["result"]["menu"]>

  export type $menuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "menu"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parent_id: number | null
      link: string | null
      visible: boolean
      role: string | null
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type menuGetPayload<S extends boolean | null | undefined | menuDefaultArgs> = $Result.GetResult<Prisma.$menuPayload, S>

  type menuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<menuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface menuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['menu'], meta: { name: 'menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {menuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends menuFindUniqueArgs>(args: SelectSubset<T, menuFindUniqueArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {menuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends menuFindUniqueOrThrowArgs>(args: SelectSubset<T, menuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends menuFindFirstArgs>(args?: SelectSubset<T, menuFindFirstArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends menuFindFirstOrThrowArgs>(args?: SelectSubset<T, menuFindFirstOrThrowArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends menuFindManyArgs>(args?: SelectSubset<T, menuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {menuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends menuCreateArgs>(args: SelectSubset<T, menuCreateArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {menuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends menuCreateManyArgs>(args?: SelectSubset<T, menuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {menuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends menuDeleteArgs>(args: SelectSubset<T, menuDeleteArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {menuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends menuUpdateArgs>(args: SelectSubset<T, menuUpdateArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {menuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends menuDeleteManyArgs>(args?: SelectSubset<T, menuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends menuUpdateManyArgs>(args: SelectSubset<T, menuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {menuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends menuUpsertArgs>(args: SelectSubset<T, menuUpsertArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends menuCountArgs>(
      args?: Subset<T, menuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends menuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: menuGroupByArgs['orderBy'] }
        : { orderBy?: menuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, menuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the menu model
   */
  readonly fields: menuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__menuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the menu model
   */
  interface menuFieldRefs {
    readonly id: FieldRef<"menu", 'Int'>
    readonly name: FieldRef<"menu", 'String'>
    readonly parent_id: FieldRef<"menu", 'Int'>
    readonly link: FieldRef<"menu", 'String'>
    readonly visible: FieldRef<"menu", 'Boolean'>
    readonly role: FieldRef<"menu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * menu findUnique
   */
  export type menuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu findUniqueOrThrow
   */
  export type menuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu findFirst
   */
  export type menuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * menu findFirstOrThrow
   */
  export type menuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * menu findMany
   */
  export type menuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * menu create
   */
  export type menuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * The data needed to create a menu.
     */
    data: XOR<menuCreateInput, menuUncheckedCreateInput>
  }

  /**
   * menu createMany
   */
  export type menuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many menus.
     */
    data: menuCreateManyInput | menuCreateManyInput[]
  }

  /**
   * menu update
   */
  export type menuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * The data needed to update a menu.
     */
    data: XOR<menuUpdateInput, menuUncheckedUpdateInput>
    /**
     * Choose, which menu to update.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu updateMany
   */
  export type menuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update menus.
     */
    data: XOR<menuUpdateManyMutationInput, menuUncheckedUpdateManyInput>
    /**
     * Filter which menus to update
     */
    where?: menuWhereInput
    /**
     * Limit how many menus to update.
     */
    limit?: number
  }

  /**
   * menu upsert
   */
  export type menuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * The filter to search for the menu to update in case it exists.
     */
    where: menuWhereUniqueInput
    /**
     * In case the menu found by the `where` argument doesn't exist, create a new menu with this data.
     */
    create: XOR<menuCreateInput, menuUncheckedCreateInput>
    /**
     * In case the menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<menuUpdateInput, menuUncheckedUpdateInput>
  }

  /**
   * menu delete
   */
  export type menuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter which menu to delete.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu deleteMany
   */
  export type menuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menus to delete
     */
    where?: menuWhereInput
    /**
     * Limit how many menus to delete.
     */
    limit?: number
  }

  /**
   * menu without action
   */
  export type menuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
  }


  /**
   * Model scores
   */

  export type AggregateScores = {
    _count: ScoresCountAggregateOutputType | null
    _avg: ScoresAvgAggregateOutputType | null
    _sum: ScoresSumAggregateOutputType | null
    _min: ScoresMinAggregateOutputType | null
    _max: ScoresMaxAggregateOutputType | null
  }

  export type ScoresAvgAggregateOutputType = {
    id: number | null
    exam_id: number | null
    user_id: number | null
    total_score: number | null
  }

  export type ScoresSumAggregateOutputType = {
    id: number | null
    exam_id: number | null
    user_id: number | null
    total_score: number | null
  }

  export type ScoresMinAggregateOutputType = {
    id: number | null
    exam_id: number | null
    user_id: number | null
    total_score: number | null
    created_at: Date | null
  }

  export type ScoresMaxAggregateOutputType = {
    id: number | null
    exam_id: number | null
    user_id: number | null
    total_score: number | null
    created_at: Date | null
  }

  export type ScoresCountAggregateOutputType = {
    id: number
    exam_id: number
    user_id: number
    total_score: number
    created_at: number
    _all: number
  }


  export type ScoresAvgAggregateInputType = {
    id?: true
    exam_id?: true
    user_id?: true
    total_score?: true
  }

  export type ScoresSumAggregateInputType = {
    id?: true
    exam_id?: true
    user_id?: true
    total_score?: true
  }

  export type ScoresMinAggregateInputType = {
    id?: true
    exam_id?: true
    user_id?: true
    total_score?: true
    created_at?: true
  }

  export type ScoresMaxAggregateInputType = {
    id?: true
    exam_id?: true
    user_id?: true
    total_score?: true
    created_at?: true
  }

  export type ScoresCountAggregateInputType = {
    id?: true
    exam_id?: true
    user_id?: true
    total_score?: true
    created_at?: true
    _all?: true
  }

  export type ScoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scores to aggregate.
     */
    where?: scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scores to fetch.
     */
    orderBy?: scoresOrderByWithRelationInput | scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scores
    **/
    _count?: true | ScoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoresMaxAggregateInputType
  }

  export type GetScoresAggregateType<T extends ScoresAggregateArgs> = {
        [P in keyof T & keyof AggregateScores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScores[P]>
      : GetScalarType<T[P], AggregateScores[P]>
  }




  export type scoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scoresWhereInput
    orderBy?: scoresOrderByWithAggregationInput | scoresOrderByWithAggregationInput[]
    by: ScoresScalarFieldEnum[] | ScoresScalarFieldEnum
    having?: scoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoresCountAggregateInputType | true
    _avg?: ScoresAvgAggregateInputType
    _sum?: ScoresSumAggregateInputType
    _min?: ScoresMinAggregateInputType
    _max?: ScoresMaxAggregateInputType
  }

  export type ScoresGroupByOutputType = {
    id: number
    exam_id: number
    user_id: number
    total_score: number
    created_at: Date | null
    _count: ScoresCountAggregateOutputType | null
    _avg: ScoresAvgAggregateOutputType | null
    _sum: ScoresSumAggregateOutputType | null
    _min: ScoresMinAggregateOutputType | null
    _max: ScoresMaxAggregateOutputType | null
  }

  type GetScoresGroupByPayload<T extends scoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoresGroupByOutputType[P]>
            : GetScalarType<T[P], ScoresGroupByOutputType[P]>
        }
      >
    >


  export type scoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exam_id?: boolean
    user_id?: boolean
    total_score?: boolean
    created_at?: boolean
    em_exams?: boolean | em_examsDefaultArgs<ExtArgs>
    emapp?: boolean | emappDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scores"]>



  export type scoresSelectScalar = {
    id?: boolean
    exam_id?: boolean
    user_id?: boolean
    total_score?: boolean
    created_at?: boolean
  }

  export type scoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exam_id" | "user_id" | "total_score" | "created_at", ExtArgs["result"]["scores"]>
  export type scoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    em_exams?: boolean | em_examsDefaultArgs<ExtArgs>
    emapp?: boolean | emappDefaultArgs<ExtArgs>
  }

  export type $scoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "scores"
    objects: {
      em_exams: Prisma.$em_examsPayload<ExtArgs>
      emapp: Prisma.$emappPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exam_id: number
      user_id: number
      total_score: number
      created_at: Date | null
    }, ExtArgs["result"]["scores"]>
    composites: {}
  }

  type scoresGetPayload<S extends boolean | null | undefined | scoresDefaultArgs> = $Result.GetResult<Prisma.$scoresPayload, S>

  type scoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<scoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScoresCountAggregateInputType | true
    }

  export interface scoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['scores'], meta: { name: 'scores' } }
    /**
     * Find zero or one Scores that matches the filter.
     * @param {scoresFindUniqueArgs} args - Arguments to find a Scores
     * @example
     * // Get one Scores
     * const scores = await prisma.scores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends scoresFindUniqueArgs>(args: SelectSubset<T, scoresFindUniqueArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {scoresFindUniqueOrThrowArgs} args - Arguments to find a Scores
     * @example
     * // Get one Scores
     * const scores = await prisma.scores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends scoresFindUniqueOrThrowArgs>(args: SelectSubset<T, scoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scoresFindFirstArgs} args - Arguments to find a Scores
     * @example
     * // Get one Scores
     * const scores = await prisma.scores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends scoresFindFirstArgs>(args?: SelectSubset<T, scoresFindFirstArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scoresFindFirstOrThrowArgs} args - Arguments to find a Scores
     * @example
     * // Get one Scores
     * const scores = await prisma.scores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends scoresFindFirstOrThrowArgs>(args?: SelectSubset<T, scoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scores
     * const scores = await prisma.scores.findMany()
     * 
     * // Get first 10 Scores
     * const scores = await prisma.scores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoresWithIdOnly = await prisma.scores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends scoresFindManyArgs>(args?: SelectSubset<T, scoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scores.
     * @param {scoresCreateArgs} args - Arguments to create a Scores.
     * @example
     * // Create one Scores
     * const Scores = await prisma.scores.create({
     *   data: {
     *     // ... data to create a Scores
     *   }
     * })
     * 
     */
    create<T extends scoresCreateArgs>(args: SelectSubset<T, scoresCreateArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scores.
     * @param {scoresCreateManyArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const scores = await prisma.scores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends scoresCreateManyArgs>(args?: SelectSubset<T, scoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Scores.
     * @param {scoresDeleteArgs} args - Arguments to delete one Scores.
     * @example
     * // Delete one Scores
     * const Scores = await prisma.scores.delete({
     *   where: {
     *     // ... filter to delete one Scores
     *   }
     * })
     * 
     */
    delete<T extends scoresDeleteArgs>(args: SelectSubset<T, scoresDeleteArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scores.
     * @param {scoresUpdateArgs} args - Arguments to update one Scores.
     * @example
     * // Update one Scores
     * const scores = await prisma.scores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends scoresUpdateArgs>(args: SelectSubset<T, scoresUpdateArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scores.
     * @param {scoresDeleteManyArgs} args - Arguments to filter Scores to delete.
     * @example
     * // Delete a few Scores
     * const { count } = await prisma.scores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends scoresDeleteManyArgs>(args?: SelectSubset<T, scoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scores
     * const scores = await prisma.scores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends scoresUpdateManyArgs>(args: SelectSubset<T, scoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Scores.
     * @param {scoresUpsertArgs} args - Arguments to update or create a Scores.
     * @example
     * // Update or create a Scores
     * const scores = await prisma.scores.upsert({
     *   create: {
     *     // ... data to create a Scores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scores we want to update
     *   }
     * })
     */
    upsert<T extends scoresUpsertArgs>(args: SelectSubset<T, scoresUpsertArgs<ExtArgs>>): Prisma__scoresClient<$Result.GetResult<Prisma.$scoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scoresCountArgs} args - Arguments to filter Scores to count.
     * @example
     * // Count the number of Scores
     * const count = await prisma.scores.count({
     *   where: {
     *     // ... the filter for the Scores we want to count
     *   }
     * })
    **/
    count<T extends scoresCountArgs>(
      args?: Subset<T, scoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoresAggregateArgs>(args: Subset<T, ScoresAggregateArgs>): Prisma.PrismaPromise<GetScoresAggregateType<T>>

    /**
     * Group by Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends scoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: scoresGroupByArgs['orderBy'] }
        : { orderBy?: scoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, scoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the scores model
   */
  readonly fields: scoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for scores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__scoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    em_exams<T extends em_examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, em_examsDefaultArgs<ExtArgs>>): Prisma__em_examsClient<$Result.GetResult<Prisma.$em_examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emapp<T extends emappDefaultArgs<ExtArgs> = {}>(args?: Subset<T, emappDefaultArgs<ExtArgs>>): Prisma__emappClient<$Result.GetResult<Prisma.$emappPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the scores model
   */
  interface scoresFieldRefs {
    readonly id: FieldRef<"scores", 'Int'>
    readonly exam_id: FieldRef<"scores", 'Int'>
    readonly user_id: FieldRef<"scores", 'Int'>
    readonly total_score: FieldRef<"scores", 'Int'>
    readonly created_at: FieldRef<"scores", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * scores findUnique
   */
  export type scoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * Filter, which scores to fetch.
     */
    where: scoresWhereUniqueInput
  }

  /**
   * scores findUniqueOrThrow
   */
  export type scoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * Filter, which scores to fetch.
     */
    where: scoresWhereUniqueInput
  }

  /**
   * scores findFirst
   */
  export type scoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * Filter, which scores to fetch.
     */
    where?: scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scores to fetch.
     */
    orderBy?: scoresOrderByWithRelationInput | scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scores.
     */
    cursor?: scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scores.
     */
    distinct?: ScoresScalarFieldEnum | ScoresScalarFieldEnum[]
  }

  /**
   * scores findFirstOrThrow
   */
  export type scoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * Filter, which scores to fetch.
     */
    where?: scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scores to fetch.
     */
    orderBy?: scoresOrderByWithRelationInput | scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scores.
     */
    cursor?: scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scores.
     */
    distinct?: ScoresScalarFieldEnum | ScoresScalarFieldEnum[]
  }

  /**
   * scores findMany
   */
  export type scoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * Filter, which scores to fetch.
     */
    where?: scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scores to fetch.
     */
    orderBy?: scoresOrderByWithRelationInput | scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scores.
     */
    cursor?: scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scores.
     */
    skip?: number
    distinct?: ScoresScalarFieldEnum | ScoresScalarFieldEnum[]
  }

  /**
   * scores create
   */
  export type scoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * The data needed to create a scores.
     */
    data: XOR<scoresCreateInput, scoresUncheckedCreateInput>
  }

  /**
   * scores createMany
   */
  export type scoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many scores.
     */
    data: scoresCreateManyInput | scoresCreateManyInput[]
  }

  /**
   * scores update
   */
  export type scoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * The data needed to update a scores.
     */
    data: XOR<scoresUpdateInput, scoresUncheckedUpdateInput>
    /**
     * Choose, which scores to update.
     */
    where: scoresWhereUniqueInput
  }

  /**
   * scores updateMany
   */
  export type scoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update scores.
     */
    data: XOR<scoresUpdateManyMutationInput, scoresUncheckedUpdateManyInput>
    /**
     * Filter which scores to update
     */
    where?: scoresWhereInput
    /**
     * Limit how many scores to update.
     */
    limit?: number
  }

  /**
   * scores upsert
   */
  export type scoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * The filter to search for the scores to update in case it exists.
     */
    where: scoresWhereUniqueInput
    /**
     * In case the scores found by the `where` argument doesn't exist, create a new scores with this data.
     */
    create: XOR<scoresCreateInput, scoresUncheckedCreateInput>
    /**
     * In case the scores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<scoresUpdateInput, scoresUncheckedUpdateInput>
  }

  /**
   * scores delete
   */
  export type scoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
    /**
     * Filter which scores to delete.
     */
    where: scoresWhereUniqueInput
  }

  /**
   * scores deleteMany
   */
  export type scoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scores to delete
     */
    where?: scoresWhereInput
    /**
     * Limit how many scores to delete.
     */
    limit?: number
  }

  /**
   * scores without action
   */
  export type scoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scores
     */
    select?: scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scores
     */
    omit?: scoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scoresInclude<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Bytes | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Bytes | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Bytes | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>



  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }

  export type sysdiagramsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "principal_id" | "diagram_id" | "version" | "definition", ExtArgs["result"]["sysdiagrams"]>

  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Prisma.Bytes | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to update.
     */
    limit?: number
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to delete.
     */
    limit?: number
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Em_absensiScalarFieldEnum: {
    Id: 'Id',
    faceId: 'faceId',
    inDate: 'inDate',
    outDate: 'outDate',
    fileImage: 'fileImage'
  };

  export type Em_absensiScalarFieldEnum = (typeof Em_absensiScalarFieldEnum)[keyof typeof Em_absensiScalarFieldEnum]


  export const Em_apc_academyScalarFieldEnum: {
    AcademyId: 'AcademyId',
    ApcId: 'ApcId',
    SchoolName: 'SchoolName',
    Province: 'Province',
    Major: 'Major',
    Degree: 'Degree',
    EnrollDate: 'EnrollDate',
    GraduatDate: 'GraduatDate',
    IPK: 'IPK',
    OrganizeExperience: 'OrganizeExperience',
    Explain: 'Explain',
    GradeSchool: 'GradeSchool',
    DailySchedule: 'DailySchedule',
    SchoolAddress: 'SchoolAddress'
  };

  export type Em_apc_academyScalarFieldEnum = (typeof Em_apc_academyScalarFieldEnum)[keyof typeof Em_apc_academyScalarFieldEnum]


  export const Em_apc_personalScalarFieldEnum: {
    ApcId: 'ApcId',
    PossId: 'PossId',
    AboutUs: 'AboutUs',
    FullName: 'FullName',
    NickName: 'NickName',
    PlaceBirth: 'PlaceBirth',
    DateBirth: 'DateBirth',
    Age: 'Age',
    Gender: 'Gender',
    Religion: 'Religion',
    MaritalStats: 'MaritalStats',
    Citizenship: 'Citizenship',
    Province: 'Province',
    Regency: 'Regency',
    Subdistrict: 'Subdistrict',
    PostCode: 'PostCode',
    Address: 'Address',
    IdentityType: 'IdentityType',
    IdentityNumber: 'IdentityNumber',
    PhoneCode: 'PhoneCode',
    PhoneNumber: 'PhoneNumber',
    EmailAddress: 'EmailAddress',
    Height: 'Height',
    Weight: 'Weight',
    FatherName: 'FatherName',
    FatherOccupa: 'FatherOccupa',
    MotherName: 'MotherName',
    MotherOccupa: 'MotherOccupa',
    NumofSibling: 'NumofSibling',
    SiblingNote: 'SiblingNote',
    NikFileName: 'NikFileName',
    PhotoFileName: 'PhotoFileName',
    CvFileName: 'CvFileName',
    IsTransferPosst: 'IsTransferPosst',
    Status: 'Status',
    CreatedAt: 'CreatedAt',
    isHobby: 'isHobby',
    LokCat: 'LokCat',
    isSosmedId: 'isSosmedId',
    isSosmed: 'isSosmed',
    IsCall: 'IsCall',
    DateCall: 'DateCall',
    isLinked: 'isLinked',
    PossName: 'PossName'
  };

  export type Em_apc_personalScalarFieldEnum = (typeof Em_apc_personalScalarFieldEnum)[keyof typeof Em_apc_personalScalarFieldEnum]


  export const Em_apc_photographScalarFieldEnum: {
    Id: 'Id',
    ApcId: 'ApcId',
    GenrName: 'GenrName'
  };

  export type Em_apc_photographScalarFieldEnum = (typeof Em_apc_photographScalarFieldEnum)[keyof typeof Em_apc_photographScalarFieldEnum]


  export const Em_apc_regulationScalarFieldEnum: {
    ApcRegId: 'ApcRegId',
    ApcId: 'ApcId',
    RegId: 'RegId',
    RegChoice: 'RegChoice'
  };

  export type Em_apc_regulationScalarFieldEnum = (typeof Em_apc_regulationScalarFieldEnum)[keyof typeof Em_apc_regulationScalarFieldEnum]


  export const Em_apc_skill_experScalarFieldEnum: {
    SkillId: 'SkillId',
    ApcId: 'ApcId',
    CompanyName: 'CompanyName',
    Province: 'Province',
    JobTitle: 'JobTitle',
    Salary: 'Salary',
    StartDate: 'StartDate',
    EndDate: 'EndDate',
    Responsibilities: 'Responsibilities',
    CareerGoals: 'CareerGoals',
    WhyJoin: 'WhyJoin',
    IsFriend: 'IsFriend',
    IsMentions: 'IsMentions',
    IsCompProgram: 'IsCompProgram',
    IsIllnes: 'IsIllnes',
    HaveCriminal: 'HaveCriminal',
    WhenWork: 'WhenWork',
    ExpectedSalary: 'ExpectedSalary',
    isContribution: 'isContribution',
    isDuration: 'isDuration',
    isAgency: 'isAgency',
    isExprn: 'isExprn',
    isGenre: 'isGenre',
    isRelevan: 'isRelevan',
    isSpesialSkill: 'isSpesialSkill',
    isShoot: 'isShoot',
    isSchedl: 'isSchedl',
    isMotivation: 'isMotivation',
    isStress: 'isStress',
    isLongExpr: 'isLongExpr',
    isPhotTools: 'isPhotTools',
    isChalleng: 'isChalleng',
    isThreeYears: 'isThreeYears',
    PersonVal: 'PersonVal'
  };

  export type Em_apc_skill_experScalarFieldEnum = (typeof Em_apc_skill_experScalarFieldEnum)[keyof typeof Em_apc_skill_experScalarFieldEnum]


  export const Em_api_keysScalarFieldEnum: {
    id: 'id',
    username: 'username',
    api_key: 'api_key',
    created_at: 'created_at'
  };

  export type Em_api_keysScalarFieldEnum = (typeof Em_api_keysScalarFieldEnum)[keyof typeof Em_api_keysScalarFieldEnum]


  export const Em_applicant_criteriaScalarFieldEnum: {
    id_kriteria: 'id_kriteria',
    id_loker: 'id_loker',
    jenis_kriteria: 'jenis_kriteria',
    value: 'value',
    value_en: 'value_en',
    bobot: 'bobot',
    created_at: 'created_at',
    lastupdate: 'lastupdate'
  };

  export type Em_applicant_criteriaScalarFieldEnum = (typeof Em_applicant_criteriaScalarFieldEnum)[keyof typeof Em_applicant_criteriaScalarFieldEnum]


  export const Em_applicant_matchScalarFieldEnum: {
    id_match: 'id_match',
    id_applicant: 'id_applicant',
    id_loker: 'id_loker',
    pendidikan_score: 'pendidikan_score',
    jurusan_score: 'jurusan_score',
    pengalaman_score: 'pengalaman_score',
    skill_score: 'skill_score',
    bahasa_score: 'bahasa_score',
    usia_score: 'usia_score',
    total_score: 'total_score',
    total_kriteria: 'total_kriteria',
    scoring_json: 'scoring_json',
    created_at: 'created_at'
  };

  export type Em_applicant_matchScalarFieldEnum = (typeof Em_applicant_matchScalarFieldEnum)[keyof typeof Em_applicant_matchScalarFieldEnum]


  export const Em_bannerScalarFieldEnum: {
    Id: 'Id',
    bannerName: 'bannerName',
    fileName: 'fileName',
    menuName: 'menuName',
    noUrut: 'noUrut',
    Status: 'Status',
    created_at: 'created_at',
    last_update: 'last_update',
    userid: 'userid'
  };

  export type Em_bannerScalarFieldEnum = (typeof Em_bannerScalarFieldEnum)[keyof typeof Em_bannerScalarFieldEnum]


  export const Em_career_contactScalarFieldEnum: {
    cpId: 'cpId',
    companyName: 'companyName',
    email: 'email',
    waNumber: 'waNumber',
    fileImage: 'fileImage',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    userid: 'userid'
  };

  export type Em_career_contactScalarFieldEnum = (typeof Em_career_contactScalarFieldEnum)[keyof typeof Em_career_contactScalarFieldEnum]


  export const Em_certificate_fieldsScalarFieldEnum: {
    id: 'id',
    certificate_id: 'certificate_id',
    is_text: 'is_text',
    is_left: 'is_left',
    is_top: 'is_top',
    text_width: 'text_width',
    text_height: 'text_height',
    font_size: 'font_size',
    align: 'align',
    font_family: 'font_family',
    font_style: 'font_style',
    font_weight: 'font_weight',
    font_color: 'font_color',
    created_date: 'created_date',
    lastupdate: 'lastupdate'
  };

  export type Em_certificate_fieldsScalarFieldEnum = (typeof Em_certificate_fieldsScalarFieldEnum)[keyof typeof Em_certificate_fieldsScalarFieldEnum]


  export const Em_certificate_templatesScalarFieldEnum: {
    certificate_id: 'certificate_id',
    name: 'name',
    background_image: 'background_image',
    created_at: 'created_at',
    certificate_name: 'certificate_name',
    lastupdate: 'lastupdate'
  };

  export type Em_certificate_templatesScalarFieldEnum = (typeof Em_certificate_templatesScalarFieldEnum)[keyof typeof Em_certificate_templatesScalarFieldEnum]


  export const Em_certificates_resultScalarFieldEnum: {
    cert_number: 'cert_number',
    cert_templ_id: 'cert_templ_id',
    empl_id: 'empl_id',
    cert_name: 'cert_name',
    created_date: 'created_date',
    status: 'status',
    generated_by: 'generated_by',
    schedule_id: 'schedule_id'
  };

  export type Em_certificates_resultScalarFieldEnum = (typeof Em_certificates_resultScalarFieldEnum)[keyof typeof Em_certificates_resultScalarFieldEnum]


  export const Em_chanceScalarFieldEnum: {
    chId: 'chId',
    chName: 'chName',
    chDesc: 'chDesc',
    chStats: 'chStats',
    chFileImage: 'chFileImage',
    chLink: 'chLink',
    chUserid: 'chUserid',
    chDate: 'chDate',
    chLastupdate: 'chLastupdate'
  };

  export type Em_chanceScalarFieldEnum = (typeof Em_chanceScalarFieldEnum)[keyof typeof Em_chanceScalarFieldEnum]


  export const Em_contrctypeScalarFieldEnum: {
    id: 'id',
    contract_text: 'contract_text',
    status: 'status',
    lastupdate: 'lastupdate'
  };

  export type Em_contrctypeScalarFieldEnum = (typeof Em_contrctypeScalarFieldEnum)[keyof typeof Em_contrctypeScalarFieldEnum]


  export const Em_deptScalarFieldEnum: {
    DEPTID: 'DEPTID',
    DEPTNAME: 'DEPTNAME',
    sbu_sub: 'sbu_sub',
    status: 'status',
    add_by: 'add_by',
    created_at: 'created_at',
    lastupdate: 'lastupdate'
  };

  export type Em_deptScalarFieldEnum = (typeof Em_deptScalarFieldEnum)[keyof typeof Em_deptScalarFieldEnum]


  export const Em_employeeScalarFieldEnum: {
    UserId: 'UserId',
    BadgeNum: 'BadgeNum',
    Name: 'Name',
    Gender: 'Gender',
    BirthDay: 'BirthDay',
    HireDay: 'HireDay',
    Street: 'Street',
    Religion: 'Religion',
    Tipe: 'Tipe',
    isLokasi: 'isLokasi',
    Phone: 'Phone',
    DeptId: 'DeptId',
    Password: 'Password',
    CardNo: 'CardNo',
    Shift: 'Shift',
    isMem: 'isMem',
    AddBy: 'AddBy',
    Created_at: 'Created_at',
    Lastupdate: 'Lastupdate',
    isMemDate: 'isMemDate',
    isFirstLogin: 'isFirstLogin',
    ImgName: 'ImgName',
    SbuSub: 'SbuSub',
    Nik: 'Nik',
    ResignDate: 'ResignDate',
    status: 'status'
  };

  export type Em_employeeScalarFieldEnum = (typeof Em_employeeScalarFieldEnum)[keyof typeof Em_employeeScalarFieldEnum]


  export const Em_eventScalarFieldEnum: {
    event_id: 'event_id',
    event_name: 'event_name',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    lokasi: 'lokasi',
    created_date: 'created_date',
    last_update: 'last_update'
  };

  export type Em_eventScalarFieldEnum = (typeof Em_eventScalarFieldEnum)[keyof typeof Em_eventScalarFieldEnum]


  export const Em_event_regScalarFieldEnum: {
    Regid: 'Regid',
    name: 'name',
    optic_name: 'optic_name',
    password: 'password',
    wa_num: 'wa_num',
    email: 'email',
    profesi_id: 'profesi_id',
    event_id: 'event_id',
    status: 'status',
    first_login: 'first_login',
    created_date: 'created_date',
    last_update: 'last_update',
    image_name: 'image_name'
  };

  export type Em_event_regScalarFieldEnum = (typeof Em_event_regScalarFieldEnum)[keyof typeof Em_event_regScalarFieldEnum]


  export const Em_event2ScalarFieldEnum: {
    sess_id: 'sess_id',
    event_id: 'event_id',
    event_name: 'event_name',
    status: 'status',
    qr_code: 'qr_code'
  };

  export type Em_event2ScalarFieldEnum = (typeof Em_event2ScalarFieldEnum)[keyof typeof Em_event2ScalarFieldEnum]


  export const Em_exam_questionsScalarFieldEnum: {
    id: 'id',
    exam_id: 'exam_id',
    question_id: 'question_id'
  };

  export type Em_exam_questionsScalarFieldEnum = (typeof Em_exam_questionsScalarFieldEnum)[keyof typeof Em_exam_questionsScalarFieldEnum]


  export const Em_examsScalarFieldEnum: {
    id: 'id',
    exam_name: 'exam_name',
    UserId: 'UserId',
    Status: 'Status',
    LastUpdate: 'LastUpdate',
    Deskripsi: 'Deskripsi',
    FileImage: 'FileImage',
    CatType: 'CatType'
  };

  export type Em_examsScalarFieldEnum = (typeof Em_examsScalarFieldEnum)[keyof typeof Em_examsScalarFieldEnum]


  export const Em_exams_monitorScalarFieldEnum: {
    Id: 'Id',
    schedule_id: 'schedule_id',
    exams_id: 'exams_id',
    empl_id: 'empl_id',
    tipe_soal: 'tipe_soal',
    jumlah_soal: 'jumlah_soal',
    status: 'status',
    created_at: 'created_at'
  };

  export type Em_exams_monitorScalarFieldEnum = (typeof Em_exams_monitorScalarFieldEnum)[keyof typeof Em_exams_monitorScalarFieldEnum]


  export const Em_exams_resultsScalarFieldEnum: {
    Id: 'Id',
    exams_id: 'exams_id',
    empl_id: 'empl_id',
    soal_id: 'soal_id',
    is_changes: 'is_changes',
    is_answer: 'is_answer',
    is_time: 'is_time'
  };

  export type Em_exams_resultsScalarFieldEnum = (typeof Em_exams_resultsScalarFieldEnum)[keyof typeof Em_exams_resultsScalarFieldEnum]


  export const Em_faqScalarFieldEnum: {
    fqId: 'fqId',
    fqcatid: 'fqcatid',
    isquestions: 'isquestions',
    isanswer: 'isanswer',
    status: 'status',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    userid: 'userid'
  };

  export type Em_faqScalarFieldEnum = (typeof Em_faqScalarFieldEnum)[keyof typeof Em_faqScalarFieldEnum]


  export const Em_faq_catScalarFieldEnum: {
    fqcatid: 'fqcatid',
    name: 'name',
    status: 'status',
    created_at: 'created_at',
    lastupdate: 'lastupdate'
  };

  export type Em_faq_catScalarFieldEnum = (typeof Em_faq_catScalarFieldEnum)[keyof typeof Em_faq_catScalarFieldEnum]


  export const Em_galeri_materiScalarFieldEnum: {
    id: 'id',
    title: 'title',
    file_type: 'file_type',
    file_name: 'file_name',
    file_size: 'file_size',
    url: 'url',
    urutan: 'urutan',
    status: 'status',
    created_date: 'created_date',
    last_update: 'last_update'
  };

  export type Em_galeri_materiScalarFieldEnum = (typeof Em_galeri_materiScalarFieldEnum)[keyof typeof Em_galeri_materiScalarFieldEnum]


  export const Em_groupScalarFieldEnum: {
    GroupId: 'GroupId',
    GroupName: 'GroupName',
    Status: 'Status',
    CreateDate: 'CreateDate',
    LastUpdate: 'LastUpdate'
  };

  export type Em_groupScalarFieldEnum = (typeof Em_groupScalarFieldEnum)[keyof typeof Em_groupScalarFieldEnum]


  export const Em_hero_sectionScalarFieldEnum: {
    hsId: 'hsId',
    hsName: 'hsName',
    hsDesc: 'hsDesc',
    hsStats: 'hsStats',
    hsFileImage: 'hsFileImage',
    hsLink: 'hsLink',
    hsUserid: 'hsUserid',
    hsDate: 'hsDate',
    hsLastupdate: 'hsLastupdate',
    Urutan: 'Urutan'
  };

  export type Em_hero_sectionScalarFieldEnum = (typeof Em_hero_sectionScalarFieldEnum)[keyof typeof Em_hero_sectionScalarFieldEnum]


  export const Em_jawaban_pesertaScalarFieldEnum: {
    Id: 'Id',
    empl_id: 'empl_id',
    soal_id: 'soal_id',
    session_exams_id: 'session_exams_id',
    jawaban: 'jawaban',
    jawaban2: 'jawaban2',
    waktu_jawab: 'waktu_jawab',
    Score: 'Score',
    is_correction: 'is_correction',
    is_train_jawaban: 'is_train_jawaban'
  };

  export type Em_jawaban_pesertaScalarFieldEnum = (typeof Em_jawaban_pesertaScalarFieldEnum)[keyof typeof Em_jawaban_pesertaScalarFieldEnum]


  export const Em_jawaban_peserta_apcScalarFieldEnum: {
    Id: 'Id',
    apc_id: 'apc_id',
    soal_id: 'soal_id',
    topic_id: 'topic_id',
    session_exams_id: 'session_exams_id',
    jawaban_option: 'jawaban_option',
    jawaban_text: 'jawaban_text',
    waktu_jawab: 'waktu_jawab',
    score: 'score',
    is_correction: 'is_correction',
    is_train_jawaban: 'is_train_jawaban'
  };

  export type Em_jawaban_peserta_apcScalarFieldEnum = (typeof Em_jawaban_peserta_apcScalarFieldEnum)[keyof typeof Em_jawaban_peserta_apcScalarFieldEnum]


  export const Em_jobfairScalarFieldEnum: {
    id: 'id',
    lokasi: 'lokasi',
    status: 'status',
    lastupdate: 'lastupdate'
  };

  export type Em_jobfairScalarFieldEnum = (typeof Em_jobfairScalarFieldEnum)[keyof typeof Em_jobfairScalarFieldEnum]


  export const Em_levelpossScalarFieldEnum: {
    id: 'id',
    level_text: 'level_text',
    status: 'status',
    lastupdate: 'lastupdate'
  };

  export type Em_levelpossScalarFieldEnum = (typeof Em_levelpossScalarFieldEnum)[keyof typeof Em_levelpossScalarFieldEnum]


  export const Em_logsScalarFieldEnum: {
    Id: 'Id',
    IP: 'IP',
    Login: 'Login',
    Logout: 'Logout',
    UserId: 'UserId',
    LogId: 'LogId',
    Notes: 'Notes',
    LastUpdate: 'LastUpdate'
  };

  export type Em_logsScalarFieldEnum = (typeof Em_logsScalarFieldEnum)[keyof typeof Em_logsScalarFieldEnum]


  export const Em_lokerScalarFieldEnum: {
    lokerid: 'lokerid',
    possid: 'possid',
    startdate: 'startdate',
    enddate: 'enddate',
    jobdesc: 'jobdesc',
    qualify: 'qualify',
    worktype: 'worktype',
    salary: 'salary',
    contrtype: 'contrtype',
    posslevel: 'posslevel',
    status: 'status',
    benefit: 'benefit',
    fileimage: 'fileimage',
    createdate: 'createdate',
    lastupdate: 'lastupdate',
    userid: 'userid',
    kategori: 'kategori'
  };

  export type Em_lokerScalarFieldEnum = (typeof Em_lokerScalarFieldEnum)[keyof typeof Em_lokerScalarFieldEnum]


  export const Em_loktopikScalarFieldEnum: {
    id: 'id',
    loker_id: 'loker_id',
    topik_id: 'topik_id',
    jmlh_soal: 'jmlh_soal',
    created_at: 'created_at',
    possid: 'possid',
    urutan: 'urutan'
  };

  export type Em_loktopikScalarFieldEnum = (typeof Em_loktopikScalarFieldEnum)[keyof typeof Em_loktopikScalarFieldEnum]


  export const Em_materi_fileScalarFieldEnum: {
    id: 'id',
    materi_id: 'materi_id',
    file_name: 'file_name',
    file_type: 'file_type',
    file_size: 'file_size',
    url: 'url',
    urutan: 'urutan',
    judul: 'judul',
    created_at: 'created_at',
    updated_at: 'updated_at',
    galeri_id: 'galeri_id'
  };

  export type Em_materi_fileScalarFieldEnum = (typeof Em_materi_fileScalarFieldEnum)[keyof typeof Em_materi_fileScalarFieldEnum]


  export const Em_materi_kategoriScalarFieldEnum: {
    id: 'id',
    kategori_nama: 'kategori_nama',
    kategori_deskripsi: 'kategori_deskripsi',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type Em_materi_kategoriScalarFieldEnum = (typeof Em_materi_kategoriScalarFieldEnum)[keyof typeof Em_materi_kategoriScalarFieldEnum]


  export const Em_materi_typeScalarFieldEnum: {
    id: 'id',
    materi_name: 'materi_name',
    deskripsi: 'deskripsi',
    status: 'status',
    created_at: 'created_at',
    created_by: 'created_by',
    lastupdate: 'lastupdate'
  };

  export type Em_materi_typeScalarFieldEnum = (typeof Em_materi_typeScalarFieldEnum)[keyof typeof Em_materi_typeScalarFieldEnum]


  export const Em_materi1ScalarFieldEnum: {
    id: 'id',
    kode_materi: 'kode_materi',
    judul_materi: 'judul_materi',
    deskripsi_materi: 'deskripsi_materi',
    kategori: 'kategori',
    urutan: 'urutan',
    is_required: 'is_required',
    status: 'status',
    created_by: 'created_by',
    created_at: 'created_at',
    lastupdate: 'lastupdate'
  };

  export type Em_materi1ScalarFieldEnum = (typeof Em_materi1ScalarFieldEnum)[keyof typeof Em_materi1ScalarFieldEnum]


  export const Em_materi2ScalarFieldEnum: {
    id: 'id',
    materi_id: 'materi_id',
    materi_type: 'materi_type'
  };

  export type Em_materi2ScalarFieldEnum = (typeof Em_materi2ScalarFieldEnum)[keyof typeof Em_materi2ScalarFieldEnum]


  export const Em_menuScalarFieldEnum: {
    id: 'id',
    menuid: 'menuid',
    name: 'name',
    parent_id: 'parent_id',
    link: 'link',
    visible: 'visible',
    status: 'status',
    lastupdate: 'lastupdate',
    icon: 'icon',
    menutype: 'menutype'
  };

  export type Em_menuScalarFieldEnum = (typeof Em_menuScalarFieldEnum)[keyof typeof Em_menuScalarFieldEnum]


  export const Em_notifikasiScalarFieldEnum: {
    NotifyId: 'NotifyId',
    UserId: 'UserId',
    GroupId: 'GroupId',
    Note: 'Note',
    Status: 'Status',
    CreateDate: 'CreateDate',
    LastUpdate: 'LastUpdate'
  };

  export type Em_notifikasiScalarFieldEnum = (typeof Em_notifikasiScalarFieldEnum)[keyof typeof Em_notifikasiScalarFieldEnum]


  export const Em_notifikasi_readScalarFieldEnum: {
    ReadId: 'ReadId',
    NotifyId: 'NotifyId',
    UserId: 'UserId',
    ReadDate: 'ReadDate'
  };

  export type Em_notifikasi_readScalarFieldEnum = (typeof Em_notifikasi_readScalarFieldEnum)[keyof typeof Em_notifikasi_readScalarFieldEnum]


  export const Em_onboardingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    status: 'status',
    current_step: 'current_step',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Em_onboardingScalarFieldEnum = (typeof Em_onboardingScalarFieldEnum)[keyof typeof Em_onboardingScalarFieldEnum]


  export const Em_pilarScalarFieldEnum: {
    id: 'id',
    pilar_name: 'pilar_name',
    status: 'status',
    add_by: 'add_by',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    description: 'description',
    pic: 'pic'
  };

  export type Em_pilarScalarFieldEnum = (typeof Em_pilarScalarFieldEnum)[keyof typeof Em_pilarScalarFieldEnum]


  export const Em_profesiScalarFieldEnum: {
    profesi_id: 'profesi_id',
    profesi_name: 'profesi_name',
    status: 'status',
    created_date: 'created_date',
    last_update: 'last_update'
  };

  export type Em_profesiScalarFieldEnum = (typeof Em_profesiScalarFieldEnum)[keyof typeof Em_profesiScalarFieldEnum]


  export const Em_questions1ScalarFieldEnum: {
    id: 'id',
    question_text: 'question_text',
    question_type: 'question_type',
    correct_answer: 'correct_answer',
    correct_answer2: 'correct_answer2',
    exam_id: 'exam_id',
    time_limit: 'time_limit',
    score: 'score',
    status: 'status',
    userid: 'userid',
    qdate: 'qdate',
    lastupdate: 'lastupdate',
    fileimage: 'fileimage',
    isExams: 'isExams',
    isLevel: 'isLevel'
  };

  export type Em_questions1ScalarFieldEnum = (typeof Em_questions1ScalarFieldEnum)[keyof typeof Em_questions1ScalarFieldEnum]


  export const Em_questions2ScalarFieldEnum: {
    Id: 'Id',
    question_id: 'question_id',
    option_choices: 'option_choices',
    option_text: 'option_text'
  };

  export type Em_questions2ScalarFieldEnum = (typeof Em_questions2ScalarFieldEnum)[keyof typeof Em_questions2ScalarFieldEnum]


  export const Em_questtypeScalarFieldEnum: {
    Id: 'Id',
    TypeName: 'TypeName',
    Status: 'Status'
  };

  export type Em_questtypeScalarFieldEnum = (typeof Em_questtypeScalarFieldEnum)[keyof typeof Em_questtypeScalarFieldEnum]


  export const Em_regulationsScalarFieldEnum: {
    Id: 'Id',
    chanceId: 'chanceId',
    regName: 'regName',
    urut: 'urut',
    status: 'status',
    userid: 'userid',
    createDate: 'createDate',
    lastUpdate: 'lastUpdate'
  };

  export type Em_regulationsScalarFieldEnum = (typeof Em_regulationsScalarFieldEnum)[keyof typeof Em_regulationsScalarFieldEnum]


  export const Em_sbuScalarFieldEnum: {
    id: 'id',
    sbu_code: 'sbu_code',
    sbu_name: 'sbu_name',
    sbu_pilar: 'sbu_pilar',
    status: 'status',
    add_by: 'add_by',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    description: 'description',
    pic: 'pic'
  };

  export type Em_sbuScalarFieldEnum = (typeof Em_sbuScalarFieldEnum)[keyof typeof Em_sbuScalarFieldEnum]


  export const Em_sbu_subScalarFieldEnum: {
    id: 'id',
    sbu_sub_code: 'sbu_sub_code',
    sbu_sub_name: 'sbu_sub_name',
    sbu_id: 'sbu_id',
    sbu_pilar: 'sbu_pilar',
    status: 'status',
    add_by: 'add_by',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    description: 'description',
    pic: 'pic'
  };

  export type Em_sbu_subScalarFieldEnum = (typeof Em_sbu_subScalarFieldEnum)[keyof typeof Em_sbu_subScalarFieldEnum]


  export const Em_schedule1ScalarFieldEnum: {
    Id: 'Id',
    scheName: 'scheName',
    scheDeskripsi: 'scheDeskripsi',
    isMateri: 'isMateri',
    isQuota: 'isQuota',
    startDate: 'startDate',
    endDate: 'endDate',
    startTime: 'startTime',
    endTime: 'endTime',
    isLokasi: 'isLokasi',
    isTrainer: 'isTrainer',
    status: 'status',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    sendWA: 'sendWA',
    ujian_stats: 'ujian_stats',
    is_with_soal: 'is_with_soal',
    usr_by: 'usr_by',
    is_wa_template: 'is_wa_template',
    is_batch: 'is_batch',
    event_id: 'event_id'
  };

  export type Em_schedule1ScalarFieldEnum = (typeof Em_schedule1ScalarFieldEnum)[keyof typeof Em_schedule1ScalarFieldEnum]


  export const Em_schedule2ScalarFieldEnum: {
    Id: 'Id',
    scheduleId: 'scheduleId',
    employeeId: 'employeeId',
    Regid: 'Regid',
    is_send_wa_stats: 'is_send_wa_stats',
    send_date: 'send_date',
    is_code_send: 'is_code_send'
  };

  export type Em_schedule2ScalarFieldEnum = (typeof Em_schedule2ScalarFieldEnum)[keyof typeof Em_schedule2ScalarFieldEnum]


  export const Em_schedule3ScalarFieldEnum: {
    Id: 'Id',
    scheduleId: 'scheduleId',
    soalId: 'soalId',
    urutanSoal: 'urutanSoal',
    materiId: 'materiId',
    urutanTipeSoal: 'urutanTipeSoal',
    tipeSoal: 'tipeSoal'
  };

  export type Em_schedule3ScalarFieldEnum = (typeof Em_schedule3ScalarFieldEnum)[keyof typeof Em_schedule3ScalarFieldEnum]


  export const Em_schedule4ScalarFieldEnum: {
    Id: 'Id',
    scheduleId: 'scheduleId',
    tipeSoal: 'tipeSoal',
    jumlahSoal: 'jumlahSoal',
    durasiPerTipe: 'durasiPerTipe'
  };

  export type Em_schedule4ScalarFieldEnum = (typeof Em_schedule4ScalarFieldEnum)[keyof typeof Em_schedule4ScalarFieldEnum]


  export const Em_session_examsScalarFieldEnum: {
    Id: 'Id',
    schedule_id: 'schedule_id',
    exams_id: 'exams_id',
    empl_id: 'empl_id',
    soal_urut: 'soal_urut',
    start_time: 'start_time',
    end_time: 'end_time',
    is_selesai: 'is_selesai',
    is_token: 'is_token',
    is_token_expr: 'is_token_expr',
    durasi: 'durasi',
    is_correct: 'is_correct',
    is_notes: 'is_notes',
    is_score_akhir: 'is_score_akhir'
  };

  export type Em_session_examsScalarFieldEnum = (typeof Em_session_examsScalarFieldEnum)[keyof typeof Em_session_examsScalarFieldEnum]


  export const Em_session_exams_apcScalarFieldEnum: {
    Id: 'Id',
    lokerid: 'lokerid',
    exams_id: 'exams_id',
    apcid: 'apcid',
    soal_urut: 'soal_urut',
    start_time: 'start_time',
    end_time: 'end_time',
    is_selesai: 'is_selesai',
    is_token: 'is_token',
    is_token_expr: 'is_token_expr',
    durasi: 'durasi',
    is_correct: 'is_correct',
    is_notes: 'is_notes',
    is_score_akhir: 'is_score_akhir',
    curr_topic_index: 'curr_topic_index',
    curr_soal_index: 'curr_soal_index',
    is_intro_topic: 'is_intro_topic',
    is_jawaban_kosong: 'is_jawaban_kosong'
  };

  export type Em_session_exams_apcScalarFieldEnum = (typeof Em_session_exams_apcScalarFieldEnum)[keyof typeof Em_session_exams_apcScalarFieldEnum]


  export const Em_subscribeScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    Name: 'Name',
    Status: 'Status',
    Endpoint: 'Endpoint',
    P256dh: 'P256dh',
    Auth: 'Auth',
    Created_at: 'Created_at',
    LastUpdate: 'LastUpdate'
  };

  export type Em_subscribeScalarFieldEnum = (typeof Em_subscribeScalarFieldEnum)[keyof typeof Em_subscribeScalarFieldEnum]


  export const Em_subscriptionScalarFieldEnum: {
    Id: 'Id',
    username: 'username',
    subscription: 'subscription',
    status: 'status',
    createdat: 'createdat'
  };

  export type Em_subscriptionScalarFieldEnum = (typeof Em_subscriptionScalarFieldEnum)[keyof typeof Em_subscriptionScalarFieldEnum]


  export const Em_topic_selesaiScalarFieldEnum: {
    id: 'id',
    session_exams_id: 'session_exams_id',
    apc_id: 'apc_id',
    topic_id: 'topic_id',
    selesai_at: 'selesai_at'
  };

  export type Em_topic_selesaiScalarFieldEnum = (typeof Em_topic_selesaiScalarFieldEnum)[keyof typeof Em_topic_selesaiScalarFieldEnum]


  export const Em_user_answers1ScalarFieldEnum: {
    Id: 'Id',
    apcid: 'apcid',
    topic_id: 'topic_id',
    status: 'status',
    startdate: 'startdate'
  };

  export type Em_user_answers1ScalarFieldEnum = (typeof Em_user_answers1ScalarFieldEnum)[keyof typeof Em_user_answers1ScalarFieldEnum]


  export const Em_user_dashboardScalarFieldEnum: {
    UserId: 'UserId',
    Username: 'Username',
    Password: 'Password',
    FullName: 'FullName',
    RoleId: 'RoleId',
    Status: 'Status',
    CreateDate: 'CreateDate',
    LastUpdate: 'LastUpdate',
    GroupId: 'GroupId'
  };

  export type Em_user_dashboardScalarFieldEnum = (typeof Em_user_dashboardScalarFieldEnum)[keyof typeof Em_user_dashboardScalarFieldEnum]


  export const Em_user_listScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    menuid: 'menuid',
    visible: 'visible',
    lastupdate: 'lastupdate'
  };

  export type Em_user_listScalarFieldEnum = (typeof Em_user_listScalarFieldEnum)[keyof typeof Em_user_listScalarFieldEnum]


  export const Em_usersScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    Username: 'Username',
    Password: 'Password',
    LastUpdate: 'LastUpdate',
    LevelId: 'LevelId',
    Name: 'Name',
    Status: 'Status',
    imagename: 'imagename',
    Pass_Access_Menu: 'Pass_Access_Menu'
  };

  export type Em_usersScalarFieldEnum = (typeof Em_usersScalarFieldEnum)[keyof typeof Em_usersScalarFieldEnum]


  export const Em_verify_linksScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    token: 'token',
    expires_at: 'expires_at',
    created_at: 'created_at',
    status: 'status',
    useragent: 'useragent',
    ipaddress: 'ipaddress',
    browser: 'browser',
    platform: 'platform',
    device: 'device'
  };

  export type Em_verify_linksScalarFieldEnum = (typeof Em_verify_linksScalarFieldEnum)[keyof typeof Em_verify_linksScalarFieldEnum]


  export const Em_wa_templatesScalarFieldEnum: {
    id: 'id',
    template_name: 'template_name',
    template_text: 'template_text',
    add_by: 'add_by',
    created_at: 'created_at',
    lastupdate: 'lastupdate',
    status: 'status',
    tpfor: 'tpfor'
  };

  export type Em_wa_templatesScalarFieldEnum = (typeof Em_wa_templatesScalarFieldEnum)[keyof typeof Em_wa_templatesScalarFieldEnum]


  export const Em_worktypeScalarFieldEnum: {
    id: 'id',
    worktype_text: 'worktype_text',
    status: 'status',
    lastupdate: 'lastupdate'
  };

  export type Em_worktypeScalarFieldEnum = (typeof Em_worktypeScalarFieldEnum)[keyof typeof Em_worktypeScalarFieldEnum]


  export const Em_xquetestScalarFieldEnum: {
    ID: 'ID',
    q_id: 'q_id',
    question_text: 'question_text'
  };

  export type Em_xquetestScalarFieldEnum = (typeof Em_xquetestScalarFieldEnum)[keyof typeof Em_xquetestScalarFieldEnum]


  export const EmappScalarFieldEnum: {
    AppId: 'AppId',
    AppName: 'AppName',
    AppPoss: 'AppPoss',
    AppWa: 'AppWa',
    AppMail: 'AppMail',
    AppAge: 'AppAge',
    AppJk: 'AppJk',
    AppAddres: 'AppAddres',
    AppFakt: 'AppFakt',
    AppFileName: 'AppFileName',
    AppLastUpdate: 'AppLastUpdate',
    AppDate: 'AppDate',
    AppStatus: 'AppStatus',
    IsCall: 'IsCall',
    DateCall: 'DateCall',
    JobsIs: 'JobsIs',
    JFStats: 'JFStats',
    LokasiId: 'LokasiId'
  };

  export type EmappScalarFieldEnum = (typeof EmappScalarFieldEnum)[keyof typeof EmappScalarFieldEnum]


  export const EmpasswScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Pass: 'Pass',
    Level: 'Level'
  };

  export type EmpasswScalarFieldEnum = (typeof EmpasswScalarFieldEnum)[keyof typeof EmpasswScalarFieldEnum]


  export const EmpossScalarFieldEnum: {
    Id: 'Id',
    PossName: 'PossName',
    Status: 'Status',
    UserId: 'UserId',
    LastUpdate: 'LastUpdate'
  };

  export type EmpossScalarFieldEnum = (typeof EmpossScalarFieldEnum)[keyof typeof EmpossScalarFieldEnum]


  export const FaceusersScalarFieldEnum: {
    Id: 'Id',
    name: 'name',
    fileimage: 'fileimage',
    descriptor: 'descriptor',
    pose: 'pose',
    created_at: 'created_at',
    lastupdate: 'lastupdate'
  };

  export type FaceusersScalarFieldEnum = (typeof FaceusersScalarFieldEnum)[keyof typeof FaceusersScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parent_id: 'parent_id',
    link: 'link',
    visible: 'visible',
    role: 'role'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const ScoresScalarFieldEnum: {
    id: 'id',
    exam_id: 'exam_id',
    user_id: 'user_id',
    total_score: 'total_score',
    created_at: 'created_at'
  };

  export type ScoresScalarFieldEnum = (typeof ScoresScalarFieldEnum)[keyof typeof ScoresScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    
  /**
   * Deep Input Types
   */


  export type em_absensiWhereInput = {
    AND?: em_absensiWhereInput | em_absensiWhereInput[]
    OR?: em_absensiWhereInput[]
    NOT?: em_absensiWhereInput | em_absensiWhereInput[]
    Id?: IntFilter<"em_absensi"> | number
    faceId?: IntNullableFilter<"em_absensi"> | number | null
    inDate?: DateTimeNullableFilter<"em_absensi"> | Date | string | null
    outDate?: DateTimeNullableFilter<"em_absensi"> | Date | string | null
    fileImage?: StringNullableFilter<"em_absensi"> | string | null
  }

  export type em_absensiOrderByWithRelationInput = {
    Id?: SortOrder
    faceId?: SortOrderInput | SortOrder
    inDate?: SortOrderInput | SortOrder
    outDate?: SortOrderInput | SortOrder
    fileImage?: SortOrderInput | SortOrder
  }

  export type em_absensiWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_absensiWhereInput | em_absensiWhereInput[]
    OR?: em_absensiWhereInput[]
    NOT?: em_absensiWhereInput | em_absensiWhereInput[]
    faceId?: IntNullableFilter<"em_absensi"> | number | null
    inDate?: DateTimeNullableFilter<"em_absensi"> | Date | string | null
    outDate?: DateTimeNullableFilter<"em_absensi"> | Date | string | null
    fileImage?: StringNullableFilter<"em_absensi"> | string | null
  }, "Id">

  export type em_absensiOrderByWithAggregationInput = {
    Id?: SortOrder
    faceId?: SortOrderInput | SortOrder
    inDate?: SortOrderInput | SortOrder
    outDate?: SortOrderInput | SortOrder
    fileImage?: SortOrderInput | SortOrder
    _count?: em_absensiCountOrderByAggregateInput
    _avg?: em_absensiAvgOrderByAggregateInput
    _max?: em_absensiMaxOrderByAggregateInput
    _min?: em_absensiMinOrderByAggregateInput
    _sum?: em_absensiSumOrderByAggregateInput
  }

  export type em_absensiScalarWhereWithAggregatesInput = {
    AND?: em_absensiScalarWhereWithAggregatesInput | em_absensiScalarWhereWithAggregatesInput[]
    OR?: em_absensiScalarWhereWithAggregatesInput[]
    NOT?: em_absensiScalarWhereWithAggregatesInput | em_absensiScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_absensi"> | number
    faceId?: IntNullableWithAggregatesFilter<"em_absensi"> | number | null
    inDate?: DateTimeNullableWithAggregatesFilter<"em_absensi"> | Date | string | null
    outDate?: DateTimeNullableWithAggregatesFilter<"em_absensi"> | Date | string | null
    fileImage?: StringNullableWithAggregatesFilter<"em_absensi"> | string | null
  }

  export type em_apc_academyWhereInput = {
    AND?: em_apc_academyWhereInput | em_apc_academyWhereInput[]
    OR?: em_apc_academyWhereInput[]
    NOT?: em_apc_academyWhereInput | em_apc_academyWhereInput[]
    AcademyId?: IntFilter<"em_apc_academy"> | number
    ApcId?: IntFilter<"em_apc_academy"> | number
    SchoolName?: StringNullableFilter<"em_apc_academy"> | string | null
    Province?: StringNullableFilter<"em_apc_academy"> | string | null
    Major?: StringNullableFilter<"em_apc_academy"> | string | null
    Degree?: StringNullableFilter<"em_apc_academy"> | string | null
    EnrollDate?: DateTimeNullableFilter<"em_apc_academy"> | Date | string | null
    GraduatDate?: DateTimeNullableFilter<"em_apc_academy"> | Date | string | null
    IPK?: FloatNullableFilter<"em_apc_academy"> | number | null
    OrganizeExperience?: StringNullableFilter<"em_apc_academy"> | string | null
    Explain?: StringNullableFilter<"em_apc_academy"> | string | null
    GradeSchool?: StringNullableFilter<"em_apc_academy"> | string | null
    DailySchedule?: StringNullableFilter<"em_apc_academy"> | string | null
    SchoolAddress?: StringNullableFilter<"em_apc_academy"> | string | null
    em_apc_personal?: XOR<Em_apc_personalScalarRelationFilter, em_apc_personalWhereInput>
  }

  export type em_apc_academyOrderByWithRelationInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    SchoolName?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    Major?: SortOrderInput | SortOrder
    Degree?: SortOrderInput | SortOrder
    EnrollDate?: SortOrderInput | SortOrder
    GraduatDate?: SortOrderInput | SortOrder
    IPK?: SortOrderInput | SortOrder
    OrganizeExperience?: SortOrderInput | SortOrder
    Explain?: SortOrderInput | SortOrder
    GradeSchool?: SortOrderInput | SortOrder
    DailySchedule?: SortOrderInput | SortOrder
    SchoolAddress?: SortOrderInput | SortOrder
    em_apc_personal?: em_apc_personalOrderByWithRelationInput
  }

  export type em_apc_academyWhereUniqueInput = Prisma.AtLeast<{
    AcademyId?: number
    AND?: em_apc_academyWhereInput | em_apc_academyWhereInput[]
    OR?: em_apc_academyWhereInput[]
    NOT?: em_apc_academyWhereInput | em_apc_academyWhereInput[]
    ApcId?: IntFilter<"em_apc_academy"> | number
    SchoolName?: StringNullableFilter<"em_apc_academy"> | string | null
    Province?: StringNullableFilter<"em_apc_academy"> | string | null
    Major?: StringNullableFilter<"em_apc_academy"> | string | null
    Degree?: StringNullableFilter<"em_apc_academy"> | string | null
    EnrollDate?: DateTimeNullableFilter<"em_apc_academy"> | Date | string | null
    GraduatDate?: DateTimeNullableFilter<"em_apc_academy"> | Date | string | null
    IPK?: FloatNullableFilter<"em_apc_academy"> | number | null
    OrganizeExperience?: StringNullableFilter<"em_apc_academy"> | string | null
    Explain?: StringNullableFilter<"em_apc_academy"> | string | null
    GradeSchool?: StringNullableFilter<"em_apc_academy"> | string | null
    DailySchedule?: StringNullableFilter<"em_apc_academy"> | string | null
    SchoolAddress?: StringNullableFilter<"em_apc_academy"> | string | null
    em_apc_personal?: XOR<Em_apc_personalScalarRelationFilter, em_apc_personalWhereInput>
  }, "AcademyId">

  export type em_apc_academyOrderByWithAggregationInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    SchoolName?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    Major?: SortOrderInput | SortOrder
    Degree?: SortOrderInput | SortOrder
    EnrollDate?: SortOrderInput | SortOrder
    GraduatDate?: SortOrderInput | SortOrder
    IPK?: SortOrderInput | SortOrder
    OrganizeExperience?: SortOrderInput | SortOrder
    Explain?: SortOrderInput | SortOrder
    GradeSchool?: SortOrderInput | SortOrder
    DailySchedule?: SortOrderInput | SortOrder
    SchoolAddress?: SortOrderInput | SortOrder
    _count?: em_apc_academyCountOrderByAggregateInput
    _avg?: em_apc_academyAvgOrderByAggregateInput
    _max?: em_apc_academyMaxOrderByAggregateInput
    _min?: em_apc_academyMinOrderByAggregateInput
    _sum?: em_apc_academySumOrderByAggregateInput
  }

  export type em_apc_academyScalarWhereWithAggregatesInput = {
    AND?: em_apc_academyScalarWhereWithAggregatesInput | em_apc_academyScalarWhereWithAggregatesInput[]
    OR?: em_apc_academyScalarWhereWithAggregatesInput[]
    NOT?: em_apc_academyScalarWhereWithAggregatesInput | em_apc_academyScalarWhereWithAggregatesInput[]
    AcademyId?: IntWithAggregatesFilter<"em_apc_academy"> | number
    ApcId?: IntWithAggregatesFilter<"em_apc_academy"> | number
    SchoolName?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    Province?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    Major?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    Degree?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    EnrollDate?: DateTimeNullableWithAggregatesFilter<"em_apc_academy"> | Date | string | null
    GraduatDate?: DateTimeNullableWithAggregatesFilter<"em_apc_academy"> | Date | string | null
    IPK?: FloatNullableWithAggregatesFilter<"em_apc_academy"> | number | null
    OrganizeExperience?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    Explain?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    GradeSchool?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    DailySchedule?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
    SchoolAddress?: StringNullableWithAggregatesFilter<"em_apc_academy"> | string | null
  }

  export type em_apc_personalWhereInput = {
    AND?: em_apc_personalWhereInput | em_apc_personalWhereInput[]
    OR?: em_apc_personalWhereInput[]
    NOT?: em_apc_personalWhereInput | em_apc_personalWhereInput[]
    ApcId?: IntFilter<"em_apc_personal"> | number
    PossId?: IntNullableFilter<"em_apc_personal"> | number | null
    AboutUs?: StringNullableFilter<"em_apc_personal"> | string | null
    FullName?: StringNullableFilter<"em_apc_personal"> | string | null
    NickName?: StringNullableFilter<"em_apc_personal"> | string | null
    PlaceBirth?: StringNullableFilter<"em_apc_personal"> | string | null
    DateBirth?: DateTimeNullableFilter<"em_apc_personal"> | Date | string | null
    Age?: IntNullableFilter<"em_apc_personal"> | number | null
    Gender?: IntNullableFilter<"em_apc_personal"> | number | null
    Religion?: IntNullableFilter<"em_apc_personal"> | number | null
    MaritalStats?: IntNullableFilter<"em_apc_personal"> | number | null
    Citizenship?: IntNullableFilter<"em_apc_personal"> | number | null
    Province?: IntNullableFilter<"em_apc_personal"> | number | null
    Regency?: IntNullableFilter<"em_apc_personal"> | number | null
    Subdistrict?: IntNullableFilter<"em_apc_personal"> | number | null
    PostCode?: StringNullableFilter<"em_apc_personal"> | string | null
    Address?: StringNullableFilter<"em_apc_personal"> | string | null
    IdentityType?: StringNullableFilter<"em_apc_personal"> | string | null
    IdentityNumber?: StringNullableFilter<"em_apc_personal"> | string | null
    PhoneCode?: IntNullableFilter<"em_apc_personal"> | number | null
    PhoneNumber?: StringNullableFilter<"em_apc_personal"> | string | null
    EmailAddress?: StringNullableFilter<"em_apc_personal"> | string | null
    Height?: IntNullableFilter<"em_apc_personal"> | number | null
    Weight?: IntNullableFilter<"em_apc_personal"> | number | null
    FatherName?: StringNullableFilter<"em_apc_personal"> | string | null
    FatherOccupa?: StringNullableFilter<"em_apc_personal"> | string | null
    MotherName?: StringNullableFilter<"em_apc_personal"> | string | null
    MotherOccupa?: StringNullableFilter<"em_apc_personal"> | string | null
    NumofSibling?: IntNullableFilter<"em_apc_personal"> | number | null
    SiblingNote?: StringNullableFilter<"em_apc_personal"> | string | null
    NikFileName?: StringNullableFilter<"em_apc_personal"> | string | null
    PhotoFileName?: StringNullableFilter<"em_apc_personal"> | string | null
    CvFileName?: StringNullableFilter<"em_apc_personal"> | string | null
    IsTransferPosst?: StringNullableFilter<"em_apc_personal"> | string | null
    Status?: StringNullableFilter<"em_apc_personal"> | string | null
    CreatedAt?: DateTimeNullableFilter<"em_apc_personal"> | Date | string | null
    isHobby?: StringNullableFilter<"em_apc_personal"> | string | null
    LokCat?: IntNullableFilter<"em_apc_personal"> | number | null
    isSosmedId?: IntNullableFilter<"em_apc_personal"> | number | null
    isSosmed?: StringNullableFilter<"em_apc_personal"> | string | null
    IsCall?: IntNullableFilter<"em_apc_personal"> | number | null
    DateCall?: DateTimeNullableFilter<"em_apc_personal"> | Date | string | null
    isLinked?: StringNullableFilter<"em_apc_personal"> | string | null
    PossName?: StringNullableFilter<"em_apc_personal"> | string | null
    em_apc_academy?: Em_apc_academyListRelationFilter
    em_apc_photograph?: Em_apc_photographListRelationFilter
    em_apc_regulation?: Em_apc_regulationListRelationFilter
    em_apc_skill_exper?: Em_apc_skill_experListRelationFilter
    em_applicant_match?: Em_applicant_matchListRelationFilter
  }

  export type em_apc_personalOrderByWithRelationInput = {
    ApcId?: SortOrder
    PossId?: SortOrderInput | SortOrder
    AboutUs?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    NickName?: SortOrderInput | SortOrder
    PlaceBirth?: SortOrderInput | SortOrder
    DateBirth?: SortOrderInput | SortOrder
    Age?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    Religion?: SortOrderInput | SortOrder
    MaritalStats?: SortOrderInput | SortOrder
    Citizenship?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    Regency?: SortOrderInput | SortOrder
    Subdistrict?: SortOrderInput | SortOrder
    PostCode?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    IdentityType?: SortOrderInput | SortOrder
    IdentityNumber?: SortOrderInput | SortOrder
    PhoneCode?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    EmailAddress?: SortOrderInput | SortOrder
    Height?: SortOrderInput | SortOrder
    Weight?: SortOrderInput | SortOrder
    FatherName?: SortOrderInput | SortOrder
    FatherOccupa?: SortOrderInput | SortOrder
    MotherName?: SortOrderInput | SortOrder
    MotherOccupa?: SortOrderInput | SortOrder
    NumofSibling?: SortOrderInput | SortOrder
    SiblingNote?: SortOrderInput | SortOrder
    NikFileName?: SortOrderInput | SortOrder
    PhotoFileName?: SortOrderInput | SortOrder
    CvFileName?: SortOrderInput | SortOrder
    IsTransferPosst?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    isHobby?: SortOrderInput | SortOrder
    LokCat?: SortOrderInput | SortOrder
    isSosmedId?: SortOrderInput | SortOrder
    isSosmed?: SortOrderInput | SortOrder
    IsCall?: SortOrderInput | SortOrder
    DateCall?: SortOrderInput | SortOrder
    isLinked?: SortOrderInput | SortOrder
    PossName?: SortOrderInput | SortOrder
    em_apc_academy?: em_apc_academyOrderByRelationAggregateInput
    em_apc_photograph?: em_apc_photographOrderByRelationAggregateInput
    em_apc_regulation?: em_apc_regulationOrderByRelationAggregateInput
    em_apc_skill_exper?: em_apc_skill_experOrderByRelationAggregateInput
    em_applicant_match?: em_applicant_matchOrderByRelationAggregateInput
  }

  export type em_apc_personalWhereUniqueInput = Prisma.AtLeast<{
    ApcId?: number
    AND?: em_apc_personalWhereInput | em_apc_personalWhereInput[]
    OR?: em_apc_personalWhereInput[]
    NOT?: em_apc_personalWhereInput | em_apc_personalWhereInput[]
    PossId?: IntNullableFilter<"em_apc_personal"> | number | null
    AboutUs?: StringNullableFilter<"em_apc_personal"> | string | null
    FullName?: StringNullableFilter<"em_apc_personal"> | string | null
    NickName?: StringNullableFilter<"em_apc_personal"> | string | null
    PlaceBirth?: StringNullableFilter<"em_apc_personal"> | string | null
    DateBirth?: DateTimeNullableFilter<"em_apc_personal"> | Date | string | null
    Age?: IntNullableFilter<"em_apc_personal"> | number | null
    Gender?: IntNullableFilter<"em_apc_personal"> | number | null
    Religion?: IntNullableFilter<"em_apc_personal"> | number | null
    MaritalStats?: IntNullableFilter<"em_apc_personal"> | number | null
    Citizenship?: IntNullableFilter<"em_apc_personal"> | number | null
    Province?: IntNullableFilter<"em_apc_personal"> | number | null
    Regency?: IntNullableFilter<"em_apc_personal"> | number | null
    Subdistrict?: IntNullableFilter<"em_apc_personal"> | number | null
    PostCode?: StringNullableFilter<"em_apc_personal"> | string | null
    Address?: StringNullableFilter<"em_apc_personal"> | string | null
    IdentityType?: StringNullableFilter<"em_apc_personal"> | string | null
    IdentityNumber?: StringNullableFilter<"em_apc_personal"> | string | null
    PhoneCode?: IntNullableFilter<"em_apc_personal"> | number | null
    PhoneNumber?: StringNullableFilter<"em_apc_personal"> | string | null
    EmailAddress?: StringNullableFilter<"em_apc_personal"> | string | null
    Height?: IntNullableFilter<"em_apc_personal"> | number | null
    Weight?: IntNullableFilter<"em_apc_personal"> | number | null
    FatherName?: StringNullableFilter<"em_apc_personal"> | string | null
    FatherOccupa?: StringNullableFilter<"em_apc_personal"> | string | null
    MotherName?: StringNullableFilter<"em_apc_personal"> | string | null
    MotherOccupa?: StringNullableFilter<"em_apc_personal"> | string | null
    NumofSibling?: IntNullableFilter<"em_apc_personal"> | number | null
    SiblingNote?: StringNullableFilter<"em_apc_personal"> | string | null
    NikFileName?: StringNullableFilter<"em_apc_personal"> | string | null
    PhotoFileName?: StringNullableFilter<"em_apc_personal"> | string | null
    CvFileName?: StringNullableFilter<"em_apc_personal"> | string | null
    IsTransferPosst?: StringNullableFilter<"em_apc_personal"> | string | null
    Status?: StringNullableFilter<"em_apc_personal"> | string | null
    CreatedAt?: DateTimeNullableFilter<"em_apc_personal"> | Date | string | null
    isHobby?: StringNullableFilter<"em_apc_personal"> | string | null
    LokCat?: IntNullableFilter<"em_apc_personal"> | number | null
    isSosmedId?: IntNullableFilter<"em_apc_personal"> | number | null
    isSosmed?: StringNullableFilter<"em_apc_personal"> | string | null
    IsCall?: IntNullableFilter<"em_apc_personal"> | number | null
    DateCall?: DateTimeNullableFilter<"em_apc_personal"> | Date | string | null
    isLinked?: StringNullableFilter<"em_apc_personal"> | string | null
    PossName?: StringNullableFilter<"em_apc_personal"> | string | null
    em_apc_academy?: Em_apc_academyListRelationFilter
    em_apc_photograph?: Em_apc_photographListRelationFilter
    em_apc_regulation?: Em_apc_regulationListRelationFilter
    em_apc_skill_exper?: Em_apc_skill_experListRelationFilter
    em_applicant_match?: Em_applicant_matchListRelationFilter
  }, "ApcId">

  export type em_apc_personalOrderByWithAggregationInput = {
    ApcId?: SortOrder
    PossId?: SortOrderInput | SortOrder
    AboutUs?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    NickName?: SortOrderInput | SortOrder
    PlaceBirth?: SortOrderInput | SortOrder
    DateBirth?: SortOrderInput | SortOrder
    Age?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    Religion?: SortOrderInput | SortOrder
    MaritalStats?: SortOrderInput | SortOrder
    Citizenship?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    Regency?: SortOrderInput | SortOrder
    Subdistrict?: SortOrderInput | SortOrder
    PostCode?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    IdentityType?: SortOrderInput | SortOrder
    IdentityNumber?: SortOrderInput | SortOrder
    PhoneCode?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    EmailAddress?: SortOrderInput | SortOrder
    Height?: SortOrderInput | SortOrder
    Weight?: SortOrderInput | SortOrder
    FatherName?: SortOrderInput | SortOrder
    FatherOccupa?: SortOrderInput | SortOrder
    MotherName?: SortOrderInput | SortOrder
    MotherOccupa?: SortOrderInput | SortOrder
    NumofSibling?: SortOrderInput | SortOrder
    SiblingNote?: SortOrderInput | SortOrder
    NikFileName?: SortOrderInput | SortOrder
    PhotoFileName?: SortOrderInput | SortOrder
    CvFileName?: SortOrderInput | SortOrder
    IsTransferPosst?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    isHobby?: SortOrderInput | SortOrder
    LokCat?: SortOrderInput | SortOrder
    isSosmedId?: SortOrderInput | SortOrder
    isSosmed?: SortOrderInput | SortOrder
    IsCall?: SortOrderInput | SortOrder
    DateCall?: SortOrderInput | SortOrder
    isLinked?: SortOrderInput | SortOrder
    PossName?: SortOrderInput | SortOrder
    _count?: em_apc_personalCountOrderByAggregateInput
    _avg?: em_apc_personalAvgOrderByAggregateInput
    _max?: em_apc_personalMaxOrderByAggregateInput
    _min?: em_apc_personalMinOrderByAggregateInput
    _sum?: em_apc_personalSumOrderByAggregateInput
  }

  export type em_apc_personalScalarWhereWithAggregatesInput = {
    AND?: em_apc_personalScalarWhereWithAggregatesInput | em_apc_personalScalarWhereWithAggregatesInput[]
    OR?: em_apc_personalScalarWhereWithAggregatesInput[]
    NOT?: em_apc_personalScalarWhereWithAggregatesInput | em_apc_personalScalarWhereWithAggregatesInput[]
    ApcId?: IntWithAggregatesFilter<"em_apc_personal"> | number
    PossId?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    AboutUs?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    FullName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    NickName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    PlaceBirth?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    DateBirth?: DateTimeNullableWithAggregatesFilter<"em_apc_personal"> | Date | string | null
    Age?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Gender?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Religion?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    MaritalStats?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Citizenship?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Province?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Regency?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Subdistrict?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    PostCode?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    Address?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    IdentityType?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    IdentityNumber?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    PhoneCode?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    EmailAddress?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    Height?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    Weight?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    FatherName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    FatherOccupa?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    MotherName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    MotherOccupa?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    NumofSibling?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    SiblingNote?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    NikFileName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    PhotoFileName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    CvFileName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    IsTransferPosst?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    Status?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"em_apc_personal"> | Date | string | null
    isHobby?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    LokCat?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    isSosmedId?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    isSosmed?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    IsCall?: IntNullableWithAggregatesFilter<"em_apc_personal"> | number | null
    DateCall?: DateTimeNullableWithAggregatesFilter<"em_apc_personal"> | Date | string | null
    isLinked?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
    PossName?: StringNullableWithAggregatesFilter<"em_apc_personal"> | string | null
  }

  export type em_apc_photographWhereInput = {
    AND?: em_apc_photographWhereInput | em_apc_photographWhereInput[]
    OR?: em_apc_photographWhereInput[]
    NOT?: em_apc_photographWhereInput | em_apc_photographWhereInput[]
    Id?: IntFilter<"em_apc_photograph"> | number
    ApcId?: IntNullableFilter<"em_apc_photograph"> | number | null
    GenrName?: StringNullableFilter<"em_apc_photograph"> | string | null
    em_apc_personal?: XOR<Em_apc_personalNullableScalarRelationFilter, em_apc_personalWhereInput> | null
  }

  export type em_apc_photographOrderByWithRelationInput = {
    Id?: SortOrder
    ApcId?: SortOrderInput | SortOrder
    GenrName?: SortOrderInput | SortOrder
    em_apc_personal?: em_apc_personalOrderByWithRelationInput
  }

  export type em_apc_photographWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_apc_photographWhereInput | em_apc_photographWhereInput[]
    OR?: em_apc_photographWhereInput[]
    NOT?: em_apc_photographWhereInput | em_apc_photographWhereInput[]
    ApcId?: IntNullableFilter<"em_apc_photograph"> | number | null
    GenrName?: StringNullableFilter<"em_apc_photograph"> | string | null
    em_apc_personal?: XOR<Em_apc_personalNullableScalarRelationFilter, em_apc_personalWhereInput> | null
  }, "Id">

  export type em_apc_photographOrderByWithAggregationInput = {
    Id?: SortOrder
    ApcId?: SortOrderInput | SortOrder
    GenrName?: SortOrderInput | SortOrder
    _count?: em_apc_photographCountOrderByAggregateInput
    _avg?: em_apc_photographAvgOrderByAggregateInput
    _max?: em_apc_photographMaxOrderByAggregateInput
    _min?: em_apc_photographMinOrderByAggregateInput
    _sum?: em_apc_photographSumOrderByAggregateInput
  }

  export type em_apc_photographScalarWhereWithAggregatesInput = {
    AND?: em_apc_photographScalarWhereWithAggregatesInput | em_apc_photographScalarWhereWithAggregatesInput[]
    OR?: em_apc_photographScalarWhereWithAggregatesInput[]
    NOT?: em_apc_photographScalarWhereWithAggregatesInput | em_apc_photographScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_apc_photograph"> | number
    ApcId?: IntNullableWithAggregatesFilter<"em_apc_photograph"> | number | null
    GenrName?: StringNullableWithAggregatesFilter<"em_apc_photograph"> | string | null
  }

  export type em_apc_regulationWhereInput = {
    AND?: em_apc_regulationWhereInput | em_apc_regulationWhereInput[]
    OR?: em_apc_regulationWhereInput[]
    NOT?: em_apc_regulationWhereInput | em_apc_regulationWhereInput[]
    ApcRegId?: IntFilter<"em_apc_regulation"> | number
    ApcId?: IntNullableFilter<"em_apc_regulation"> | number | null
    RegId?: IntNullableFilter<"em_apc_regulation"> | number | null
    RegChoice?: BoolNullableFilter<"em_apc_regulation"> | boolean | null
    em_apc_personal?: XOR<Em_apc_personalNullableScalarRelationFilter, em_apc_personalWhereInput> | null
  }

  export type em_apc_regulationOrderByWithRelationInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrderInput | SortOrder
    RegId?: SortOrderInput | SortOrder
    RegChoice?: SortOrderInput | SortOrder
    em_apc_personal?: em_apc_personalOrderByWithRelationInput
  }

  export type em_apc_regulationWhereUniqueInput = Prisma.AtLeast<{
    ApcRegId?: number
    AND?: em_apc_regulationWhereInput | em_apc_regulationWhereInput[]
    OR?: em_apc_regulationWhereInput[]
    NOT?: em_apc_regulationWhereInput | em_apc_regulationWhereInput[]
    ApcId?: IntNullableFilter<"em_apc_regulation"> | number | null
    RegId?: IntNullableFilter<"em_apc_regulation"> | number | null
    RegChoice?: BoolNullableFilter<"em_apc_regulation"> | boolean | null
    em_apc_personal?: XOR<Em_apc_personalNullableScalarRelationFilter, em_apc_personalWhereInput> | null
  }, "ApcRegId">

  export type em_apc_regulationOrderByWithAggregationInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrderInput | SortOrder
    RegId?: SortOrderInput | SortOrder
    RegChoice?: SortOrderInput | SortOrder
    _count?: em_apc_regulationCountOrderByAggregateInput
    _avg?: em_apc_regulationAvgOrderByAggregateInput
    _max?: em_apc_regulationMaxOrderByAggregateInput
    _min?: em_apc_regulationMinOrderByAggregateInput
    _sum?: em_apc_regulationSumOrderByAggregateInput
  }

  export type em_apc_regulationScalarWhereWithAggregatesInput = {
    AND?: em_apc_regulationScalarWhereWithAggregatesInput | em_apc_regulationScalarWhereWithAggregatesInput[]
    OR?: em_apc_regulationScalarWhereWithAggregatesInput[]
    NOT?: em_apc_regulationScalarWhereWithAggregatesInput | em_apc_regulationScalarWhereWithAggregatesInput[]
    ApcRegId?: IntWithAggregatesFilter<"em_apc_regulation"> | number
    ApcId?: IntNullableWithAggregatesFilter<"em_apc_regulation"> | number | null
    RegId?: IntNullableWithAggregatesFilter<"em_apc_regulation"> | number | null
    RegChoice?: BoolNullableWithAggregatesFilter<"em_apc_regulation"> | boolean | null
  }

  export type em_apc_skill_experWhereInput = {
    AND?: em_apc_skill_experWhereInput | em_apc_skill_experWhereInput[]
    OR?: em_apc_skill_experWhereInput[]
    NOT?: em_apc_skill_experWhereInput | em_apc_skill_experWhereInput[]
    SkillId?: IntFilter<"em_apc_skill_exper"> | number
    ApcId?: IntFilter<"em_apc_skill_exper"> | number
    CompanyName?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    Province?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    JobTitle?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    Salary?: FloatNullableFilter<"em_apc_skill_exper"> | number | null
    StartDate?: DateTimeNullableFilter<"em_apc_skill_exper"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"em_apc_skill_exper"> | Date | string | null
    Responsibilities?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    CareerGoals?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    WhyJoin?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsFriend?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsMentions?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsCompProgram?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsIllnes?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    HaveCriminal?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    WhenWork?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    ExpectedSalary?: FloatNullableFilter<"em_apc_skill_exper"> | number | null
    isContribution?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isDuration?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isAgency?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isExprn?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isGenre?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isRelevan?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isSpesialSkill?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isShoot?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isSchedl?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isMotivation?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isStress?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isLongExpr?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isPhotTools?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isChalleng?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isThreeYears?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    PersonVal?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    em_apc_personal?: XOR<Em_apc_personalScalarRelationFilter, em_apc_personalWhereInput>
  }

  export type em_apc_skill_experOrderByWithRelationInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    CompanyName?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    JobTitle?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    StartDate?: SortOrderInput | SortOrder
    EndDate?: SortOrderInput | SortOrder
    Responsibilities?: SortOrderInput | SortOrder
    CareerGoals?: SortOrderInput | SortOrder
    WhyJoin?: SortOrderInput | SortOrder
    IsFriend?: SortOrderInput | SortOrder
    IsMentions?: SortOrderInput | SortOrder
    IsCompProgram?: SortOrderInput | SortOrder
    IsIllnes?: SortOrderInput | SortOrder
    HaveCriminal?: SortOrderInput | SortOrder
    WhenWork?: SortOrderInput | SortOrder
    ExpectedSalary?: SortOrderInput | SortOrder
    isContribution?: SortOrderInput | SortOrder
    isDuration?: SortOrderInput | SortOrder
    isAgency?: SortOrderInput | SortOrder
    isExprn?: SortOrderInput | SortOrder
    isGenre?: SortOrderInput | SortOrder
    isRelevan?: SortOrderInput | SortOrder
    isSpesialSkill?: SortOrderInput | SortOrder
    isShoot?: SortOrderInput | SortOrder
    isSchedl?: SortOrderInput | SortOrder
    isMotivation?: SortOrderInput | SortOrder
    isStress?: SortOrderInput | SortOrder
    isLongExpr?: SortOrderInput | SortOrder
    isPhotTools?: SortOrderInput | SortOrder
    isChalleng?: SortOrderInput | SortOrder
    isThreeYears?: SortOrderInput | SortOrder
    PersonVal?: SortOrderInput | SortOrder
    em_apc_personal?: em_apc_personalOrderByWithRelationInput
  }

  export type em_apc_skill_experWhereUniqueInput = Prisma.AtLeast<{
    SkillId?: number
    AND?: em_apc_skill_experWhereInput | em_apc_skill_experWhereInput[]
    OR?: em_apc_skill_experWhereInput[]
    NOT?: em_apc_skill_experWhereInput | em_apc_skill_experWhereInput[]
    ApcId?: IntFilter<"em_apc_skill_exper"> | number
    CompanyName?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    Province?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    JobTitle?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    Salary?: FloatNullableFilter<"em_apc_skill_exper"> | number | null
    StartDate?: DateTimeNullableFilter<"em_apc_skill_exper"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"em_apc_skill_exper"> | Date | string | null
    Responsibilities?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    CareerGoals?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    WhyJoin?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsFriend?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsMentions?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsCompProgram?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsIllnes?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    HaveCriminal?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    WhenWork?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    ExpectedSalary?: FloatNullableFilter<"em_apc_skill_exper"> | number | null
    isContribution?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isDuration?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isAgency?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isExprn?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isGenre?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isRelevan?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isSpesialSkill?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isShoot?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isSchedl?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isMotivation?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isStress?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isLongExpr?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isPhotTools?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isChalleng?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isThreeYears?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    PersonVal?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    em_apc_personal?: XOR<Em_apc_personalScalarRelationFilter, em_apc_personalWhereInput>
  }, "SkillId">

  export type em_apc_skill_experOrderByWithAggregationInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    CompanyName?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    JobTitle?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    StartDate?: SortOrderInput | SortOrder
    EndDate?: SortOrderInput | SortOrder
    Responsibilities?: SortOrderInput | SortOrder
    CareerGoals?: SortOrderInput | SortOrder
    WhyJoin?: SortOrderInput | SortOrder
    IsFriend?: SortOrderInput | SortOrder
    IsMentions?: SortOrderInput | SortOrder
    IsCompProgram?: SortOrderInput | SortOrder
    IsIllnes?: SortOrderInput | SortOrder
    HaveCriminal?: SortOrderInput | SortOrder
    WhenWork?: SortOrderInput | SortOrder
    ExpectedSalary?: SortOrderInput | SortOrder
    isContribution?: SortOrderInput | SortOrder
    isDuration?: SortOrderInput | SortOrder
    isAgency?: SortOrderInput | SortOrder
    isExprn?: SortOrderInput | SortOrder
    isGenre?: SortOrderInput | SortOrder
    isRelevan?: SortOrderInput | SortOrder
    isSpesialSkill?: SortOrderInput | SortOrder
    isShoot?: SortOrderInput | SortOrder
    isSchedl?: SortOrderInput | SortOrder
    isMotivation?: SortOrderInput | SortOrder
    isStress?: SortOrderInput | SortOrder
    isLongExpr?: SortOrderInput | SortOrder
    isPhotTools?: SortOrderInput | SortOrder
    isChalleng?: SortOrderInput | SortOrder
    isThreeYears?: SortOrderInput | SortOrder
    PersonVal?: SortOrderInput | SortOrder
    _count?: em_apc_skill_experCountOrderByAggregateInput
    _avg?: em_apc_skill_experAvgOrderByAggregateInput
    _max?: em_apc_skill_experMaxOrderByAggregateInput
    _min?: em_apc_skill_experMinOrderByAggregateInput
    _sum?: em_apc_skill_experSumOrderByAggregateInput
  }

  export type em_apc_skill_experScalarWhereWithAggregatesInput = {
    AND?: em_apc_skill_experScalarWhereWithAggregatesInput | em_apc_skill_experScalarWhereWithAggregatesInput[]
    OR?: em_apc_skill_experScalarWhereWithAggregatesInput[]
    NOT?: em_apc_skill_experScalarWhereWithAggregatesInput | em_apc_skill_experScalarWhereWithAggregatesInput[]
    SkillId?: IntWithAggregatesFilter<"em_apc_skill_exper"> | number
    ApcId?: IntWithAggregatesFilter<"em_apc_skill_exper"> | number
    CompanyName?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    Province?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    JobTitle?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    Salary?: FloatNullableWithAggregatesFilter<"em_apc_skill_exper"> | number | null
    StartDate?: DateTimeNullableWithAggregatesFilter<"em_apc_skill_exper"> | Date | string | null
    EndDate?: DateTimeNullableWithAggregatesFilter<"em_apc_skill_exper"> | Date | string | null
    Responsibilities?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    CareerGoals?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    WhyJoin?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    IsFriend?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    IsMentions?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    IsCompProgram?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    IsIllnes?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    HaveCriminal?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    WhenWork?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    ExpectedSalary?: FloatNullableWithAggregatesFilter<"em_apc_skill_exper"> | number | null
    isContribution?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isDuration?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isAgency?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isExprn?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isGenre?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isRelevan?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isSpesialSkill?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isShoot?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isSchedl?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isMotivation?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isStress?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isLongExpr?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isPhotTools?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isChalleng?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    isThreeYears?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
    PersonVal?: StringNullableWithAggregatesFilter<"em_apc_skill_exper"> | string | null
  }

  export type em_api_keysWhereInput = {
    AND?: em_api_keysWhereInput | em_api_keysWhereInput[]
    OR?: em_api_keysWhereInput[]
    NOT?: em_api_keysWhereInput | em_api_keysWhereInput[]
    id?: IntFilter<"em_api_keys"> | number
    username?: StringNullableFilter<"em_api_keys"> | string | null
    api_key?: StringFilter<"em_api_keys"> | string
    created_at?: DateTimeFilter<"em_api_keys"> | Date | string
  }

  export type em_api_keysOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    api_key?: SortOrder
    created_at?: SortOrder
  }

  export type em_api_keysWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_api_keysWhereInput | em_api_keysWhereInput[]
    OR?: em_api_keysWhereInput[]
    NOT?: em_api_keysWhereInput | em_api_keysWhereInput[]
    username?: StringNullableFilter<"em_api_keys"> | string | null
    api_key?: StringFilter<"em_api_keys"> | string
    created_at?: DateTimeFilter<"em_api_keys"> | Date | string
  }, "id">

  export type em_api_keysOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    api_key?: SortOrder
    created_at?: SortOrder
    _count?: em_api_keysCountOrderByAggregateInput
    _avg?: em_api_keysAvgOrderByAggregateInput
    _max?: em_api_keysMaxOrderByAggregateInput
    _min?: em_api_keysMinOrderByAggregateInput
    _sum?: em_api_keysSumOrderByAggregateInput
  }

  export type em_api_keysScalarWhereWithAggregatesInput = {
    AND?: em_api_keysScalarWhereWithAggregatesInput | em_api_keysScalarWhereWithAggregatesInput[]
    OR?: em_api_keysScalarWhereWithAggregatesInput[]
    NOT?: em_api_keysScalarWhereWithAggregatesInput | em_api_keysScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_api_keys"> | number
    username?: StringNullableWithAggregatesFilter<"em_api_keys"> | string | null
    api_key?: StringWithAggregatesFilter<"em_api_keys"> | string
    created_at?: DateTimeWithAggregatesFilter<"em_api_keys"> | Date | string
  }

  export type em_applicant_criteriaWhereInput = {
    AND?: em_applicant_criteriaWhereInput | em_applicant_criteriaWhereInput[]
    OR?: em_applicant_criteriaWhereInput[]
    NOT?: em_applicant_criteriaWhereInput | em_applicant_criteriaWhereInput[]
    id_kriteria?: IntFilter<"em_applicant_criteria"> | number
    id_loker?: IntFilter<"em_applicant_criteria"> | number
    jenis_kriteria?: StringNullableFilter<"em_applicant_criteria"> | string | null
    value?: StringNullableFilter<"em_applicant_criteria"> | string | null
    value_en?: StringNullableFilter<"em_applicant_criteria"> | string | null
    bobot?: FloatNullableFilter<"em_applicant_criteria"> | number | null
    created_at?: DateTimeNullableFilter<"em_applicant_criteria"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_applicant_criteria"> | Date | string | null
    emposs?: XOR<EmpossScalarRelationFilter, empossWhereInput>
  }

  export type em_applicant_criteriaOrderByWithRelationInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    jenis_kriteria?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    value_en?: SortOrderInput | SortOrder
    bobot?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    emposs?: empossOrderByWithRelationInput
  }

  export type em_applicant_criteriaWhereUniqueInput = Prisma.AtLeast<{
    id_kriteria?: number
    AND?: em_applicant_criteriaWhereInput | em_applicant_criteriaWhereInput[]
    OR?: em_applicant_criteriaWhereInput[]
    NOT?: em_applicant_criteriaWhereInput | em_applicant_criteriaWhereInput[]
    id_loker?: IntFilter<"em_applicant_criteria"> | number
    jenis_kriteria?: StringNullableFilter<"em_applicant_criteria"> | string | null
    value?: StringNullableFilter<"em_applicant_criteria"> | string | null
    value_en?: StringNullableFilter<"em_applicant_criteria"> | string | null
    bobot?: FloatNullableFilter<"em_applicant_criteria"> | number | null
    created_at?: DateTimeNullableFilter<"em_applicant_criteria"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_applicant_criteria"> | Date | string | null
    emposs?: XOR<EmpossScalarRelationFilter, empossWhereInput>
  }, "id_kriteria">

  export type em_applicant_criteriaOrderByWithAggregationInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    jenis_kriteria?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    value_en?: SortOrderInput | SortOrder
    bobot?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_applicant_criteriaCountOrderByAggregateInput
    _avg?: em_applicant_criteriaAvgOrderByAggregateInput
    _max?: em_applicant_criteriaMaxOrderByAggregateInput
    _min?: em_applicant_criteriaMinOrderByAggregateInput
    _sum?: em_applicant_criteriaSumOrderByAggregateInput
  }

  export type em_applicant_criteriaScalarWhereWithAggregatesInput = {
    AND?: em_applicant_criteriaScalarWhereWithAggregatesInput | em_applicant_criteriaScalarWhereWithAggregatesInput[]
    OR?: em_applicant_criteriaScalarWhereWithAggregatesInput[]
    NOT?: em_applicant_criteriaScalarWhereWithAggregatesInput | em_applicant_criteriaScalarWhereWithAggregatesInput[]
    id_kriteria?: IntWithAggregatesFilter<"em_applicant_criteria"> | number
    id_loker?: IntWithAggregatesFilter<"em_applicant_criteria"> | number
    jenis_kriteria?: StringNullableWithAggregatesFilter<"em_applicant_criteria"> | string | null
    value?: StringNullableWithAggregatesFilter<"em_applicant_criteria"> | string | null
    value_en?: StringNullableWithAggregatesFilter<"em_applicant_criteria"> | string | null
    bobot?: FloatNullableWithAggregatesFilter<"em_applicant_criteria"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_applicant_criteria"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_applicant_criteria"> | Date | string | null
  }

  export type em_applicant_matchWhereInput = {
    AND?: em_applicant_matchWhereInput | em_applicant_matchWhereInput[]
    OR?: em_applicant_matchWhereInput[]
    NOT?: em_applicant_matchWhereInput | em_applicant_matchWhereInput[]
    id_match?: IntFilter<"em_applicant_match"> | number
    id_applicant?: IntFilter<"em_applicant_match"> | number
    id_loker?: IntFilter<"em_applicant_match"> | number
    pendidikan_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    jurusan_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    pengalaman_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    skill_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    bahasa_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    usia_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    total_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    total_kriteria?: IntNullableFilter<"em_applicant_match"> | number | null
    scoring_json?: StringNullableFilter<"em_applicant_match"> | string | null
    created_at?: DateTimeNullableFilter<"em_applicant_match"> | Date | string | null
    em_apc_personal?: XOR<Em_apc_personalScalarRelationFilter, em_apc_personalWhereInput>
    emposs?: XOR<EmpossScalarRelationFilter, empossWhereInput>
  }

  export type em_applicant_matchOrderByWithRelationInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrderInput | SortOrder
    jurusan_score?: SortOrderInput | SortOrder
    pengalaman_score?: SortOrderInput | SortOrder
    skill_score?: SortOrderInput | SortOrder
    bahasa_score?: SortOrderInput | SortOrder
    usia_score?: SortOrderInput | SortOrder
    total_score?: SortOrderInput | SortOrder
    total_kriteria?: SortOrderInput | SortOrder
    scoring_json?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    em_apc_personal?: em_apc_personalOrderByWithRelationInput
    emposs?: empossOrderByWithRelationInput
  }

  export type em_applicant_matchWhereUniqueInput = Prisma.AtLeast<{
    id_match?: number
    AND?: em_applicant_matchWhereInput | em_applicant_matchWhereInput[]
    OR?: em_applicant_matchWhereInput[]
    NOT?: em_applicant_matchWhereInput | em_applicant_matchWhereInput[]
    id_applicant?: IntFilter<"em_applicant_match"> | number
    id_loker?: IntFilter<"em_applicant_match"> | number
    pendidikan_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    jurusan_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    pengalaman_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    skill_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    bahasa_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    usia_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    total_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    total_kriteria?: IntNullableFilter<"em_applicant_match"> | number | null
    scoring_json?: StringNullableFilter<"em_applicant_match"> | string | null
    created_at?: DateTimeNullableFilter<"em_applicant_match"> | Date | string | null
    em_apc_personal?: XOR<Em_apc_personalScalarRelationFilter, em_apc_personalWhereInput>
    emposs?: XOR<EmpossScalarRelationFilter, empossWhereInput>
  }, "id_match">

  export type em_applicant_matchOrderByWithAggregationInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrderInput | SortOrder
    jurusan_score?: SortOrderInput | SortOrder
    pengalaman_score?: SortOrderInput | SortOrder
    skill_score?: SortOrderInput | SortOrder
    bahasa_score?: SortOrderInput | SortOrder
    usia_score?: SortOrderInput | SortOrder
    total_score?: SortOrderInput | SortOrder
    total_kriteria?: SortOrderInput | SortOrder
    scoring_json?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: em_applicant_matchCountOrderByAggregateInput
    _avg?: em_applicant_matchAvgOrderByAggregateInput
    _max?: em_applicant_matchMaxOrderByAggregateInput
    _min?: em_applicant_matchMinOrderByAggregateInput
    _sum?: em_applicant_matchSumOrderByAggregateInput
  }

  export type em_applicant_matchScalarWhereWithAggregatesInput = {
    AND?: em_applicant_matchScalarWhereWithAggregatesInput | em_applicant_matchScalarWhereWithAggregatesInput[]
    OR?: em_applicant_matchScalarWhereWithAggregatesInput[]
    NOT?: em_applicant_matchScalarWhereWithAggregatesInput | em_applicant_matchScalarWhereWithAggregatesInput[]
    id_match?: IntWithAggregatesFilter<"em_applicant_match"> | number
    id_applicant?: IntWithAggregatesFilter<"em_applicant_match"> | number
    id_loker?: IntWithAggregatesFilter<"em_applicant_match"> | number
    pendidikan_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    jurusan_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    pengalaman_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    skill_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    bahasa_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    usia_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    total_score?: FloatNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    total_kriteria?: IntNullableWithAggregatesFilter<"em_applicant_match"> | number | null
    scoring_json?: StringNullableWithAggregatesFilter<"em_applicant_match"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_applicant_match"> | Date | string | null
  }

  export type em_bannerWhereInput = {
    AND?: em_bannerWhereInput | em_bannerWhereInput[]
    OR?: em_bannerWhereInput[]
    NOT?: em_bannerWhereInput | em_bannerWhereInput[]
    Id?: IntFilter<"em_banner"> | number
    bannerName?: StringNullableFilter<"em_banner"> | string | null
    fileName?: StringNullableFilter<"em_banner"> | string | null
    menuName?: StringNullableFilter<"em_banner"> | string | null
    noUrut?: IntNullableFilter<"em_banner"> | number | null
    Status?: StringNullableFilter<"em_banner"> | string | null
    created_at?: DateTimeNullableFilter<"em_banner"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_banner"> | Date | string | null
    userid?: StringNullableFilter<"em_banner"> | string | null
  }

  export type em_bannerOrderByWithRelationInput = {
    Id?: SortOrder
    bannerName?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    menuName?: SortOrderInput | SortOrder
    noUrut?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
  }

  export type em_bannerWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_bannerWhereInput | em_bannerWhereInput[]
    OR?: em_bannerWhereInput[]
    NOT?: em_bannerWhereInput | em_bannerWhereInput[]
    bannerName?: StringNullableFilter<"em_banner"> | string | null
    fileName?: StringNullableFilter<"em_banner"> | string | null
    menuName?: StringNullableFilter<"em_banner"> | string | null
    noUrut?: IntNullableFilter<"em_banner"> | number | null
    Status?: StringNullableFilter<"em_banner"> | string | null
    created_at?: DateTimeNullableFilter<"em_banner"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_banner"> | Date | string | null
    userid?: StringNullableFilter<"em_banner"> | string | null
  }, "Id">

  export type em_bannerOrderByWithAggregationInput = {
    Id?: SortOrder
    bannerName?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    menuName?: SortOrderInput | SortOrder
    noUrut?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    _count?: em_bannerCountOrderByAggregateInput
    _avg?: em_bannerAvgOrderByAggregateInput
    _max?: em_bannerMaxOrderByAggregateInput
    _min?: em_bannerMinOrderByAggregateInput
    _sum?: em_bannerSumOrderByAggregateInput
  }

  export type em_bannerScalarWhereWithAggregatesInput = {
    AND?: em_bannerScalarWhereWithAggregatesInput | em_bannerScalarWhereWithAggregatesInput[]
    OR?: em_bannerScalarWhereWithAggregatesInput[]
    NOT?: em_bannerScalarWhereWithAggregatesInput | em_bannerScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_banner"> | number
    bannerName?: StringNullableWithAggregatesFilter<"em_banner"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"em_banner"> | string | null
    menuName?: StringNullableWithAggregatesFilter<"em_banner"> | string | null
    noUrut?: IntNullableWithAggregatesFilter<"em_banner"> | number | null
    Status?: StringNullableWithAggregatesFilter<"em_banner"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_banner"> | Date | string | null
    last_update?: DateTimeNullableWithAggregatesFilter<"em_banner"> | Date | string | null
    userid?: StringNullableWithAggregatesFilter<"em_banner"> | string | null
  }

  export type em_career_contactWhereInput = {
    AND?: em_career_contactWhereInput | em_career_contactWhereInput[]
    OR?: em_career_contactWhereInput[]
    NOT?: em_career_contactWhereInput | em_career_contactWhereInput[]
    cpId?: IntFilter<"em_career_contact"> | number
    companyName?: StringNullableFilter<"em_career_contact"> | string | null
    email?: StringNullableFilter<"em_career_contact"> | string | null
    waNumber?: StringNullableFilter<"em_career_contact"> | string | null
    fileImage?: StringNullableFilter<"em_career_contact"> | string | null
    created_at?: DateTimeNullableFilter<"em_career_contact"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_career_contact"> | Date | string | null
    userid?: StringNullableFilter<"em_career_contact"> | string | null
  }

  export type em_career_contactOrderByWithRelationInput = {
    cpId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    waNumber?: SortOrderInput | SortOrder
    fileImage?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
  }

  export type em_career_contactWhereUniqueInput = Prisma.AtLeast<{
    cpId?: number
    AND?: em_career_contactWhereInput | em_career_contactWhereInput[]
    OR?: em_career_contactWhereInput[]
    NOT?: em_career_contactWhereInput | em_career_contactWhereInput[]
    companyName?: StringNullableFilter<"em_career_contact"> | string | null
    email?: StringNullableFilter<"em_career_contact"> | string | null
    waNumber?: StringNullableFilter<"em_career_contact"> | string | null
    fileImage?: StringNullableFilter<"em_career_contact"> | string | null
    created_at?: DateTimeNullableFilter<"em_career_contact"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_career_contact"> | Date | string | null
    userid?: StringNullableFilter<"em_career_contact"> | string | null
  }, "cpId">

  export type em_career_contactOrderByWithAggregationInput = {
    cpId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    waNumber?: SortOrderInput | SortOrder
    fileImage?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    _count?: em_career_contactCountOrderByAggregateInput
    _avg?: em_career_contactAvgOrderByAggregateInput
    _max?: em_career_contactMaxOrderByAggregateInput
    _min?: em_career_contactMinOrderByAggregateInput
    _sum?: em_career_contactSumOrderByAggregateInput
  }

  export type em_career_contactScalarWhereWithAggregatesInput = {
    AND?: em_career_contactScalarWhereWithAggregatesInput | em_career_contactScalarWhereWithAggregatesInput[]
    OR?: em_career_contactScalarWhereWithAggregatesInput[]
    NOT?: em_career_contactScalarWhereWithAggregatesInput | em_career_contactScalarWhereWithAggregatesInput[]
    cpId?: IntWithAggregatesFilter<"em_career_contact"> | number
    companyName?: StringNullableWithAggregatesFilter<"em_career_contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"em_career_contact"> | string | null
    waNumber?: StringNullableWithAggregatesFilter<"em_career_contact"> | string | null
    fileImage?: StringNullableWithAggregatesFilter<"em_career_contact"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_career_contact"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_career_contact"> | Date | string | null
    userid?: StringNullableWithAggregatesFilter<"em_career_contact"> | string | null
  }

  export type em_certificate_fieldsWhereInput = {
    AND?: em_certificate_fieldsWhereInput | em_certificate_fieldsWhereInput[]
    OR?: em_certificate_fieldsWhereInput[]
    NOT?: em_certificate_fieldsWhereInput | em_certificate_fieldsWhereInput[]
    id?: IntFilter<"em_certificate_fields"> | number
    certificate_id?: IntFilter<"em_certificate_fields"> | number
    is_text?: StringFilter<"em_certificate_fields"> | string
    is_left?: FloatFilter<"em_certificate_fields"> | number
    is_top?: FloatFilter<"em_certificate_fields"> | number
    text_width?: FloatFilter<"em_certificate_fields"> | number
    text_height?: FloatFilter<"em_certificate_fields"> | number
    font_size?: IntFilter<"em_certificate_fields"> | number
    align?: StringFilter<"em_certificate_fields"> | string
    font_family?: StringFilter<"em_certificate_fields"> | string
    font_style?: StringNullableFilter<"em_certificate_fields"> | string | null
    font_weight?: StringNullableFilter<"em_certificate_fields"> | string | null
    font_color?: StringNullableFilter<"em_certificate_fields"> | string | null
    created_date?: DateTimeNullableFilter<"em_certificate_fields"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_certificate_fields"> | Date | string | null
    em_certificate_templates?: XOR<Em_certificate_templatesScalarRelationFilter, em_certificate_templatesWhereInput>
  }

  export type em_certificate_fieldsOrderByWithRelationInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_text?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
    align?: SortOrder
    font_family?: SortOrder
    font_style?: SortOrderInput | SortOrder
    font_weight?: SortOrderInput | SortOrder
    font_color?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    em_certificate_templates?: em_certificate_templatesOrderByWithRelationInput
  }

  export type em_certificate_fieldsWhereUniqueInput = Prisma.AtLeast<{
    id_certificate_id?: em_certificate_fieldsIdCertificate_idCompoundUniqueInput
    AND?: em_certificate_fieldsWhereInput | em_certificate_fieldsWhereInput[]
    OR?: em_certificate_fieldsWhereInput[]
    NOT?: em_certificate_fieldsWhereInput | em_certificate_fieldsWhereInput[]
    id?: IntFilter<"em_certificate_fields"> | number
    certificate_id?: IntFilter<"em_certificate_fields"> | number
    is_text?: StringFilter<"em_certificate_fields"> | string
    is_left?: FloatFilter<"em_certificate_fields"> | number
    is_top?: FloatFilter<"em_certificate_fields"> | number
    text_width?: FloatFilter<"em_certificate_fields"> | number
    text_height?: FloatFilter<"em_certificate_fields"> | number
    font_size?: IntFilter<"em_certificate_fields"> | number
    align?: StringFilter<"em_certificate_fields"> | string
    font_family?: StringFilter<"em_certificate_fields"> | string
    font_style?: StringNullableFilter<"em_certificate_fields"> | string | null
    font_weight?: StringNullableFilter<"em_certificate_fields"> | string | null
    font_color?: StringNullableFilter<"em_certificate_fields"> | string | null
    created_date?: DateTimeNullableFilter<"em_certificate_fields"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_certificate_fields"> | Date | string | null
    em_certificate_templates?: XOR<Em_certificate_templatesScalarRelationFilter, em_certificate_templatesWhereInput>
  }, "id_certificate_id">

  export type em_certificate_fieldsOrderByWithAggregationInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_text?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
    align?: SortOrder
    font_family?: SortOrder
    font_style?: SortOrderInput | SortOrder
    font_weight?: SortOrderInput | SortOrder
    font_color?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_certificate_fieldsCountOrderByAggregateInput
    _avg?: em_certificate_fieldsAvgOrderByAggregateInput
    _max?: em_certificate_fieldsMaxOrderByAggregateInput
    _min?: em_certificate_fieldsMinOrderByAggregateInput
    _sum?: em_certificate_fieldsSumOrderByAggregateInput
  }

  export type em_certificate_fieldsScalarWhereWithAggregatesInput = {
    AND?: em_certificate_fieldsScalarWhereWithAggregatesInput | em_certificate_fieldsScalarWhereWithAggregatesInput[]
    OR?: em_certificate_fieldsScalarWhereWithAggregatesInput[]
    NOT?: em_certificate_fieldsScalarWhereWithAggregatesInput | em_certificate_fieldsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_certificate_fields"> | number
    certificate_id?: IntWithAggregatesFilter<"em_certificate_fields"> | number
    is_text?: StringWithAggregatesFilter<"em_certificate_fields"> | string
    is_left?: FloatWithAggregatesFilter<"em_certificate_fields"> | number
    is_top?: FloatWithAggregatesFilter<"em_certificate_fields"> | number
    text_width?: FloatWithAggregatesFilter<"em_certificate_fields"> | number
    text_height?: FloatWithAggregatesFilter<"em_certificate_fields"> | number
    font_size?: IntWithAggregatesFilter<"em_certificate_fields"> | number
    align?: StringWithAggregatesFilter<"em_certificate_fields"> | string
    font_family?: StringWithAggregatesFilter<"em_certificate_fields"> | string
    font_style?: StringNullableWithAggregatesFilter<"em_certificate_fields"> | string | null
    font_weight?: StringNullableWithAggregatesFilter<"em_certificate_fields"> | string | null
    font_color?: StringNullableWithAggregatesFilter<"em_certificate_fields"> | string | null
    created_date?: DateTimeNullableWithAggregatesFilter<"em_certificate_fields"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_certificate_fields"> | Date | string | null
  }

  export type em_certificate_templatesWhereInput = {
    AND?: em_certificate_templatesWhereInput | em_certificate_templatesWhereInput[]
    OR?: em_certificate_templatesWhereInput[]
    NOT?: em_certificate_templatesWhereInput | em_certificate_templatesWhereInput[]
    certificate_id?: IntFilter<"em_certificate_templates"> | number
    name?: StringNullableFilter<"em_certificate_templates"> | string | null
    background_image?: StringNullableFilter<"em_certificate_templates"> | string | null
    created_at?: DateTimeNullableFilter<"em_certificate_templates"> | Date | string | null
    certificate_name?: StringNullableFilter<"em_certificate_templates"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_certificate_templates"> | Date | string | null
    em_certificate_fields?: Em_certificate_fieldsListRelationFilter
  }

  export type em_certificate_templatesOrderByWithRelationInput = {
    certificate_id?: SortOrder
    name?: SortOrderInput | SortOrder
    background_image?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    certificate_name?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    em_certificate_fields?: em_certificate_fieldsOrderByRelationAggregateInput
  }

  export type em_certificate_templatesWhereUniqueInput = Prisma.AtLeast<{
    certificate_id?: number
    AND?: em_certificate_templatesWhereInput | em_certificate_templatesWhereInput[]
    OR?: em_certificate_templatesWhereInput[]
    NOT?: em_certificate_templatesWhereInput | em_certificate_templatesWhereInput[]
    name?: StringNullableFilter<"em_certificate_templates"> | string | null
    background_image?: StringNullableFilter<"em_certificate_templates"> | string | null
    created_at?: DateTimeNullableFilter<"em_certificate_templates"> | Date | string | null
    certificate_name?: StringNullableFilter<"em_certificate_templates"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_certificate_templates"> | Date | string | null
    em_certificate_fields?: Em_certificate_fieldsListRelationFilter
  }, "certificate_id">

  export type em_certificate_templatesOrderByWithAggregationInput = {
    certificate_id?: SortOrder
    name?: SortOrderInput | SortOrder
    background_image?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    certificate_name?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_certificate_templatesCountOrderByAggregateInput
    _avg?: em_certificate_templatesAvgOrderByAggregateInput
    _max?: em_certificate_templatesMaxOrderByAggregateInput
    _min?: em_certificate_templatesMinOrderByAggregateInput
    _sum?: em_certificate_templatesSumOrderByAggregateInput
  }

  export type em_certificate_templatesScalarWhereWithAggregatesInput = {
    AND?: em_certificate_templatesScalarWhereWithAggregatesInput | em_certificate_templatesScalarWhereWithAggregatesInput[]
    OR?: em_certificate_templatesScalarWhereWithAggregatesInput[]
    NOT?: em_certificate_templatesScalarWhereWithAggregatesInput | em_certificate_templatesScalarWhereWithAggregatesInput[]
    certificate_id?: IntWithAggregatesFilter<"em_certificate_templates"> | number
    name?: StringNullableWithAggregatesFilter<"em_certificate_templates"> | string | null
    background_image?: StringNullableWithAggregatesFilter<"em_certificate_templates"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_certificate_templates"> | Date | string | null
    certificate_name?: StringNullableWithAggregatesFilter<"em_certificate_templates"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_certificate_templates"> | Date | string | null
  }

  export type em_certificates_resultWhereInput = {
    AND?: em_certificates_resultWhereInput | em_certificates_resultWhereInput[]
    OR?: em_certificates_resultWhereInput[]
    NOT?: em_certificates_resultWhereInput | em_certificates_resultWhereInput[]
    cert_number?: StringFilter<"em_certificates_result"> | string
    cert_templ_id?: IntFilter<"em_certificates_result"> | number
    empl_id?: IntFilter<"em_certificates_result"> | number
    cert_name?: StringFilter<"em_certificates_result"> | string
    created_date?: DateTimeNullableFilter<"em_certificates_result"> | Date | string | null
    status?: StringNullableFilter<"em_certificates_result"> | string | null
    generated_by?: StringNullableFilter<"em_certificates_result"> | string | null
    schedule_id?: IntNullableFilter<"em_certificates_result"> | number | null
  }

  export type em_certificates_resultOrderByWithRelationInput = {
    cert_number?: SortOrder
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    cert_name?: SortOrder
    created_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    generated_by?: SortOrderInput | SortOrder
    schedule_id?: SortOrderInput | SortOrder
  }

  export type em_certificates_resultWhereUniqueInput = Prisma.AtLeast<{
    cert_number?: string
    AND?: em_certificates_resultWhereInput | em_certificates_resultWhereInput[]
    OR?: em_certificates_resultWhereInput[]
    NOT?: em_certificates_resultWhereInput | em_certificates_resultWhereInput[]
    cert_templ_id?: IntFilter<"em_certificates_result"> | number
    empl_id?: IntFilter<"em_certificates_result"> | number
    cert_name?: StringFilter<"em_certificates_result"> | string
    created_date?: DateTimeNullableFilter<"em_certificates_result"> | Date | string | null
    status?: StringNullableFilter<"em_certificates_result"> | string | null
    generated_by?: StringNullableFilter<"em_certificates_result"> | string | null
    schedule_id?: IntNullableFilter<"em_certificates_result"> | number | null
  }, "cert_number">

  export type em_certificates_resultOrderByWithAggregationInput = {
    cert_number?: SortOrder
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    cert_name?: SortOrder
    created_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    generated_by?: SortOrderInput | SortOrder
    schedule_id?: SortOrderInput | SortOrder
    _count?: em_certificates_resultCountOrderByAggregateInput
    _avg?: em_certificates_resultAvgOrderByAggregateInput
    _max?: em_certificates_resultMaxOrderByAggregateInput
    _min?: em_certificates_resultMinOrderByAggregateInput
    _sum?: em_certificates_resultSumOrderByAggregateInput
  }

  export type em_certificates_resultScalarWhereWithAggregatesInput = {
    AND?: em_certificates_resultScalarWhereWithAggregatesInput | em_certificates_resultScalarWhereWithAggregatesInput[]
    OR?: em_certificates_resultScalarWhereWithAggregatesInput[]
    NOT?: em_certificates_resultScalarWhereWithAggregatesInput | em_certificates_resultScalarWhereWithAggregatesInput[]
    cert_number?: StringWithAggregatesFilter<"em_certificates_result"> | string
    cert_templ_id?: IntWithAggregatesFilter<"em_certificates_result"> | number
    empl_id?: IntWithAggregatesFilter<"em_certificates_result"> | number
    cert_name?: StringWithAggregatesFilter<"em_certificates_result"> | string
    created_date?: DateTimeNullableWithAggregatesFilter<"em_certificates_result"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"em_certificates_result"> | string | null
    generated_by?: StringNullableWithAggregatesFilter<"em_certificates_result"> | string | null
    schedule_id?: IntNullableWithAggregatesFilter<"em_certificates_result"> | number | null
  }

  export type em_chanceWhereInput = {
    AND?: em_chanceWhereInput | em_chanceWhereInput[]
    OR?: em_chanceWhereInput[]
    NOT?: em_chanceWhereInput | em_chanceWhereInput[]
    chId?: IntFilter<"em_chance"> | number
    chName?: StringNullableFilter<"em_chance"> | string | null
    chDesc?: StringNullableFilter<"em_chance"> | string | null
    chStats?: StringNullableFilter<"em_chance"> | string | null
    chFileImage?: StringNullableFilter<"em_chance"> | string | null
    chLink?: StringNullableFilter<"em_chance"> | string | null
    chUserid?: StringNullableFilter<"em_chance"> | string | null
    chDate?: DateTimeNullableFilter<"em_chance"> | Date | string | null
    chLastupdate?: DateTimeNullableFilter<"em_chance"> | Date | string | null
  }

  export type em_chanceOrderByWithRelationInput = {
    chId?: SortOrder
    chName?: SortOrderInput | SortOrder
    chDesc?: SortOrderInput | SortOrder
    chStats?: SortOrderInput | SortOrder
    chFileImage?: SortOrderInput | SortOrder
    chLink?: SortOrderInput | SortOrder
    chUserid?: SortOrderInput | SortOrder
    chDate?: SortOrderInput | SortOrder
    chLastupdate?: SortOrderInput | SortOrder
  }

  export type em_chanceWhereUniqueInput = Prisma.AtLeast<{
    chId?: number
    AND?: em_chanceWhereInput | em_chanceWhereInput[]
    OR?: em_chanceWhereInput[]
    NOT?: em_chanceWhereInput | em_chanceWhereInput[]
    chName?: StringNullableFilter<"em_chance"> | string | null
    chDesc?: StringNullableFilter<"em_chance"> | string | null
    chStats?: StringNullableFilter<"em_chance"> | string | null
    chFileImage?: StringNullableFilter<"em_chance"> | string | null
    chLink?: StringNullableFilter<"em_chance"> | string | null
    chUserid?: StringNullableFilter<"em_chance"> | string | null
    chDate?: DateTimeNullableFilter<"em_chance"> | Date | string | null
    chLastupdate?: DateTimeNullableFilter<"em_chance"> | Date | string | null
  }, "chId">

  export type em_chanceOrderByWithAggregationInput = {
    chId?: SortOrder
    chName?: SortOrderInput | SortOrder
    chDesc?: SortOrderInput | SortOrder
    chStats?: SortOrderInput | SortOrder
    chFileImage?: SortOrderInput | SortOrder
    chLink?: SortOrderInput | SortOrder
    chUserid?: SortOrderInput | SortOrder
    chDate?: SortOrderInput | SortOrder
    chLastupdate?: SortOrderInput | SortOrder
    _count?: em_chanceCountOrderByAggregateInput
    _avg?: em_chanceAvgOrderByAggregateInput
    _max?: em_chanceMaxOrderByAggregateInput
    _min?: em_chanceMinOrderByAggregateInput
    _sum?: em_chanceSumOrderByAggregateInput
  }

  export type em_chanceScalarWhereWithAggregatesInput = {
    AND?: em_chanceScalarWhereWithAggregatesInput | em_chanceScalarWhereWithAggregatesInput[]
    OR?: em_chanceScalarWhereWithAggregatesInput[]
    NOT?: em_chanceScalarWhereWithAggregatesInput | em_chanceScalarWhereWithAggregatesInput[]
    chId?: IntWithAggregatesFilter<"em_chance"> | number
    chName?: StringNullableWithAggregatesFilter<"em_chance"> | string | null
    chDesc?: StringNullableWithAggregatesFilter<"em_chance"> | string | null
    chStats?: StringNullableWithAggregatesFilter<"em_chance"> | string | null
    chFileImage?: StringNullableWithAggregatesFilter<"em_chance"> | string | null
    chLink?: StringNullableWithAggregatesFilter<"em_chance"> | string | null
    chUserid?: StringNullableWithAggregatesFilter<"em_chance"> | string | null
    chDate?: DateTimeNullableWithAggregatesFilter<"em_chance"> | Date | string | null
    chLastupdate?: DateTimeNullableWithAggregatesFilter<"em_chance"> | Date | string | null
  }

  export type em_contrctypeWhereInput = {
    AND?: em_contrctypeWhereInput | em_contrctypeWhereInput[]
    OR?: em_contrctypeWhereInput[]
    NOT?: em_contrctypeWhereInput | em_contrctypeWhereInput[]
    id?: IntFilter<"em_contrctype"> | number
    contract_text?: StringFilter<"em_contrctype"> | string
    status?: StringNullableFilter<"em_contrctype"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_contrctype"> | Date | string | null
  }

  export type em_contrctypeOrderByWithRelationInput = {
    id?: SortOrder
    contract_text?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type em_contrctypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_contrctypeWhereInput | em_contrctypeWhereInput[]
    OR?: em_contrctypeWhereInput[]
    NOT?: em_contrctypeWhereInput | em_contrctypeWhereInput[]
    contract_text?: StringFilter<"em_contrctype"> | string
    status?: StringNullableFilter<"em_contrctype"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_contrctype"> | Date | string | null
  }, "id">

  export type em_contrctypeOrderByWithAggregationInput = {
    id?: SortOrder
    contract_text?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_contrctypeCountOrderByAggregateInput
    _avg?: em_contrctypeAvgOrderByAggregateInput
    _max?: em_contrctypeMaxOrderByAggregateInput
    _min?: em_contrctypeMinOrderByAggregateInput
    _sum?: em_contrctypeSumOrderByAggregateInput
  }

  export type em_contrctypeScalarWhereWithAggregatesInput = {
    AND?: em_contrctypeScalarWhereWithAggregatesInput | em_contrctypeScalarWhereWithAggregatesInput[]
    OR?: em_contrctypeScalarWhereWithAggregatesInput[]
    NOT?: em_contrctypeScalarWhereWithAggregatesInput | em_contrctypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_contrctype"> | number
    contract_text?: StringWithAggregatesFilter<"em_contrctype"> | string
    status?: StringNullableWithAggregatesFilter<"em_contrctype"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_contrctype"> | Date | string | null
  }

  export type em_deptWhereInput = {
    AND?: em_deptWhereInput | em_deptWhereInput[]
    OR?: em_deptWhereInput[]
    NOT?: em_deptWhereInput | em_deptWhereInput[]
    DEPTID?: IntFilter<"em_dept"> | number
    DEPTNAME?: StringNullableFilter<"em_dept"> | string | null
    sbu_sub?: IntNullableFilter<"em_dept"> | number | null
    status?: StringNullableFilter<"em_dept"> | string | null
    add_by?: StringNullableFilter<"em_dept"> | string | null
    created_at?: DateTimeNullableFilter<"em_dept"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_dept"> | Date | string | null
  }

  export type em_deptOrderByWithRelationInput = {
    DEPTID?: SortOrder
    DEPTNAME?: SortOrderInput | SortOrder
    sbu_sub?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type em_deptWhereUniqueInput = Prisma.AtLeast<{
    DEPTID?: number
    AND?: em_deptWhereInput | em_deptWhereInput[]
    OR?: em_deptWhereInput[]
    NOT?: em_deptWhereInput | em_deptWhereInput[]
    DEPTNAME?: StringNullableFilter<"em_dept"> | string | null
    sbu_sub?: IntNullableFilter<"em_dept"> | number | null
    status?: StringNullableFilter<"em_dept"> | string | null
    add_by?: StringNullableFilter<"em_dept"> | string | null
    created_at?: DateTimeNullableFilter<"em_dept"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_dept"> | Date | string | null
  }, "DEPTID">

  export type em_deptOrderByWithAggregationInput = {
    DEPTID?: SortOrder
    DEPTNAME?: SortOrderInput | SortOrder
    sbu_sub?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_deptCountOrderByAggregateInput
    _avg?: em_deptAvgOrderByAggregateInput
    _max?: em_deptMaxOrderByAggregateInput
    _min?: em_deptMinOrderByAggregateInput
    _sum?: em_deptSumOrderByAggregateInput
  }

  export type em_deptScalarWhereWithAggregatesInput = {
    AND?: em_deptScalarWhereWithAggregatesInput | em_deptScalarWhereWithAggregatesInput[]
    OR?: em_deptScalarWhereWithAggregatesInput[]
    NOT?: em_deptScalarWhereWithAggregatesInput | em_deptScalarWhereWithAggregatesInput[]
    DEPTID?: IntWithAggregatesFilter<"em_dept"> | number
    DEPTNAME?: StringNullableWithAggregatesFilter<"em_dept"> | string | null
    sbu_sub?: IntNullableWithAggregatesFilter<"em_dept"> | number | null
    status?: StringNullableWithAggregatesFilter<"em_dept"> | string | null
    add_by?: StringNullableWithAggregatesFilter<"em_dept"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_dept"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_dept"> | Date | string | null
  }

  export type em_employeeWhereInput = {
    AND?: em_employeeWhereInput | em_employeeWhereInput[]
    OR?: em_employeeWhereInput[]
    NOT?: em_employeeWhereInput | em_employeeWhereInput[]
    UserId?: IntFilter<"em_employee"> | number
    BadgeNum?: StringFilter<"em_employee"> | string
    Name?: StringNullableFilter<"em_employee"> | string | null
    Gender?: StringNullableFilter<"em_employee"> | string | null
    BirthDay?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    HireDay?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    Street?: StringNullableFilter<"em_employee"> | string | null
    Religion?: StringNullableFilter<"em_employee"> | string | null
    Tipe?: StringNullableFilter<"em_employee"> | string | null
    isLokasi?: StringNullableFilter<"em_employee"> | string | null
    Phone?: StringNullableFilter<"em_employee"> | string | null
    DeptId?: IntNullableFilter<"em_employee"> | number | null
    Password?: StringNullableFilter<"em_employee"> | string | null
    CardNo?: StringNullableFilter<"em_employee"> | string | null
    Shift?: IntNullableFilter<"em_employee"> | number | null
    isMem?: BoolNullableFilter<"em_employee"> | boolean | null
    AddBy?: StringNullableFilter<"em_employee"> | string | null
    Created_at?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    Lastupdate?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    isMemDate?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    isFirstLogin?: IntNullableFilter<"em_employee"> | number | null
    ImgName?: StringNullableFilter<"em_employee"> | string | null
    SbuSub?: IntNullableFilter<"em_employee"> | number | null
    Nik?: StringNullableFilter<"em_employee"> | string | null
    ResignDate?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    status?: StringNullableFilter<"em_employee"> | string | null
  }

  export type em_employeeOrderByWithRelationInput = {
    UserId?: SortOrder
    BadgeNum?: SortOrder
    Name?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    BirthDay?: SortOrderInput | SortOrder
    HireDay?: SortOrderInput | SortOrder
    Street?: SortOrderInput | SortOrder
    Religion?: SortOrderInput | SortOrder
    Tipe?: SortOrderInput | SortOrder
    isLokasi?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    DeptId?: SortOrderInput | SortOrder
    Password?: SortOrderInput | SortOrder
    CardNo?: SortOrderInput | SortOrder
    Shift?: SortOrderInput | SortOrder
    isMem?: SortOrderInput | SortOrder
    AddBy?: SortOrderInput | SortOrder
    Created_at?: SortOrderInput | SortOrder
    Lastupdate?: SortOrderInput | SortOrder
    isMemDate?: SortOrderInput | SortOrder
    isFirstLogin?: SortOrderInput | SortOrder
    ImgName?: SortOrderInput | SortOrder
    SbuSub?: SortOrderInput | SortOrder
    Nik?: SortOrderInput | SortOrder
    ResignDate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
  }

  export type em_employeeWhereUniqueInput = Prisma.AtLeast<{
    UserId?: number
    AND?: em_employeeWhereInput | em_employeeWhereInput[]
    OR?: em_employeeWhereInput[]
    NOT?: em_employeeWhereInput | em_employeeWhereInput[]
    BadgeNum?: StringFilter<"em_employee"> | string
    Name?: StringNullableFilter<"em_employee"> | string | null
    Gender?: StringNullableFilter<"em_employee"> | string | null
    BirthDay?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    HireDay?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    Street?: StringNullableFilter<"em_employee"> | string | null
    Religion?: StringNullableFilter<"em_employee"> | string | null
    Tipe?: StringNullableFilter<"em_employee"> | string | null
    isLokasi?: StringNullableFilter<"em_employee"> | string | null
    Phone?: StringNullableFilter<"em_employee"> | string | null
    DeptId?: IntNullableFilter<"em_employee"> | number | null
    Password?: StringNullableFilter<"em_employee"> | string | null
    CardNo?: StringNullableFilter<"em_employee"> | string | null
    Shift?: IntNullableFilter<"em_employee"> | number | null
    isMem?: BoolNullableFilter<"em_employee"> | boolean | null
    AddBy?: StringNullableFilter<"em_employee"> | string | null
    Created_at?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    Lastupdate?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    isMemDate?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    isFirstLogin?: IntNullableFilter<"em_employee"> | number | null
    ImgName?: StringNullableFilter<"em_employee"> | string | null
    SbuSub?: IntNullableFilter<"em_employee"> | number | null
    Nik?: StringNullableFilter<"em_employee"> | string | null
    ResignDate?: DateTimeNullableFilter<"em_employee"> | Date | string | null
    status?: StringNullableFilter<"em_employee"> | string | null
  }, "UserId">

  export type em_employeeOrderByWithAggregationInput = {
    UserId?: SortOrder
    BadgeNum?: SortOrder
    Name?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    BirthDay?: SortOrderInput | SortOrder
    HireDay?: SortOrderInput | SortOrder
    Street?: SortOrderInput | SortOrder
    Religion?: SortOrderInput | SortOrder
    Tipe?: SortOrderInput | SortOrder
    isLokasi?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    DeptId?: SortOrderInput | SortOrder
    Password?: SortOrderInput | SortOrder
    CardNo?: SortOrderInput | SortOrder
    Shift?: SortOrderInput | SortOrder
    isMem?: SortOrderInput | SortOrder
    AddBy?: SortOrderInput | SortOrder
    Created_at?: SortOrderInput | SortOrder
    Lastupdate?: SortOrderInput | SortOrder
    isMemDate?: SortOrderInput | SortOrder
    isFirstLogin?: SortOrderInput | SortOrder
    ImgName?: SortOrderInput | SortOrder
    SbuSub?: SortOrderInput | SortOrder
    Nik?: SortOrderInput | SortOrder
    ResignDate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: em_employeeCountOrderByAggregateInput
    _avg?: em_employeeAvgOrderByAggregateInput
    _max?: em_employeeMaxOrderByAggregateInput
    _min?: em_employeeMinOrderByAggregateInput
    _sum?: em_employeeSumOrderByAggregateInput
  }

  export type em_employeeScalarWhereWithAggregatesInput = {
    AND?: em_employeeScalarWhereWithAggregatesInput | em_employeeScalarWhereWithAggregatesInput[]
    OR?: em_employeeScalarWhereWithAggregatesInput[]
    NOT?: em_employeeScalarWhereWithAggregatesInput | em_employeeScalarWhereWithAggregatesInput[]
    UserId?: IntWithAggregatesFilter<"em_employee"> | number
    BadgeNum?: StringWithAggregatesFilter<"em_employee"> | string
    Name?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    Gender?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    BirthDay?: DateTimeNullableWithAggregatesFilter<"em_employee"> | Date | string | null
    HireDay?: DateTimeNullableWithAggregatesFilter<"em_employee"> | Date | string | null
    Street?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    Religion?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    Tipe?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    isLokasi?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    Phone?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    DeptId?: IntNullableWithAggregatesFilter<"em_employee"> | number | null
    Password?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    CardNo?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    Shift?: IntNullableWithAggregatesFilter<"em_employee"> | number | null
    isMem?: BoolNullableWithAggregatesFilter<"em_employee"> | boolean | null
    AddBy?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    Created_at?: DateTimeNullableWithAggregatesFilter<"em_employee"> | Date | string | null
    Lastupdate?: DateTimeNullableWithAggregatesFilter<"em_employee"> | Date | string | null
    isMemDate?: DateTimeNullableWithAggregatesFilter<"em_employee"> | Date | string | null
    isFirstLogin?: IntNullableWithAggregatesFilter<"em_employee"> | number | null
    ImgName?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    SbuSub?: IntNullableWithAggregatesFilter<"em_employee"> | number | null
    Nik?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
    ResignDate?: DateTimeNullableWithAggregatesFilter<"em_employee"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"em_employee"> | string | null
  }

  export type em_eventWhereInput = {
    AND?: em_eventWhereInput | em_eventWhereInput[]
    OR?: em_eventWhereInput[]
    NOT?: em_eventWhereInput | em_eventWhereInput[]
    event_id?: IntFilter<"em_event"> | number
    event_name?: StringNullableFilter<"em_event"> | string | null
    start_date?: DateTimeNullableFilter<"em_event"> | Date | string | null
    end_date?: DateTimeNullableFilter<"em_event"> | Date | string | null
    status?: StringNullableFilter<"em_event"> | string | null
    lokasi?: StringNullableFilter<"em_event"> | string | null
    created_date?: DateTimeNullableFilter<"em_event"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_event"> | Date | string | null
    em_event2?: Em_event2ListRelationFilter
  }

  export type em_eventOrderByWithRelationInput = {
    event_id?: SortOrder
    event_name?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    lokasi?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    em_event2?: em_event2OrderByRelationAggregateInput
  }

  export type em_eventWhereUniqueInput = Prisma.AtLeast<{
    event_id?: number
    AND?: em_eventWhereInput | em_eventWhereInput[]
    OR?: em_eventWhereInput[]
    NOT?: em_eventWhereInput | em_eventWhereInput[]
    event_name?: StringNullableFilter<"em_event"> | string | null
    start_date?: DateTimeNullableFilter<"em_event"> | Date | string | null
    end_date?: DateTimeNullableFilter<"em_event"> | Date | string | null
    status?: StringNullableFilter<"em_event"> | string | null
    lokasi?: StringNullableFilter<"em_event"> | string | null
    created_date?: DateTimeNullableFilter<"em_event"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_event"> | Date | string | null
    em_event2?: Em_event2ListRelationFilter
  }, "event_id">

  export type em_eventOrderByWithAggregationInput = {
    event_id?: SortOrder
    event_name?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    lokasi?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    _count?: em_eventCountOrderByAggregateInput
    _avg?: em_eventAvgOrderByAggregateInput
    _max?: em_eventMaxOrderByAggregateInput
    _min?: em_eventMinOrderByAggregateInput
    _sum?: em_eventSumOrderByAggregateInput
  }

  export type em_eventScalarWhereWithAggregatesInput = {
    AND?: em_eventScalarWhereWithAggregatesInput | em_eventScalarWhereWithAggregatesInput[]
    OR?: em_eventScalarWhereWithAggregatesInput[]
    NOT?: em_eventScalarWhereWithAggregatesInput | em_eventScalarWhereWithAggregatesInput[]
    event_id?: IntWithAggregatesFilter<"em_event"> | number
    event_name?: StringNullableWithAggregatesFilter<"em_event"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"em_event"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"em_event"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"em_event"> | string | null
    lokasi?: StringNullableWithAggregatesFilter<"em_event"> | string | null
    created_date?: DateTimeNullableWithAggregatesFilter<"em_event"> | Date | string | null
    last_update?: DateTimeNullableWithAggregatesFilter<"em_event"> | Date | string | null
  }

  export type em_event_regWhereInput = {
    AND?: em_event_regWhereInput | em_event_regWhereInput[]
    OR?: em_event_regWhereInput[]
    NOT?: em_event_regWhereInput | em_event_regWhereInput[]
    Regid?: IntFilter<"em_event_reg"> | number
    name?: StringNullableFilter<"em_event_reg"> | string | null
    optic_name?: StringNullableFilter<"em_event_reg"> | string | null
    password?: StringNullableFilter<"em_event_reg"> | string | null
    wa_num?: StringNullableFilter<"em_event_reg"> | string | null
    email?: StringNullableFilter<"em_event_reg"> | string | null
    profesi_id?: IntNullableFilter<"em_event_reg"> | number | null
    event_id?: IntNullableFilter<"em_event_reg"> | number | null
    status?: StringNullableFilter<"em_event_reg"> | string | null
    first_login?: BoolNullableFilter<"em_event_reg"> | boolean | null
    created_date?: DateTimeNullableFilter<"em_event_reg"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_event_reg"> | Date | string | null
    image_name?: StringNullableFilter<"em_event_reg"> | string | null
  }

  export type em_event_regOrderByWithRelationInput = {
    Regid?: SortOrder
    name?: SortOrderInput | SortOrder
    optic_name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    wa_num?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    profesi_id?: SortOrderInput | SortOrder
    event_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    first_login?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    image_name?: SortOrderInput | SortOrder
  }

  export type em_event_regWhereUniqueInput = Prisma.AtLeast<{
    Regid?: number
    AND?: em_event_regWhereInput | em_event_regWhereInput[]
    OR?: em_event_regWhereInput[]
    NOT?: em_event_regWhereInput | em_event_regWhereInput[]
    name?: StringNullableFilter<"em_event_reg"> | string | null
    optic_name?: StringNullableFilter<"em_event_reg"> | string | null
    password?: StringNullableFilter<"em_event_reg"> | string | null
    wa_num?: StringNullableFilter<"em_event_reg"> | string | null
    email?: StringNullableFilter<"em_event_reg"> | string | null
    profesi_id?: IntNullableFilter<"em_event_reg"> | number | null
    event_id?: IntNullableFilter<"em_event_reg"> | number | null
    status?: StringNullableFilter<"em_event_reg"> | string | null
    first_login?: BoolNullableFilter<"em_event_reg"> | boolean | null
    created_date?: DateTimeNullableFilter<"em_event_reg"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_event_reg"> | Date | string | null
    image_name?: StringNullableFilter<"em_event_reg"> | string | null
  }, "Regid">

  export type em_event_regOrderByWithAggregationInput = {
    Regid?: SortOrder
    name?: SortOrderInput | SortOrder
    optic_name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    wa_num?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    profesi_id?: SortOrderInput | SortOrder
    event_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    first_login?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    image_name?: SortOrderInput | SortOrder
    _count?: em_event_regCountOrderByAggregateInput
    _avg?: em_event_regAvgOrderByAggregateInput
    _max?: em_event_regMaxOrderByAggregateInput
    _min?: em_event_regMinOrderByAggregateInput
    _sum?: em_event_regSumOrderByAggregateInput
  }

  export type em_event_regScalarWhereWithAggregatesInput = {
    AND?: em_event_regScalarWhereWithAggregatesInput | em_event_regScalarWhereWithAggregatesInput[]
    OR?: em_event_regScalarWhereWithAggregatesInput[]
    NOT?: em_event_regScalarWhereWithAggregatesInput | em_event_regScalarWhereWithAggregatesInput[]
    Regid?: IntWithAggregatesFilter<"em_event_reg"> | number
    name?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
    optic_name?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
    password?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
    wa_num?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
    email?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
    profesi_id?: IntNullableWithAggregatesFilter<"em_event_reg"> | number | null
    event_id?: IntNullableWithAggregatesFilter<"em_event_reg"> | number | null
    status?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
    first_login?: BoolNullableWithAggregatesFilter<"em_event_reg"> | boolean | null
    created_date?: DateTimeNullableWithAggregatesFilter<"em_event_reg"> | Date | string | null
    last_update?: DateTimeNullableWithAggregatesFilter<"em_event_reg"> | Date | string | null
    image_name?: StringNullableWithAggregatesFilter<"em_event_reg"> | string | null
  }

  export type em_event2WhereInput = {
    AND?: em_event2WhereInput | em_event2WhereInput[]
    OR?: em_event2WhereInput[]
    NOT?: em_event2WhereInput | em_event2WhereInput[]
    sess_id?: IntFilter<"em_event2"> | number
    event_id?: IntNullableFilter<"em_event2"> | number | null
    event_name?: StringNullableFilter<"em_event2"> | string | null
    status?: StringNullableFilter<"em_event2"> | string | null
    qr_code?: StringNullableFilter<"em_event2"> | string | null
    em_event?: XOR<Em_eventNullableScalarRelationFilter, em_eventWhereInput> | null
  }

  export type em_event2OrderByWithRelationInput = {
    sess_id?: SortOrder
    event_id?: SortOrderInput | SortOrder
    event_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    qr_code?: SortOrderInput | SortOrder
    em_event?: em_eventOrderByWithRelationInput
  }

  export type em_event2WhereUniqueInput = Prisma.AtLeast<{
    sess_id?: number
    AND?: em_event2WhereInput | em_event2WhereInput[]
    OR?: em_event2WhereInput[]
    NOT?: em_event2WhereInput | em_event2WhereInput[]
    event_id?: IntNullableFilter<"em_event2"> | number | null
    event_name?: StringNullableFilter<"em_event2"> | string | null
    status?: StringNullableFilter<"em_event2"> | string | null
    qr_code?: StringNullableFilter<"em_event2"> | string | null
    em_event?: XOR<Em_eventNullableScalarRelationFilter, em_eventWhereInput> | null
  }, "sess_id">

  export type em_event2OrderByWithAggregationInput = {
    sess_id?: SortOrder
    event_id?: SortOrderInput | SortOrder
    event_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    qr_code?: SortOrderInput | SortOrder
    _count?: em_event2CountOrderByAggregateInput
    _avg?: em_event2AvgOrderByAggregateInput
    _max?: em_event2MaxOrderByAggregateInput
    _min?: em_event2MinOrderByAggregateInput
    _sum?: em_event2SumOrderByAggregateInput
  }

  export type em_event2ScalarWhereWithAggregatesInput = {
    AND?: em_event2ScalarWhereWithAggregatesInput | em_event2ScalarWhereWithAggregatesInput[]
    OR?: em_event2ScalarWhereWithAggregatesInput[]
    NOT?: em_event2ScalarWhereWithAggregatesInput | em_event2ScalarWhereWithAggregatesInput[]
    sess_id?: IntWithAggregatesFilter<"em_event2"> | number
    event_id?: IntNullableWithAggregatesFilter<"em_event2"> | number | null
    event_name?: StringNullableWithAggregatesFilter<"em_event2"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_event2"> | string | null
    qr_code?: StringNullableWithAggregatesFilter<"em_event2"> | string | null
  }

  export type em_exam_questionsWhereInput = {
    AND?: em_exam_questionsWhereInput | em_exam_questionsWhereInput[]
    OR?: em_exam_questionsWhereInput[]
    NOT?: em_exam_questionsWhereInput | em_exam_questionsWhereInput[]
    id?: IntFilter<"em_exam_questions"> | number
    exam_id?: IntFilter<"em_exam_questions"> | number
    question_id?: IntFilter<"em_exam_questions"> | number
  }

  export type em_exam_questionsOrderByWithRelationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
  }

  export type em_exam_questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_exam_questionsWhereInput | em_exam_questionsWhereInput[]
    OR?: em_exam_questionsWhereInput[]
    NOT?: em_exam_questionsWhereInput | em_exam_questionsWhereInput[]
    exam_id?: IntFilter<"em_exam_questions"> | number
    question_id?: IntFilter<"em_exam_questions"> | number
  }, "id">

  export type em_exam_questionsOrderByWithAggregationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
    _count?: em_exam_questionsCountOrderByAggregateInput
    _avg?: em_exam_questionsAvgOrderByAggregateInput
    _max?: em_exam_questionsMaxOrderByAggregateInput
    _min?: em_exam_questionsMinOrderByAggregateInput
    _sum?: em_exam_questionsSumOrderByAggregateInput
  }

  export type em_exam_questionsScalarWhereWithAggregatesInput = {
    AND?: em_exam_questionsScalarWhereWithAggregatesInput | em_exam_questionsScalarWhereWithAggregatesInput[]
    OR?: em_exam_questionsScalarWhereWithAggregatesInput[]
    NOT?: em_exam_questionsScalarWhereWithAggregatesInput | em_exam_questionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_exam_questions"> | number
    exam_id?: IntWithAggregatesFilter<"em_exam_questions"> | number
    question_id?: IntWithAggregatesFilter<"em_exam_questions"> | number
  }

  export type em_examsWhereInput = {
    AND?: em_examsWhereInput | em_examsWhereInput[]
    OR?: em_examsWhereInput[]
    NOT?: em_examsWhereInput | em_examsWhereInput[]
    id?: IntFilter<"em_exams"> | number
    exam_name?: StringFilter<"em_exams"> | string
    UserId?: StringNullableFilter<"em_exams"> | string | null
    Status?: StringNullableFilter<"em_exams"> | string | null
    LastUpdate?: DateTimeNullableFilter<"em_exams"> | Date | string | null
    Deskripsi?: StringNullableFilter<"em_exams"> | string | null
    FileImage?: StringNullableFilter<"em_exams"> | string | null
    CatType?: StringNullableFilter<"em_exams"> | string | null
    em_loktopik?: Em_loktopikListRelationFilter
    scores?: ScoresListRelationFilter
  }

  export type em_examsOrderByWithRelationInput = {
    id?: SortOrder
    exam_name?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    Deskripsi?: SortOrderInput | SortOrder
    FileImage?: SortOrderInput | SortOrder
    CatType?: SortOrderInput | SortOrder
    em_loktopik?: em_loktopikOrderByRelationAggregateInput
    scores?: scoresOrderByRelationAggregateInput
  }

  export type em_examsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_examsWhereInput | em_examsWhereInput[]
    OR?: em_examsWhereInput[]
    NOT?: em_examsWhereInput | em_examsWhereInput[]
    exam_name?: StringFilter<"em_exams"> | string
    UserId?: StringNullableFilter<"em_exams"> | string | null
    Status?: StringNullableFilter<"em_exams"> | string | null
    LastUpdate?: DateTimeNullableFilter<"em_exams"> | Date | string | null
    Deskripsi?: StringNullableFilter<"em_exams"> | string | null
    FileImage?: StringNullableFilter<"em_exams"> | string | null
    CatType?: StringNullableFilter<"em_exams"> | string | null
    em_loktopik?: Em_loktopikListRelationFilter
    scores?: ScoresListRelationFilter
  }, "id">

  export type em_examsOrderByWithAggregationInput = {
    id?: SortOrder
    exam_name?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    Deskripsi?: SortOrderInput | SortOrder
    FileImage?: SortOrderInput | SortOrder
    CatType?: SortOrderInput | SortOrder
    _count?: em_examsCountOrderByAggregateInput
    _avg?: em_examsAvgOrderByAggregateInput
    _max?: em_examsMaxOrderByAggregateInput
    _min?: em_examsMinOrderByAggregateInput
    _sum?: em_examsSumOrderByAggregateInput
  }

  export type em_examsScalarWhereWithAggregatesInput = {
    AND?: em_examsScalarWhereWithAggregatesInput | em_examsScalarWhereWithAggregatesInput[]
    OR?: em_examsScalarWhereWithAggregatesInput[]
    NOT?: em_examsScalarWhereWithAggregatesInput | em_examsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_exams"> | number
    exam_name?: StringWithAggregatesFilter<"em_exams"> | string
    UserId?: StringNullableWithAggregatesFilter<"em_exams"> | string | null
    Status?: StringNullableWithAggregatesFilter<"em_exams"> | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_exams"> | Date | string | null
    Deskripsi?: StringNullableWithAggregatesFilter<"em_exams"> | string | null
    FileImage?: StringNullableWithAggregatesFilter<"em_exams"> | string | null
    CatType?: StringNullableWithAggregatesFilter<"em_exams"> | string | null
  }

  export type em_exams_monitorWhereInput = {
    AND?: em_exams_monitorWhereInput | em_exams_monitorWhereInput[]
    OR?: em_exams_monitorWhereInput[]
    NOT?: em_exams_monitorWhereInput | em_exams_monitorWhereInput[]
    Id?: BigIntFilter<"em_exams_monitor"> | bigint | number
    schedule_id?: IntNullableFilter<"em_exams_monitor"> | number | null
    exams_id?: StringNullableFilter<"em_exams_monitor"> | string | null
    empl_id?: IntNullableFilter<"em_exams_monitor"> | number | null
    tipe_soal?: StringNullableFilter<"em_exams_monitor"> | string | null
    jumlah_soal?: IntNullableFilter<"em_exams_monitor"> | number | null
    status?: StringNullableFilter<"em_exams_monitor"> | string | null
    created_at?: DateTimeNullableFilter<"em_exams_monitor"> | Date | string | null
  }

  export type em_exams_monitorOrderByWithRelationInput = {
    Id?: SortOrder
    schedule_id?: SortOrderInput | SortOrder
    exams_id?: SortOrderInput | SortOrder
    empl_id?: SortOrderInput | SortOrder
    tipe_soal?: SortOrderInput | SortOrder
    jumlah_soal?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type em_exams_monitorWhereUniqueInput = Prisma.AtLeast<{
    Id?: bigint | number
    AND?: em_exams_monitorWhereInput | em_exams_monitorWhereInput[]
    OR?: em_exams_monitorWhereInput[]
    NOT?: em_exams_monitorWhereInput | em_exams_monitorWhereInput[]
    schedule_id?: IntNullableFilter<"em_exams_monitor"> | number | null
    exams_id?: StringNullableFilter<"em_exams_monitor"> | string | null
    empl_id?: IntNullableFilter<"em_exams_monitor"> | number | null
    tipe_soal?: StringNullableFilter<"em_exams_monitor"> | string | null
    jumlah_soal?: IntNullableFilter<"em_exams_monitor"> | number | null
    status?: StringNullableFilter<"em_exams_monitor"> | string | null
    created_at?: DateTimeNullableFilter<"em_exams_monitor"> | Date | string | null
  }, "Id">

  export type em_exams_monitorOrderByWithAggregationInput = {
    Id?: SortOrder
    schedule_id?: SortOrderInput | SortOrder
    exams_id?: SortOrderInput | SortOrder
    empl_id?: SortOrderInput | SortOrder
    tipe_soal?: SortOrderInput | SortOrder
    jumlah_soal?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: em_exams_monitorCountOrderByAggregateInput
    _avg?: em_exams_monitorAvgOrderByAggregateInput
    _max?: em_exams_monitorMaxOrderByAggregateInput
    _min?: em_exams_monitorMinOrderByAggregateInput
    _sum?: em_exams_monitorSumOrderByAggregateInput
  }

  export type em_exams_monitorScalarWhereWithAggregatesInput = {
    AND?: em_exams_monitorScalarWhereWithAggregatesInput | em_exams_monitorScalarWhereWithAggregatesInput[]
    OR?: em_exams_monitorScalarWhereWithAggregatesInput[]
    NOT?: em_exams_monitorScalarWhereWithAggregatesInput | em_exams_monitorScalarWhereWithAggregatesInput[]
    Id?: BigIntWithAggregatesFilter<"em_exams_monitor"> | bigint | number
    schedule_id?: IntNullableWithAggregatesFilter<"em_exams_monitor"> | number | null
    exams_id?: StringNullableWithAggregatesFilter<"em_exams_monitor"> | string | null
    empl_id?: IntNullableWithAggregatesFilter<"em_exams_monitor"> | number | null
    tipe_soal?: StringNullableWithAggregatesFilter<"em_exams_monitor"> | string | null
    jumlah_soal?: IntNullableWithAggregatesFilter<"em_exams_monitor"> | number | null
    status?: StringNullableWithAggregatesFilter<"em_exams_monitor"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_exams_monitor"> | Date | string | null
  }

  export type em_exams_resultsWhereInput = {
    AND?: em_exams_resultsWhereInput | em_exams_resultsWhereInput[]
    OR?: em_exams_resultsWhereInput[]
    NOT?: em_exams_resultsWhereInput | em_exams_resultsWhereInput[]
    Id?: IntFilter<"em_exams_results"> | number
    exams_id?: StringNullableFilter<"em_exams_results"> | string | null
    empl_id?: IntNullableFilter<"em_exams_results"> | number | null
    soal_id?: IntNullableFilter<"em_exams_results"> | number | null
    is_changes?: IntNullableFilter<"em_exams_results"> | number | null
    is_answer?: StringNullableFilter<"em_exams_results"> | string | null
    is_time?: DateTimeNullableFilter<"em_exams_results"> | Date | string | null
  }

  export type em_exams_resultsOrderByWithRelationInput = {
    Id?: SortOrder
    exams_id?: SortOrderInput | SortOrder
    empl_id?: SortOrderInput | SortOrder
    soal_id?: SortOrderInput | SortOrder
    is_changes?: SortOrderInput | SortOrder
    is_answer?: SortOrderInput | SortOrder
    is_time?: SortOrderInput | SortOrder
  }

  export type em_exams_resultsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_exams_resultsWhereInput | em_exams_resultsWhereInput[]
    OR?: em_exams_resultsWhereInput[]
    NOT?: em_exams_resultsWhereInput | em_exams_resultsWhereInput[]
    exams_id?: StringNullableFilter<"em_exams_results"> | string | null
    empl_id?: IntNullableFilter<"em_exams_results"> | number | null
    soal_id?: IntNullableFilter<"em_exams_results"> | number | null
    is_changes?: IntNullableFilter<"em_exams_results"> | number | null
    is_answer?: StringNullableFilter<"em_exams_results"> | string | null
    is_time?: DateTimeNullableFilter<"em_exams_results"> | Date | string | null
  }, "Id">

  export type em_exams_resultsOrderByWithAggregationInput = {
    Id?: SortOrder
    exams_id?: SortOrderInput | SortOrder
    empl_id?: SortOrderInput | SortOrder
    soal_id?: SortOrderInput | SortOrder
    is_changes?: SortOrderInput | SortOrder
    is_answer?: SortOrderInput | SortOrder
    is_time?: SortOrderInput | SortOrder
    _count?: em_exams_resultsCountOrderByAggregateInput
    _avg?: em_exams_resultsAvgOrderByAggregateInput
    _max?: em_exams_resultsMaxOrderByAggregateInput
    _min?: em_exams_resultsMinOrderByAggregateInput
    _sum?: em_exams_resultsSumOrderByAggregateInput
  }

  export type em_exams_resultsScalarWhereWithAggregatesInput = {
    AND?: em_exams_resultsScalarWhereWithAggregatesInput | em_exams_resultsScalarWhereWithAggregatesInput[]
    OR?: em_exams_resultsScalarWhereWithAggregatesInput[]
    NOT?: em_exams_resultsScalarWhereWithAggregatesInput | em_exams_resultsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_exams_results"> | number
    exams_id?: StringNullableWithAggregatesFilter<"em_exams_results"> | string | null
    empl_id?: IntNullableWithAggregatesFilter<"em_exams_results"> | number | null
    soal_id?: IntNullableWithAggregatesFilter<"em_exams_results"> | number | null
    is_changes?: IntNullableWithAggregatesFilter<"em_exams_results"> | number | null
    is_answer?: StringNullableWithAggregatesFilter<"em_exams_results"> | string | null
    is_time?: DateTimeNullableWithAggregatesFilter<"em_exams_results"> | Date | string | null
  }

  export type em_faqWhereInput = {
    AND?: em_faqWhereInput | em_faqWhereInput[]
    OR?: em_faqWhereInput[]
    NOT?: em_faqWhereInput | em_faqWhereInput[]
    fqId?: IntFilter<"em_faq"> | number
    fqcatid?: IntNullableFilter<"em_faq"> | number | null
    isquestions?: StringNullableFilter<"em_faq"> | string | null
    isanswer?: StringNullableFilter<"em_faq"> | string | null
    status?: StringNullableFilter<"em_faq"> | string | null
    created_at?: DateTimeNullableFilter<"em_faq"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_faq"> | Date | string | null
    userid?: StringNullableFilter<"em_faq"> | string | null
    em_faq_cat?: XOR<Em_faq_catNullableScalarRelationFilter, em_faq_catWhereInput> | null
  }

  export type em_faqOrderByWithRelationInput = {
    fqId?: SortOrder
    fqcatid?: SortOrderInput | SortOrder
    isquestions?: SortOrderInput | SortOrder
    isanswer?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    em_faq_cat?: em_faq_catOrderByWithRelationInput
  }

  export type em_faqWhereUniqueInput = Prisma.AtLeast<{
    fqId?: number
    AND?: em_faqWhereInput | em_faqWhereInput[]
    OR?: em_faqWhereInput[]
    NOT?: em_faqWhereInput | em_faqWhereInput[]
    fqcatid?: IntNullableFilter<"em_faq"> | number | null
    isquestions?: StringNullableFilter<"em_faq"> | string | null
    isanswer?: StringNullableFilter<"em_faq"> | string | null
    status?: StringNullableFilter<"em_faq"> | string | null
    created_at?: DateTimeNullableFilter<"em_faq"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_faq"> | Date | string | null
    userid?: StringNullableFilter<"em_faq"> | string | null
    em_faq_cat?: XOR<Em_faq_catNullableScalarRelationFilter, em_faq_catWhereInput> | null
  }, "fqId">

  export type em_faqOrderByWithAggregationInput = {
    fqId?: SortOrder
    fqcatid?: SortOrderInput | SortOrder
    isquestions?: SortOrderInput | SortOrder
    isanswer?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    _count?: em_faqCountOrderByAggregateInput
    _avg?: em_faqAvgOrderByAggregateInput
    _max?: em_faqMaxOrderByAggregateInput
    _min?: em_faqMinOrderByAggregateInput
    _sum?: em_faqSumOrderByAggregateInput
  }

  export type em_faqScalarWhereWithAggregatesInput = {
    AND?: em_faqScalarWhereWithAggregatesInput | em_faqScalarWhereWithAggregatesInput[]
    OR?: em_faqScalarWhereWithAggregatesInput[]
    NOT?: em_faqScalarWhereWithAggregatesInput | em_faqScalarWhereWithAggregatesInput[]
    fqId?: IntWithAggregatesFilter<"em_faq"> | number
    fqcatid?: IntNullableWithAggregatesFilter<"em_faq"> | number | null
    isquestions?: StringNullableWithAggregatesFilter<"em_faq"> | string | null
    isanswer?: StringNullableWithAggregatesFilter<"em_faq"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_faq"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_faq"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_faq"> | Date | string | null
    userid?: StringNullableWithAggregatesFilter<"em_faq"> | string | null
  }

  export type em_faq_catWhereInput = {
    AND?: em_faq_catWhereInput | em_faq_catWhereInput[]
    OR?: em_faq_catWhereInput[]
    NOT?: em_faq_catWhereInput | em_faq_catWhereInput[]
    fqcatid?: IntFilter<"em_faq_cat"> | number
    name?: StringNullableFilter<"em_faq_cat"> | string | null
    status?: StringNullableFilter<"em_faq_cat"> | string | null
    created_at?: DateTimeNullableFilter<"em_faq_cat"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_faq_cat"> | Date | string | null
    em_faq?: Em_faqListRelationFilter
  }

  export type em_faq_catOrderByWithRelationInput = {
    fqcatid?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    em_faq?: em_faqOrderByRelationAggregateInput
  }

  export type em_faq_catWhereUniqueInput = Prisma.AtLeast<{
    fqcatid?: number
    AND?: em_faq_catWhereInput | em_faq_catWhereInput[]
    OR?: em_faq_catWhereInput[]
    NOT?: em_faq_catWhereInput | em_faq_catWhereInput[]
    name?: StringNullableFilter<"em_faq_cat"> | string | null
    status?: StringNullableFilter<"em_faq_cat"> | string | null
    created_at?: DateTimeNullableFilter<"em_faq_cat"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_faq_cat"> | Date | string | null
    em_faq?: Em_faqListRelationFilter
  }, "fqcatid">

  export type em_faq_catOrderByWithAggregationInput = {
    fqcatid?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_faq_catCountOrderByAggregateInput
    _avg?: em_faq_catAvgOrderByAggregateInput
    _max?: em_faq_catMaxOrderByAggregateInput
    _min?: em_faq_catMinOrderByAggregateInput
    _sum?: em_faq_catSumOrderByAggregateInput
  }

  export type em_faq_catScalarWhereWithAggregatesInput = {
    AND?: em_faq_catScalarWhereWithAggregatesInput | em_faq_catScalarWhereWithAggregatesInput[]
    OR?: em_faq_catScalarWhereWithAggregatesInput[]
    NOT?: em_faq_catScalarWhereWithAggregatesInput | em_faq_catScalarWhereWithAggregatesInput[]
    fqcatid?: IntWithAggregatesFilter<"em_faq_cat"> | number
    name?: StringNullableWithAggregatesFilter<"em_faq_cat"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_faq_cat"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_faq_cat"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_faq_cat"> | Date | string | null
  }

  export type em_galeri_materiWhereInput = {
    AND?: em_galeri_materiWhereInput | em_galeri_materiWhereInput[]
    OR?: em_galeri_materiWhereInput[]
    NOT?: em_galeri_materiWhereInput | em_galeri_materiWhereInput[]
    id?: IntFilter<"em_galeri_materi"> | number
    title?: StringFilter<"em_galeri_materi"> | string
    file_type?: IntFilter<"em_galeri_materi"> | number
    file_name?: StringNullableFilter<"em_galeri_materi"> | string | null
    file_size?: FloatNullableFilter<"em_galeri_materi"> | number | null
    url?: StringNullableFilter<"em_galeri_materi"> | string | null
    urutan?: IntNullableFilter<"em_galeri_materi"> | number | null
    status?: StringNullableFilter<"em_galeri_materi"> | string | null
    created_date?: DateTimeNullableFilter<"em_galeri_materi"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_galeri_materi"> | Date | string | null
  }

  export type em_galeri_materiOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    file_type?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    urutan?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
  }

  export type em_galeri_materiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_galeri_materiWhereInput | em_galeri_materiWhereInput[]
    OR?: em_galeri_materiWhereInput[]
    NOT?: em_galeri_materiWhereInput | em_galeri_materiWhereInput[]
    title?: StringFilter<"em_galeri_materi"> | string
    file_type?: IntFilter<"em_galeri_materi"> | number
    file_name?: StringNullableFilter<"em_galeri_materi"> | string | null
    file_size?: FloatNullableFilter<"em_galeri_materi"> | number | null
    url?: StringNullableFilter<"em_galeri_materi"> | string | null
    urutan?: IntNullableFilter<"em_galeri_materi"> | number | null
    status?: StringNullableFilter<"em_galeri_materi"> | string | null
    created_date?: DateTimeNullableFilter<"em_galeri_materi"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_galeri_materi"> | Date | string | null
  }, "id">

  export type em_galeri_materiOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    file_type?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    urutan?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    _count?: em_galeri_materiCountOrderByAggregateInput
    _avg?: em_galeri_materiAvgOrderByAggregateInput
    _max?: em_galeri_materiMaxOrderByAggregateInput
    _min?: em_galeri_materiMinOrderByAggregateInput
    _sum?: em_galeri_materiSumOrderByAggregateInput
  }

  export type em_galeri_materiScalarWhereWithAggregatesInput = {
    AND?: em_galeri_materiScalarWhereWithAggregatesInput | em_galeri_materiScalarWhereWithAggregatesInput[]
    OR?: em_galeri_materiScalarWhereWithAggregatesInput[]
    NOT?: em_galeri_materiScalarWhereWithAggregatesInput | em_galeri_materiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_galeri_materi"> | number
    title?: StringWithAggregatesFilter<"em_galeri_materi"> | string
    file_type?: IntWithAggregatesFilter<"em_galeri_materi"> | number
    file_name?: StringNullableWithAggregatesFilter<"em_galeri_materi"> | string | null
    file_size?: FloatNullableWithAggregatesFilter<"em_galeri_materi"> | number | null
    url?: StringNullableWithAggregatesFilter<"em_galeri_materi"> | string | null
    urutan?: IntNullableWithAggregatesFilter<"em_galeri_materi"> | number | null
    status?: StringNullableWithAggregatesFilter<"em_galeri_materi"> | string | null
    created_date?: DateTimeNullableWithAggregatesFilter<"em_galeri_materi"> | Date | string | null
    last_update?: DateTimeNullableWithAggregatesFilter<"em_galeri_materi"> | Date | string | null
  }

  export type em_groupWhereInput = {
    AND?: em_groupWhereInput | em_groupWhereInput[]
    OR?: em_groupWhereInput[]
    NOT?: em_groupWhereInput | em_groupWhereInput[]
    GroupId?: IntFilter<"em_group"> | number
    GroupName?: StringNullableFilter<"em_group"> | string | null
    Status?: StringNullableFilter<"em_group"> | string | null
    CreateDate?: DateTimeNullableFilter<"em_group"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_group"> | Date | string | null
  }

  export type em_groupOrderByWithRelationInput = {
    GroupId?: SortOrder
    GroupName?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreateDate?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
  }

  export type em_groupWhereUniqueInput = Prisma.AtLeast<{
    GroupId?: number
    AND?: em_groupWhereInput | em_groupWhereInput[]
    OR?: em_groupWhereInput[]
    NOT?: em_groupWhereInput | em_groupWhereInput[]
    GroupName?: StringNullableFilter<"em_group"> | string | null
    Status?: StringNullableFilter<"em_group"> | string | null
    CreateDate?: DateTimeNullableFilter<"em_group"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_group"> | Date | string | null
  }, "GroupId">

  export type em_groupOrderByWithAggregationInput = {
    GroupId?: SortOrder
    GroupName?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreateDate?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    _count?: em_groupCountOrderByAggregateInput
    _avg?: em_groupAvgOrderByAggregateInput
    _max?: em_groupMaxOrderByAggregateInput
    _min?: em_groupMinOrderByAggregateInput
    _sum?: em_groupSumOrderByAggregateInput
  }

  export type em_groupScalarWhereWithAggregatesInput = {
    AND?: em_groupScalarWhereWithAggregatesInput | em_groupScalarWhereWithAggregatesInput[]
    OR?: em_groupScalarWhereWithAggregatesInput[]
    NOT?: em_groupScalarWhereWithAggregatesInput | em_groupScalarWhereWithAggregatesInput[]
    GroupId?: IntWithAggregatesFilter<"em_group"> | number
    GroupName?: StringNullableWithAggregatesFilter<"em_group"> | string | null
    Status?: StringNullableWithAggregatesFilter<"em_group"> | string | null
    CreateDate?: DateTimeNullableWithAggregatesFilter<"em_group"> | Date | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_group"> | Date | string | null
  }

  export type em_hero_sectionWhereInput = {
    AND?: em_hero_sectionWhereInput | em_hero_sectionWhereInput[]
    OR?: em_hero_sectionWhereInput[]
    NOT?: em_hero_sectionWhereInput | em_hero_sectionWhereInput[]
    hsId?: IntFilter<"em_hero_section"> | number
    hsName?: StringNullableFilter<"em_hero_section"> | string | null
    hsDesc?: StringNullableFilter<"em_hero_section"> | string | null
    hsStats?: StringNullableFilter<"em_hero_section"> | string | null
    hsFileImage?: StringNullableFilter<"em_hero_section"> | string | null
    hsLink?: StringNullableFilter<"em_hero_section"> | string | null
    hsUserid?: StringNullableFilter<"em_hero_section"> | string | null
    hsDate?: DateTimeNullableFilter<"em_hero_section"> | Date | string | null
    hsLastupdate?: DateTimeNullableFilter<"em_hero_section"> | Date | string | null
    Urutan?: IntNullableFilter<"em_hero_section"> | number | null
  }

  export type em_hero_sectionOrderByWithRelationInput = {
    hsId?: SortOrder
    hsName?: SortOrderInput | SortOrder
    hsDesc?: SortOrderInput | SortOrder
    hsStats?: SortOrderInput | SortOrder
    hsFileImage?: SortOrderInput | SortOrder
    hsLink?: SortOrderInput | SortOrder
    hsUserid?: SortOrderInput | SortOrder
    hsDate?: SortOrderInput | SortOrder
    hsLastupdate?: SortOrderInput | SortOrder
    Urutan?: SortOrderInput | SortOrder
  }

  export type em_hero_sectionWhereUniqueInput = Prisma.AtLeast<{
    hsId?: number
    AND?: em_hero_sectionWhereInput | em_hero_sectionWhereInput[]
    OR?: em_hero_sectionWhereInput[]
    NOT?: em_hero_sectionWhereInput | em_hero_sectionWhereInput[]
    hsName?: StringNullableFilter<"em_hero_section"> | string | null
    hsDesc?: StringNullableFilter<"em_hero_section"> | string | null
    hsStats?: StringNullableFilter<"em_hero_section"> | string | null
    hsFileImage?: StringNullableFilter<"em_hero_section"> | string | null
    hsLink?: StringNullableFilter<"em_hero_section"> | string | null
    hsUserid?: StringNullableFilter<"em_hero_section"> | string | null
    hsDate?: DateTimeNullableFilter<"em_hero_section"> | Date | string | null
    hsLastupdate?: DateTimeNullableFilter<"em_hero_section"> | Date | string | null
    Urutan?: IntNullableFilter<"em_hero_section"> | number | null
  }, "hsId">

  export type em_hero_sectionOrderByWithAggregationInput = {
    hsId?: SortOrder
    hsName?: SortOrderInput | SortOrder
    hsDesc?: SortOrderInput | SortOrder
    hsStats?: SortOrderInput | SortOrder
    hsFileImage?: SortOrderInput | SortOrder
    hsLink?: SortOrderInput | SortOrder
    hsUserid?: SortOrderInput | SortOrder
    hsDate?: SortOrderInput | SortOrder
    hsLastupdate?: SortOrderInput | SortOrder
    Urutan?: SortOrderInput | SortOrder
    _count?: em_hero_sectionCountOrderByAggregateInput
    _avg?: em_hero_sectionAvgOrderByAggregateInput
    _max?: em_hero_sectionMaxOrderByAggregateInput
    _min?: em_hero_sectionMinOrderByAggregateInput
    _sum?: em_hero_sectionSumOrderByAggregateInput
  }

  export type em_hero_sectionScalarWhereWithAggregatesInput = {
    AND?: em_hero_sectionScalarWhereWithAggregatesInput | em_hero_sectionScalarWhereWithAggregatesInput[]
    OR?: em_hero_sectionScalarWhereWithAggregatesInput[]
    NOT?: em_hero_sectionScalarWhereWithAggregatesInput | em_hero_sectionScalarWhereWithAggregatesInput[]
    hsId?: IntWithAggregatesFilter<"em_hero_section"> | number
    hsName?: StringNullableWithAggregatesFilter<"em_hero_section"> | string | null
    hsDesc?: StringNullableWithAggregatesFilter<"em_hero_section"> | string | null
    hsStats?: StringNullableWithAggregatesFilter<"em_hero_section"> | string | null
    hsFileImage?: StringNullableWithAggregatesFilter<"em_hero_section"> | string | null
    hsLink?: StringNullableWithAggregatesFilter<"em_hero_section"> | string | null
    hsUserid?: StringNullableWithAggregatesFilter<"em_hero_section"> | string | null
    hsDate?: DateTimeNullableWithAggregatesFilter<"em_hero_section"> | Date | string | null
    hsLastupdate?: DateTimeNullableWithAggregatesFilter<"em_hero_section"> | Date | string | null
    Urutan?: IntNullableWithAggregatesFilter<"em_hero_section"> | number | null
  }

  export type em_jawaban_pesertaWhereInput = {
    AND?: em_jawaban_pesertaWhereInput | em_jawaban_pesertaWhereInput[]
    OR?: em_jawaban_pesertaWhereInput[]
    NOT?: em_jawaban_pesertaWhereInput | em_jawaban_pesertaWhereInput[]
    Id?: IntFilter<"em_jawaban_peserta"> | number
    empl_id?: IntFilter<"em_jawaban_peserta"> | number
    soal_id?: IntFilter<"em_jawaban_peserta"> | number
    session_exams_id?: StringFilter<"em_jawaban_peserta"> | string
    jawaban?: StringNullableFilter<"em_jawaban_peserta"> | string | null
    jawaban2?: StringNullableFilter<"em_jawaban_peserta"> | string | null
    waktu_jawab?: DateTimeNullableFilter<"em_jawaban_peserta"> | Date | string | null
    Score?: FloatNullableFilter<"em_jawaban_peserta"> | number | null
    is_correction?: IntNullableFilter<"em_jawaban_peserta"> | number | null
    is_train_jawaban?: BoolNullableFilter<"em_jawaban_peserta"> | boolean | null
    em_session_exams?: XOR<Em_session_examsScalarRelationFilter, em_session_examsWhereInput>
  }

  export type em_jawaban_pesertaOrderByWithRelationInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban?: SortOrderInput | SortOrder
    jawaban2?: SortOrderInput | SortOrder
    waktu_jawab?: SortOrderInput | SortOrder
    Score?: SortOrderInput | SortOrder
    is_correction?: SortOrderInput | SortOrder
    is_train_jawaban?: SortOrderInput | SortOrder
    em_session_exams?: em_session_examsOrderByWithRelationInput
  }

  export type em_jawaban_pesertaWhereUniqueInput = Prisma.AtLeast<{
    Id_empl_id_soal_id_session_exams_id?: em_jawaban_pesertaIdEmpl_idSoal_idSession_exams_idCompoundUniqueInput
    AND?: em_jawaban_pesertaWhereInput | em_jawaban_pesertaWhereInput[]
    OR?: em_jawaban_pesertaWhereInput[]
    NOT?: em_jawaban_pesertaWhereInput | em_jawaban_pesertaWhereInput[]
    Id?: IntFilter<"em_jawaban_peserta"> | number
    empl_id?: IntFilter<"em_jawaban_peserta"> | number
    soal_id?: IntFilter<"em_jawaban_peserta"> | number
    session_exams_id?: StringFilter<"em_jawaban_peserta"> | string
    jawaban?: StringNullableFilter<"em_jawaban_peserta"> | string | null
    jawaban2?: StringNullableFilter<"em_jawaban_peserta"> | string | null
    waktu_jawab?: DateTimeNullableFilter<"em_jawaban_peserta"> | Date | string | null
    Score?: FloatNullableFilter<"em_jawaban_peserta"> | number | null
    is_correction?: IntNullableFilter<"em_jawaban_peserta"> | number | null
    is_train_jawaban?: BoolNullableFilter<"em_jawaban_peserta"> | boolean | null
    em_session_exams?: XOR<Em_session_examsScalarRelationFilter, em_session_examsWhereInput>
  }, "Id_empl_id_soal_id_session_exams_id">

  export type em_jawaban_pesertaOrderByWithAggregationInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban?: SortOrderInput | SortOrder
    jawaban2?: SortOrderInput | SortOrder
    waktu_jawab?: SortOrderInput | SortOrder
    Score?: SortOrderInput | SortOrder
    is_correction?: SortOrderInput | SortOrder
    is_train_jawaban?: SortOrderInput | SortOrder
    _count?: em_jawaban_pesertaCountOrderByAggregateInput
    _avg?: em_jawaban_pesertaAvgOrderByAggregateInput
    _max?: em_jawaban_pesertaMaxOrderByAggregateInput
    _min?: em_jawaban_pesertaMinOrderByAggregateInput
    _sum?: em_jawaban_pesertaSumOrderByAggregateInput
  }

  export type em_jawaban_pesertaScalarWhereWithAggregatesInput = {
    AND?: em_jawaban_pesertaScalarWhereWithAggregatesInput | em_jawaban_pesertaScalarWhereWithAggregatesInput[]
    OR?: em_jawaban_pesertaScalarWhereWithAggregatesInput[]
    NOT?: em_jawaban_pesertaScalarWhereWithAggregatesInput | em_jawaban_pesertaScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_jawaban_peserta"> | number
    empl_id?: IntWithAggregatesFilter<"em_jawaban_peserta"> | number
    soal_id?: IntWithAggregatesFilter<"em_jawaban_peserta"> | number
    session_exams_id?: StringWithAggregatesFilter<"em_jawaban_peserta"> | string
    jawaban?: StringNullableWithAggregatesFilter<"em_jawaban_peserta"> | string | null
    jawaban2?: StringNullableWithAggregatesFilter<"em_jawaban_peserta"> | string | null
    waktu_jawab?: DateTimeNullableWithAggregatesFilter<"em_jawaban_peserta"> | Date | string | null
    Score?: FloatNullableWithAggregatesFilter<"em_jawaban_peserta"> | number | null
    is_correction?: IntNullableWithAggregatesFilter<"em_jawaban_peserta"> | number | null
    is_train_jawaban?: BoolNullableWithAggregatesFilter<"em_jawaban_peserta"> | boolean | null
  }

  export type em_jawaban_peserta_apcWhereInput = {
    AND?: em_jawaban_peserta_apcWhereInput | em_jawaban_peserta_apcWhereInput[]
    OR?: em_jawaban_peserta_apcWhereInput[]
    NOT?: em_jawaban_peserta_apcWhereInput | em_jawaban_peserta_apcWhereInput[]
    Id?: IntFilter<"em_jawaban_peserta_apc"> | number
    apc_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    soal_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    topic_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    session_exams_id?: StringFilter<"em_jawaban_peserta_apc"> | string
    jawaban_option?: StringNullableFilter<"em_jawaban_peserta_apc"> | string | null
    jawaban_text?: StringNullableFilter<"em_jawaban_peserta_apc"> | string | null
    waktu_jawab?: DateTimeNullableFilter<"em_jawaban_peserta_apc"> | Date | string | null
    score?: FloatNullableFilter<"em_jawaban_peserta_apc"> | number | null
    is_correction?: BoolNullableFilter<"em_jawaban_peserta_apc"> | boolean | null
    is_train_jawaban?: BoolNullableFilter<"em_jawaban_peserta_apc"> | boolean | null
    em_session_exams_apc?: XOR<Em_session_exams_apcScalarRelationFilter, em_session_exams_apcWhereInput>
  }

  export type em_jawaban_peserta_apcOrderByWithRelationInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban_option?: SortOrderInput | SortOrder
    jawaban_text?: SortOrderInput | SortOrder
    waktu_jawab?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    is_correction?: SortOrderInput | SortOrder
    is_train_jawaban?: SortOrderInput | SortOrder
    em_session_exams_apc?: em_session_exams_apcOrderByWithRelationInput
  }

  export type em_jawaban_peserta_apcWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_jawaban_peserta_apcWhereInput | em_jawaban_peserta_apcWhereInput[]
    OR?: em_jawaban_peserta_apcWhereInput[]
    NOT?: em_jawaban_peserta_apcWhereInput | em_jawaban_peserta_apcWhereInput[]
    apc_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    soal_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    topic_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    session_exams_id?: StringFilter<"em_jawaban_peserta_apc"> | string
    jawaban_option?: StringNullableFilter<"em_jawaban_peserta_apc"> | string | null
    jawaban_text?: StringNullableFilter<"em_jawaban_peserta_apc"> | string | null
    waktu_jawab?: DateTimeNullableFilter<"em_jawaban_peserta_apc"> | Date | string | null
    score?: FloatNullableFilter<"em_jawaban_peserta_apc"> | number | null
    is_correction?: BoolNullableFilter<"em_jawaban_peserta_apc"> | boolean | null
    is_train_jawaban?: BoolNullableFilter<"em_jawaban_peserta_apc"> | boolean | null
    em_session_exams_apc?: XOR<Em_session_exams_apcScalarRelationFilter, em_session_exams_apcWhereInput>
  }, "Id">

  export type em_jawaban_peserta_apcOrderByWithAggregationInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban_option?: SortOrderInput | SortOrder
    jawaban_text?: SortOrderInput | SortOrder
    waktu_jawab?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    is_correction?: SortOrderInput | SortOrder
    is_train_jawaban?: SortOrderInput | SortOrder
    _count?: em_jawaban_peserta_apcCountOrderByAggregateInput
    _avg?: em_jawaban_peserta_apcAvgOrderByAggregateInput
    _max?: em_jawaban_peserta_apcMaxOrderByAggregateInput
    _min?: em_jawaban_peserta_apcMinOrderByAggregateInput
    _sum?: em_jawaban_peserta_apcSumOrderByAggregateInput
  }

  export type em_jawaban_peserta_apcScalarWhereWithAggregatesInput = {
    AND?: em_jawaban_peserta_apcScalarWhereWithAggregatesInput | em_jawaban_peserta_apcScalarWhereWithAggregatesInput[]
    OR?: em_jawaban_peserta_apcScalarWhereWithAggregatesInput[]
    NOT?: em_jawaban_peserta_apcScalarWhereWithAggregatesInput | em_jawaban_peserta_apcScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_jawaban_peserta_apc"> | number
    apc_id?: IntWithAggregatesFilter<"em_jawaban_peserta_apc"> | number
    soal_id?: IntWithAggregatesFilter<"em_jawaban_peserta_apc"> | number
    topic_id?: IntWithAggregatesFilter<"em_jawaban_peserta_apc"> | number
    session_exams_id?: StringWithAggregatesFilter<"em_jawaban_peserta_apc"> | string
    jawaban_option?: StringNullableWithAggregatesFilter<"em_jawaban_peserta_apc"> | string | null
    jawaban_text?: StringNullableWithAggregatesFilter<"em_jawaban_peserta_apc"> | string | null
    waktu_jawab?: DateTimeNullableWithAggregatesFilter<"em_jawaban_peserta_apc"> | Date | string | null
    score?: FloatNullableWithAggregatesFilter<"em_jawaban_peserta_apc"> | number | null
    is_correction?: BoolNullableWithAggregatesFilter<"em_jawaban_peserta_apc"> | boolean | null
    is_train_jawaban?: BoolNullableWithAggregatesFilter<"em_jawaban_peserta_apc"> | boolean | null
  }

  export type em_jobfairWhereInput = {
    AND?: em_jobfairWhereInput | em_jobfairWhereInput[]
    OR?: em_jobfairWhereInput[]
    NOT?: em_jobfairWhereInput | em_jobfairWhereInput[]
    id?: IntFilter<"em_jobfair"> | number
    lokasi?: StringFilter<"em_jobfair"> | string
    status?: StringNullableFilter<"em_jobfair"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_jobfair"> | Date | string | null
  }

  export type em_jobfairOrderByWithRelationInput = {
    id?: SortOrder
    lokasi?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type em_jobfairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_jobfairWhereInput | em_jobfairWhereInput[]
    OR?: em_jobfairWhereInput[]
    NOT?: em_jobfairWhereInput | em_jobfairWhereInput[]
    lokasi?: StringFilter<"em_jobfair"> | string
    status?: StringNullableFilter<"em_jobfair"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_jobfair"> | Date | string | null
  }, "id">

  export type em_jobfairOrderByWithAggregationInput = {
    id?: SortOrder
    lokasi?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_jobfairCountOrderByAggregateInput
    _avg?: em_jobfairAvgOrderByAggregateInput
    _max?: em_jobfairMaxOrderByAggregateInput
    _min?: em_jobfairMinOrderByAggregateInput
    _sum?: em_jobfairSumOrderByAggregateInput
  }

  export type em_jobfairScalarWhereWithAggregatesInput = {
    AND?: em_jobfairScalarWhereWithAggregatesInput | em_jobfairScalarWhereWithAggregatesInput[]
    OR?: em_jobfairScalarWhereWithAggregatesInput[]
    NOT?: em_jobfairScalarWhereWithAggregatesInput | em_jobfairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_jobfair"> | number
    lokasi?: StringWithAggregatesFilter<"em_jobfair"> | string
    status?: StringNullableWithAggregatesFilter<"em_jobfair"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_jobfair"> | Date | string | null
  }

  export type em_levelpossWhereInput = {
    AND?: em_levelpossWhereInput | em_levelpossWhereInput[]
    OR?: em_levelpossWhereInput[]
    NOT?: em_levelpossWhereInput | em_levelpossWhereInput[]
    id?: IntFilter<"em_levelposs"> | number
    level_text?: StringFilter<"em_levelposs"> | string
    status?: StringNullableFilter<"em_levelposs"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_levelposs"> | Date | string | null
  }

  export type em_levelpossOrderByWithRelationInput = {
    id?: SortOrder
    level_text?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type em_levelpossWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_levelpossWhereInput | em_levelpossWhereInput[]
    OR?: em_levelpossWhereInput[]
    NOT?: em_levelpossWhereInput | em_levelpossWhereInput[]
    level_text?: StringFilter<"em_levelposs"> | string
    status?: StringNullableFilter<"em_levelposs"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_levelposs"> | Date | string | null
  }, "id">

  export type em_levelpossOrderByWithAggregationInput = {
    id?: SortOrder
    level_text?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_levelpossCountOrderByAggregateInput
    _avg?: em_levelpossAvgOrderByAggregateInput
    _max?: em_levelpossMaxOrderByAggregateInput
    _min?: em_levelpossMinOrderByAggregateInput
    _sum?: em_levelpossSumOrderByAggregateInput
  }

  export type em_levelpossScalarWhereWithAggregatesInput = {
    AND?: em_levelpossScalarWhereWithAggregatesInput | em_levelpossScalarWhereWithAggregatesInput[]
    OR?: em_levelpossScalarWhereWithAggregatesInput[]
    NOT?: em_levelpossScalarWhereWithAggregatesInput | em_levelpossScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_levelposs"> | number
    level_text?: StringWithAggregatesFilter<"em_levelposs"> | string
    status?: StringNullableWithAggregatesFilter<"em_levelposs"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_levelposs"> | Date | string | null
  }

  export type em_logsWhereInput = {
    AND?: em_logsWhereInput | em_logsWhereInput[]
    OR?: em_logsWhereInput[]
    NOT?: em_logsWhereInput | em_logsWhereInput[]
    Id?: IntFilter<"em_logs"> | number
    IP?: StringNullableFilter<"em_logs"> | string | null
    Login?: DateTimeNullableFilter<"em_logs"> | Date | string | null
    Logout?: DateTimeNullableFilter<"em_logs"> | Date | string | null
    UserId?: StringNullableFilter<"em_logs"> | string | null
    LogId?: IntNullableFilter<"em_logs"> | number | null
    Notes?: StringNullableFilter<"em_logs"> | string | null
    LastUpdate?: DateTimeNullableFilter<"em_logs"> | Date | string | null
  }

  export type em_logsOrderByWithRelationInput = {
    Id?: SortOrder
    IP?: SortOrderInput | SortOrder
    Login?: SortOrderInput | SortOrder
    Logout?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    LogId?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
  }

  export type em_logsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_logsWhereInput | em_logsWhereInput[]
    OR?: em_logsWhereInput[]
    NOT?: em_logsWhereInput | em_logsWhereInput[]
    IP?: StringNullableFilter<"em_logs"> | string | null
    Login?: DateTimeNullableFilter<"em_logs"> | Date | string | null
    Logout?: DateTimeNullableFilter<"em_logs"> | Date | string | null
    UserId?: StringNullableFilter<"em_logs"> | string | null
    LogId?: IntNullableFilter<"em_logs"> | number | null
    Notes?: StringNullableFilter<"em_logs"> | string | null
    LastUpdate?: DateTimeNullableFilter<"em_logs"> | Date | string | null
  }, "Id">

  export type em_logsOrderByWithAggregationInput = {
    Id?: SortOrder
    IP?: SortOrderInput | SortOrder
    Login?: SortOrderInput | SortOrder
    Logout?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    LogId?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    _count?: em_logsCountOrderByAggregateInput
    _avg?: em_logsAvgOrderByAggregateInput
    _max?: em_logsMaxOrderByAggregateInput
    _min?: em_logsMinOrderByAggregateInput
    _sum?: em_logsSumOrderByAggregateInput
  }

  export type em_logsScalarWhereWithAggregatesInput = {
    AND?: em_logsScalarWhereWithAggregatesInput | em_logsScalarWhereWithAggregatesInput[]
    OR?: em_logsScalarWhereWithAggregatesInput[]
    NOT?: em_logsScalarWhereWithAggregatesInput | em_logsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_logs"> | number
    IP?: StringNullableWithAggregatesFilter<"em_logs"> | string | null
    Login?: DateTimeNullableWithAggregatesFilter<"em_logs"> | Date | string | null
    Logout?: DateTimeNullableWithAggregatesFilter<"em_logs"> | Date | string | null
    UserId?: StringNullableWithAggregatesFilter<"em_logs"> | string | null
    LogId?: IntNullableWithAggregatesFilter<"em_logs"> | number | null
    Notes?: StringNullableWithAggregatesFilter<"em_logs"> | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_logs"> | Date | string | null
  }

  export type em_lokerWhereInput = {
    AND?: em_lokerWhereInput | em_lokerWhereInput[]
    OR?: em_lokerWhereInput[]
    NOT?: em_lokerWhereInput | em_lokerWhereInput[]
    lokerid?: IntFilter<"em_loker"> | number
    possid?: IntFilter<"em_loker"> | number
    startdate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    enddate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    jobdesc?: StringNullableFilter<"em_loker"> | string | null
    qualify?: StringNullableFilter<"em_loker"> | string | null
    worktype?: StringNullableFilter<"em_loker"> | string | null
    salary?: StringNullableFilter<"em_loker"> | string | null
    contrtype?: StringNullableFilter<"em_loker"> | string | null
    posslevel?: StringNullableFilter<"em_loker"> | string | null
    status?: StringNullableFilter<"em_loker"> | string | null
    benefit?: StringNullableFilter<"em_loker"> | string | null
    fileimage?: StringNullableFilter<"em_loker"> | string | null
    createdate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    userid?: StringNullableFilter<"em_loker"> | string | null
    kategori?: IntNullableFilter<"em_loker"> | number | null
    em_loktopik?: Em_loktopikListRelationFilter
  }

  export type em_lokerOrderByWithRelationInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    jobdesc?: SortOrderInput | SortOrder
    qualify?: SortOrderInput | SortOrder
    worktype?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    contrtype?: SortOrderInput | SortOrder
    posslevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    fileimage?: SortOrderInput | SortOrder
    createdate?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    kategori?: SortOrderInput | SortOrder
    em_loktopik?: em_loktopikOrderByRelationAggregateInput
  }

  export type em_lokerWhereUniqueInput = Prisma.AtLeast<{
    lokerid?: number
    AND?: em_lokerWhereInput | em_lokerWhereInput[]
    OR?: em_lokerWhereInput[]
    NOT?: em_lokerWhereInput | em_lokerWhereInput[]
    possid?: IntFilter<"em_loker"> | number
    startdate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    enddate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    jobdesc?: StringNullableFilter<"em_loker"> | string | null
    qualify?: StringNullableFilter<"em_loker"> | string | null
    worktype?: StringNullableFilter<"em_loker"> | string | null
    salary?: StringNullableFilter<"em_loker"> | string | null
    contrtype?: StringNullableFilter<"em_loker"> | string | null
    posslevel?: StringNullableFilter<"em_loker"> | string | null
    status?: StringNullableFilter<"em_loker"> | string | null
    benefit?: StringNullableFilter<"em_loker"> | string | null
    fileimage?: StringNullableFilter<"em_loker"> | string | null
    createdate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_loker"> | Date | string | null
    userid?: StringNullableFilter<"em_loker"> | string | null
    kategori?: IntNullableFilter<"em_loker"> | number | null
    em_loktopik?: Em_loktopikListRelationFilter
  }, "lokerid">

  export type em_lokerOrderByWithAggregationInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    jobdesc?: SortOrderInput | SortOrder
    qualify?: SortOrderInput | SortOrder
    worktype?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    contrtype?: SortOrderInput | SortOrder
    posslevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    fileimage?: SortOrderInput | SortOrder
    createdate?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    kategori?: SortOrderInput | SortOrder
    _count?: em_lokerCountOrderByAggregateInput
    _avg?: em_lokerAvgOrderByAggregateInput
    _max?: em_lokerMaxOrderByAggregateInput
    _min?: em_lokerMinOrderByAggregateInput
    _sum?: em_lokerSumOrderByAggregateInput
  }

  export type em_lokerScalarWhereWithAggregatesInput = {
    AND?: em_lokerScalarWhereWithAggregatesInput | em_lokerScalarWhereWithAggregatesInput[]
    OR?: em_lokerScalarWhereWithAggregatesInput[]
    NOT?: em_lokerScalarWhereWithAggregatesInput | em_lokerScalarWhereWithAggregatesInput[]
    lokerid?: IntWithAggregatesFilter<"em_loker"> | number
    possid?: IntWithAggregatesFilter<"em_loker"> | number
    startdate?: DateTimeNullableWithAggregatesFilter<"em_loker"> | Date | string | null
    enddate?: DateTimeNullableWithAggregatesFilter<"em_loker"> | Date | string | null
    jobdesc?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    qualify?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    worktype?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    salary?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    contrtype?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    posslevel?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    benefit?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    fileimage?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    createdate?: DateTimeNullableWithAggregatesFilter<"em_loker"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_loker"> | Date | string | null
    userid?: StringNullableWithAggregatesFilter<"em_loker"> | string | null
    kategori?: IntNullableWithAggregatesFilter<"em_loker"> | number | null
  }

  export type em_loktopikWhereInput = {
    AND?: em_loktopikWhereInput | em_loktopikWhereInput[]
    OR?: em_loktopikWhereInput[]
    NOT?: em_loktopikWhereInput | em_loktopikWhereInput[]
    id?: IntFilter<"em_loktopik"> | number
    loker_id?: IntFilter<"em_loktopik"> | number
    topik_id?: IntFilter<"em_loktopik"> | number
    jmlh_soal?: IntFilter<"em_loktopik"> | number
    created_at?: DateTimeNullableFilter<"em_loktopik"> | Date | string | null
    possid?: IntNullableFilter<"em_loktopik"> | number | null
    urutan?: IntNullableFilter<"em_loktopik"> | number | null
    em_loker?: XOR<Em_lokerScalarRelationFilter, em_lokerWhereInput>
    em_exams?: XOR<Em_examsScalarRelationFilter, em_examsWhereInput>
  }

  export type em_loktopikOrderByWithRelationInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    created_at?: SortOrderInput | SortOrder
    possid?: SortOrderInput | SortOrder
    urutan?: SortOrderInput | SortOrder
    em_loker?: em_lokerOrderByWithRelationInput
    em_exams?: em_examsOrderByWithRelationInput
  }

  export type em_loktopikWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_loktopikWhereInput | em_loktopikWhereInput[]
    OR?: em_loktopikWhereInput[]
    NOT?: em_loktopikWhereInput | em_loktopikWhereInput[]
    loker_id?: IntFilter<"em_loktopik"> | number
    topik_id?: IntFilter<"em_loktopik"> | number
    jmlh_soal?: IntFilter<"em_loktopik"> | number
    created_at?: DateTimeNullableFilter<"em_loktopik"> | Date | string | null
    possid?: IntNullableFilter<"em_loktopik"> | number | null
    urutan?: IntNullableFilter<"em_loktopik"> | number | null
    em_loker?: XOR<Em_lokerScalarRelationFilter, em_lokerWhereInput>
    em_exams?: XOR<Em_examsScalarRelationFilter, em_examsWhereInput>
  }, "id">

  export type em_loktopikOrderByWithAggregationInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    created_at?: SortOrderInput | SortOrder
    possid?: SortOrderInput | SortOrder
    urutan?: SortOrderInput | SortOrder
    _count?: em_loktopikCountOrderByAggregateInput
    _avg?: em_loktopikAvgOrderByAggregateInput
    _max?: em_loktopikMaxOrderByAggregateInput
    _min?: em_loktopikMinOrderByAggregateInput
    _sum?: em_loktopikSumOrderByAggregateInput
  }

  export type em_loktopikScalarWhereWithAggregatesInput = {
    AND?: em_loktopikScalarWhereWithAggregatesInput | em_loktopikScalarWhereWithAggregatesInput[]
    OR?: em_loktopikScalarWhereWithAggregatesInput[]
    NOT?: em_loktopikScalarWhereWithAggregatesInput | em_loktopikScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_loktopik"> | number
    loker_id?: IntWithAggregatesFilter<"em_loktopik"> | number
    topik_id?: IntWithAggregatesFilter<"em_loktopik"> | number
    jmlh_soal?: IntWithAggregatesFilter<"em_loktopik"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"em_loktopik"> | Date | string | null
    possid?: IntNullableWithAggregatesFilter<"em_loktopik"> | number | null
    urutan?: IntNullableWithAggregatesFilter<"em_loktopik"> | number | null
  }

  export type em_materi_fileWhereInput = {
    AND?: em_materi_fileWhereInput | em_materi_fileWhereInput[]
    OR?: em_materi_fileWhereInput[]
    NOT?: em_materi_fileWhereInput | em_materi_fileWhereInput[]
    id?: IntFilter<"em_materi_file"> | number
    materi_id?: IntFilter<"em_materi_file"> | number
    file_name?: StringFilter<"em_materi_file"> | string
    file_type?: IntFilter<"em_materi_file"> | number
    file_size?: FloatNullableFilter<"em_materi_file"> | number | null
    url?: StringNullableFilter<"em_materi_file"> | string | null
    urutan?: IntNullableFilter<"em_materi_file"> | number | null
    judul?: StringNullableFilter<"em_materi_file"> | string | null
    created_at?: DateTimeNullableFilter<"em_materi_file"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"em_materi_file"> | Date | string | null
    galeri_id?: IntNullableFilter<"em_materi_file"> | number | null
    em_materi1?: XOR<Em_materi1ScalarRelationFilter, em_materi1WhereInput>
  }

  export type em_materi_fileOrderByWithRelationInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    urutan?: SortOrderInput | SortOrder
    judul?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    galeri_id?: SortOrderInput | SortOrder
    em_materi1?: em_materi1OrderByWithRelationInput
  }

  export type em_materi_fileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_materi_fileWhereInput | em_materi_fileWhereInput[]
    OR?: em_materi_fileWhereInput[]
    NOT?: em_materi_fileWhereInput | em_materi_fileWhereInput[]
    materi_id?: IntFilter<"em_materi_file"> | number
    file_name?: StringFilter<"em_materi_file"> | string
    file_type?: IntFilter<"em_materi_file"> | number
    file_size?: FloatNullableFilter<"em_materi_file"> | number | null
    url?: StringNullableFilter<"em_materi_file"> | string | null
    urutan?: IntNullableFilter<"em_materi_file"> | number | null
    judul?: StringNullableFilter<"em_materi_file"> | string | null
    created_at?: DateTimeNullableFilter<"em_materi_file"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"em_materi_file"> | Date | string | null
    galeri_id?: IntNullableFilter<"em_materi_file"> | number | null
    em_materi1?: XOR<Em_materi1ScalarRelationFilter, em_materi1WhereInput>
  }, "id">

  export type em_materi_fileOrderByWithAggregationInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    urutan?: SortOrderInput | SortOrder
    judul?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    galeri_id?: SortOrderInput | SortOrder
    _count?: em_materi_fileCountOrderByAggregateInput
    _avg?: em_materi_fileAvgOrderByAggregateInput
    _max?: em_materi_fileMaxOrderByAggregateInput
    _min?: em_materi_fileMinOrderByAggregateInput
    _sum?: em_materi_fileSumOrderByAggregateInput
  }

  export type em_materi_fileScalarWhereWithAggregatesInput = {
    AND?: em_materi_fileScalarWhereWithAggregatesInput | em_materi_fileScalarWhereWithAggregatesInput[]
    OR?: em_materi_fileScalarWhereWithAggregatesInput[]
    NOT?: em_materi_fileScalarWhereWithAggregatesInput | em_materi_fileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_materi_file"> | number
    materi_id?: IntWithAggregatesFilter<"em_materi_file"> | number
    file_name?: StringWithAggregatesFilter<"em_materi_file"> | string
    file_type?: IntWithAggregatesFilter<"em_materi_file"> | number
    file_size?: FloatNullableWithAggregatesFilter<"em_materi_file"> | number | null
    url?: StringNullableWithAggregatesFilter<"em_materi_file"> | string | null
    urutan?: IntNullableWithAggregatesFilter<"em_materi_file"> | number | null
    judul?: StringNullableWithAggregatesFilter<"em_materi_file"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_materi_file"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"em_materi_file"> | Date | string | null
    galeri_id?: IntNullableWithAggregatesFilter<"em_materi_file"> | number | null
  }

  export type em_materi_kategoriWhereInput = {
    AND?: em_materi_kategoriWhereInput | em_materi_kategoriWhereInput[]
    OR?: em_materi_kategoriWhereInput[]
    NOT?: em_materi_kategoriWhereInput | em_materi_kategoriWhereInput[]
    id?: IntFilter<"em_materi_kategori"> | number
    kategori_nama?: StringFilter<"em_materi_kategori"> | string
    kategori_deskripsi?: StringNullableFilter<"em_materi_kategori"> | string | null
    is_active?: BoolNullableFilter<"em_materi_kategori"> | boolean | null
    created_at?: DateTimeNullableFilter<"em_materi_kategori"> | Date | string | null
  }

  export type em_materi_kategoriOrderByWithRelationInput = {
    id?: SortOrder
    kategori_nama?: SortOrder
    kategori_deskripsi?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type em_materi_kategoriWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_materi_kategoriWhereInput | em_materi_kategoriWhereInput[]
    OR?: em_materi_kategoriWhereInput[]
    NOT?: em_materi_kategoriWhereInput | em_materi_kategoriWhereInput[]
    kategori_nama?: StringFilter<"em_materi_kategori"> | string
    kategori_deskripsi?: StringNullableFilter<"em_materi_kategori"> | string | null
    is_active?: BoolNullableFilter<"em_materi_kategori"> | boolean | null
    created_at?: DateTimeNullableFilter<"em_materi_kategori"> | Date | string | null
  }, "id">

  export type em_materi_kategoriOrderByWithAggregationInput = {
    id?: SortOrder
    kategori_nama?: SortOrder
    kategori_deskripsi?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: em_materi_kategoriCountOrderByAggregateInput
    _avg?: em_materi_kategoriAvgOrderByAggregateInput
    _max?: em_materi_kategoriMaxOrderByAggregateInput
    _min?: em_materi_kategoriMinOrderByAggregateInput
    _sum?: em_materi_kategoriSumOrderByAggregateInput
  }

  export type em_materi_kategoriScalarWhereWithAggregatesInput = {
    AND?: em_materi_kategoriScalarWhereWithAggregatesInput | em_materi_kategoriScalarWhereWithAggregatesInput[]
    OR?: em_materi_kategoriScalarWhereWithAggregatesInput[]
    NOT?: em_materi_kategoriScalarWhereWithAggregatesInput | em_materi_kategoriScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_materi_kategori"> | number
    kategori_nama?: StringWithAggregatesFilter<"em_materi_kategori"> | string
    kategori_deskripsi?: StringNullableWithAggregatesFilter<"em_materi_kategori"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"em_materi_kategori"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_materi_kategori"> | Date | string | null
  }

  export type em_materi_typeWhereInput = {
    AND?: em_materi_typeWhereInput | em_materi_typeWhereInput[]
    OR?: em_materi_typeWhereInput[]
    NOT?: em_materi_typeWhereInput | em_materi_typeWhereInput[]
    id?: IntFilter<"em_materi_type"> | number
    materi_name?: StringFilter<"em_materi_type"> | string
    deskripsi?: StringNullableFilter<"em_materi_type"> | string | null
    status?: StringNullableFilter<"em_materi_type"> | string | null
    created_at?: DateTimeFilter<"em_materi_type"> | Date | string
    created_by?: StringNullableFilter<"em_materi_type"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_materi_type"> | Date | string | null
    em_materi2?: Em_materi2ListRelationFilter
  }

  export type em_materi_typeOrderByWithRelationInput = {
    id?: SortOrder
    materi_name?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    em_materi2?: em_materi2OrderByRelationAggregateInput
  }

  export type em_materi_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_materi_typeWhereInput | em_materi_typeWhereInput[]
    OR?: em_materi_typeWhereInput[]
    NOT?: em_materi_typeWhereInput | em_materi_typeWhereInput[]
    materi_name?: StringFilter<"em_materi_type"> | string
    deskripsi?: StringNullableFilter<"em_materi_type"> | string | null
    status?: StringNullableFilter<"em_materi_type"> | string | null
    created_at?: DateTimeFilter<"em_materi_type"> | Date | string
    created_by?: StringNullableFilter<"em_materi_type"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_materi_type"> | Date | string | null
    em_materi2?: Em_materi2ListRelationFilter
  }, "id">

  export type em_materi_typeOrderByWithAggregationInput = {
    id?: SortOrder
    materi_name?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_materi_typeCountOrderByAggregateInput
    _avg?: em_materi_typeAvgOrderByAggregateInput
    _max?: em_materi_typeMaxOrderByAggregateInput
    _min?: em_materi_typeMinOrderByAggregateInput
    _sum?: em_materi_typeSumOrderByAggregateInput
  }

  export type em_materi_typeScalarWhereWithAggregatesInput = {
    AND?: em_materi_typeScalarWhereWithAggregatesInput | em_materi_typeScalarWhereWithAggregatesInput[]
    OR?: em_materi_typeScalarWhereWithAggregatesInput[]
    NOT?: em_materi_typeScalarWhereWithAggregatesInput | em_materi_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_materi_type"> | number
    materi_name?: StringWithAggregatesFilter<"em_materi_type"> | string
    deskripsi?: StringNullableWithAggregatesFilter<"em_materi_type"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_materi_type"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"em_materi_type"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"em_materi_type"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_materi_type"> | Date | string | null
  }

  export type em_materi1WhereInput = {
    AND?: em_materi1WhereInput | em_materi1WhereInput[]
    OR?: em_materi1WhereInput[]
    NOT?: em_materi1WhereInput | em_materi1WhereInput[]
    id?: IntFilter<"em_materi1"> | number
    kode_materi?: StringFilter<"em_materi1"> | string
    judul_materi?: StringFilter<"em_materi1"> | string
    deskripsi_materi?: StringNullableFilter<"em_materi1"> | string | null
    kategori?: IntNullableFilter<"em_materi1"> | number | null
    urutan?: IntFilter<"em_materi1"> | number
    is_required?: BoolFilter<"em_materi1"> | boolean
    status?: StringNullableFilter<"em_materi1"> | string | null
    created_by?: StringNullableFilter<"em_materi1"> | string | null
    created_at?: DateTimeFilter<"em_materi1"> | Date | string
    lastupdate?: DateTimeNullableFilter<"em_materi1"> | Date | string | null
    em_materi_file?: Em_materi_fileListRelationFilter
    em_materi2?: Em_materi2ListRelationFilter
  }

  export type em_materi1OrderByWithRelationInput = {
    id?: SortOrder
    kode_materi?: SortOrder
    judul_materi?: SortOrder
    deskripsi_materi?: SortOrderInput | SortOrder
    kategori?: SortOrderInput | SortOrder
    urutan?: SortOrder
    is_required?: SortOrder
    status?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrderInput | SortOrder
    em_materi_file?: em_materi_fileOrderByRelationAggregateInput
    em_materi2?: em_materi2OrderByRelationAggregateInput
  }

  export type em_materi1WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_materi1WhereInput | em_materi1WhereInput[]
    OR?: em_materi1WhereInput[]
    NOT?: em_materi1WhereInput | em_materi1WhereInput[]
    kode_materi?: StringFilter<"em_materi1"> | string
    judul_materi?: StringFilter<"em_materi1"> | string
    deskripsi_materi?: StringNullableFilter<"em_materi1"> | string | null
    kategori?: IntNullableFilter<"em_materi1"> | number | null
    urutan?: IntFilter<"em_materi1"> | number
    is_required?: BoolFilter<"em_materi1"> | boolean
    status?: StringNullableFilter<"em_materi1"> | string | null
    created_by?: StringNullableFilter<"em_materi1"> | string | null
    created_at?: DateTimeFilter<"em_materi1"> | Date | string
    lastupdate?: DateTimeNullableFilter<"em_materi1"> | Date | string | null
    em_materi_file?: Em_materi_fileListRelationFilter
    em_materi2?: Em_materi2ListRelationFilter
  }, "id">

  export type em_materi1OrderByWithAggregationInput = {
    id?: SortOrder
    kode_materi?: SortOrder
    judul_materi?: SortOrder
    deskripsi_materi?: SortOrderInput | SortOrder
    kategori?: SortOrderInput | SortOrder
    urutan?: SortOrder
    is_required?: SortOrder
    status?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_materi1CountOrderByAggregateInput
    _avg?: em_materi1AvgOrderByAggregateInput
    _max?: em_materi1MaxOrderByAggregateInput
    _min?: em_materi1MinOrderByAggregateInput
    _sum?: em_materi1SumOrderByAggregateInput
  }

  export type em_materi1ScalarWhereWithAggregatesInput = {
    AND?: em_materi1ScalarWhereWithAggregatesInput | em_materi1ScalarWhereWithAggregatesInput[]
    OR?: em_materi1ScalarWhereWithAggregatesInput[]
    NOT?: em_materi1ScalarWhereWithAggregatesInput | em_materi1ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_materi1"> | number
    kode_materi?: StringWithAggregatesFilter<"em_materi1"> | string
    judul_materi?: StringWithAggregatesFilter<"em_materi1"> | string
    deskripsi_materi?: StringNullableWithAggregatesFilter<"em_materi1"> | string | null
    kategori?: IntNullableWithAggregatesFilter<"em_materi1"> | number | null
    urutan?: IntWithAggregatesFilter<"em_materi1"> | number
    is_required?: BoolWithAggregatesFilter<"em_materi1"> | boolean
    status?: StringNullableWithAggregatesFilter<"em_materi1"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"em_materi1"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"em_materi1"> | Date | string
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_materi1"> | Date | string | null
  }

  export type em_materi2WhereInput = {
    AND?: em_materi2WhereInput | em_materi2WhereInput[]
    OR?: em_materi2WhereInput[]
    NOT?: em_materi2WhereInput | em_materi2WhereInput[]
    id?: IntFilter<"em_materi2"> | number
    materi_id?: IntFilter<"em_materi2"> | number
    materi_type?: IntFilter<"em_materi2"> | number
    em_materi_type?: XOR<Em_materi_typeScalarRelationFilter, em_materi_typeWhereInput>
    em_materi1?: XOR<Em_materi1ScalarRelationFilter, em_materi1WhereInput>
  }

  export type em_materi2OrderByWithRelationInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
    em_materi_type?: em_materi_typeOrderByWithRelationInput
    em_materi1?: em_materi1OrderByWithRelationInput
  }

  export type em_materi2WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_materi2WhereInput | em_materi2WhereInput[]
    OR?: em_materi2WhereInput[]
    NOT?: em_materi2WhereInput | em_materi2WhereInput[]
    materi_id?: IntFilter<"em_materi2"> | number
    materi_type?: IntFilter<"em_materi2"> | number
    em_materi_type?: XOR<Em_materi_typeScalarRelationFilter, em_materi_typeWhereInput>
    em_materi1?: XOR<Em_materi1ScalarRelationFilter, em_materi1WhereInput>
  }, "id">

  export type em_materi2OrderByWithAggregationInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
    _count?: em_materi2CountOrderByAggregateInput
    _avg?: em_materi2AvgOrderByAggregateInput
    _max?: em_materi2MaxOrderByAggregateInput
    _min?: em_materi2MinOrderByAggregateInput
    _sum?: em_materi2SumOrderByAggregateInput
  }

  export type em_materi2ScalarWhereWithAggregatesInput = {
    AND?: em_materi2ScalarWhereWithAggregatesInput | em_materi2ScalarWhereWithAggregatesInput[]
    OR?: em_materi2ScalarWhereWithAggregatesInput[]
    NOT?: em_materi2ScalarWhereWithAggregatesInput | em_materi2ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_materi2"> | number
    materi_id?: IntWithAggregatesFilter<"em_materi2"> | number
    materi_type?: IntWithAggregatesFilter<"em_materi2"> | number
  }

  export type em_menuWhereInput = {
    AND?: em_menuWhereInput | em_menuWhereInput[]
    OR?: em_menuWhereInput[]
    NOT?: em_menuWhereInput | em_menuWhereInput[]
    id?: IntFilter<"em_menu"> | number
    menuid?: StringFilter<"em_menu"> | string
    name?: StringFilter<"em_menu"> | string
    parent_id?: StringNullableFilter<"em_menu"> | string | null
    link?: StringNullableFilter<"em_menu"> | string | null
    visible?: BoolFilter<"em_menu"> | boolean
    status?: StringNullableFilter<"em_menu"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_menu"> | Date | string | null
    icon?: StringNullableFilter<"em_menu"> | string | null
    menutype?: StringNullableFilter<"em_menu"> | string | null
  }

  export type em_menuOrderByWithRelationInput = {
    id?: SortOrder
    menuid?: SortOrder
    name?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    visible?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    menutype?: SortOrderInput | SortOrder
  }

  export type em_menuWhereUniqueInput = Prisma.AtLeast<{
    id_menuid?: em_menuIdMenuidCompoundUniqueInput
    AND?: em_menuWhereInput | em_menuWhereInput[]
    OR?: em_menuWhereInput[]
    NOT?: em_menuWhereInput | em_menuWhereInput[]
    id?: IntFilter<"em_menu"> | number
    menuid?: StringFilter<"em_menu"> | string
    name?: StringFilter<"em_menu"> | string
    parent_id?: StringNullableFilter<"em_menu"> | string | null
    link?: StringNullableFilter<"em_menu"> | string | null
    visible?: BoolFilter<"em_menu"> | boolean
    status?: StringNullableFilter<"em_menu"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_menu"> | Date | string | null
    icon?: StringNullableFilter<"em_menu"> | string | null
    menutype?: StringNullableFilter<"em_menu"> | string | null
  }, "id_menuid">

  export type em_menuOrderByWithAggregationInput = {
    id?: SortOrder
    menuid?: SortOrder
    name?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    visible?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    menutype?: SortOrderInput | SortOrder
    _count?: em_menuCountOrderByAggregateInput
    _avg?: em_menuAvgOrderByAggregateInput
    _max?: em_menuMaxOrderByAggregateInput
    _min?: em_menuMinOrderByAggregateInput
    _sum?: em_menuSumOrderByAggregateInput
  }

  export type em_menuScalarWhereWithAggregatesInput = {
    AND?: em_menuScalarWhereWithAggregatesInput | em_menuScalarWhereWithAggregatesInput[]
    OR?: em_menuScalarWhereWithAggregatesInput[]
    NOT?: em_menuScalarWhereWithAggregatesInput | em_menuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_menu"> | number
    menuid?: StringWithAggregatesFilter<"em_menu"> | string
    name?: StringWithAggregatesFilter<"em_menu"> | string
    parent_id?: StringNullableWithAggregatesFilter<"em_menu"> | string | null
    link?: StringNullableWithAggregatesFilter<"em_menu"> | string | null
    visible?: BoolWithAggregatesFilter<"em_menu"> | boolean
    status?: StringNullableWithAggregatesFilter<"em_menu"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_menu"> | Date | string | null
    icon?: StringNullableWithAggregatesFilter<"em_menu"> | string | null
    menutype?: StringNullableWithAggregatesFilter<"em_menu"> | string | null
  }

  export type em_notifikasiWhereInput = {
    AND?: em_notifikasiWhereInput | em_notifikasiWhereInput[]
    OR?: em_notifikasiWhereInput[]
    NOT?: em_notifikasiWhereInput | em_notifikasiWhereInput[]
    NotifyId?: IntFilter<"em_notifikasi"> | number
    UserId?: IntNullableFilter<"em_notifikasi"> | number | null
    GroupId?: IntNullableFilter<"em_notifikasi"> | number | null
    Note?: StringNullableFilter<"em_notifikasi"> | string | null
    Status?: StringNullableFilter<"em_notifikasi"> | string | null
    CreateDate?: DateTimeNullableFilter<"em_notifikasi"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_notifikasi"> | Date | string | null
  }

  export type em_notifikasiOrderByWithRelationInput = {
    NotifyId?: SortOrder
    UserId?: SortOrderInput | SortOrder
    GroupId?: SortOrderInput | SortOrder
    Note?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreateDate?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
  }

  export type em_notifikasiWhereUniqueInput = Prisma.AtLeast<{
    NotifyId?: number
    AND?: em_notifikasiWhereInput | em_notifikasiWhereInput[]
    OR?: em_notifikasiWhereInput[]
    NOT?: em_notifikasiWhereInput | em_notifikasiWhereInput[]
    UserId?: IntNullableFilter<"em_notifikasi"> | number | null
    GroupId?: IntNullableFilter<"em_notifikasi"> | number | null
    Note?: StringNullableFilter<"em_notifikasi"> | string | null
    Status?: StringNullableFilter<"em_notifikasi"> | string | null
    CreateDate?: DateTimeNullableFilter<"em_notifikasi"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_notifikasi"> | Date | string | null
  }, "NotifyId">

  export type em_notifikasiOrderByWithAggregationInput = {
    NotifyId?: SortOrder
    UserId?: SortOrderInput | SortOrder
    GroupId?: SortOrderInput | SortOrder
    Note?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreateDate?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    _count?: em_notifikasiCountOrderByAggregateInput
    _avg?: em_notifikasiAvgOrderByAggregateInput
    _max?: em_notifikasiMaxOrderByAggregateInput
    _min?: em_notifikasiMinOrderByAggregateInput
    _sum?: em_notifikasiSumOrderByAggregateInput
  }

  export type em_notifikasiScalarWhereWithAggregatesInput = {
    AND?: em_notifikasiScalarWhereWithAggregatesInput | em_notifikasiScalarWhereWithAggregatesInput[]
    OR?: em_notifikasiScalarWhereWithAggregatesInput[]
    NOT?: em_notifikasiScalarWhereWithAggregatesInput | em_notifikasiScalarWhereWithAggregatesInput[]
    NotifyId?: IntWithAggregatesFilter<"em_notifikasi"> | number
    UserId?: IntNullableWithAggregatesFilter<"em_notifikasi"> | number | null
    GroupId?: IntNullableWithAggregatesFilter<"em_notifikasi"> | number | null
    Note?: StringNullableWithAggregatesFilter<"em_notifikasi"> | string | null
    Status?: StringNullableWithAggregatesFilter<"em_notifikasi"> | string | null
    CreateDate?: DateTimeNullableWithAggregatesFilter<"em_notifikasi"> | Date | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_notifikasi"> | Date | string | null
  }

  export type em_notifikasi_readWhereInput = {
    AND?: em_notifikasi_readWhereInput | em_notifikasi_readWhereInput[]
    OR?: em_notifikasi_readWhereInput[]
    NOT?: em_notifikasi_readWhereInput | em_notifikasi_readWhereInput[]
    ReadId?: IntFilter<"em_notifikasi_read"> | number
    NotifyId?: IntNullableFilter<"em_notifikasi_read"> | number | null
    UserId?: IntNullableFilter<"em_notifikasi_read"> | number | null
    ReadDate?: DateTimeNullableFilter<"em_notifikasi_read"> | Date | string | null
  }

  export type em_notifikasi_readOrderByWithRelationInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    ReadDate?: SortOrderInput | SortOrder
  }

  export type em_notifikasi_readWhereUniqueInput = Prisma.AtLeast<{
    ReadId?: number
    AND?: em_notifikasi_readWhereInput | em_notifikasi_readWhereInput[]
    OR?: em_notifikasi_readWhereInput[]
    NOT?: em_notifikasi_readWhereInput | em_notifikasi_readWhereInput[]
    NotifyId?: IntNullableFilter<"em_notifikasi_read"> | number | null
    UserId?: IntNullableFilter<"em_notifikasi_read"> | number | null
    ReadDate?: DateTimeNullableFilter<"em_notifikasi_read"> | Date | string | null
  }, "ReadId">

  export type em_notifikasi_readOrderByWithAggregationInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    ReadDate?: SortOrderInput | SortOrder
    _count?: em_notifikasi_readCountOrderByAggregateInput
    _avg?: em_notifikasi_readAvgOrderByAggregateInput
    _max?: em_notifikasi_readMaxOrderByAggregateInput
    _min?: em_notifikasi_readMinOrderByAggregateInput
    _sum?: em_notifikasi_readSumOrderByAggregateInput
  }

  export type em_notifikasi_readScalarWhereWithAggregatesInput = {
    AND?: em_notifikasi_readScalarWhereWithAggregatesInput | em_notifikasi_readScalarWhereWithAggregatesInput[]
    OR?: em_notifikasi_readScalarWhereWithAggregatesInput[]
    NOT?: em_notifikasi_readScalarWhereWithAggregatesInput | em_notifikasi_readScalarWhereWithAggregatesInput[]
    ReadId?: IntWithAggregatesFilter<"em_notifikasi_read"> | number
    NotifyId?: IntNullableWithAggregatesFilter<"em_notifikasi_read"> | number | null
    UserId?: IntNullableWithAggregatesFilter<"em_notifikasi_read"> | number | null
    ReadDate?: DateTimeNullableWithAggregatesFilter<"em_notifikasi_read"> | Date | string | null
  }

  export type em_onboardingWhereInput = {
    AND?: em_onboardingWhereInput | em_onboardingWhereInput[]
    OR?: em_onboardingWhereInput[]
    NOT?: em_onboardingWhereInput | em_onboardingWhereInput[]
    id?: IntFilter<"em_onboarding"> | number
    user_id?: IntFilter<"em_onboarding"> | number
    status?: StringNullableFilter<"em_onboarding"> | string | null
    current_step?: IntNullableFilter<"em_onboarding"> | number | null
    created_at?: DateTimeNullableFilter<"em_onboarding"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"em_onboarding"> | Date | string | null
  }

  export type em_onboardingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrderInput | SortOrder
    current_step?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type em_onboardingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_onboardingWhereInput | em_onboardingWhereInput[]
    OR?: em_onboardingWhereInput[]
    NOT?: em_onboardingWhereInput | em_onboardingWhereInput[]
    user_id?: IntFilter<"em_onboarding"> | number
    status?: StringNullableFilter<"em_onboarding"> | string | null
    current_step?: IntNullableFilter<"em_onboarding"> | number | null
    created_at?: DateTimeNullableFilter<"em_onboarding"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"em_onboarding"> | Date | string | null
  }, "id">

  export type em_onboardingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrderInput | SortOrder
    current_step?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: em_onboardingCountOrderByAggregateInput
    _avg?: em_onboardingAvgOrderByAggregateInput
    _max?: em_onboardingMaxOrderByAggregateInput
    _min?: em_onboardingMinOrderByAggregateInput
    _sum?: em_onboardingSumOrderByAggregateInput
  }

  export type em_onboardingScalarWhereWithAggregatesInput = {
    AND?: em_onboardingScalarWhereWithAggregatesInput | em_onboardingScalarWhereWithAggregatesInput[]
    OR?: em_onboardingScalarWhereWithAggregatesInput[]
    NOT?: em_onboardingScalarWhereWithAggregatesInput | em_onboardingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_onboarding"> | number
    user_id?: IntWithAggregatesFilter<"em_onboarding"> | number
    status?: StringNullableWithAggregatesFilter<"em_onboarding"> | string | null
    current_step?: IntNullableWithAggregatesFilter<"em_onboarding"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_onboarding"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"em_onboarding"> | Date | string | null
  }

  export type em_pilarWhereInput = {
    AND?: em_pilarWhereInput | em_pilarWhereInput[]
    OR?: em_pilarWhereInput[]
    NOT?: em_pilarWhereInput | em_pilarWhereInput[]
    id?: IntFilter<"em_pilar"> | number
    pilar_name?: StringFilter<"em_pilar"> | string
    status?: StringFilter<"em_pilar"> | string
    add_by?: StringNullableFilter<"em_pilar"> | string | null
    created_at?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    createdBy?: StringNullableFilter<"em_pilar"> | string | null
    updatedAt?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    updatedBy?: StringNullableFilter<"em_pilar"> | string | null
    isDeleted?: BoolNullableFilter<"em_pilar"> | boolean | null
    deletedAt?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    deletedBy?: StringNullableFilter<"em_pilar"> | string | null
    description?: StringNullableFilter<"em_pilar"> | string | null
    pic?: IntNullableFilter<"em_pilar"> | number | null
  }

  export type em_pilarOrderByWithRelationInput = {
    id?: SortOrder
    pilar_name?: SortOrder
    status?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
  }

  export type em_pilarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_pilarWhereInput | em_pilarWhereInput[]
    OR?: em_pilarWhereInput[]
    NOT?: em_pilarWhereInput | em_pilarWhereInput[]
    pilar_name?: StringFilter<"em_pilar"> | string
    status?: StringFilter<"em_pilar"> | string
    add_by?: StringNullableFilter<"em_pilar"> | string | null
    created_at?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    createdBy?: StringNullableFilter<"em_pilar"> | string | null
    updatedAt?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    updatedBy?: StringNullableFilter<"em_pilar"> | string | null
    isDeleted?: BoolNullableFilter<"em_pilar"> | boolean | null
    deletedAt?: DateTimeNullableFilter<"em_pilar"> | Date | string | null
    deletedBy?: StringNullableFilter<"em_pilar"> | string | null
    description?: StringNullableFilter<"em_pilar"> | string | null
    pic?: IntNullableFilter<"em_pilar"> | number | null
  }, "id">

  export type em_pilarOrderByWithAggregationInput = {
    id?: SortOrder
    pilar_name?: SortOrder
    status?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
    _count?: em_pilarCountOrderByAggregateInput
    _avg?: em_pilarAvgOrderByAggregateInput
    _max?: em_pilarMaxOrderByAggregateInput
    _min?: em_pilarMinOrderByAggregateInput
    _sum?: em_pilarSumOrderByAggregateInput
  }

  export type em_pilarScalarWhereWithAggregatesInput = {
    AND?: em_pilarScalarWhereWithAggregatesInput | em_pilarScalarWhereWithAggregatesInput[]
    OR?: em_pilarScalarWhereWithAggregatesInput[]
    NOT?: em_pilarScalarWhereWithAggregatesInput | em_pilarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_pilar"> | number
    pilar_name?: StringWithAggregatesFilter<"em_pilar"> | string
    status?: StringWithAggregatesFilter<"em_pilar"> | string
    add_by?: StringNullableWithAggregatesFilter<"em_pilar"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_pilar"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_pilar"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"em_pilar"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"em_pilar"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"em_pilar"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"em_pilar"> | string | null
    isDeleted?: BoolNullableWithAggregatesFilter<"em_pilar"> | boolean | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"em_pilar"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"em_pilar"> | string | null
    description?: StringNullableWithAggregatesFilter<"em_pilar"> | string | null
    pic?: IntNullableWithAggregatesFilter<"em_pilar"> | number | null
  }

  export type em_profesiWhereInput = {
    AND?: em_profesiWhereInput | em_profesiWhereInput[]
    OR?: em_profesiWhereInput[]
    NOT?: em_profesiWhereInput | em_profesiWhereInput[]
    profesi_id?: IntFilter<"em_profesi"> | number
    profesi_name?: StringNullableFilter<"em_profesi"> | string | null
    status?: StringNullableFilter<"em_profesi"> | string | null
    created_date?: DateTimeNullableFilter<"em_profesi"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_profesi"> | Date | string | null
  }

  export type em_profesiOrderByWithRelationInput = {
    profesi_id?: SortOrder
    profesi_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
  }

  export type em_profesiWhereUniqueInput = Prisma.AtLeast<{
    profesi_id?: number
    AND?: em_profesiWhereInput | em_profesiWhereInput[]
    OR?: em_profesiWhereInput[]
    NOT?: em_profesiWhereInput | em_profesiWhereInput[]
    profesi_name?: StringNullableFilter<"em_profesi"> | string | null
    status?: StringNullableFilter<"em_profesi"> | string | null
    created_date?: DateTimeNullableFilter<"em_profesi"> | Date | string | null
    last_update?: DateTimeNullableFilter<"em_profesi"> | Date | string | null
  }, "profesi_id">

  export type em_profesiOrderByWithAggregationInput = {
    profesi_id?: SortOrder
    profesi_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    last_update?: SortOrderInput | SortOrder
    _count?: em_profesiCountOrderByAggregateInput
    _avg?: em_profesiAvgOrderByAggregateInput
    _max?: em_profesiMaxOrderByAggregateInput
    _min?: em_profesiMinOrderByAggregateInput
    _sum?: em_profesiSumOrderByAggregateInput
  }

  export type em_profesiScalarWhereWithAggregatesInput = {
    AND?: em_profesiScalarWhereWithAggregatesInput | em_profesiScalarWhereWithAggregatesInput[]
    OR?: em_profesiScalarWhereWithAggregatesInput[]
    NOT?: em_profesiScalarWhereWithAggregatesInput | em_profesiScalarWhereWithAggregatesInput[]
    profesi_id?: IntWithAggregatesFilter<"em_profesi"> | number
    profesi_name?: StringNullableWithAggregatesFilter<"em_profesi"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_profesi"> | string | null
    created_date?: DateTimeNullableWithAggregatesFilter<"em_profesi"> | Date | string | null
    last_update?: DateTimeNullableWithAggregatesFilter<"em_profesi"> | Date | string | null
  }

  export type em_questions1WhereInput = {
    AND?: em_questions1WhereInput | em_questions1WhereInput[]
    OR?: em_questions1WhereInput[]
    NOT?: em_questions1WhereInput | em_questions1WhereInput[]
    id?: IntFilter<"em_questions1"> | number
    question_text?: StringFilter<"em_questions1"> | string
    question_type?: IntNullableFilter<"em_questions1"> | number | null
    correct_answer?: StringNullableFilter<"em_questions1"> | string | null
    correct_answer2?: StringNullableFilter<"em_questions1"> | string | null
    exam_id?: IntNullableFilter<"em_questions1"> | number | null
    time_limit?: IntFilter<"em_questions1"> | number
    score?: FloatFilter<"em_questions1"> | number
    status?: StringNullableFilter<"em_questions1"> | string | null
    userid?: StringNullableFilter<"em_questions1"> | string | null
    qdate?: DateTimeNullableFilter<"em_questions1"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_questions1"> | Date | string | null
    fileimage?: StringNullableFilter<"em_questions1"> | string | null
    isExams?: StringNullableFilter<"em_questions1"> | string | null
    isLevel?: IntNullableFilter<"em_questions1"> | number | null
    em_questions2?: Em_questions2ListRelationFilter
  }

  export type em_questions1OrderByWithRelationInput = {
    id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrderInput | SortOrder
    correct_answer?: SortOrderInput | SortOrder
    correct_answer2?: SortOrderInput | SortOrder
    exam_id?: SortOrderInput | SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    status?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    qdate?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    fileimage?: SortOrderInput | SortOrder
    isExams?: SortOrderInput | SortOrder
    isLevel?: SortOrderInput | SortOrder
    em_questions2?: em_questions2OrderByRelationAggregateInput
  }

  export type em_questions1WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_questions1WhereInput | em_questions1WhereInput[]
    OR?: em_questions1WhereInput[]
    NOT?: em_questions1WhereInput | em_questions1WhereInput[]
    question_text?: StringFilter<"em_questions1"> | string
    question_type?: IntNullableFilter<"em_questions1"> | number | null
    correct_answer?: StringNullableFilter<"em_questions1"> | string | null
    correct_answer2?: StringNullableFilter<"em_questions1"> | string | null
    exam_id?: IntNullableFilter<"em_questions1"> | number | null
    time_limit?: IntFilter<"em_questions1"> | number
    score?: FloatFilter<"em_questions1"> | number
    status?: StringNullableFilter<"em_questions1"> | string | null
    userid?: StringNullableFilter<"em_questions1"> | string | null
    qdate?: DateTimeNullableFilter<"em_questions1"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_questions1"> | Date | string | null
    fileimage?: StringNullableFilter<"em_questions1"> | string | null
    isExams?: StringNullableFilter<"em_questions1"> | string | null
    isLevel?: IntNullableFilter<"em_questions1"> | number | null
    em_questions2?: Em_questions2ListRelationFilter
  }, "id">

  export type em_questions1OrderByWithAggregationInput = {
    id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrderInput | SortOrder
    correct_answer?: SortOrderInput | SortOrder
    correct_answer2?: SortOrderInput | SortOrder
    exam_id?: SortOrderInput | SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    status?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    qdate?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    fileimage?: SortOrderInput | SortOrder
    isExams?: SortOrderInput | SortOrder
    isLevel?: SortOrderInput | SortOrder
    _count?: em_questions1CountOrderByAggregateInput
    _avg?: em_questions1AvgOrderByAggregateInput
    _max?: em_questions1MaxOrderByAggregateInput
    _min?: em_questions1MinOrderByAggregateInput
    _sum?: em_questions1SumOrderByAggregateInput
  }

  export type em_questions1ScalarWhereWithAggregatesInput = {
    AND?: em_questions1ScalarWhereWithAggregatesInput | em_questions1ScalarWhereWithAggregatesInput[]
    OR?: em_questions1ScalarWhereWithAggregatesInput[]
    NOT?: em_questions1ScalarWhereWithAggregatesInput | em_questions1ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_questions1"> | number
    question_text?: StringWithAggregatesFilter<"em_questions1"> | string
    question_type?: IntNullableWithAggregatesFilter<"em_questions1"> | number | null
    correct_answer?: StringNullableWithAggregatesFilter<"em_questions1"> | string | null
    correct_answer2?: StringNullableWithAggregatesFilter<"em_questions1"> | string | null
    exam_id?: IntNullableWithAggregatesFilter<"em_questions1"> | number | null
    time_limit?: IntWithAggregatesFilter<"em_questions1"> | number
    score?: FloatWithAggregatesFilter<"em_questions1"> | number
    status?: StringNullableWithAggregatesFilter<"em_questions1"> | string | null
    userid?: StringNullableWithAggregatesFilter<"em_questions1"> | string | null
    qdate?: DateTimeNullableWithAggregatesFilter<"em_questions1"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_questions1"> | Date | string | null
    fileimage?: StringNullableWithAggregatesFilter<"em_questions1"> | string | null
    isExams?: StringNullableWithAggregatesFilter<"em_questions1"> | string | null
    isLevel?: IntNullableWithAggregatesFilter<"em_questions1"> | number | null
  }

  export type em_questions2WhereInput = {
    AND?: em_questions2WhereInput | em_questions2WhereInput[]
    OR?: em_questions2WhereInput[]
    NOT?: em_questions2WhereInput | em_questions2WhereInput[]
    Id?: BigIntFilter<"em_questions2"> | bigint | number
    question_id?: IntFilter<"em_questions2"> | number
    option_choices?: StringFilter<"em_questions2"> | string
    option_text?: StringFilter<"em_questions2"> | string
    em_questions1?: XOR<Em_questions1ScalarRelationFilter, em_questions1WhereInput>
  }

  export type em_questions2OrderByWithRelationInput = {
    Id?: SortOrder
    question_id?: SortOrder
    option_choices?: SortOrder
    option_text?: SortOrder
    em_questions1?: em_questions1OrderByWithRelationInput
  }

  export type em_questions2WhereUniqueInput = Prisma.AtLeast<{
    Id_question_id_option_choices?: em_questions2IdQuestion_idOption_choicesCompoundUniqueInput
    AND?: em_questions2WhereInput | em_questions2WhereInput[]
    OR?: em_questions2WhereInput[]
    NOT?: em_questions2WhereInput | em_questions2WhereInput[]
    Id?: BigIntFilter<"em_questions2"> | bigint | number
    question_id?: IntFilter<"em_questions2"> | number
    option_choices?: StringFilter<"em_questions2"> | string
    option_text?: StringFilter<"em_questions2"> | string
    em_questions1?: XOR<Em_questions1ScalarRelationFilter, em_questions1WhereInput>
  }, "Id_question_id_option_choices">

  export type em_questions2OrderByWithAggregationInput = {
    Id?: SortOrder
    question_id?: SortOrder
    option_choices?: SortOrder
    option_text?: SortOrder
    _count?: em_questions2CountOrderByAggregateInput
    _avg?: em_questions2AvgOrderByAggregateInput
    _max?: em_questions2MaxOrderByAggregateInput
    _min?: em_questions2MinOrderByAggregateInput
    _sum?: em_questions2SumOrderByAggregateInput
  }

  export type em_questions2ScalarWhereWithAggregatesInput = {
    AND?: em_questions2ScalarWhereWithAggregatesInput | em_questions2ScalarWhereWithAggregatesInput[]
    OR?: em_questions2ScalarWhereWithAggregatesInput[]
    NOT?: em_questions2ScalarWhereWithAggregatesInput | em_questions2ScalarWhereWithAggregatesInput[]
    Id?: BigIntWithAggregatesFilter<"em_questions2"> | bigint | number
    question_id?: IntWithAggregatesFilter<"em_questions2"> | number
    option_choices?: StringWithAggregatesFilter<"em_questions2"> | string
    option_text?: StringWithAggregatesFilter<"em_questions2"> | string
  }

  export type em_questtypeWhereInput = {
    AND?: em_questtypeWhereInput | em_questtypeWhereInput[]
    OR?: em_questtypeWhereInput[]
    NOT?: em_questtypeWhereInput | em_questtypeWhereInput[]
    Id?: IntFilter<"em_questtype"> | number
    TypeName?: StringNullableFilter<"em_questtype"> | string | null
    Status?: StringNullableFilter<"em_questtype"> | string | null
  }

  export type em_questtypeOrderByWithRelationInput = {
    Id?: SortOrder
    TypeName?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
  }

  export type em_questtypeWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_questtypeWhereInput | em_questtypeWhereInput[]
    OR?: em_questtypeWhereInput[]
    NOT?: em_questtypeWhereInput | em_questtypeWhereInput[]
    TypeName?: StringNullableFilter<"em_questtype"> | string | null
    Status?: StringNullableFilter<"em_questtype"> | string | null
  }, "Id">

  export type em_questtypeOrderByWithAggregationInput = {
    Id?: SortOrder
    TypeName?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    _count?: em_questtypeCountOrderByAggregateInput
    _avg?: em_questtypeAvgOrderByAggregateInput
    _max?: em_questtypeMaxOrderByAggregateInput
    _min?: em_questtypeMinOrderByAggregateInput
    _sum?: em_questtypeSumOrderByAggregateInput
  }

  export type em_questtypeScalarWhereWithAggregatesInput = {
    AND?: em_questtypeScalarWhereWithAggregatesInput | em_questtypeScalarWhereWithAggregatesInput[]
    OR?: em_questtypeScalarWhereWithAggregatesInput[]
    NOT?: em_questtypeScalarWhereWithAggregatesInput | em_questtypeScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_questtype"> | number
    TypeName?: StringNullableWithAggregatesFilter<"em_questtype"> | string | null
    Status?: StringNullableWithAggregatesFilter<"em_questtype"> | string | null
  }

  export type em_regulationsWhereInput = {
    AND?: em_regulationsWhereInput | em_regulationsWhereInput[]
    OR?: em_regulationsWhereInput[]
    NOT?: em_regulationsWhereInput | em_regulationsWhereInput[]
    Id?: IntFilter<"em_regulations"> | number
    chanceId?: IntNullableFilter<"em_regulations"> | number | null
    regName?: StringNullableFilter<"em_regulations"> | string | null
    urut?: IntNullableFilter<"em_regulations"> | number | null
    status?: StringNullableFilter<"em_regulations"> | string | null
    userid?: StringNullableFilter<"em_regulations"> | string | null
    createDate?: DateTimeNullableFilter<"em_regulations"> | Date | string | null
    lastUpdate?: DateTimeNullableFilter<"em_regulations"> | Date | string | null
  }

  export type em_regulationsOrderByWithRelationInput = {
    Id?: SortOrder
    chanceId?: SortOrderInput | SortOrder
    regName?: SortOrderInput | SortOrder
    urut?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    lastUpdate?: SortOrderInput | SortOrder
  }

  export type em_regulationsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_regulationsWhereInput | em_regulationsWhereInput[]
    OR?: em_regulationsWhereInput[]
    NOT?: em_regulationsWhereInput | em_regulationsWhereInput[]
    chanceId?: IntNullableFilter<"em_regulations"> | number | null
    regName?: StringNullableFilter<"em_regulations"> | string | null
    urut?: IntNullableFilter<"em_regulations"> | number | null
    status?: StringNullableFilter<"em_regulations"> | string | null
    userid?: StringNullableFilter<"em_regulations"> | string | null
    createDate?: DateTimeNullableFilter<"em_regulations"> | Date | string | null
    lastUpdate?: DateTimeNullableFilter<"em_regulations"> | Date | string | null
  }, "Id">

  export type em_regulationsOrderByWithAggregationInput = {
    Id?: SortOrder
    chanceId?: SortOrderInput | SortOrder
    regName?: SortOrderInput | SortOrder
    urut?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    lastUpdate?: SortOrderInput | SortOrder
    _count?: em_regulationsCountOrderByAggregateInput
    _avg?: em_regulationsAvgOrderByAggregateInput
    _max?: em_regulationsMaxOrderByAggregateInput
    _min?: em_regulationsMinOrderByAggregateInput
    _sum?: em_regulationsSumOrderByAggregateInput
  }

  export type em_regulationsScalarWhereWithAggregatesInput = {
    AND?: em_regulationsScalarWhereWithAggregatesInput | em_regulationsScalarWhereWithAggregatesInput[]
    OR?: em_regulationsScalarWhereWithAggregatesInput[]
    NOT?: em_regulationsScalarWhereWithAggregatesInput | em_regulationsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_regulations"> | number
    chanceId?: IntNullableWithAggregatesFilter<"em_regulations"> | number | null
    regName?: StringNullableWithAggregatesFilter<"em_regulations"> | string | null
    urut?: IntNullableWithAggregatesFilter<"em_regulations"> | number | null
    status?: StringNullableWithAggregatesFilter<"em_regulations"> | string | null
    userid?: StringNullableWithAggregatesFilter<"em_regulations"> | string | null
    createDate?: DateTimeNullableWithAggregatesFilter<"em_regulations"> | Date | string | null
    lastUpdate?: DateTimeNullableWithAggregatesFilter<"em_regulations"> | Date | string | null
  }

  export type em_sbuWhereInput = {
    AND?: em_sbuWhereInput | em_sbuWhereInput[]
    OR?: em_sbuWhereInput[]
    NOT?: em_sbuWhereInput | em_sbuWhereInput[]
    id?: IntFilter<"em_sbu"> | number
    sbu_code?: StringFilter<"em_sbu"> | string
    sbu_name?: StringFilter<"em_sbu"> | string
    sbu_pilar?: IntNullableFilter<"em_sbu"> | number | null
    status?: StringFilter<"em_sbu"> | string
    add_by?: StringNullableFilter<"em_sbu"> | string | null
    created_at?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    createdBy?: StringNullableFilter<"em_sbu"> | string | null
    updatedAt?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    updatedBy?: StringNullableFilter<"em_sbu"> | string | null
    isDeleted?: BoolFilter<"em_sbu"> | boolean
    deletedAt?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    deletedBy?: StringNullableFilter<"em_sbu"> | string | null
    description?: StringNullableFilter<"em_sbu"> | string | null
    pic?: IntNullableFilter<"em_sbu"> | number | null
  }

  export type em_sbuOrderByWithRelationInput = {
    id?: SortOrder
    sbu_code?: SortOrder
    sbu_name?: SortOrder
    sbu_pilar?: SortOrderInput | SortOrder
    status?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
  }

  export type em_sbuWhereUniqueInput = Prisma.AtLeast<{
    id_sbu_code?: em_sbuIdSbu_codeCompoundUniqueInput
    AND?: em_sbuWhereInput | em_sbuWhereInput[]
    OR?: em_sbuWhereInput[]
    NOT?: em_sbuWhereInput | em_sbuWhereInput[]
    id?: IntFilter<"em_sbu"> | number
    sbu_code?: StringFilter<"em_sbu"> | string
    sbu_name?: StringFilter<"em_sbu"> | string
    sbu_pilar?: IntNullableFilter<"em_sbu"> | number | null
    status?: StringFilter<"em_sbu"> | string
    add_by?: StringNullableFilter<"em_sbu"> | string | null
    created_at?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    createdBy?: StringNullableFilter<"em_sbu"> | string | null
    updatedAt?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    updatedBy?: StringNullableFilter<"em_sbu"> | string | null
    isDeleted?: BoolFilter<"em_sbu"> | boolean
    deletedAt?: DateTimeNullableFilter<"em_sbu"> | Date | string | null
    deletedBy?: StringNullableFilter<"em_sbu"> | string | null
    description?: StringNullableFilter<"em_sbu"> | string | null
    pic?: IntNullableFilter<"em_sbu"> | number | null
  }, "id_sbu_code">

  export type em_sbuOrderByWithAggregationInput = {
    id?: SortOrder
    sbu_code?: SortOrder
    sbu_name?: SortOrder
    sbu_pilar?: SortOrderInput | SortOrder
    status?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
    _count?: em_sbuCountOrderByAggregateInput
    _avg?: em_sbuAvgOrderByAggregateInput
    _max?: em_sbuMaxOrderByAggregateInput
    _min?: em_sbuMinOrderByAggregateInput
    _sum?: em_sbuSumOrderByAggregateInput
  }

  export type em_sbuScalarWhereWithAggregatesInput = {
    AND?: em_sbuScalarWhereWithAggregatesInput | em_sbuScalarWhereWithAggregatesInput[]
    OR?: em_sbuScalarWhereWithAggregatesInput[]
    NOT?: em_sbuScalarWhereWithAggregatesInput | em_sbuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_sbu"> | number
    sbu_code?: StringWithAggregatesFilter<"em_sbu"> | string
    sbu_name?: StringWithAggregatesFilter<"em_sbu"> | string
    sbu_pilar?: IntNullableWithAggregatesFilter<"em_sbu"> | number | null
    status?: StringWithAggregatesFilter<"em_sbu"> | string
    add_by?: StringNullableWithAggregatesFilter<"em_sbu"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_sbu"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_sbu"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"em_sbu"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"em_sbu"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"em_sbu"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"em_sbu"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"em_sbu"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"em_sbu"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"em_sbu"> | string | null
    description?: StringNullableWithAggregatesFilter<"em_sbu"> | string | null
    pic?: IntNullableWithAggregatesFilter<"em_sbu"> | number | null
  }

  export type em_sbu_subWhereInput = {
    AND?: em_sbu_subWhereInput | em_sbu_subWhereInput[]
    OR?: em_sbu_subWhereInput[]
    NOT?: em_sbu_subWhereInput | em_sbu_subWhereInput[]
    id?: IntFilter<"em_sbu_sub"> | number
    sbu_sub_code?: StringFilter<"em_sbu_sub"> | string
    sbu_sub_name?: StringFilter<"em_sbu_sub"> | string
    sbu_id?: IntNullableFilter<"em_sbu_sub"> | number | null
    sbu_pilar?: IntNullableFilter<"em_sbu_sub"> | number | null
    status?: StringFilter<"em_sbu_sub"> | string
    add_by?: StringNullableFilter<"em_sbu_sub"> | string | null
    created_at?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    createdBy?: StringNullableFilter<"em_sbu_sub"> | string | null
    updatedAt?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    updatedBy?: StringNullableFilter<"em_sbu_sub"> | string | null
    isDeleted?: BoolFilter<"em_sbu_sub"> | boolean
    deletedAt?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    deletedBy?: StringNullableFilter<"em_sbu_sub"> | string | null
    description?: StringNullableFilter<"em_sbu_sub"> | string | null
    pic?: IntNullableFilter<"em_sbu_sub"> | number | null
  }

  export type em_sbu_subOrderByWithRelationInput = {
    id?: SortOrder
    sbu_sub_code?: SortOrder
    sbu_sub_name?: SortOrder
    sbu_id?: SortOrderInput | SortOrder
    sbu_pilar?: SortOrderInput | SortOrder
    status?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
  }

  export type em_sbu_subWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_sbu_subWhereInput | em_sbu_subWhereInput[]
    OR?: em_sbu_subWhereInput[]
    NOT?: em_sbu_subWhereInput | em_sbu_subWhereInput[]
    sbu_sub_code?: StringFilter<"em_sbu_sub"> | string
    sbu_sub_name?: StringFilter<"em_sbu_sub"> | string
    sbu_id?: IntNullableFilter<"em_sbu_sub"> | number | null
    sbu_pilar?: IntNullableFilter<"em_sbu_sub"> | number | null
    status?: StringFilter<"em_sbu_sub"> | string
    add_by?: StringNullableFilter<"em_sbu_sub"> | string | null
    created_at?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    createdBy?: StringNullableFilter<"em_sbu_sub"> | string | null
    updatedAt?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    updatedBy?: StringNullableFilter<"em_sbu_sub"> | string | null
    isDeleted?: BoolFilter<"em_sbu_sub"> | boolean
    deletedAt?: DateTimeNullableFilter<"em_sbu_sub"> | Date | string | null
    deletedBy?: StringNullableFilter<"em_sbu_sub"> | string | null
    description?: StringNullableFilter<"em_sbu_sub"> | string | null
    pic?: IntNullableFilter<"em_sbu_sub"> | number | null
  }, "id">

  export type em_sbu_subOrderByWithAggregationInput = {
    id?: SortOrder
    sbu_sub_code?: SortOrder
    sbu_sub_name?: SortOrder
    sbu_id?: SortOrderInput | SortOrder
    sbu_pilar?: SortOrderInput | SortOrder
    status?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
    _count?: em_sbu_subCountOrderByAggregateInput
    _avg?: em_sbu_subAvgOrderByAggregateInput
    _max?: em_sbu_subMaxOrderByAggregateInput
    _min?: em_sbu_subMinOrderByAggregateInput
    _sum?: em_sbu_subSumOrderByAggregateInput
  }

  export type em_sbu_subScalarWhereWithAggregatesInput = {
    AND?: em_sbu_subScalarWhereWithAggregatesInput | em_sbu_subScalarWhereWithAggregatesInput[]
    OR?: em_sbu_subScalarWhereWithAggregatesInput[]
    NOT?: em_sbu_subScalarWhereWithAggregatesInput | em_sbu_subScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_sbu_sub"> | number
    sbu_sub_code?: StringWithAggregatesFilter<"em_sbu_sub"> | string
    sbu_sub_name?: StringWithAggregatesFilter<"em_sbu_sub"> | string
    sbu_id?: IntNullableWithAggregatesFilter<"em_sbu_sub"> | number | null
    sbu_pilar?: IntNullableWithAggregatesFilter<"em_sbu_sub"> | number | null
    status?: StringWithAggregatesFilter<"em_sbu_sub"> | string
    add_by?: StringNullableWithAggregatesFilter<"em_sbu_sub"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_sbu_sub"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_sbu_sub"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"em_sbu_sub"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"em_sbu_sub"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"em_sbu_sub"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"em_sbu_sub"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"em_sbu_sub"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"em_sbu_sub"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"em_sbu_sub"> | string | null
    description?: StringNullableWithAggregatesFilter<"em_sbu_sub"> | string | null
    pic?: IntNullableWithAggregatesFilter<"em_sbu_sub"> | number | null
  }

  export type em_schedule1WhereInput = {
    AND?: em_schedule1WhereInput | em_schedule1WhereInput[]
    OR?: em_schedule1WhereInput[]
    NOT?: em_schedule1WhereInput | em_schedule1WhereInput[]
    Id?: IntFilter<"em_schedule1"> | number
    scheName?: StringNullableFilter<"em_schedule1"> | string | null
    scheDeskripsi?: StringNullableFilter<"em_schedule1"> | string | null
    isMateri?: IntNullableFilter<"em_schedule1"> | number | null
    isQuota?: IntNullableFilter<"em_schedule1"> | number | null
    startDate?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    endDate?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    startTime?: StringNullableFilter<"em_schedule1"> | string | null
    endTime?: StringNullableFilter<"em_schedule1"> | string | null
    isLokasi?: StringNullableFilter<"em_schedule1"> | string | null
    isTrainer?: StringNullableFilter<"em_schedule1"> | string | null
    status?: StringNullableFilter<"em_schedule1"> | string | null
    created_at?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    sendWA?: IntNullableFilter<"em_schedule1"> | number | null
    ujian_stats?: StringNullableFilter<"em_schedule1"> | string | null
    is_with_soal?: StringNullableFilter<"em_schedule1"> | string | null
    usr_by?: StringNullableFilter<"em_schedule1"> | string | null
    is_wa_template?: IntNullableFilter<"em_schedule1"> | number | null
    is_batch?: StringNullableFilter<"em_schedule1"> | string | null
    event_id?: IntNullableFilter<"em_schedule1"> | number | null
    em_schedule2?: Em_schedule2ListRelationFilter
    em_schedule3?: Em_schedule3ListRelationFilter
    em_schedule4?: Em_schedule4ListRelationFilter
  }

  export type em_schedule1OrderByWithRelationInput = {
    Id?: SortOrder
    scheName?: SortOrderInput | SortOrder
    scheDeskripsi?: SortOrderInput | SortOrder
    isMateri?: SortOrderInput | SortOrder
    isQuota?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isLokasi?: SortOrderInput | SortOrder
    isTrainer?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    sendWA?: SortOrderInput | SortOrder
    ujian_stats?: SortOrderInput | SortOrder
    is_with_soal?: SortOrderInput | SortOrder
    usr_by?: SortOrderInput | SortOrder
    is_wa_template?: SortOrderInput | SortOrder
    is_batch?: SortOrderInput | SortOrder
    event_id?: SortOrderInput | SortOrder
    em_schedule2?: em_schedule2OrderByRelationAggregateInput
    em_schedule3?: em_schedule3OrderByRelationAggregateInput
    em_schedule4?: em_schedule4OrderByRelationAggregateInput
  }

  export type em_schedule1WhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_schedule1WhereInput | em_schedule1WhereInput[]
    OR?: em_schedule1WhereInput[]
    NOT?: em_schedule1WhereInput | em_schedule1WhereInput[]
    scheName?: StringNullableFilter<"em_schedule1"> | string | null
    scheDeskripsi?: StringNullableFilter<"em_schedule1"> | string | null
    isMateri?: IntNullableFilter<"em_schedule1"> | number | null
    isQuota?: IntNullableFilter<"em_schedule1"> | number | null
    startDate?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    endDate?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    startTime?: StringNullableFilter<"em_schedule1"> | string | null
    endTime?: StringNullableFilter<"em_schedule1"> | string | null
    isLokasi?: StringNullableFilter<"em_schedule1"> | string | null
    isTrainer?: StringNullableFilter<"em_schedule1"> | string | null
    status?: StringNullableFilter<"em_schedule1"> | string | null
    created_at?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_schedule1"> | Date | string | null
    sendWA?: IntNullableFilter<"em_schedule1"> | number | null
    ujian_stats?: StringNullableFilter<"em_schedule1"> | string | null
    is_with_soal?: StringNullableFilter<"em_schedule1"> | string | null
    usr_by?: StringNullableFilter<"em_schedule1"> | string | null
    is_wa_template?: IntNullableFilter<"em_schedule1"> | number | null
    is_batch?: StringNullableFilter<"em_schedule1"> | string | null
    event_id?: IntNullableFilter<"em_schedule1"> | number | null
    em_schedule2?: Em_schedule2ListRelationFilter
    em_schedule3?: Em_schedule3ListRelationFilter
    em_schedule4?: Em_schedule4ListRelationFilter
  }, "Id">

  export type em_schedule1OrderByWithAggregationInput = {
    Id?: SortOrder
    scheName?: SortOrderInput | SortOrder
    scheDeskripsi?: SortOrderInput | SortOrder
    isMateri?: SortOrderInput | SortOrder
    isQuota?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isLokasi?: SortOrderInput | SortOrder
    isTrainer?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    sendWA?: SortOrderInput | SortOrder
    ujian_stats?: SortOrderInput | SortOrder
    is_with_soal?: SortOrderInput | SortOrder
    usr_by?: SortOrderInput | SortOrder
    is_wa_template?: SortOrderInput | SortOrder
    is_batch?: SortOrderInput | SortOrder
    event_id?: SortOrderInput | SortOrder
    _count?: em_schedule1CountOrderByAggregateInput
    _avg?: em_schedule1AvgOrderByAggregateInput
    _max?: em_schedule1MaxOrderByAggregateInput
    _min?: em_schedule1MinOrderByAggregateInput
    _sum?: em_schedule1SumOrderByAggregateInput
  }

  export type em_schedule1ScalarWhereWithAggregatesInput = {
    AND?: em_schedule1ScalarWhereWithAggregatesInput | em_schedule1ScalarWhereWithAggregatesInput[]
    OR?: em_schedule1ScalarWhereWithAggregatesInput[]
    NOT?: em_schedule1ScalarWhereWithAggregatesInput | em_schedule1ScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_schedule1"> | number
    scheName?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    scheDeskripsi?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    isMateri?: IntNullableWithAggregatesFilter<"em_schedule1"> | number | null
    isQuota?: IntNullableWithAggregatesFilter<"em_schedule1"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"em_schedule1"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"em_schedule1"> | Date | string | null
    startTime?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    isLokasi?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    isTrainer?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_schedule1"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_schedule1"> | Date | string | null
    sendWA?: IntNullableWithAggregatesFilter<"em_schedule1"> | number | null
    ujian_stats?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    is_with_soal?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    usr_by?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    is_wa_template?: IntNullableWithAggregatesFilter<"em_schedule1"> | number | null
    is_batch?: StringNullableWithAggregatesFilter<"em_schedule1"> | string | null
    event_id?: IntNullableWithAggregatesFilter<"em_schedule1"> | number | null
  }

  export type em_schedule2WhereInput = {
    AND?: em_schedule2WhereInput | em_schedule2WhereInput[]
    OR?: em_schedule2WhereInput[]
    NOT?: em_schedule2WhereInput | em_schedule2WhereInput[]
    Id?: IntFilter<"em_schedule2"> | number
    scheduleId?: IntNullableFilter<"em_schedule2"> | number | null
    employeeId?: IntNullableFilter<"em_schedule2"> | number | null
    Regid?: StringNullableFilter<"em_schedule2"> | string | null
    is_send_wa_stats?: IntNullableFilter<"em_schedule2"> | number | null
    send_date?: DateTimeNullableFilter<"em_schedule2"> | Date | string | null
    is_code_send?: StringNullableFilter<"em_schedule2"> | string | null
    em_schedule1?: XOR<Em_schedule1NullableScalarRelationFilter, em_schedule1WhereInput> | null
  }

  export type em_schedule2OrderByWithRelationInput = {
    Id?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    Regid?: SortOrderInput | SortOrder
    is_send_wa_stats?: SortOrderInput | SortOrder
    send_date?: SortOrderInput | SortOrder
    is_code_send?: SortOrderInput | SortOrder
    em_schedule1?: em_schedule1OrderByWithRelationInput
  }

  export type em_schedule2WhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_schedule2WhereInput | em_schedule2WhereInput[]
    OR?: em_schedule2WhereInput[]
    NOT?: em_schedule2WhereInput | em_schedule2WhereInput[]
    scheduleId?: IntNullableFilter<"em_schedule2"> | number | null
    employeeId?: IntNullableFilter<"em_schedule2"> | number | null
    Regid?: StringNullableFilter<"em_schedule2"> | string | null
    is_send_wa_stats?: IntNullableFilter<"em_schedule2"> | number | null
    send_date?: DateTimeNullableFilter<"em_schedule2"> | Date | string | null
    is_code_send?: StringNullableFilter<"em_schedule2"> | string | null
    em_schedule1?: XOR<Em_schedule1NullableScalarRelationFilter, em_schedule1WhereInput> | null
  }, "Id">

  export type em_schedule2OrderByWithAggregationInput = {
    Id?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    Regid?: SortOrderInput | SortOrder
    is_send_wa_stats?: SortOrderInput | SortOrder
    send_date?: SortOrderInput | SortOrder
    is_code_send?: SortOrderInput | SortOrder
    _count?: em_schedule2CountOrderByAggregateInput
    _avg?: em_schedule2AvgOrderByAggregateInput
    _max?: em_schedule2MaxOrderByAggregateInput
    _min?: em_schedule2MinOrderByAggregateInput
    _sum?: em_schedule2SumOrderByAggregateInput
  }

  export type em_schedule2ScalarWhereWithAggregatesInput = {
    AND?: em_schedule2ScalarWhereWithAggregatesInput | em_schedule2ScalarWhereWithAggregatesInput[]
    OR?: em_schedule2ScalarWhereWithAggregatesInput[]
    NOT?: em_schedule2ScalarWhereWithAggregatesInput | em_schedule2ScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_schedule2"> | number
    scheduleId?: IntNullableWithAggregatesFilter<"em_schedule2"> | number | null
    employeeId?: IntNullableWithAggregatesFilter<"em_schedule2"> | number | null
    Regid?: StringNullableWithAggregatesFilter<"em_schedule2"> | string | null
    is_send_wa_stats?: IntNullableWithAggregatesFilter<"em_schedule2"> | number | null
    send_date?: DateTimeNullableWithAggregatesFilter<"em_schedule2"> | Date | string | null
    is_code_send?: StringNullableWithAggregatesFilter<"em_schedule2"> | string | null
  }

  export type em_schedule3WhereInput = {
    AND?: em_schedule3WhereInput | em_schedule3WhereInput[]
    OR?: em_schedule3WhereInput[]
    NOT?: em_schedule3WhereInput | em_schedule3WhereInput[]
    Id?: IntFilter<"em_schedule3"> | number
    scheduleId?: IntFilter<"em_schedule3"> | number
    soalId?: IntFilter<"em_schedule3"> | number
    urutanSoal?: IntFilter<"em_schedule3"> | number
    materiId?: IntFilter<"em_schedule3"> | number
    urutanTipeSoal?: IntFilter<"em_schedule3"> | number
    tipeSoal?: IntFilter<"em_schedule3"> | number
    em_schedule1?: XOR<Em_schedule1ScalarRelationFilter, em_schedule1WhereInput>
  }

  export type em_schedule3OrderByWithRelationInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
    em_schedule1?: em_schedule1OrderByWithRelationInput
  }

  export type em_schedule3WhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_schedule3WhereInput | em_schedule3WhereInput[]
    OR?: em_schedule3WhereInput[]
    NOT?: em_schedule3WhereInput | em_schedule3WhereInput[]
    scheduleId?: IntFilter<"em_schedule3"> | number
    soalId?: IntFilter<"em_schedule3"> | number
    urutanSoal?: IntFilter<"em_schedule3"> | number
    materiId?: IntFilter<"em_schedule3"> | number
    urutanTipeSoal?: IntFilter<"em_schedule3"> | number
    tipeSoal?: IntFilter<"em_schedule3"> | number
    em_schedule1?: XOR<Em_schedule1ScalarRelationFilter, em_schedule1WhereInput>
  }, "Id">

  export type em_schedule3OrderByWithAggregationInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
    _count?: em_schedule3CountOrderByAggregateInput
    _avg?: em_schedule3AvgOrderByAggregateInput
    _max?: em_schedule3MaxOrderByAggregateInput
    _min?: em_schedule3MinOrderByAggregateInput
    _sum?: em_schedule3SumOrderByAggregateInput
  }

  export type em_schedule3ScalarWhereWithAggregatesInput = {
    AND?: em_schedule3ScalarWhereWithAggregatesInput | em_schedule3ScalarWhereWithAggregatesInput[]
    OR?: em_schedule3ScalarWhereWithAggregatesInput[]
    NOT?: em_schedule3ScalarWhereWithAggregatesInput | em_schedule3ScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_schedule3"> | number
    scheduleId?: IntWithAggregatesFilter<"em_schedule3"> | number
    soalId?: IntWithAggregatesFilter<"em_schedule3"> | number
    urutanSoal?: IntWithAggregatesFilter<"em_schedule3"> | number
    materiId?: IntWithAggregatesFilter<"em_schedule3"> | number
    urutanTipeSoal?: IntWithAggregatesFilter<"em_schedule3"> | number
    tipeSoal?: IntWithAggregatesFilter<"em_schedule3"> | number
  }

  export type em_schedule4WhereInput = {
    AND?: em_schedule4WhereInput | em_schedule4WhereInput[]
    OR?: em_schedule4WhereInput[]
    NOT?: em_schedule4WhereInput | em_schedule4WhereInput[]
    Id?: IntFilter<"em_schedule4"> | number
    scheduleId?: IntNullableFilter<"em_schedule4"> | number | null
    tipeSoal?: IntNullableFilter<"em_schedule4"> | number | null
    jumlahSoal?: FloatNullableFilter<"em_schedule4"> | number | null
    durasiPerTipe?: IntNullableFilter<"em_schedule4"> | number | null
    em_schedule1?: XOR<Em_schedule1NullableScalarRelationFilter, em_schedule1WhereInput> | null
  }

  export type em_schedule4OrderByWithRelationInput = {
    Id?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    tipeSoal?: SortOrderInput | SortOrder
    jumlahSoal?: SortOrderInput | SortOrder
    durasiPerTipe?: SortOrderInput | SortOrder
    em_schedule1?: em_schedule1OrderByWithRelationInput
  }

  export type em_schedule4WhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_schedule4WhereInput | em_schedule4WhereInput[]
    OR?: em_schedule4WhereInput[]
    NOT?: em_schedule4WhereInput | em_schedule4WhereInput[]
    scheduleId?: IntNullableFilter<"em_schedule4"> | number | null
    tipeSoal?: IntNullableFilter<"em_schedule4"> | number | null
    jumlahSoal?: FloatNullableFilter<"em_schedule4"> | number | null
    durasiPerTipe?: IntNullableFilter<"em_schedule4"> | number | null
    em_schedule1?: XOR<Em_schedule1NullableScalarRelationFilter, em_schedule1WhereInput> | null
  }, "Id">

  export type em_schedule4OrderByWithAggregationInput = {
    Id?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    tipeSoal?: SortOrderInput | SortOrder
    jumlahSoal?: SortOrderInput | SortOrder
    durasiPerTipe?: SortOrderInput | SortOrder
    _count?: em_schedule4CountOrderByAggregateInput
    _avg?: em_schedule4AvgOrderByAggregateInput
    _max?: em_schedule4MaxOrderByAggregateInput
    _min?: em_schedule4MinOrderByAggregateInput
    _sum?: em_schedule4SumOrderByAggregateInput
  }

  export type em_schedule4ScalarWhereWithAggregatesInput = {
    AND?: em_schedule4ScalarWhereWithAggregatesInput | em_schedule4ScalarWhereWithAggregatesInput[]
    OR?: em_schedule4ScalarWhereWithAggregatesInput[]
    NOT?: em_schedule4ScalarWhereWithAggregatesInput | em_schedule4ScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_schedule4"> | number
    scheduleId?: IntNullableWithAggregatesFilter<"em_schedule4"> | number | null
    tipeSoal?: IntNullableWithAggregatesFilter<"em_schedule4"> | number | null
    jumlahSoal?: FloatNullableWithAggregatesFilter<"em_schedule4"> | number | null
    durasiPerTipe?: IntNullableWithAggregatesFilter<"em_schedule4"> | number | null
  }

  export type em_session_examsWhereInput = {
    AND?: em_session_examsWhereInput | em_session_examsWhereInput[]
    OR?: em_session_examsWhereInput[]
    NOT?: em_session_examsWhereInput | em_session_examsWhereInput[]
    Id?: IntFilter<"em_session_exams"> | number
    schedule_id?: IntNullableFilter<"em_session_exams"> | number | null
    exams_id?: StringNullableFilter<"em_session_exams"> | string | null
    empl_id?: IntNullableFilter<"em_session_exams"> | number | null
    soal_urut?: StringNullableFilter<"em_session_exams"> | string | null
    start_time?: DateTimeNullableFilter<"em_session_exams"> | Date | string | null
    end_time?: DateTimeNullableFilter<"em_session_exams"> | Date | string | null
    is_selesai?: StringNullableFilter<"em_session_exams"> | string | null
    is_token?: StringNullableFilter<"em_session_exams"> | string | null
    is_token_expr?: DateTimeNullableFilter<"em_session_exams"> | Date | string | null
    durasi?: IntNullableFilter<"em_session_exams"> | number | null
    is_correct?: IntNullableFilter<"em_session_exams"> | number | null
    is_notes?: StringNullableFilter<"em_session_exams"> | string | null
    is_score_akhir?: FloatNullableFilter<"em_session_exams"> | number | null
    em_jawaban_peserta?: Em_jawaban_pesertaListRelationFilter
  }

  export type em_session_examsOrderByWithRelationInput = {
    Id?: SortOrder
    schedule_id?: SortOrderInput | SortOrder
    exams_id?: SortOrderInput | SortOrder
    empl_id?: SortOrderInput | SortOrder
    soal_urut?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    is_selesai?: SortOrderInput | SortOrder
    is_token?: SortOrderInput | SortOrder
    is_token_expr?: SortOrderInput | SortOrder
    durasi?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    is_notes?: SortOrderInput | SortOrder
    is_score_akhir?: SortOrderInput | SortOrder
    em_jawaban_peserta?: em_jawaban_pesertaOrderByRelationAggregateInput
  }

  export type em_session_examsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    exams_id?: string
    AND?: em_session_examsWhereInput | em_session_examsWhereInput[]
    OR?: em_session_examsWhereInput[]
    NOT?: em_session_examsWhereInput | em_session_examsWhereInput[]
    schedule_id?: IntNullableFilter<"em_session_exams"> | number | null
    empl_id?: IntNullableFilter<"em_session_exams"> | number | null
    soal_urut?: StringNullableFilter<"em_session_exams"> | string | null
    start_time?: DateTimeNullableFilter<"em_session_exams"> | Date | string | null
    end_time?: DateTimeNullableFilter<"em_session_exams"> | Date | string | null
    is_selesai?: StringNullableFilter<"em_session_exams"> | string | null
    is_token?: StringNullableFilter<"em_session_exams"> | string | null
    is_token_expr?: DateTimeNullableFilter<"em_session_exams"> | Date | string | null
    durasi?: IntNullableFilter<"em_session_exams"> | number | null
    is_correct?: IntNullableFilter<"em_session_exams"> | number | null
    is_notes?: StringNullableFilter<"em_session_exams"> | string | null
    is_score_akhir?: FloatNullableFilter<"em_session_exams"> | number | null
    em_jawaban_peserta?: Em_jawaban_pesertaListRelationFilter
  }, "Id" | "exams_id">

  export type em_session_examsOrderByWithAggregationInput = {
    Id?: SortOrder
    schedule_id?: SortOrderInput | SortOrder
    exams_id?: SortOrderInput | SortOrder
    empl_id?: SortOrderInput | SortOrder
    soal_urut?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    is_selesai?: SortOrderInput | SortOrder
    is_token?: SortOrderInput | SortOrder
    is_token_expr?: SortOrderInput | SortOrder
    durasi?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    is_notes?: SortOrderInput | SortOrder
    is_score_akhir?: SortOrderInput | SortOrder
    _count?: em_session_examsCountOrderByAggregateInput
    _avg?: em_session_examsAvgOrderByAggregateInput
    _max?: em_session_examsMaxOrderByAggregateInput
    _min?: em_session_examsMinOrderByAggregateInput
    _sum?: em_session_examsSumOrderByAggregateInput
  }

  export type em_session_examsScalarWhereWithAggregatesInput = {
    AND?: em_session_examsScalarWhereWithAggregatesInput | em_session_examsScalarWhereWithAggregatesInput[]
    OR?: em_session_examsScalarWhereWithAggregatesInput[]
    NOT?: em_session_examsScalarWhereWithAggregatesInput | em_session_examsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_session_exams"> | number
    schedule_id?: IntNullableWithAggregatesFilter<"em_session_exams"> | number | null
    exams_id?: StringNullableWithAggregatesFilter<"em_session_exams"> | string | null
    empl_id?: IntNullableWithAggregatesFilter<"em_session_exams"> | number | null
    soal_urut?: StringNullableWithAggregatesFilter<"em_session_exams"> | string | null
    start_time?: DateTimeNullableWithAggregatesFilter<"em_session_exams"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"em_session_exams"> | Date | string | null
    is_selesai?: StringNullableWithAggregatesFilter<"em_session_exams"> | string | null
    is_token?: StringNullableWithAggregatesFilter<"em_session_exams"> | string | null
    is_token_expr?: DateTimeNullableWithAggregatesFilter<"em_session_exams"> | Date | string | null
    durasi?: IntNullableWithAggregatesFilter<"em_session_exams"> | number | null
    is_correct?: IntNullableWithAggregatesFilter<"em_session_exams"> | number | null
    is_notes?: StringNullableWithAggregatesFilter<"em_session_exams"> | string | null
    is_score_akhir?: FloatNullableWithAggregatesFilter<"em_session_exams"> | number | null
  }

  export type em_session_exams_apcWhereInput = {
    AND?: em_session_exams_apcWhereInput | em_session_exams_apcWhereInput[]
    OR?: em_session_exams_apcWhereInput[]
    NOT?: em_session_exams_apcWhereInput | em_session_exams_apcWhereInput[]
    Id?: IntFilter<"em_session_exams_apc"> | number
    lokerid?: IntFilter<"em_session_exams_apc"> | number
    exams_id?: StringFilter<"em_session_exams_apc"> | string
    apcid?: IntFilter<"em_session_exams_apc"> | number
    soal_urut?: StringNullableFilter<"em_session_exams_apc"> | string | null
    start_time?: DateTimeNullableFilter<"em_session_exams_apc"> | Date | string | null
    end_time?: DateTimeNullableFilter<"em_session_exams_apc"> | Date | string | null
    is_selesai?: StringNullableFilter<"em_session_exams_apc"> | string | null
    is_token?: StringNullableFilter<"em_session_exams_apc"> | string | null
    is_token_expr?: DateTimeNullableFilter<"em_session_exams_apc"> | Date | string | null
    durasi?: IntNullableFilter<"em_session_exams_apc"> | number | null
    is_correct?: IntNullableFilter<"em_session_exams_apc"> | number | null
    is_notes?: StringNullableFilter<"em_session_exams_apc"> | string | null
    is_score_akhir?: FloatNullableFilter<"em_session_exams_apc"> | number | null
    curr_topic_index?: IntNullableFilter<"em_session_exams_apc"> | number | null
    curr_soal_index?: IntNullableFilter<"em_session_exams_apc"> | number | null
    is_intro_topic?: BoolNullableFilter<"em_session_exams_apc"> | boolean | null
    is_jawaban_kosong?: IntNullableFilter<"em_session_exams_apc"> | number | null
    em_jawaban_peserta_apc?: Em_jawaban_peserta_apcListRelationFilter
    em_topic_selesai?: Em_topic_selesaiListRelationFilter
  }

  export type em_session_exams_apcOrderByWithRelationInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    exams_id?: SortOrder
    apcid?: SortOrder
    soal_urut?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    is_selesai?: SortOrderInput | SortOrder
    is_token?: SortOrderInput | SortOrder
    is_token_expr?: SortOrderInput | SortOrder
    durasi?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    is_notes?: SortOrderInput | SortOrder
    is_score_akhir?: SortOrderInput | SortOrder
    curr_topic_index?: SortOrderInput | SortOrder
    curr_soal_index?: SortOrderInput | SortOrder
    is_intro_topic?: SortOrderInput | SortOrder
    is_jawaban_kosong?: SortOrderInput | SortOrder
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcOrderByRelationAggregateInput
    em_topic_selesai?: em_topic_selesaiOrderByRelationAggregateInput
  }

  export type em_session_exams_apcWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    exams_id?: string
    AND?: em_session_exams_apcWhereInput | em_session_exams_apcWhereInput[]
    OR?: em_session_exams_apcWhereInput[]
    NOT?: em_session_exams_apcWhereInput | em_session_exams_apcWhereInput[]
    lokerid?: IntFilter<"em_session_exams_apc"> | number
    apcid?: IntFilter<"em_session_exams_apc"> | number
    soal_urut?: StringNullableFilter<"em_session_exams_apc"> | string | null
    start_time?: DateTimeNullableFilter<"em_session_exams_apc"> | Date | string | null
    end_time?: DateTimeNullableFilter<"em_session_exams_apc"> | Date | string | null
    is_selesai?: StringNullableFilter<"em_session_exams_apc"> | string | null
    is_token?: StringNullableFilter<"em_session_exams_apc"> | string | null
    is_token_expr?: DateTimeNullableFilter<"em_session_exams_apc"> | Date | string | null
    durasi?: IntNullableFilter<"em_session_exams_apc"> | number | null
    is_correct?: IntNullableFilter<"em_session_exams_apc"> | number | null
    is_notes?: StringNullableFilter<"em_session_exams_apc"> | string | null
    is_score_akhir?: FloatNullableFilter<"em_session_exams_apc"> | number | null
    curr_topic_index?: IntNullableFilter<"em_session_exams_apc"> | number | null
    curr_soal_index?: IntNullableFilter<"em_session_exams_apc"> | number | null
    is_intro_topic?: BoolNullableFilter<"em_session_exams_apc"> | boolean | null
    is_jawaban_kosong?: IntNullableFilter<"em_session_exams_apc"> | number | null
    em_jawaban_peserta_apc?: Em_jawaban_peserta_apcListRelationFilter
    em_topic_selesai?: Em_topic_selesaiListRelationFilter
  }, "Id" | "exams_id">

  export type em_session_exams_apcOrderByWithAggregationInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    exams_id?: SortOrder
    apcid?: SortOrder
    soal_urut?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    is_selesai?: SortOrderInput | SortOrder
    is_token?: SortOrderInput | SortOrder
    is_token_expr?: SortOrderInput | SortOrder
    durasi?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    is_notes?: SortOrderInput | SortOrder
    is_score_akhir?: SortOrderInput | SortOrder
    curr_topic_index?: SortOrderInput | SortOrder
    curr_soal_index?: SortOrderInput | SortOrder
    is_intro_topic?: SortOrderInput | SortOrder
    is_jawaban_kosong?: SortOrderInput | SortOrder
    _count?: em_session_exams_apcCountOrderByAggregateInput
    _avg?: em_session_exams_apcAvgOrderByAggregateInput
    _max?: em_session_exams_apcMaxOrderByAggregateInput
    _min?: em_session_exams_apcMinOrderByAggregateInput
    _sum?: em_session_exams_apcSumOrderByAggregateInput
  }

  export type em_session_exams_apcScalarWhereWithAggregatesInput = {
    AND?: em_session_exams_apcScalarWhereWithAggregatesInput | em_session_exams_apcScalarWhereWithAggregatesInput[]
    OR?: em_session_exams_apcScalarWhereWithAggregatesInput[]
    NOT?: em_session_exams_apcScalarWhereWithAggregatesInput | em_session_exams_apcScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_session_exams_apc"> | number
    lokerid?: IntWithAggregatesFilter<"em_session_exams_apc"> | number
    exams_id?: StringWithAggregatesFilter<"em_session_exams_apc"> | string
    apcid?: IntWithAggregatesFilter<"em_session_exams_apc"> | number
    soal_urut?: StringNullableWithAggregatesFilter<"em_session_exams_apc"> | string | null
    start_time?: DateTimeNullableWithAggregatesFilter<"em_session_exams_apc"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"em_session_exams_apc"> | Date | string | null
    is_selesai?: StringNullableWithAggregatesFilter<"em_session_exams_apc"> | string | null
    is_token?: StringNullableWithAggregatesFilter<"em_session_exams_apc"> | string | null
    is_token_expr?: DateTimeNullableWithAggregatesFilter<"em_session_exams_apc"> | Date | string | null
    durasi?: IntNullableWithAggregatesFilter<"em_session_exams_apc"> | number | null
    is_correct?: IntNullableWithAggregatesFilter<"em_session_exams_apc"> | number | null
    is_notes?: StringNullableWithAggregatesFilter<"em_session_exams_apc"> | string | null
    is_score_akhir?: FloatNullableWithAggregatesFilter<"em_session_exams_apc"> | number | null
    curr_topic_index?: IntNullableWithAggregatesFilter<"em_session_exams_apc"> | number | null
    curr_soal_index?: IntNullableWithAggregatesFilter<"em_session_exams_apc"> | number | null
    is_intro_topic?: BoolNullableWithAggregatesFilter<"em_session_exams_apc"> | boolean | null
    is_jawaban_kosong?: IntNullableWithAggregatesFilter<"em_session_exams_apc"> | number | null
  }

  export type em_subscribeWhereInput = {
    AND?: em_subscribeWhereInput | em_subscribeWhereInput[]
    OR?: em_subscribeWhereInput[]
    NOT?: em_subscribeWhereInput | em_subscribeWhereInput[]
    Id?: IntFilter<"em_subscribe"> | number
    UserId?: StringNullableFilter<"em_subscribe"> | string | null
    Name?: StringNullableFilter<"em_subscribe"> | string | null
    Status?: StringNullableFilter<"em_subscribe"> | string | null
    Endpoint?: StringNullableFilter<"em_subscribe"> | string | null
    P256dh?: StringNullableFilter<"em_subscribe"> | string | null
    Auth?: StringNullableFilter<"em_subscribe"> | string | null
    Created_at?: DateTimeNullableFilter<"em_subscribe"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_subscribe"> | Date | string | null
  }

  export type em_subscribeOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Endpoint?: SortOrderInput | SortOrder
    P256dh?: SortOrderInput | SortOrder
    Auth?: SortOrderInput | SortOrder
    Created_at?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
  }

  export type em_subscribeWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_subscribeWhereInput | em_subscribeWhereInput[]
    OR?: em_subscribeWhereInput[]
    NOT?: em_subscribeWhereInput | em_subscribeWhereInput[]
    UserId?: StringNullableFilter<"em_subscribe"> | string | null
    Name?: StringNullableFilter<"em_subscribe"> | string | null
    Status?: StringNullableFilter<"em_subscribe"> | string | null
    Endpoint?: StringNullableFilter<"em_subscribe"> | string | null
    P256dh?: StringNullableFilter<"em_subscribe"> | string | null
    Auth?: StringNullableFilter<"em_subscribe"> | string | null
    Created_at?: DateTimeNullableFilter<"em_subscribe"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_subscribe"> | Date | string | null
  }, "Id">

  export type em_subscribeOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Endpoint?: SortOrderInput | SortOrder
    P256dh?: SortOrderInput | SortOrder
    Auth?: SortOrderInput | SortOrder
    Created_at?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    _count?: em_subscribeCountOrderByAggregateInput
    _avg?: em_subscribeAvgOrderByAggregateInput
    _max?: em_subscribeMaxOrderByAggregateInput
    _min?: em_subscribeMinOrderByAggregateInput
    _sum?: em_subscribeSumOrderByAggregateInput
  }

  export type em_subscribeScalarWhereWithAggregatesInput = {
    AND?: em_subscribeScalarWhereWithAggregatesInput | em_subscribeScalarWhereWithAggregatesInput[]
    OR?: em_subscribeScalarWhereWithAggregatesInput[]
    NOT?: em_subscribeScalarWhereWithAggregatesInput | em_subscribeScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_subscribe"> | number
    UserId?: StringNullableWithAggregatesFilter<"em_subscribe"> | string | null
    Name?: StringNullableWithAggregatesFilter<"em_subscribe"> | string | null
    Status?: StringNullableWithAggregatesFilter<"em_subscribe"> | string | null
    Endpoint?: StringNullableWithAggregatesFilter<"em_subscribe"> | string | null
    P256dh?: StringNullableWithAggregatesFilter<"em_subscribe"> | string | null
    Auth?: StringNullableWithAggregatesFilter<"em_subscribe"> | string | null
    Created_at?: DateTimeNullableWithAggregatesFilter<"em_subscribe"> | Date | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_subscribe"> | Date | string | null
  }

  export type em_subscriptionWhereInput = {
    AND?: em_subscriptionWhereInput | em_subscriptionWhereInput[]
    OR?: em_subscriptionWhereInput[]
    NOT?: em_subscriptionWhereInput | em_subscriptionWhereInput[]
    Id?: IntFilter<"em_subscription"> | number
    username?: StringFilter<"em_subscription"> | string
    subscription?: StringNullableFilter<"em_subscription"> | string | null
    status?: StringNullableFilter<"em_subscription"> | string | null
    createdat?: DateTimeNullableFilter<"em_subscription"> | Date | string | null
  }

  export type em_subscriptionOrderByWithRelationInput = {
    Id?: SortOrder
    username?: SortOrder
    subscription?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
  }

  export type em_subscriptionWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_subscriptionWhereInput | em_subscriptionWhereInput[]
    OR?: em_subscriptionWhereInput[]
    NOT?: em_subscriptionWhereInput | em_subscriptionWhereInput[]
    username?: StringFilter<"em_subscription"> | string
    subscription?: StringNullableFilter<"em_subscription"> | string | null
    status?: StringNullableFilter<"em_subscription"> | string | null
    createdat?: DateTimeNullableFilter<"em_subscription"> | Date | string | null
  }, "Id">

  export type em_subscriptionOrderByWithAggregationInput = {
    Id?: SortOrder
    username?: SortOrder
    subscription?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: em_subscriptionCountOrderByAggregateInput
    _avg?: em_subscriptionAvgOrderByAggregateInput
    _max?: em_subscriptionMaxOrderByAggregateInput
    _min?: em_subscriptionMinOrderByAggregateInput
    _sum?: em_subscriptionSumOrderByAggregateInput
  }

  export type em_subscriptionScalarWhereWithAggregatesInput = {
    AND?: em_subscriptionScalarWhereWithAggregatesInput | em_subscriptionScalarWhereWithAggregatesInput[]
    OR?: em_subscriptionScalarWhereWithAggregatesInput[]
    NOT?: em_subscriptionScalarWhereWithAggregatesInput | em_subscriptionScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_subscription"> | number
    username?: StringWithAggregatesFilter<"em_subscription"> | string
    subscription?: StringNullableWithAggregatesFilter<"em_subscription"> | string | null
    status?: StringNullableWithAggregatesFilter<"em_subscription"> | string | null
    createdat?: DateTimeNullableWithAggregatesFilter<"em_subscription"> | Date | string | null
  }

  export type em_topic_selesaiWhereInput = {
    AND?: em_topic_selesaiWhereInput | em_topic_selesaiWhereInput[]
    OR?: em_topic_selesaiWhereInput[]
    NOT?: em_topic_selesaiWhereInput | em_topic_selesaiWhereInput[]
    id?: IntFilter<"em_topic_selesai"> | number
    session_exams_id?: StringFilter<"em_topic_selesai"> | string
    apc_id?: IntFilter<"em_topic_selesai"> | number
    topic_id?: IntFilter<"em_topic_selesai"> | number
    selesai_at?: DateTimeNullableFilter<"em_topic_selesai"> | Date | string | null
    em_session_exams_apc?: XOR<Em_session_exams_apcScalarRelationFilter, em_session_exams_apcWhereInput>
  }

  export type em_topic_selesaiOrderByWithRelationInput = {
    id?: SortOrder
    session_exams_id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
    selesai_at?: SortOrderInput | SortOrder
    em_session_exams_apc?: em_session_exams_apcOrderByWithRelationInput
  }

  export type em_topic_selesaiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_topic_selesaiWhereInput | em_topic_selesaiWhereInput[]
    OR?: em_topic_selesaiWhereInput[]
    NOT?: em_topic_selesaiWhereInput | em_topic_selesaiWhereInput[]
    session_exams_id?: StringFilter<"em_topic_selesai"> | string
    apc_id?: IntFilter<"em_topic_selesai"> | number
    topic_id?: IntFilter<"em_topic_selesai"> | number
    selesai_at?: DateTimeNullableFilter<"em_topic_selesai"> | Date | string | null
    em_session_exams_apc?: XOR<Em_session_exams_apcScalarRelationFilter, em_session_exams_apcWhereInput>
  }, "id">

  export type em_topic_selesaiOrderByWithAggregationInput = {
    id?: SortOrder
    session_exams_id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
    selesai_at?: SortOrderInput | SortOrder
    _count?: em_topic_selesaiCountOrderByAggregateInput
    _avg?: em_topic_selesaiAvgOrderByAggregateInput
    _max?: em_topic_selesaiMaxOrderByAggregateInput
    _min?: em_topic_selesaiMinOrderByAggregateInput
    _sum?: em_topic_selesaiSumOrderByAggregateInput
  }

  export type em_topic_selesaiScalarWhereWithAggregatesInput = {
    AND?: em_topic_selesaiScalarWhereWithAggregatesInput | em_topic_selesaiScalarWhereWithAggregatesInput[]
    OR?: em_topic_selesaiScalarWhereWithAggregatesInput[]
    NOT?: em_topic_selesaiScalarWhereWithAggregatesInput | em_topic_selesaiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_topic_selesai"> | number
    session_exams_id?: StringWithAggregatesFilter<"em_topic_selesai"> | string
    apc_id?: IntWithAggregatesFilter<"em_topic_selesai"> | number
    topic_id?: IntWithAggregatesFilter<"em_topic_selesai"> | number
    selesai_at?: DateTimeNullableWithAggregatesFilter<"em_topic_selesai"> | Date | string | null
  }

  export type em_user_answers1WhereInput = {
    AND?: em_user_answers1WhereInput | em_user_answers1WhereInput[]
    OR?: em_user_answers1WhereInput[]
    NOT?: em_user_answers1WhereInput | em_user_answers1WhereInput[]
    Id?: IntFilter<"em_user_answers1"> | number
    apcid?: IntFilter<"em_user_answers1"> | number
    topic_id?: IntFilter<"em_user_answers1"> | number
    status?: StringNullableFilter<"em_user_answers1"> | string | null
    startdate?: DateTimeNullableFilter<"em_user_answers1"> | Date | string | null
  }

  export type em_user_answers1OrderByWithRelationInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
    status?: SortOrderInput | SortOrder
    startdate?: SortOrderInput | SortOrder
  }

  export type em_user_answers1WhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: em_user_answers1WhereInput | em_user_answers1WhereInput[]
    OR?: em_user_answers1WhereInput[]
    NOT?: em_user_answers1WhereInput | em_user_answers1WhereInput[]
    apcid?: IntFilter<"em_user_answers1"> | number
    topic_id?: IntFilter<"em_user_answers1"> | number
    status?: StringNullableFilter<"em_user_answers1"> | string | null
    startdate?: DateTimeNullableFilter<"em_user_answers1"> | Date | string | null
  }, "Id">

  export type em_user_answers1OrderByWithAggregationInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
    status?: SortOrderInput | SortOrder
    startdate?: SortOrderInput | SortOrder
    _count?: em_user_answers1CountOrderByAggregateInput
    _avg?: em_user_answers1AvgOrderByAggregateInput
    _max?: em_user_answers1MaxOrderByAggregateInput
    _min?: em_user_answers1MinOrderByAggregateInput
    _sum?: em_user_answers1SumOrderByAggregateInput
  }

  export type em_user_answers1ScalarWhereWithAggregatesInput = {
    AND?: em_user_answers1ScalarWhereWithAggregatesInput | em_user_answers1ScalarWhereWithAggregatesInput[]
    OR?: em_user_answers1ScalarWhereWithAggregatesInput[]
    NOT?: em_user_answers1ScalarWhereWithAggregatesInput | em_user_answers1ScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_user_answers1"> | number
    apcid?: IntWithAggregatesFilter<"em_user_answers1"> | number
    topic_id?: IntWithAggregatesFilter<"em_user_answers1"> | number
    status?: StringNullableWithAggregatesFilter<"em_user_answers1"> | string | null
    startdate?: DateTimeNullableWithAggregatesFilter<"em_user_answers1"> | Date | string | null
  }

  export type em_user_dashboardWhereInput = {
    AND?: em_user_dashboardWhereInput | em_user_dashboardWhereInput[]
    OR?: em_user_dashboardWhereInput[]
    NOT?: em_user_dashboardWhereInput | em_user_dashboardWhereInput[]
    UserId?: IntFilter<"em_user_dashboard"> | number
    Username?: StringFilter<"em_user_dashboard"> | string
    Password?: StringFilter<"em_user_dashboard"> | string
    FullName?: StringNullableFilter<"em_user_dashboard"> | string | null
    RoleId?: IntNullableFilter<"em_user_dashboard"> | number | null
    Status?: StringNullableFilter<"em_user_dashboard"> | string | null
    CreateDate?: DateTimeNullableFilter<"em_user_dashboard"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_user_dashboard"> | Date | string | null
    GroupId?: IntNullableFilter<"em_user_dashboard"> | number | null
  }

  export type em_user_dashboardOrderByWithRelationInput = {
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    FullName?: SortOrderInput | SortOrder
    RoleId?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreateDate?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    GroupId?: SortOrderInput | SortOrder
  }

  export type em_user_dashboardWhereUniqueInput = Prisma.AtLeast<{
    UserId?: number
    AND?: em_user_dashboardWhereInput | em_user_dashboardWhereInput[]
    OR?: em_user_dashboardWhereInput[]
    NOT?: em_user_dashboardWhereInput | em_user_dashboardWhereInput[]
    Username?: StringFilter<"em_user_dashboard"> | string
    Password?: StringFilter<"em_user_dashboard"> | string
    FullName?: StringNullableFilter<"em_user_dashboard"> | string | null
    RoleId?: IntNullableFilter<"em_user_dashboard"> | number | null
    Status?: StringNullableFilter<"em_user_dashboard"> | string | null
    CreateDate?: DateTimeNullableFilter<"em_user_dashboard"> | Date | string | null
    LastUpdate?: DateTimeNullableFilter<"em_user_dashboard"> | Date | string | null
    GroupId?: IntNullableFilter<"em_user_dashboard"> | number | null
  }, "UserId">

  export type em_user_dashboardOrderByWithAggregationInput = {
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    FullName?: SortOrderInput | SortOrder
    RoleId?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    CreateDate?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    GroupId?: SortOrderInput | SortOrder
    _count?: em_user_dashboardCountOrderByAggregateInput
    _avg?: em_user_dashboardAvgOrderByAggregateInput
    _max?: em_user_dashboardMaxOrderByAggregateInput
    _min?: em_user_dashboardMinOrderByAggregateInput
    _sum?: em_user_dashboardSumOrderByAggregateInput
  }

  export type em_user_dashboardScalarWhereWithAggregatesInput = {
    AND?: em_user_dashboardScalarWhereWithAggregatesInput | em_user_dashboardScalarWhereWithAggregatesInput[]
    OR?: em_user_dashboardScalarWhereWithAggregatesInput[]
    NOT?: em_user_dashboardScalarWhereWithAggregatesInput | em_user_dashboardScalarWhereWithAggregatesInput[]
    UserId?: IntWithAggregatesFilter<"em_user_dashboard"> | number
    Username?: StringWithAggregatesFilter<"em_user_dashboard"> | string
    Password?: StringWithAggregatesFilter<"em_user_dashboard"> | string
    FullName?: StringNullableWithAggregatesFilter<"em_user_dashboard"> | string | null
    RoleId?: IntNullableWithAggregatesFilter<"em_user_dashboard"> | number | null
    Status?: StringNullableWithAggregatesFilter<"em_user_dashboard"> | string | null
    CreateDate?: DateTimeNullableWithAggregatesFilter<"em_user_dashboard"> | Date | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_user_dashboard"> | Date | string | null
    GroupId?: IntNullableWithAggregatesFilter<"em_user_dashboard"> | number | null
  }

  export type em_user_listWhereInput = {
    AND?: em_user_listWhereInput | em_user_listWhereInput[]
    OR?: em_user_listWhereInput[]
    NOT?: em_user_listWhereInput | em_user_listWhereInput[]
    id?: IntFilter<"em_user_list"> | number
    userid?: StringFilter<"em_user_list"> | string
    menuid?: IntNullableFilter<"em_user_list"> | number | null
    visible?: BoolFilter<"em_user_list"> | boolean
    lastupdate?: DateTimeNullableFilter<"em_user_list"> | Date | string | null
  }

  export type em_user_listOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    menuid?: SortOrderInput | SortOrder
    visible?: SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type em_user_listWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_user_listWhereInput | em_user_listWhereInput[]
    OR?: em_user_listWhereInput[]
    NOT?: em_user_listWhereInput | em_user_listWhereInput[]
    userid?: StringFilter<"em_user_list"> | string
    menuid?: IntNullableFilter<"em_user_list"> | number | null
    visible?: BoolFilter<"em_user_list"> | boolean
    lastupdate?: DateTimeNullableFilter<"em_user_list"> | Date | string | null
  }, "id">

  export type em_user_listOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    menuid?: SortOrderInput | SortOrder
    visible?: SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_user_listCountOrderByAggregateInput
    _avg?: em_user_listAvgOrderByAggregateInput
    _max?: em_user_listMaxOrderByAggregateInput
    _min?: em_user_listMinOrderByAggregateInput
    _sum?: em_user_listSumOrderByAggregateInput
  }

  export type em_user_listScalarWhereWithAggregatesInput = {
    AND?: em_user_listScalarWhereWithAggregatesInput | em_user_listScalarWhereWithAggregatesInput[]
    OR?: em_user_listScalarWhereWithAggregatesInput[]
    NOT?: em_user_listScalarWhereWithAggregatesInput | em_user_listScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_user_list"> | number
    userid?: StringWithAggregatesFilter<"em_user_list"> | string
    menuid?: IntNullableWithAggregatesFilter<"em_user_list"> | number | null
    visible?: BoolWithAggregatesFilter<"em_user_list"> | boolean
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_user_list"> | Date | string | null
  }

  export type em_usersWhereInput = {
    AND?: em_usersWhereInput | em_usersWhereInput[]
    OR?: em_usersWhereInput[]
    NOT?: em_usersWhereInput | em_usersWhereInput[]
    Id?: IntFilter<"em_users"> | number
    UserId?: StringFilter<"em_users"> | string
    Username?: StringFilter<"em_users"> | string
    Password?: StringFilter<"em_users"> | string
    LastUpdate?: DateTimeNullableFilter<"em_users"> | Date | string | null
    LevelId?: IntNullableFilter<"em_users"> | number | null
    Name?: StringFilter<"em_users"> | string
    Status?: StringNullableFilter<"em_users"> | string | null
    imagename?: StringNullableFilter<"em_users"> | string | null
    Pass_Access_Menu?: StringNullableFilter<"em_users"> | string | null
  }

  export type em_usersOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    LevelId?: SortOrderInput | SortOrder
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
    imagename?: SortOrderInput | SortOrder
    Pass_Access_Menu?: SortOrderInput | SortOrder
  }

  export type em_usersWhereUniqueInput = Prisma.AtLeast<{
    Id_UserId?: em_usersIdUserIdCompoundUniqueInput
    AND?: em_usersWhereInput | em_usersWhereInput[]
    OR?: em_usersWhereInput[]
    NOT?: em_usersWhereInput | em_usersWhereInput[]
    Id?: IntFilter<"em_users"> | number
    UserId?: StringFilter<"em_users"> | string
    Username?: StringFilter<"em_users"> | string
    Password?: StringFilter<"em_users"> | string
    LastUpdate?: DateTimeNullableFilter<"em_users"> | Date | string | null
    LevelId?: IntNullableFilter<"em_users"> | number | null
    Name?: StringFilter<"em_users"> | string
    Status?: StringNullableFilter<"em_users"> | string | null
    imagename?: StringNullableFilter<"em_users"> | string | null
    Pass_Access_Menu?: StringNullableFilter<"em_users"> | string | null
  }, "Id_UserId">

  export type em_usersOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    LevelId?: SortOrderInput | SortOrder
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
    imagename?: SortOrderInput | SortOrder
    Pass_Access_Menu?: SortOrderInput | SortOrder
    _count?: em_usersCountOrderByAggregateInput
    _avg?: em_usersAvgOrderByAggregateInput
    _max?: em_usersMaxOrderByAggregateInput
    _min?: em_usersMinOrderByAggregateInput
    _sum?: em_usersSumOrderByAggregateInput
  }

  export type em_usersScalarWhereWithAggregatesInput = {
    AND?: em_usersScalarWhereWithAggregatesInput | em_usersScalarWhereWithAggregatesInput[]
    OR?: em_usersScalarWhereWithAggregatesInput[]
    NOT?: em_usersScalarWhereWithAggregatesInput | em_usersScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"em_users"> | number
    UserId?: StringWithAggregatesFilter<"em_users"> | string
    Username?: StringWithAggregatesFilter<"em_users"> | string
    Password?: StringWithAggregatesFilter<"em_users"> | string
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"em_users"> | Date | string | null
    LevelId?: IntNullableWithAggregatesFilter<"em_users"> | number | null
    Name?: StringWithAggregatesFilter<"em_users"> | string
    Status?: StringNullableWithAggregatesFilter<"em_users"> | string | null
    imagename?: StringNullableWithAggregatesFilter<"em_users"> | string | null
    Pass_Access_Menu?: StringNullableWithAggregatesFilter<"em_users"> | string | null
  }

  export type em_verify_linksWhereInput = {
    AND?: em_verify_linksWhereInput | em_verify_linksWhereInput[]
    OR?: em_verify_linksWhereInput[]
    NOT?: em_verify_linksWhereInput | em_verify_linksWhereInput[]
    id?: IntFilter<"em_verify_links"> | number
    applicant_id?: IntFilter<"em_verify_links"> | number
    token?: StringNullableFilter<"em_verify_links"> | string | null
    expires_at?: DateTimeFilter<"em_verify_links"> | Date | string
    created_at?: DateTimeNullableFilter<"em_verify_links"> | Date | string | null
    status?: StringNullableFilter<"em_verify_links"> | string | null
    useragent?: StringNullableFilter<"em_verify_links"> | string | null
    ipaddress?: StringNullableFilter<"em_verify_links"> | string | null
    browser?: StringNullableFilter<"em_verify_links"> | string | null
    platform?: StringNullableFilter<"em_verify_links"> | string | null
    device?: StringNullableFilter<"em_verify_links"> | string | null
  }

  export type em_verify_linksOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    token?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    created_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    useragent?: SortOrderInput | SortOrder
    ipaddress?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
  }

  export type em_verify_linksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_verify_linksWhereInput | em_verify_linksWhereInput[]
    OR?: em_verify_linksWhereInput[]
    NOT?: em_verify_linksWhereInput | em_verify_linksWhereInput[]
    applicant_id?: IntFilter<"em_verify_links"> | number
    token?: StringNullableFilter<"em_verify_links"> | string | null
    expires_at?: DateTimeFilter<"em_verify_links"> | Date | string
    created_at?: DateTimeNullableFilter<"em_verify_links"> | Date | string | null
    status?: StringNullableFilter<"em_verify_links"> | string | null
    useragent?: StringNullableFilter<"em_verify_links"> | string | null
    ipaddress?: StringNullableFilter<"em_verify_links"> | string | null
    browser?: StringNullableFilter<"em_verify_links"> | string | null
    platform?: StringNullableFilter<"em_verify_links"> | string | null
    device?: StringNullableFilter<"em_verify_links"> | string | null
  }, "id">

  export type em_verify_linksOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    token?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    created_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    useragent?: SortOrderInput | SortOrder
    ipaddress?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    _count?: em_verify_linksCountOrderByAggregateInput
    _avg?: em_verify_linksAvgOrderByAggregateInput
    _max?: em_verify_linksMaxOrderByAggregateInput
    _min?: em_verify_linksMinOrderByAggregateInput
    _sum?: em_verify_linksSumOrderByAggregateInput
  }

  export type em_verify_linksScalarWhereWithAggregatesInput = {
    AND?: em_verify_linksScalarWhereWithAggregatesInput | em_verify_linksScalarWhereWithAggregatesInput[]
    OR?: em_verify_linksScalarWhereWithAggregatesInput[]
    NOT?: em_verify_linksScalarWhereWithAggregatesInput | em_verify_linksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_verify_links"> | number
    applicant_id?: IntWithAggregatesFilter<"em_verify_links"> | number
    token?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
    expires_at?: DateTimeWithAggregatesFilter<"em_verify_links"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"em_verify_links"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
    useragent?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
    ipaddress?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
    browser?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
    platform?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
    device?: StringNullableWithAggregatesFilter<"em_verify_links"> | string | null
  }

  export type em_wa_templatesWhereInput = {
    AND?: em_wa_templatesWhereInput | em_wa_templatesWhereInput[]
    OR?: em_wa_templatesWhereInput[]
    NOT?: em_wa_templatesWhereInput | em_wa_templatesWhereInput[]
    id?: IntFilter<"em_wa_templates"> | number
    template_name?: StringFilter<"em_wa_templates"> | string
    template_text?: StringFilter<"em_wa_templates"> | string
    add_by?: StringNullableFilter<"em_wa_templates"> | string | null
    created_at?: DateTimeNullableFilter<"em_wa_templates"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_wa_templates"> | Date | string | null
    status?: StringNullableFilter<"em_wa_templates"> | string | null
    tpfor?: IntNullableFilter<"em_wa_templates"> | number | null
  }

  export type em_wa_templatesOrderByWithRelationInput = {
    id?: SortOrder
    template_name?: SortOrder
    template_text?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    tpfor?: SortOrderInput | SortOrder
  }

  export type em_wa_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_wa_templatesWhereInput | em_wa_templatesWhereInput[]
    OR?: em_wa_templatesWhereInput[]
    NOT?: em_wa_templatesWhereInput | em_wa_templatesWhereInput[]
    template_name?: StringFilter<"em_wa_templates"> | string
    template_text?: StringFilter<"em_wa_templates"> | string
    add_by?: StringNullableFilter<"em_wa_templates"> | string | null
    created_at?: DateTimeNullableFilter<"em_wa_templates"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_wa_templates"> | Date | string | null
    status?: StringNullableFilter<"em_wa_templates"> | string | null
    tpfor?: IntNullableFilter<"em_wa_templates"> | number | null
  }, "id">

  export type em_wa_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    template_name?: SortOrder
    template_text?: SortOrder
    add_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    tpfor?: SortOrderInput | SortOrder
    _count?: em_wa_templatesCountOrderByAggregateInput
    _avg?: em_wa_templatesAvgOrderByAggregateInput
    _max?: em_wa_templatesMaxOrderByAggregateInput
    _min?: em_wa_templatesMinOrderByAggregateInput
    _sum?: em_wa_templatesSumOrderByAggregateInput
  }

  export type em_wa_templatesScalarWhereWithAggregatesInput = {
    AND?: em_wa_templatesScalarWhereWithAggregatesInput | em_wa_templatesScalarWhereWithAggregatesInput[]
    OR?: em_wa_templatesScalarWhereWithAggregatesInput[]
    NOT?: em_wa_templatesScalarWhereWithAggregatesInput | em_wa_templatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_wa_templates"> | number
    template_name?: StringWithAggregatesFilter<"em_wa_templates"> | string
    template_text?: StringWithAggregatesFilter<"em_wa_templates"> | string
    add_by?: StringNullableWithAggregatesFilter<"em_wa_templates"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"em_wa_templates"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_wa_templates"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"em_wa_templates"> | string | null
    tpfor?: IntNullableWithAggregatesFilter<"em_wa_templates"> | number | null
  }

  export type em_worktypeWhereInput = {
    AND?: em_worktypeWhereInput | em_worktypeWhereInput[]
    OR?: em_worktypeWhereInput[]
    NOT?: em_worktypeWhereInput | em_worktypeWhereInput[]
    id?: IntFilter<"em_worktype"> | number
    worktype_text?: StringFilter<"em_worktype"> | string
    status?: StringNullableFilter<"em_worktype"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_worktype"> | Date | string | null
  }

  export type em_worktypeOrderByWithRelationInput = {
    id?: SortOrder
    worktype_text?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type em_worktypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: em_worktypeWhereInput | em_worktypeWhereInput[]
    OR?: em_worktypeWhereInput[]
    NOT?: em_worktypeWhereInput | em_worktypeWhereInput[]
    worktype_text?: StringFilter<"em_worktype"> | string
    status?: StringNullableFilter<"em_worktype"> | string | null
    lastupdate?: DateTimeNullableFilter<"em_worktype"> | Date | string | null
  }, "id">

  export type em_worktypeOrderByWithAggregationInput = {
    id?: SortOrder
    worktype_text?: SortOrder
    status?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: em_worktypeCountOrderByAggregateInput
    _avg?: em_worktypeAvgOrderByAggregateInput
    _max?: em_worktypeMaxOrderByAggregateInput
    _min?: em_worktypeMinOrderByAggregateInput
    _sum?: em_worktypeSumOrderByAggregateInput
  }

  export type em_worktypeScalarWhereWithAggregatesInput = {
    AND?: em_worktypeScalarWhereWithAggregatesInput | em_worktypeScalarWhereWithAggregatesInput[]
    OR?: em_worktypeScalarWhereWithAggregatesInput[]
    NOT?: em_worktypeScalarWhereWithAggregatesInput | em_worktypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"em_worktype"> | number
    worktype_text?: StringWithAggregatesFilter<"em_worktype"> | string
    status?: StringNullableWithAggregatesFilter<"em_worktype"> | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"em_worktype"> | Date | string | null
  }

  export type em_xquetestWhereInput = {
    AND?: em_xquetestWhereInput | em_xquetestWhereInput[]
    OR?: em_xquetestWhereInput[]
    NOT?: em_xquetestWhereInput | em_xquetestWhereInput[]
    ID?: IntFilter<"em_xquetest"> | number
    q_id?: IntFilter<"em_xquetest"> | number
    question_text?: StringFilter<"em_xquetest"> | string
  }

  export type em_xquetestOrderByWithRelationInput = {
    ID?: SortOrder
    q_id?: SortOrder
    question_text?: SortOrder
  }

  export type em_xquetestWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: em_xquetestWhereInput | em_xquetestWhereInput[]
    OR?: em_xquetestWhereInput[]
    NOT?: em_xquetestWhereInput | em_xquetestWhereInput[]
    q_id?: IntFilter<"em_xquetest"> | number
    question_text?: StringFilter<"em_xquetest"> | string
  }, "ID">

  export type em_xquetestOrderByWithAggregationInput = {
    ID?: SortOrder
    q_id?: SortOrder
    question_text?: SortOrder
    _count?: em_xquetestCountOrderByAggregateInput
    _avg?: em_xquetestAvgOrderByAggregateInput
    _max?: em_xquetestMaxOrderByAggregateInput
    _min?: em_xquetestMinOrderByAggregateInput
    _sum?: em_xquetestSumOrderByAggregateInput
  }

  export type em_xquetestScalarWhereWithAggregatesInput = {
    AND?: em_xquetestScalarWhereWithAggregatesInput | em_xquetestScalarWhereWithAggregatesInput[]
    OR?: em_xquetestScalarWhereWithAggregatesInput[]
    NOT?: em_xquetestScalarWhereWithAggregatesInput | em_xquetestScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"em_xquetest"> | number
    q_id?: IntWithAggregatesFilter<"em_xquetest"> | number
    question_text?: StringWithAggregatesFilter<"em_xquetest"> | string
  }

  export type emappWhereInput = {
    AND?: emappWhereInput | emappWhereInput[]
    OR?: emappWhereInput[]
    NOT?: emappWhereInput | emappWhereInput[]
    AppId?: IntFilter<"emapp"> | number
    AppName?: StringNullableFilter<"emapp"> | string | null
    AppPoss?: IntNullableFilter<"emapp"> | number | null
    AppWa?: StringNullableFilter<"emapp"> | string | null
    AppMail?: StringNullableFilter<"emapp"> | string | null
    AppAge?: IntNullableFilter<"emapp"> | number | null
    AppJk?: IntNullableFilter<"emapp"> | number | null
    AppAddres?: StringNullableFilter<"emapp"> | string | null
    AppFakt?: StringNullableFilter<"emapp"> | string | null
    AppFileName?: StringNullableFilter<"emapp"> | string | null
    AppLastUpdate?: DateTimeNullableFilter<"emapp"> | Date | string | null
    AppDate?: DateTimeNullableFilter<"emapp"> | Date | string | null
    AppStatus?: StringNullableFilter<"emapp"> | string | null
    IsCall?: IntNullableFilter<"emapp"> | number | null
    DateCall?: DateTimeNullableFilter<"emapp"> | Date | string | null
    JobsIs?: StringNullableFilter<"emapp"> | string | null
    JFStats?: StringNullableFilter<"emapp"> | string | null
    LokasiId?: IntNullableFilter<"emapp"> | number | null
    scores?: ScoresListRelationFilter
  }

  export type emappOrderByWithRelationInput = {
    AppId?: SortOrder
    AppName?: SortOrderInput | SortOrder
    AppPoss?: SortOrderInput | SortOrder
    AppWa?: SortOrderInput | SortOrder
    AppMail?: SortOrderInput | SortOrder
    AppAge?: SortOrderInput | SortOrder
    AppJk?: SortOrderInput | SortOrder
    AppAddres?: SortOrderInput | SortOrder
    AppFakt?: SortOrderInput | SortOrder
    AppFileName?: SortOrderInput | SortOrder
    AppLastUpdate?: SortOrderInput | SortOrder
    AppDate?: SortOrderInput | SortOrder
    AppStatus?: SortOrderInput | SortOrder
    IsCall?: SortOrderInput | SortOrder
    DateCall?: SortOrderInput | SortOrder
    JobsIs?: SortOrderInput | SortOrder
    JFStats?: SortOrderInput | SortOrder
    LokasiId?: SortOrderInput | SortOrder
    scores?: scoresOrderByRelationAggregateInput
  }

  export type emappWhereUniqueInput = Prisma.AtLeast<{
    AppId?: number
    AND?: emappWhereInput | emappWhereInput[]
    OR?: emappWhereInput[]
    NOT?: emappWhereInput | emappWhereInput[]
    AppName?: StringNullableFilter<"emapp"> | string | null
    AppPoss?: IntNullableFilter<"emapp"> | number | null
    AppWa?: StringNullableFilter<"emapp"> | string | null
    AppMail?: StringNullableFilter<"emapp"> | string | null
    AppAge?: IntNullableFilter<"emapp"> | number | null
    AppJk?: IntNullableFilter<"emapp"> | number | null
    AppAddres?: StringNullableFilter<"emapp"> | string | null
    AppFakt?: StringNullableFilter<"emapp"> | string | null
    AppFileName?: StringNullableFilter<"emapp"> | string | null
    AppLastUpdate?: DateTimeNullableFilter<"emapp"> | Date | string | null
    AppDate?: DateTimeNullableFilter<"emapp"> | Date | string | null
    AppStatus?: StringNullableFilter<"emapp"> | string | null
    IsCall?: IntNullableFilter<"emapp"> | number | null
    DateCall?: DateTimeNullableFilter<"emapp"> | Date | string | null
    JobsIs?: StringNullableFilter<"emapp"> | string | null
    JFStats?: StringNullableFilter<"emapp"> | string | null
    LokasiId?: IntNullableFilter<"emapp"> | number | null
    scores?: ScoresListRelationFilter
  }, "AppId">

  export type emappOrderByWithAggregationInput = {
    AppId?: SortOrder
    AppName?: SortOrderInput | SortOrder
    AppPoss?: SortOrderInput | SortOrder
    AppWa?: SortOrderInput | SortOrder
    AppMail?: SortOrderInput | SortOrder
    AppAge?: SortOrderInput | SortOrder
    AppJk?: SortOrderInput | SortOrder
    AppAddres?: SortOrderInput | SortOrder
    AppFakt?: SortOrderInput | SortOrder
    AppFileName?: SortOrderInput | SortOrder
    AppLastUpdate?: SortOrderInput | SortOrder
    AppDate?: SortOrderInput | SortOrder
    AppStatus?: SortOrderInput | SortOrder
    IsCall?: SortOrderInput | SortOrder
    DateCall?: SortOrderInput | SortOrder
    JobsIs?: SortOrderInput | SortOrder
    JFStats?: SortOrderInput | SortOrder
    LokasiId?: SortOrderInput | SortOrder
    _count?: emappCountOrderByAggregateInput
    _avg?: emappAvgOrderByAggregateInput
    _max?: emappMaxOrderByAggregateInput
    _min?: emappMinOrderByAggregateInput
    _sum?: emappSumOrderByAggregateInput
  }

  export type emappScalarWhereWithAggregatesInput = {
    AND?: emappScalarWhereWithAggregatesInput | emappScalarWhereWithAggregatesInput[]
    OR?: emappScalarWhereWithAggregatesInput[]
    NOT?: emappScalarWhereWithAggregatesInput | emappScalarWhereWithAggregatesInput[]
    AppId?: IntWithAggregatesFilter<"emapp"> | number
    AppName?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    AppPoss?: IntNullableWithAggregatesFilter<"emapp"> | number | null
    AppWa?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    AppMail?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    AppAge?: IntNullableWithAggregatesFilter<"emapp"> | number | null
    AppJk?: IntNullableWithAggregatesFilter<"emapp"> | number | null
    AppAddres?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    AppFakt?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    AppFileName?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    AppLastUpdate?: DateTimeNullableWithAggregatesFilter<"emapp"> | Date | string | null
    AppDate?: DateTimeNullableWithAggregatesFilter<"emapp"> | Date | string | null
    AppStatus?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    IsCall?: IntNullableWithAggregatesFilter<"emapp"> | number | null
    DateCall?: DateTimeNullableWithAggregatesFilter<"emapp"> | Date | string | null
    JobsIs?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    JFStats?: StringNullableWithAggregatesFilter<"emapp"> | string | null
    LokasiId?: IntNullableWithAggregatesFilter<"emapp"> | number | null
  }

  export type empasswWhereInput = {
    AND?: empasswWhereInput | empasswWhereInput[]
    OR?: empasswWhereInput[]
    NOT?: empasswWhereInput | empasswWhereInput[]
    Id?: IntFilter<"empassw"> | number
    Name?: StringNullableFilter<"empassw"> | string | null
    Pass?: StringNullableFilter<"empassw"> | string | null
    Level?: IntNullableFilter<"empassw"> | number | null
  }

  export type empasswOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    Pass?: SortOrderInput | SortOrder
    Level?: SortOrderInput | SortOrder
  }

  export type empasswWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: empasswWhereInput | empasswWhereInput[]
    OR?: empasswWhereInput[]
    NOT?: empasswWhereInput | empasswWhereInput[]
    Name?: StringNullableFilter<"empassw"> | string | null
    Pass?: StringNullableFilter<"empassw"> | string | null
    Level?: IntNullableFilter<"empassw"> | number | null
  }, "Id">

  export type empasswOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    Pass?: SortOrderInput | SortOrder
    Level?: SortOrderInput | SortOrder
    _count?: empasswCountOrderByAggregateInput
    _avg?: empasswAvgOrderByAggregateInput
    _max?: empasswMaxOrderByAggregateInput
    _min?: empasswMinOrderByAggregateInput
    _sum?: empasswSumOrderByAggregateInput
  }

  export type empasswScalarWhereWithAggregatesInput = {
    AND?: empasswScalarWhereWithAggregatesInput | empasswScalarWhereWithAggregatesInput[]
    OR?: empasswScalarWhereWithAggregatesInput[]
    NOT?: empasswScalarWhereWithAggregatesInput | empasswScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"empassw"> | number
    Name?: StringNullableWithAggregatesFilter<"empassw"> | string | null
    Pass?: StringNullableWithAggregatesFilter<"empassw"> | string | null
    Level?: IntNullableWithAggregatesFilter<"empassw"> | number | null
  }

  export type empossWhereInput = {
    AND?: empossWhereInput | empossWhereInput[]
    OR?: empossWhereInput[]
    NOT?: empossWhereInput | empossWhereInput[]
    Id?: IntFilter<"emposs"> | number
    PossName?: StringNullableFilter<"emposs"> | string | null
    Status?: StringNullableFilter<"emposs"> | string | null
    UserId?: StringNullableFilter<"emposs"> | string | null
    LastUpdate?: DateTimeNullableFilter<"emposs"> | Date | string | null
    em_applicant_criteria?: Em_applicant_criteriaListRelationFilter
    em_applicant_match?: Em_applicant_matchListRelationFilter
  }

  export type empossOrderByWithRelationInput = {
    Id?: SortOrder
    PossName?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    em_applicant_criteria?: em_applicant_criteriaOrderByRelationAggregateInput
    em_applicant_match?: em_applicant_matchOrderByRelationAggregateInput
  }

  export type empossWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: empossWhereInput | empossWhereInput[]
    OR?: empossWhereInput[]
    NOT?: empossWhereInput | empossWhereInput[]
    PossName?: StringNullableFilter<"emposs"> | string | null
    Status?: StringNullableFilter<"emposs"> | string | null
    UserId?: StringNullableFilter<"emposs"> | string | null
    LastUpdate?: DateTimeNullableFilter<"emposs"> | Date | string | null
    em_applicant_criteria?: Em_applicant_criteriaListRelationFilter
    em_applicant_match?: Em_applicant_matchListRelationFilter
  }, "Id">

  export type empossOrderByWithAggregationInput = {
    Id?: SortOrder
    PossName?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    LastUpdate?: SortOrderInput | SortOrder
    _count?: empossCountOrderByAggregateInput
    _avg?: empossAvgOrderByAggregateInput
    _max?: empossMaxOrderByAggregateInput
    _min?: empossMinOrderByAggregateInput
    _sum?: empossSumOrderByAggregateInput
  }

  export type empossScalarWhereWithAggregatesInput = {
    AND?: empossScalarWhereWithAggregatesInput | empossScalarWhereWithAggregatesInput[]
    OR?: empossScalarWhereWithAggregatesInput[]
    NOT?: empossScalarWhereWithAggregatesInput | empossScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"emposs"> | number
    PossName?: StringNullableWithAggregatesFilter<"emposs"> | string | null
    Status?: StringNullableWithAggregatesFilter<"emposs"> | string | null
    UserId?: StringNullableWithAggregatesFilter<"emposs"> | string | null
    LastUpdate?: DateTimeNullableWithAggregatesFilter<"emposs"> | Date | string | null
  }

  export type faceusersWhereInput = {
    AND?: faceusersWhereInput | faceusersWhereInput[]
    OR?: faceusersWhereInput[]
    NOT?: faceusersWhereInput | faceusersWhereInput[]
    Id?: IntFilter<"faceusers"> | number
    name?: StringNullableFilter<"faceusers"> | string | null
    fileimage?: StringNullableFilter<"faceusers"> | string | null
    descriptor?: StringNullableFilter<"faceusers"> | string | null
    pose?: StringNullableFilter<"faceusers"> | string | null
    created_at?: DateTimeNullableFilter<"faceusers"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"faceusers"> | Date | string | null
  }

  export type faceusersOrderByWithRelationInput = {
    Id?: SortOrder
    name?: SortOrderInput | SortOrder
    fileimage?: SortOrderInput | SortOrder
    descriptor?: SortOrderInput | SortOrder
    pose?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
  }

  export type faceusersWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: faceusersWhereInput | faceusersWhereInput[]
    OR?: faceusersWhereInput[]
    NOT?: faceusersWhereInput | faceusersWhereInput[]
    name?: StringNullableFilter<"faceusers"> | string | null
    fileimage?: StringNullableFilter<"faceusers"> | string | null
    descriptor?: StringNullableFilter<"faceusers"> | string | null
    pose?: StringNullableFilter<"faceusers"> | string | null
    created_at?: DateTimeNullableFilter<"faceusers"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"faceusers"> | Date | string | null
  }, "Id">

  export type faceusersOrderByWithAggregationInput = {
    Id?: SortOrder
    name?: SortOrderInput | SortOrder
    fileimage?: SortOrderInput | SortOrder
    descriptor?: SortOrderInput | SortOrder
    pose?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lastupdate?: SortOrderInput | SortOrder
    _count?: faceusersCountOrderByAggregateInput
    _avg?: faceusersAvgOrderByAggregateInput
    _max?: faceusersMaxOrderByAggregateInput
    _min?: faceusersMinOrderByAggregateInput
    _sum?: faceusersSumOrderByAggregateInput
  }

  export type faceusersScalarWhereWithAggregatesInput = {
    AND?: faceusersScalarWhereWithAggregatesInput | faceusersScalarWhereWithAggregatesInput[]
    OR?: faceusersScalarWhereWithAggregatesInput[]
    NOT?: faceusersScalarWhereWithAggregatesInput | faceusersScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"faceusers"> | number
    name?: StringNullableWithAggregatesFilter<"faceusers"> | string | null
    fileimage?: StringNullableWithAggregatesFilter<"faceusers"> | string | null
    descriptor?: StringNullableWithAggregatesFilter<"faceusers"> | string | null
    pose?: StringNullableWithAggregatesFilter<"faceusers"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"faceusers"> | Date | string | null
    lastupdate?: DateTimeNullableWithAggregatesFilter<"faceusers"> | Date | string | null
  }

  export type menuWhereInput = {
    AND?: menuWhereInput | menuWhereInput[]
    OR?: menuWhereInput[]
    NOT?: menuWhereInput | menuWhereInput[]
    id?: IntFilter<"menu"> | number
    name?: StringFilter<"menu"> | string
    parent_id?: IntNullableFilter<"menu"> | number | null
    link?: StringNullableFilter<"menu"> | string | null
    visible?: BoolFilter<"menu"> | boolean
    role?: StringNullableFilter<"menu"> | string | null
  }

  export type menuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    visible?: SortOrder
    role?: SortOrderInput | SortOrder
  }

  export type menuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: menuWhereInput | menuWhereInput[]
    OR?: menuWhereInput[]
    NOT?: menuWhereInput | menuWhereInput[]
    name?: StringFilter<"menu"> | string
    parent_id?: IntNullableFilter<"menu"> | number | null
    link?: StringNullableFilter<"menu"> | string | null
    visible?: BoolFilter<"menu"> | boolean
    role?: StringNullableFilter<"menu"> | string | null
  }, "id">

  export type menuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    visible?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: menuCountOrderByAggregateInput
    _avg?: menuAvgOrderByAggregateInput
    _max?: menuMaxOrderByAggregateInput
    _min?: menuMinOrderByAggregateInput
    _sum?: menuSumOrderByAggregateInput
  }

  export type menuScalarWhereWithAggregatesInput = {
    AND?: menuScalarWhereWithAggregatesInput | menuScalarWhereWithAggregatesInput[]
    OR?: menuScalarWhereWithAggregatesInput[]
    NOT?: menuScalarWhereWithAggregatesInput | menuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"menu"> | number
    name?: StringWithAggregatesFilter<"menu"> | string
    parent_id?: IntNullableWithAggregatesFilter<"menu"> | number | null
    link?: StringNullableWithAggregatesFilter<"menu"> | string | null
    visible?: BoolWithAggregatesFilter<"menu"> | boolean
    role?: StringNullableWithAggregatesFilter<"menu"> | string | null
  }

  export type scoresWhereInput = {
    AND?: scoresWhereInput | scoresWhereInput[]
    OR?: scoresWhereInput[]
    NOT?: scoresWhereInput | scoresWhereInput[]
    id?: IntFilter<"scores"> | number
    exam_id?: IntFilter<"scores"> | number
    user_id?: IntFilter<"scores"> | number
    total_score?: IntFilter<"scores"> | number
    created_at?: DateTimeNullableFilter<"scores"> | Date | string | null
    em_exams?: XOR<Em_examsScalarRelationFilter, em_examsWhereInput>
    emapp?: XOR<EmappScalarRelationFilter, emappWhereInput>
  }

  export type scoresOrderByWithRelationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
    created_at?: SortOrderInput | SortOrder
    em_exams?: em_examsOrderByWithRelationInput
    emapp?: emappOrderByWithRelationInput
  }

  export type scoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: scoresWhereInput | scoresWhereInput[]
    OR?: scoresWhereInput[]
    NOT?: scoresWhereInput | scoresWhereInput[]
    exam_id?: IntFilter<"scores"> | number
    user_id?: IntFilter<"scores"> | number
    total_score?: IntFilter<"scores"> | number
    created_at?: DateTimeNullableFilter<"scores"> | Date | string | null
    em_exams?: XOR<Em_examsScalarRelationFilter, em_examsWhereInput>
    emapp?: XOR<EmappScalarRelationFilter, emappWhereInput>
  }, "id">

  export type scoresOrderByWithAggregationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: scoresCountOrderByAggregateInput
    _avg?: scoresAvgOrderByAggregateInput
    _max?: scoresMaxOrderByAggregateInput
    _min?: scoresMinOrderByAggregateInput
    _sum?: scoresSumOrderByAggregateInput
  }

  export type scoresScalarWhereWithAggregatesInput = {
    AND?: scoresScalarWhereWithAggregatesInput | scoresScalarWhereWithAggregatesInput[]
    OR?: scoresScalarWhereWithAggregatesInput[]
    NOT?: scoresScalarWhereWithAggregatesInput | scoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"scores"> | number
    exam_id?: IntWithAggregatesFilter<"scores"> | number
    user_id?: IntWithAggregatesFilter<"scores"> | number
    total_score?: IntWithAggregatesFilter<"scores"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"scores"> | Date | string | null
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Bytes | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Bytes | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Bytes | null
  }

  export type em_absensiCreateInput = {
    faceId?: number | null
    inDate?: Date | string | null
    outDate?: Date | string | null
    fileImage?: string | null
  }

  export type em_absensiUncheckedCreateInput = {
    Id?: number
    faceId?: number | null
    inDate?: Date | string | null
    outDate?: Date | string | null
    fileImage?: string | null
  }

  export type em_absensiUpdateInput = {
    faceId?: NullableIntFieldUpdateOperationsInput | number | null
    inDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_absensiUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    faceId?: NullableIntFieldUpdateOperationsInput | number | null
    inDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_absensiCreateManyInput = {
    faceId?: number | null
    inDate?: Date | string | null
    outDate?: Date | string | null
    fileImage?: string | null
  }

  export type em_absensiUpdateManyMutationInput = {
    faceId?: NullableIntFieldUpdateOperationsInput | number | null
    inDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_absensiUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    faceId?: NullableIntFieldUpdateOperationsInput | number | null
    inDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_academyCreateInput = {
    SchoolName?: string | null
    Province?: string | null
    Major?: string | null
    Degree?: string | null
    EnrollDate?: Date | string | null
    GraduatDate?: Date | string | null
    IPK?: number | null
    OrganizeExperience?: string | null
    Explain?: string | null
    GradeSchool?: string | null
    DailySchedule?: string | null
    SchoolAddress?: string | null
    em_apc_personal: em_apc_personalCreateNestedOneWithoutEm_apc_academyInput
  }

  export type em_apc_academyUncheckedCreateInput = {
    AcademyId?: number
    ApcId: number
    SchoolName?: string | null
    Province?: string | null
    Major?: string | null
    Degree?: string | null
    EnrollDate?: Date | string | null
    GraduatDate?: Date | string | null
    IPK?: number | null
    OrganizeExperience?: string | null
    Explain?: string | null
    GradeSchool?: string | null
    DailySchedule?: string | null
    SchoolAddress?: string | null
  }

  export type em_apc_academyUpdateInput = {
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_personal?: em_apc_personalUpdateOneRequiredWithoutEm_apc_academyNestedInput
  }

  export type em_apc_academyUncheckedUpdateInput = {
    AcademyId?: IntFieldUpdateOperationsInput | number
    ApcId?: IntFieldUpdateOperationsInput | number
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_academyCreateManyInput = {
    ApcId: number
    SchoolName?: string | null
    Province?: string | null
    Major?: string | null
    Degree?: string | null
    EnrollDate?: Date | string | null
    GraduatDate?: Date | string | null
    IPK?: number | null
    OrganizeExperience?: string | null
    Explain?: string | null
    GradeSchool?: string | null
    DailySchedule?: string | null
    SchoolAddress?: string | null
  }

  export type em_apc_academyUpdateManyMutationInput = {
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_academyUncheckedUpdateManyInput = {
    AcademyId?: IntFieldUpdateOperationsInput | number
    ApcId?: IntFieldUpdateOperationsInput | number
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_personalCreateInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUncheckedCreateInput = {
    ApcId?: number
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUpdateInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalUncheckedUpdateInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalCreateManyInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
  }

  export type em_apc_personalUpdateManyMutationInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_personalUncheckedUpdateManyInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_photographCreateInput = {
    GenrName?: string | null
    em_apc_personal?: em_apc_personalCreateNestedOneWithoutEm_apc_photographInput
  }

  export type em_apc_photographUncheckedCreateInput = {
    Id?: number
    ApcId?: number | null
    GenrName?: string | null
  }

  export type em_apc_photographUpdateInput = {
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_personal?: em_apc_personalUpdateOneWithoutEm_apc_photographNestedInput
  }

  export type em_apc_photographUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ApcId?: NullableIntFieldUpdateOperationsInput | number | null
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_photographCreateManyInput = {
    ApcId?: number | null
    GenrName?: string | null
  }

  export type em_apc_photographUpdateManyMutationInput = {
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_photographUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ApcId?: NullableIntFieldUpdateOperationsInput | number | null
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_regulationCreateInput = {
    RegId?: number | null
    RegChoice?: boolean | null
    em_apc_personal?: em_apc_personalCreateNestedOneWithoutEm_apc_regulationInput
  }

  export type em_apc_regulationUncheckedCreateInput = {
    ApcRegId?: number
    ApcId?: number | null
    RegId?: number | null
    RegChoice?: boolean | null
  }

  export type em_apc_regulationUpdateInput = {
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    em_apc_personal?: em_apc_personalUpdateOneWithoutEm_apc_regulationNestedInput
  }

  export type em_apc_regulationUncheckedUpdateInput = {
    ApcRegId?: IntFieldUpdateOperationsInput | number
    ApcId?: NullableIntFieldUpdateOperationsInput | number | null
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_apc_regulationCreateManyInput = {
    ApcId?: number | null
    RegId?: number | null
    RegChoice?: boolean | null
  }

  export type em_apc_regulationUpdateManyMutationInput = {
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_apc_regulationUncheckedUpdateManyInput = {
    ApcRegId?: IntFieldUpdateOperationsInput | number
    ApcId?: NullableIntFieldUpdateOperationsInput | number | null
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_apc_skill_experCreateInput = {
    CompanyName?: string | null
    Province?: string | null
    JobTitle?: string | null
    Salary?: number | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Responsibilities?: string | null
    CareerGoals?: string | null
    WhyJoin?: string | null
    IsFriend?: string | null
    IsMentions?: string | null
    IsCompProgram?: string | null
    IsIllnes?: string | null
    HaveCriminal?: string | null
    WhenWork?: string | null
    ExpectedSalary?: number | null
    isContribution?: string | null
    isDuration?: string | null
    isAgency?: string | null
    isExprn?: string | null
    isGenre?: string | null
    isRelevan?: string | null
    isSpesialSkill?: string | null
    isShoot?: string | null
    isSchedl?: string | null
    isMotivation?: string | null
    isStress?: string | null
    isLongExpr?: string | null
    isPhotTools?: string | null
    isChalleng?: string | null
    isThreeYears?: string | null
    PersonVal?: string | null
    em_apc_personal: em_apc_personalCreateNestedOneWithoutEm_apc_skill_experInput
  }

  export type em_apc_skill_experUncheckedCreateInput = {
    SkillId?: number
    ApcId: number
    CompanyName?: string | null
    Province?: string | null
    JobTitle?: string | null
    Salary?: number | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Responsibilities?: string | null
    CareerGoals?: string | null
    WhyJoin?: string | null
    IsFriend?: string | null
    IsMentions?: string | null
    IsCompProgram?: string | null
    IsIllnes?: string | null
    HaveCriminal?: string | null
    WhenWork?: string | null
    ExpectedSalary?: number | null
    isContribution?: string | null
    isDuration?: string | null
    isAgency?: string | null
    isExprn?: string | null
    isGenre?: string | null
    isRelevan?: string | null
    isSpesialSkill?: string | null
    isShoot?: string | null
    isSchedl?: string | null
    isMotivation?: string | null
    isStress?: string | null
    isLongExpr?: string | null
    isPhotTools?: string | null
    isChalleng?: string | null
    isThreeYears?: string | null
    PersonVal?: string | null
  }

  export type em_apc_skill_experUpdateInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_personal?: em_apc_personalUpdateOneRequiredWithoutEm_apc_skill_experNestedInput
  }

  export type em_apc_skill_experUncheckedUpdateInput = {
    SkillId?: IntFieldUpdateOperationsInput | number
    ApcId?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_skill_experCreateManyInput = {
    ApcId: number
    CompanyName?: string | null
    Province?: string | null
    JobTitle?: string | null
    Salary?: number | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Responsibilities?: string | null
    CareerGoals?: string | null
    WhyJoin?: string | null
    IsFriend?: string | null
    IsMentions?: string | null
    IsCompProgram?: string | null
    IsIllnes?: string | null
    HaveCriminal?: string | null
    WhenWork?: string | null
    ExpectedSalary?: number | null
    isContribution?: string | null
    isDuration?: string | null
    isAgency?: string | null
    isExprn?: string | null
    isGenre?: string | null
    isRelevan?: string | null
    isSpesialSkill?: string | null
    isShoot?: string | null
    isSchedl?: string | null
    isMotivation?: string | null
    isStress?: string | null
    isLongExpr?: string | null
    isPhotTools?: string | null
    isChalleng?: string | null
    isThreeYears?: string | null
    PersonVal?: string | null
  }

  export type em_apc_skill_experUpdateManyMutationInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_skill_experUncheckedUpdateManyInput = {
    SkillId?: IntFieldUpdateOperationsInput | number
    ApcId?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_api_keysCreateInput = {
    username?: string | null
    api_key: string
    created_at: Date | string
  }

  export type em_api_keysUncheckedCreateInput = {
    id?: number
    username?: string | null
    api_key: string
    created_at: Date | string
  }

  export type em_api_keysUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    api_key?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type em_api_keysUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    api_key?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type em_api_keysCreateManyInput = {
    username?: string | null
    api_key: string
    created_at: Date | string
  }

  export type em_api_keysUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    api_key?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type em_api_keysUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    api_key?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type em_applicant_criteriaCreateInput = {
    jenis_kriteria?: string | null
    value?: string | null
    value_en?: string | null
    bobot?: number | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    emposs: empossCreateNestedOneWithoutEm_applicant_criteriaInput
  }

  export type em_applicant_criteriaUncheckedCreateInput = {
    id_kriteria?: number
    id_loker: number
    jenis_kriteria?: string | null
    value?: string | null
    value_en?: string | null
    bobot?: number | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_applicant_criteriaUpdateInput = {
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emposs?: empossUpdateOneRequiredWithoutEm_applicant_criteriaNestedInput
  }

  export type em_applicant_criteriaUncheckedUpdateInput = {
    id_kriteria?: IntFieldUpdateOperationsInput | number
    id_loker?: IntFieldUpdateOperationsInput | number
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_criteriaCreateManyInput = {
    id_loker: number
    jenis_kriteria?: string | null
    value?: string | null
    value_en?: string | null
    bobot?: number | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_applicant_criteriaUpdateManyMutationInput = {
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_criteriaUncheckedUpdateManyInput = {
    id_kriteria?: IntFieldUpdateOperationsInput | number
    id_loker?: IntFieldUpdateOperationsInput | number
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_matchCreateInput = {
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
    em_apc_personal: em_apc_personalCreateNestedOneWithoutEm_applicant_matchInput
    emposs: empossCreateNestedOneWithoutEm_applicant_matchInput
  }

  export type em_applicant_matchUncheckedCreateInput = {
    id_match?: number
    id_applicant: number
    id_loker: number
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
  }

  export type em_applicant_matchUpdateInput = {
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_apc_personal?: em_apc_personalUpdateOneRequiredWithoutEm_applicant_matchNestedInput
    emposs?: empossUpdateOneRequiredWithoutEm_applicant_matchNestedInput
  }

  export type em_applicant_matchUncheckedUpdateInput = {
    id_match?: IntFieldUpdateOperationsInput | number
    id_applicant?: IntFieldUpdateOperationsInput | number
    id_loker?: IntFieldUpdateOperationsInput | number
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_matchCreateManyInput = {
    id_applicant: number
    id_loker: number
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
  }

  export type em_applicant_matchUpdateManyMutationInput = {
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_matchUncheckedUpdateManyInput = {
    id_match?: IntFieldUpdateOperationsInput | number
    id_applicant?: IntFieldUpdateOperationsInput | number
    id_loker?: IntFieldUpdateOperationsInput | number
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_bannerCreateInput = {
    bannerName?: string | null
    fileName?: string | null
    menuName?: string | null
    noUrut?: number | null
    Status?: string | null
    created_at?: Date | string | null
    last_update?: Date | string | null
    userid?: string | null
  }

  export type em_bannerUncheckedCreateInput = {
    Id?: number
    bannerName?: string | null
    fileName?: string | null
    menuName?: string | null
    noUrut?: number | null
    Status?: string | null
    created_at?: Date | string | null
    last_update?: Date | string | null
    userid?: string | null
  }

  export type em_bannerUpdateInput = {
    bannerName?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    menuName?: NullableStringFieldUpdateOperationsInput | string | null
    noUrut?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_bannerUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    bannerName?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    menuName?: NullableStringFieldUpdateOperationsInput | string | null
    noUrut?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_bannerCreateManyInput = {
    bannerName?: string | null
    fileName?: string | null
    menuName?: string | null
    noUrut?: number | null
    Status?: string | null
    created_at?: Date | string | null
    last_update?: Date | string | null
    userid?: string | null
  }

  export type em_bannerUpdateManyMutationInput = {
    bannerName?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    menuName?: NullableStringFieldUpdateOperationsInput | string | null
    noUrut?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_bannerUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    bannerName?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    menuName?: NullableStringFieldUpdateOperationsInput | string | null
    noUrut?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_career_contactCreateInput = {
    companyName?: string | null
    email?: string | null
    waNumber?: string | null
    fileImage?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_career_contactUncheckedCreateInput = {
    cpId?: number
    companyName?: string | null
    email?: string | null
    waNumber?: string | null
    fileImage?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_career_contactUpdateInput = {
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    waNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_career_contactUncheckedUpdateInput = {
    cpId?: IntFieldUpdateOperationsInput | number
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    waNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_career_contactCreateManyInput = {
    companyName?: string | null
    email?: string | null
    waNumber?: string | null
    fileImage?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_career_contactUpdateManyMutationInput = {
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    waNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_career_contactUncheckedUpdateManyInput = {
    cpId?: IntFieldUpdateOperationsInput | number
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    waNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fileImage?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_certificate_fieldsCreateInput = {
    id?: number
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style?: string | null
    font_weight?: string | null
    font_color?: string | null
    created_date?: Date | string | null
    lastupdate?: Date | string | null
    em_certificate_templates: em_certificate_templatesCreateNestedOneWithoutEm_certificate_fieldsInput
  }

  export type em_certificate_fieldsUncheckedCreateInput = {
    id?: number
    certificate_id: number
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style?: string | null
    font_weight?: string | null
    font_color?: string | null
    created_date?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_fieldsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_certificate_templates?: em_certificate_templatesUpdateOneRequiredWithoutEm_certificate_fieldsNestedInput
  }

  export type em_certificate_fieldsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificate_id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_fieldsCreateManyInput = {
    certificate_id: number
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style?: string | null
    font_weight?: string | null
    font_color?: string | null
    created_date?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_fieldsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_fieldsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificate_id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_templatesCreateInput = {
    name?: string | null
    background_image?: string | null
    created_at?: Date | string | null
    certificate_name?: string | null
    lastupdate?: Date | string | null
    em_certificate_fields?: em_certificate_fieldsCreateNestedManyWithoutEm_certificate_templatesInput
  }

  export type em_certificate_templatesUncheckedCreateInput = {
    certificate_id?: number
    name?: string | null
    background_image?: string | null
    created_at?: Date | string | null
    certificate_name?: string | null
    lastupdate?: Date | string | null
    em_certificate_fields?: em_certificate_fieldsUncheckedCreateNestedManyWithoutEm_certificate_templatesInput
  }

  export type em_certificate_templatesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    background_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_name?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_certificate_fields?: em_certificate_fieldsUpdateManyWithoutEm_certificate_templatesNestedInput
  }

  export type em_certificate_templatesUncheckedUpdateInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    background_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_name?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_certificate_fields?: em_certificate_fieldsUncheckedUpdateManyWithoutEm_certificate_templatesNestedInput
  }

  export type em_certificate_templatesCreateManyInput = {
    name?: string | null
    background_image?: string | null
    created_at?: Date | string | null
    certificate_name?: string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_templatesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    background_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_name?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_templatesUncheckedUpdateManyInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    background_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_name?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificates_resultCreateInput = {
    cert_number: string
    cert_templ_id: number
    empl_id: number
    cert_name: string
    created_date?: Date | string | null
    status?: string | null
    generated_by?: string | null
    schedule_id?: number | null
  }

  export type em_certificates_resultUncheckedCreateInput = {
    cert_number: string
    cert_templ_id: number
    empl_id: number
    cert_name: string
    created_date?: Date | string | null
    status?: string | null
    generated_by?: string | null
    schedule_id?: number | null
  }

  export type em_certificates_resultUpdateInput = {
    cert_number?: StringFieldUpdateOperationsInput | string
    cert_templ_id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    cert_name?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_certificates_resultUncheckedUpdateInput = {
    cert_number?: StringFieldUpdateOperationsInput | string
    cert_templ_id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    cert_name?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_certificates_resultCreateManyInput = {
    cert_number: string
    cert_templ_id: number
    empl_id: number
    cert_name: string
    created_date?: Date | string | null
    status?: string | null
    generated_by?: string | null
    schedule_id?: number | null
  }

  export type em_certificates_resultUpdateManyMutationInput = {
    cert_number?: StringFieldUpdateOperationsInput | string
    cert_templ_id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    cert_name?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_certificates_resultUncheckedUpdateManyInput = {
    cert_number?: StringFieldUpdateOperationsInput | string
    cert_templ_id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    cert_name?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_chanceCreateInput = {
    chName?: string | null
    chDesc?: string | null
    chStats?: string | null
    chFileImage?: string | null
    chLink?: string | null
    chUserid?: string | null
    chDate?: Date | string | null
    chLastupdate?: Date | string | null
  }

  export type em_chanceUncheckedCreateInput = {
    chId?: number
    chName?: string | null
    chDesc?: string | null
    chStats?: string | null
    chFileImage?: string | null
    chLink?: string | null
    chUserid?: string | null
    chDate?: Date | string | null
    chLastupdate?: Date | string | null
  }

  export type em_chanceUpdateInput = {
    chName?: NullableStringFieldUpdateOperationsInput | string | null
    chDesc?: NullableStringFieldUpdateOperationsInput | string | null
    chStats?: NullableStringFieldUpdateOperationsInput | string | null
    chFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    chLink?: NullableStringFieldUpdateOperationsInput | string | null
    chUserid?: NullableStringFieldUpdateOperationsInput | string | null
    chDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_chanceUncheckedUpdateInput = {
    chId?: IntFieldUpdateOperationsInput | number
    chName?: NullableStringFieldUpdateOperationsInput | string | null
    chDesc?: NullableStringFieldUpdateOperationsInput | string | null
    chStats?: NullableStringFieldUpdateOperationsInput | string | null
    chFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    chLink?: NullableStringFieldUpdateOperationsInput | string | null
    chUserid?: NullableStringFieldUpdateOperationsInput | string | null
    chDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_chanceCreateManyInput = {
    chName?: string | null
    chDesc?: string | null
    chStats?: string | null
    chFileImage?: string | null
    chLink?: string | null
    chUserid?: string | null
    chDate?: Date | string | null
    chLastupdate?: Date | string | null
  }

  export type em_chanceUpdateManyMutationInput = {
    chName?: NullableStringFieldUpdateOperationsInput | string | null
    chDesc?: NullableStringFieldUpdateOperationsInput | string | null
    chStats?: NullableStringFieldUpdateOperationsInput | string | null
    chFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    chLink?: NullableStringFieldUpdateOperationsInput | string | null
    chUserid?: NullableStringFieldUpdateOperationsInput | string | null
    chDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_chanceUncheckedUpdateManyInput = {
    chId?: IntFieldUpdateOperationsInput | number
    chName?: NullableStringFieldUpdateOperationsInput | string | null
    chDesc?: NullableStringFieldUpdateOperationsInput | string | null
    chStats?: NullableStringFieldUpdateOperationsInput | string | null
    chFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    chLink?: NullableStringFieldUpdateOperationsInput | string | null
    chUserid?: NullableStringFieldUpdateOperationsInput | string | null
    chDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_contrctypeCreateInput = {
    contract_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_contrctypeUncheckedCreateInput = {
    id?: number
    contract_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_contrctypeUpdateInput = {
    contract_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_contrctypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contract_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_contrctypeCreateManyInput = {
    contract_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_contrctypeUpdateManyMutationInput = {
    contract_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_contrctypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contract_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_deptCreateInput = {
    DEPTNAME?: string | null
    sbu_sub?: number | null
    status?: string | null
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_deptUncheckedCreateInput = {
    DEPTID?: number
    DEPTNAME?: string | null
    sbu_sub?: number | null
    status?: string | null
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_deptUpdateInput = {
    DEPTNAME?: NullableStringFieldUpdateOperationsInput | string | null
    sbu_sub?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_deptUncheckedUpdateInput = {
    DEPTID?: IntFieldUpdateOperationsInput | number
    DEPTNAME?: NullableStringFieldUpdateOperationsInput | string | null
    sbu_sub?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_deptCreateManyInput = {
    DEPTNAME?: string | null
    sbu_sub?: number | null
    status?: string | null
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_deptUpdateManyMutationInput = {
    DEPTNAME?: NullableStringFieldUpdateOperationsInput | string | null
    sbu_sub?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_deptUncheckedUpdateManyInput = {
    DEPTID?: IntFieldUpdateOperationsInput | number
    DEPTNAME?: NullableStringFieldUpdateOperationsInput | string | null
    sbu_sub?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_employeeCreateInput = {
    BadgeNum: string
    Name?: string | null
    Gender?: string | null
    BirthDay?: Date | string | null
    HireDay?: Date | string | null
    Street?: string | null
    Religion?: string | null
    Tipe?: string | null
    isLokasi?: string | null
    Phone?: string | null
    DeptId?: number | null
    Password?: string | null
    CardNo?: string | null
    Shift?: number | null
    isMem?: boolean | null
    AddBy?: string | null
    Created_at?: Date | string | null
    Lastupdate?: Date | string | null
    isMemDate?: Date | string | null
    isFirstLogin?: number | null
    ImgName?: string | null
    SbuSub?: number | null
    Nik?: string | null
    ResignDate?: Date | string | null
    status?: string | null
  }

  export type em_employeeUncheckedCreateInput = {
    UserId?: number
    BadgeNum: string
    Name?: string | null
    Gender?: string | null
    BirthDay?: Date | string | null
    HireDay?: Date | string | null
    Street?: string | null
    Religion?: string | null
    Tipe?: string | null
    isLokasi?: string | null
    Phone?: string | null
    DeptId?: number | null
    Password?: string | null
    CardNo?: string | null
    Shift?: number | null
    isMem?: boolean | null
    AddBy?: string | null
    Created_at?: Date | string | null
    Lastupdate?: Date | string | null
    isMemDate?: Date | string | null
    isFirstLogin?: number | null
    ImgName?: string | null
    SbuSub?: number | null
    Nik?: string | null
    ResignDate?: Date | string | null
    status?: string | null
  }

  export type em_employeeUpdateInput = {
    BadgeNum?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    Religion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipe?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    DeptId?: NullableIntFieldUpdateOperationsInput | number | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CardNo?: NullableStringFieldUpdateOperationsInput | string | null
    Shift?: NullableIntFieldUpdateOperationsInput | number | null
    isMem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AddBy?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMemDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFirstLogin?: NullableIntFieldUpdateOperationsInput | number | null
    ImgName?: NullableStringFieldUpdateOperationsInput | string | null
    SbuSub?: NullableIntFieldUpdateOperationsInput | number | null
    Nik?: NullableStringFieldUpdateOperationsInput | string | null
    ResignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_employeeUncheckedUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    BadgeNum?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    Religion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipe?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    DeptId?: NullableIntFieldUpdateOperationsInput | number | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CardNo?: NullableStringFieldUpdateOperationsInput | string | null
    Shift?: NullableIntFieldUpdateOperationsInput | number | null
    isMem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AddBy?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMemDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFirstLogin?: NullableIntFieldUpdateOperationsInput | number | null
    ImgName?: NullableStringFieldUpdateOperationsInput | string | null
    SbuSub?: NullableIntFieldUpdateOperationsInput | number | null
    Nik?: NullableStringFieldUpdateOperationsInput | string | null
    ResignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_employeeCreateManyInput = {
    BadgeNum: string
    Name?: string | null
    Gender?: string | null
    BirthDay?: Date | string | null
    HireDay?: Date | string | null
    Street?: string | null
    Religion?: string | null
    Tipe?: string | null
    isLokasi?: string | null
    Phone?: string | null
    DeptId?: number | null
    Password?: string | null
    CardNo?: string | null
    Shift?: number | null
    isMem?: boolean | null
    AddBy?: string | null
    Created_at?: Date | string | null
    Lastupdate?: Date | string | null
    isMemDate?: Date | string | null
    isFirstLogin?: number | null
    ImgName?: string | null
    SbuSub?: number | null
    Nik?: string | null
    ResignDate?: Date | string | null
    status?: string | null
  }

  export type em_employeeUpdateManyMutationInput = {
    BadgeNum?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    Religion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipe?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    DeptId?: NullableIntFieldUpdateOperationsInput | number | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CardNo?: NullableStringFieldUpdateOperationsInput | string | null
    Shift?: NullableIntFieldUpdateOperationsInput | number | null
    isMem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AddBy?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMemDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFirstLogin?: NullableIntFieldUpdateOperationsInput | number | null
    ImgName?: NullableStringFieldUpdateOperationsInput | string | null
    SbuSub?: NullableIntFieldUpdateOperationsInput | number | null
    Nik?: NullableStringFieldUpdateOperationsInput | string | null
    ResignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_employeeUncheckedUpdateManyInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    BadgeNum?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    Religion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipe?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    DeptId?: NullableIntFieldUpdateOperationsInput | number | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CardNo?: NullableStringFieldUpdateOperationsInput | string | null
    Shift?: NullableIntFieldUpdateOperationsInput | number | null
    isMem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AddBy?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMemDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFirstLogin?: NullableIntFieldUpdateOperationsInput | number | null
    ImgName?: NullableStringFieldUpdateOperationsInput | string | null
    SbuSub?: NullableIntFieldUpdateOperationsInput | number | null
    Nik?: NullableStringFieldUpdateOperationsInput | string | null
    ResignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_eventCreateInput = {
    event_name?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    lokasi?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
    em_event2?: em_event2CreateNestedManyWithoutEm_eventInput
  }

  export type em_eventUncheckedCreateInput = {
    event_id?: number
    event_name?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    lokasi?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
    em_event2?: em_event2UncheckedCreateNestedManyWithoutEm_eventInput
  }

  export type em_eventUpdateInput = {
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_event2?: em_event2UpdateManyWithoutEm_eventNestedInput
  }

  export type em_eventUncheckedUpdateInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_event2?: em_event2UncheckedUpdateManyWithoutEm_eventNestedInput
  }

  export type em_eventCreateManyInput = {
    event_name?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    lokasi?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_eventUpdateManyMutationInput = {
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_eventUncheckedUpdateManyInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_event_regCreateInput = {
    name?: string | null
    optic_name?: string | null
    password?: string | null
    wa_num?: string | null
    email?: string | null
    profesi_id?: number | null
    event_id?: number | null
    status?: string | null
    first_login?: boolean | null
    created_date?: Date | string | null
    last_update?: Date | string | null
    image_name?: string | null
  }

  export type em_event_regUncheckedCreateInput = {
    Regid?: number
    name?: string | null
    optic_name?: string | null
    password?: string | null
    wa_num?: string | null
    email?: string | null
    profesi_id?: number | null
    event_id?: number | null
    status?: string | null
    first_login?: boolean | null
    created_date?: Date | string | null
    last_update?: Date | string | null
    image_name?: string | null
  }

  export type em_event_regUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    optic_name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wa_num?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profesi_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    first_login?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event_regUncheckedUpdateInput = {
    Regid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    optic_name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wa_num?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profesi_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    first_login?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event_regCreateManyInput = {
    name?: string | null
    optic_name?: string | null
    password?: string | null
    wa_num?: string | null
    email?: string | null
    profesi_id?: number | null
    event_id?: number | null
    status?: string | null
    first_login?: boolean | null
    created_date?: Date | string | null
    last_update?: Date | string | null
    image_name?: string | null
  }

  export type em_event_regUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    optic_name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wa_num?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profesi_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    first_login?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event_regUncheckedUpdateManyInput = {
    Regid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    optic_name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wa_num?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profesi_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    first_login?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event2CreateInput = {
    event_name?: string | null
    status?: string | null
    qr_code?: string | null
    em_event?: em_eventCreateNestedOneWithoutEm_event2Input
  }

  export type em_event2UncheckedCreateInput = {
    sess_id?: number
    event_id?: number | null
    event_name?: string | null
    status?: string | null
    qr_code?: string | null
  }

  export type em_event2UpdateInput = {
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
    em_event?: em_eventUpdateOneWithoutEm_event2NestedInput
  }

  export type em_event2UncheckedUpdateInput = {
    sess_id?: IntFieldUpdateOperationsInput | number
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event2CreateManyInput = {
    event_id?: number | null
    event_name?: string | null
    status?: string | null
    qr_code?: string | null
  }

  export type em_event2UpdateManyMutationInput = {
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event2UncheckedUpdateManyInput = {
    sess_id?: IntFieldUpdateOperationsInput | number
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_exam_questionsCreateInput = {
    exam_id: number
    question_id: number
  }

  export type em_exam_questionsUncheckedCreateInput = {
    id?: number
    exam_id: number
    question_id: number
  }

  export type em_exam_questionsUpdateInput = {
    exam_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type em_exam_questionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type em_exam_questionsCreateManyInput = {
    exam_id: number
    question_id: number
  }

  export type em_exam_questionsUpdateManyMutationInput = {
    exam_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type em_exam_questionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type em_examsCreateInput = {
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
    em_loktopik?: em_loktopikCreateNestedManyWithoutEm_examsInput
    scores?: scoresCreateNestedManyWithoutEm_examsInput
  }

  export type em_examsUncheckedCreateInput = {
    id?: number
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
    em_loktopik?: em_loktopikUncheckedCreateNestedManyWithoutEm_examsInput
    scores?: scoresUncheckedCreateNestedManyWithoutEm_examsInput
  }

  export type em_examsUpdateInput = {
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
    em_loktopik?: em_loktopikUpdateManyWithoutEm_examsNestedInput
    scores?: scoresUpdateManyWithoutEm_examsNestedInput
  }

  export type em_examsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
    em_loktopik?: em_loktopikUncheckedUpdateManyWithoutEm_examsNestedInput
    scores?: scoresUncheckedUpdateManyWithoutEm_examsNestedInput
  }

  export type em_examsCreateManyInput = {
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
  }

  export type em_examsUpdateManyMutationInput = {
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_examsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_exams_monitorCreateInput = {
    Id?: bigint | number
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    tipe_soal?: string | null
    jumlah_soal?: number | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type em_exams_monitorUncheckedCreateInput = {
    Id?: bigint | number
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    tipe_soal?: string | null
    jumlah_soal?: number | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type em_exams_monitorUpdateInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    tipe_soal?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah_soal?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_monitorUncheckedUpdateInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    tipe_soal?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah_soal?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_monitorCreateManyInput = {
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    tipe_soal?: string | null
    jumlah_soal?: number | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type em_exams_monitorUpdateManyMutationInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    tipe_soal?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah_soal?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_monitorUncheckedUpdateManyInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    tipe_soal?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah_soal?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_resultsCreateInput = {
    exams_id?: string | null
    empl_id?: number | null
    soal_id?: number | null
    is_changes?: number | null
    is_answer?: string | null
    is_time?: Date | string | null
  }

  export type em_exams_resultsUncheckedCreateInput = {
    Id?: number
    exams_id?: string | null
    empl_id?: number | null
    soal_id?: number | null
    is_changes?: number | null
    is_answer?: string | null
    is_time?: Date | string | null
  }

  export type em_exams_resultsUpdateInput = {
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_changes?: NullableIntFieldUpdateOperationsInput | number | null
    is_answer?: NullableStringFieldUpdateOperationsInput | string | null
    is_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_resultsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_changes?: NullableIntFieldUpdateOperationsInput | number | null
    is_answer?: NullableStringFieldUpdateOperationsInput | string | null
    is_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_resultsCreateManyInput = {
    exams_id?: string | null
    empl_id?: number | null
    soal_id?: number | null
    is_changes?: number | null
    is_answer?: string | null
    is_time?: Date | string | null
  }

  export type em_exams_resultsUpdateManyMutationInput = {
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_changes?: NullableIntFieldUpdateOperationsInput | number | null
    is_answer?: NullableStringFieldUpdateOperationsInput | string | null
    is_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_exams_resultsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_changes?: NullableIntFieldUpdateOperationsInput | number | null
    is_answer?: NullableStringFieldUpdateOperationsInput | string | null
    is_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_faqCreateInput = {
    isquestions?: string | null
    isanswer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
    em_faq_cat?: em_faq_catCreateNestedOneWithoutEm_faqInput
  }

  export type em_faqUncheckedCreateInput = {
    fqId?: number
    fqcatid?: number | null
    isquestions?: string | null
    isanswer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_faqUpdateInput = {
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    em_faq_cat?: em_faq_catUpdateOneWithoutEm_faqNestedInput
  }

  export type em_faqUncheckedUpdateInput = {
    fqId?: IntFieldUpdateOperationsInput | number
    fqcatid?: NullableIntFieldUpdateOperationsInput | number | null
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_faqCreateManyInput = {
    fqcatid?: number | null
    isquestions?: string | null
    isanswer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_faqUpdateManyMutationInput = {
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_faqUncheckedUpdateManyInput = {
    fqId?: IntFieldUpdateOperationsInput | number
    fqcatid?: NullableIntFieldUpdateOperationsInput | number | null
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_faq_catCreateInput = {
    name?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    em_faq?: em_faqCreateNestedManyWithoutEm_faq_catInput
  }

  export type em_faq_catUncheckedCreateInput = {
    fqcatid?: number
    name?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    em_faq?: em_faqUncheckedCreateNestedManyWithoutEm_faq_catInput
  }

  export type em_faq_catUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_faq?: em_faqUpdateManyWithoutEm_faq_catNestedInput
  }

  export type em_faq_catUncheckedUpdateInput = {
    fqcatid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_faq?: em_faqUncheckedUpdateManyWithoutEm_faq_catNestedInput
  }

  export type em_faq_catCreateManyInput = {
    name?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_faq_catUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_faq_catUncheckedUpdateManyInput = {
    fqcatid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_galeri_materiCreateInput = {
    title: string
    file_type: number
    file_name?: string | null
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    status?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_galeri_materiUncheckedCreateInput = {
    id?: number
    title: string
    file_type: number
    file_name?: string | null
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    status?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_galeri_materiUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_galeri_materiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_galeri_materiCreateManyInput = {
    title: string
    file_type: number
    file_name?: string | null
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    status?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_galeri_materiUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_galeri_materiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_groupCreateInput = {
    GroupName?: string | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_groupUncheckedCreateInput = {
    GroupId?: number
    GroupName?: string | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_groupUpdateInput = {
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_groupUncheckedUpdateInput = {
    GroupId?: IntFieldUpdateOperationsInput | number
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_groupCreateManyInput = {
    GroupName?: string | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_groupUpdateManyMutationInput = {
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_groupUncheckedUpdateManyInput = {
    GroupId?: IntFieldUpdateOperationsInput | number
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_hero_sectionCreateInput = {
    hsName?: string | null
    hsDesc?: string | null
    hsStats?: string | null
    hsFileImage?: string | null
    hsLink?: string | null
    hsUserid?: string | null
    hsDate?: Date | string | null
    hsLastupdate?: Date | string | null
    Urutan?: number | null
  }

  export type em_hero_sectionUncheckedCreateInput = {
    hsId?: number
    hsName?: string | null
    hsDesc?: string | null
    hsStats?: string | null
    hsFileImage?: string | null
    hsLink?: string | null
    hsUserid?: string | null
    hsDate?: Date | string | null
    hsLastupdate?: Date | string | null
    Urutan?: number | null
  }

  export type em_hero_sectionUpdateInput = {
    hsName?: NullableStringFieldUpdateOperationsInput | string | null
    hsDesc?: NullableStringFieldUpdateOperationsInput | string | null
    hsStats?: NullableStringFieldUpdateOperationsInput | string | null
    hsFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    hsLink?: NullableStringFieldUpdateOperationsInput | string | null
    hsUserid?: NullableStringFieldUpdateOperationsInput | string | null
    hsDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hsLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_hero_sectionUncheckedUpdateInput = {
    hsId?: IntFieldUpdateOperationsInput | number
    hsName?: NullableStringFieldUpdateOperationsInput | string | null
    hsDesc?: NullableStringFieldUpdateOperationsInput | string | null
    hsStats?: NullableStringFieldUpdateOperationsInput | string | null
    hsFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    hsLink?: NullableStringFieldUpdateOperationsInput | string | null
    hsUserid?: NullableStringFieldUpdateOperationsInput | string | null
    hsDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hsLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_hero_sectionCreateManyInput = {
    hsName?: string | null
    hsDesc?: string | null
    hsStats?: string | null
    hsFileImage?: string | null
    hsLink?: string | null
    hsUserid?: string | null
    hsDate?: Date | string | null
    hsLastupdate?: Date | string | null
    Urutan?: number | null
  }

  export type em_hero_sectionUpdateManyMutationInput = {
    hsName?: NullableStringFieldUpdateOperationsInput | string | null
    hsDesc?: NullableStringFieldUpdateOperationsInput | string | null
    hsStats?: NullableStringFieldUpdateOperationsInput | string | null
    hsFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    hsLink?: NullableStringFieldUpdateOperationsInput | string | null
    hsUserid?: NullableStringFieldUpdateOperationsInput | string | null
    hsDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hsLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_hero_sectionUncheckedUpdateManyInput = {
    hsId?: IntFieldUpdateOperationsInput | number
    hsName?: NullableStringFieldUpdateOperationsInput | string | null
    hsDesc?: NullableStringFieldUpdateOperationsInput | string | null
    hsStats?: NullableStringFieldUpdateOperationsInput | string | null
    hsFileImage?: NullableStringFieldUpdateOperationsInput | string | null
    hsLink?: NullableStringFieldUpdateOperationsInput | string | null
    hsUserid?: NullableStringFieldUpdateOperationsInput | string | null
    hsDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hsLastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_jawaban_pesertaCreateInput = {
    Id?: number
    empl_id: number
    soal_id: number
    jawaban?: string | null
    jawaban2?: string | null
    waktu_jawab?: Date | string | null
    Score?: number | null
    is_correction?: number | null
    is_train_jawaban?: boolean | null
    em_session_exams: em_session_examsCreateNestedOneWithoutEm_jawaban_pesertaInput
  }

  export type em_jawaban_pesertaUncheckedCreateInput = {
    Id?: number
    empl_id: number
    soal_id: number
    session_exams_id: string
    jawaban?: string | null
    jawaban2?: string | null
    waktu_jawab?: Date | string | null
    Score?: number | null
    is_correction?: number | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_pesertaUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
    em_session_exams?: em_session_examsUpdateOneRequiredWithoutEm_jawaban_pesertaNestedInput
  }

  export type em_jawaban_pesertaUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    session_exams_id?: StringFieldUpdateOperationsInput | string
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_pesertaCreateManyInput = {
    empl_id: number
    soal_id: number
    session_exams_id: string
    jawaban?: string | null
    jawaban2?: string | null
    waktu_jawab?: Date | string | null
    Score?: number | null
    is_correction?: number | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_pesertaUpdateManyMutationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_pesertaUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    session_exams_id?: StringFieldUpdateOperationsInput | string
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_peserta_apcCreateInput = {
    apc_id: number
    soal_id: number
    topic_id: number
    jawaban_option?: string | null
    jawaban_text?: string | null
    waktu_jawab?: Date | string | null
    score?: number | null
    is_correction?: boolean | null
    is_train_jawaban?: boolean | null
    em_session_exams_apc: em_session_exams_apcCreateNestedOneWithoutEm_jawaban_peserta_apcInput
  }

  export type em_jawaban_peserta_apcUncheckedCreateInput = {
    Id?: number
    apc_id: number
    soal_id: number
    topic_id: number
    session_exams_id: string
    jawaban_option?: string | null
    jawaban_text?: string | null
    waktu_jawab?: Date | string | null
    score?: number | null
    is_correction?: boolean | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_peserta_apcUpdateInput = {
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
    em_session_exams_apc?: em_session_exams_apcUpdateOneRequiredWithoutEm_jawaban_peserta_apcNestedInput
  }

  export type em_jawaban_peserta_apcUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    session_exams_id?: StringFieldUpdateOperationsInput | string
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_peserta_apcCreateManyInput = {
    apc_id: number
    soal_id: number
    topic_id: number
    session_exams_id: string
    jawaban_option?: string | null
    jawaban_text?: string | null
    waktu_jawab?: Date | string | null
    score?: number | null
    is_correction?: boolean | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_peserta_apcUpdateManyMutationInput = {
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_peserta_apcUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    session_exams_id?: StringFieldUpdateOperationsInput | string
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jobfairCreateInput = {
    lokasi: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_jobfairUncheckedCreateInput = {
    id?: number
    lokasi: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_jobfairUpdateInput = {
    lokasi?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_jobfairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lokasi?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_jobfairCreateManyInput = {
    lokasi: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_jobfairUpdateManyMutationInput = {
    lokasi?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_jobfairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lokasi?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_levelpossCreateInput = {
    level_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_levelpossUncheckedCreateInput = {
    id?: number
    level_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_levelpossUpdateInput = {
    level_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_levelpossUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_levelpossCreateManyInput = {
    level_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_levelpossUpdateManyMutationInput = {
    level_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_levelpossUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_logsCreateInput = {
    IP?: string | null
    Login?: Date | string | null
    Logout?: Date | string | null
    UserId?: string | null
    LogId?: number | null
    Notes?: string | null
    LastUpdate?: Date | string | null
  }

  export type em_logsUncheckedCreateInput = {
    Id?: number
    IP?: string | null
    Login?: Date | string | null
    Logout?: Date | string | null
    UserId?: string | null
    LogId?: number | null
    Notes?: string | null
    LastUpdate?: Date | string | null
  }

  export type em_logsUpdateInput = {
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    Login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LogId?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_logsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    Login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LogId?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_logsCreateManyInput = {
    IP?: string | null
    Login?: Date | string | null
    Logout?: Date | string | null
    UserId?: string | null
    LogId?: number | null
    Notes?: string | null
    LastUpdate?: Date | string | null
  }

  export type em_logsUpdateManyMutationInput = {
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    Login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LogId?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_logsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    Login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LogId?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_lokerCreateInput = {
    possid: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    jobdesc?: string | null
    qualify?: string | null
    worktype?: string | null
    salary?: string | null
    contrtype?: string | null
    posslevel?: string | null
    status?: string | null
    benefit?: string | null
    fileimage?: string | null
    createdate?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
    kategori?: number | null
    em_loktopik?: em_loktopikCreateNestedManyWithoutEm_lokerInput
  }

  export type em_lokerUncheckedCreateInput = {
    lokerid?: number
    possid: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    jobdesc?: string | null
    qualify?: string | null
    worktype?: string | null
    salary?: string | null
    contrtype?: string | null
    posslevel?: string | null
    status?: string | null
    benefit?: string | null
    fileimage?: string | null
    createdate?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
    kategori?: number | null
    em_loktopik?: em_loktopikUncheckedCreateNestedManyWithoutEm_lokerInput
  }

  export type em_lokerUpdateInput = {
    possid?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobdesc?: NullableStringFieldUpdateOperationsInput | string | null
    qualify?: NullableStringFieldUpdateOperationsInput | string | null
    worktype?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    contrtype?: NullableStringFieldUpdateOperationsInput | string | null
    posslevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    em_loktopik?: em_loktopikUpdateManyWithoutEm_lokerNestedInput
  }

  export type em_lokerUncheckedUpdateInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    possid?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobdesc?: NullableStringFieldUpdateOperationsInput | string | null
    qualify?: NullableStringFieldUpdateOperationsInput | string | null
    worktype?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    contrtype?: NullableStringFieldUpdateOperationsInput | string | null
    posslevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    em_loktopik?: em_loktopikUncheckedUpdateManyWithoutEm_lokerNestedInput
  }

  export type em_lokerCreateManyInput = {
    possid: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    jobdesc?: string | null
    qualify?: string | null
    worktype?: string | null
    salary?: string | null
    contrtype?: string | null
    posslevel?: string | null
    status?: string | null
    benefit?: string | null
    fileimage?: string | null
    createdate?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
    kategori?: number | null
  }

  export type em_lokerUpdateManyMutationInput = {
    possid?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobdesc?: NullableStringFieldUpdateOperationsInput | string | null
    qualify?: NullableStringFieldUpdateOperationsInput | string | null
    worktype?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    contrtype?: NullableStringFieldUpdateOperationsInput | string | null
    posslevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_lokerUncheckedUpdateManyInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    possid?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobdesc?: NullableStringFieldUpdateOperationsInput | string | null
    qualify?: NullableStringFieldUpdateOperationsInput | string | null
    worktype?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    contrtype?: NullableStringFieldUpdateOperationsInput | string | null
    posslevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_loktopikCreateInput = {
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
    em_loker: em_lokerCreateNestedOneWithoutEm_loktopikInput
    em_exams: em_examsCreateNestedOneWithoutEm_loktopikInput
  }

  export type em_loktopikUncheckedCreateInput = {
    id?: number
    loker_id: number
    topik_id: number
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
  }

  export type em_loktopikUpdateInput = {
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    em_loker?: em_lokerUpdateOneRequiredWithoutEm_loktopikNestedInput
    em_exams?: em_examsUpdateOneRequiredWithoutEm_loktopikNestedInput
  }

  export type em_loktopikUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loker_id?: IntFieldUpdateOperationsInput | number
    topik_id?: IntFieldUpdateOperationsInput | number
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_loktopikCreateManyInput = {
    loker_id: number
    topik_id: number
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
  }

  export type em_loktopikUpdateManyMutationInput = {
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_loktopikUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loker_id?: IntFieldUpdateOperationsInput | number
    topik_id?: IntFieldUpdateOperationsInput | number
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi_fileCreateInput = {
    file_name: string
    file_type: number
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    judul?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    galeri_id?: number | null
    em_materi1: em_materi1CreateNestedOneWithoutEm_materi_fileInput
  }

  export type em_materi_fileUncheckedCreateInput = {
    id?: number
    materi_id: number
    file_name: string
    file_type: number
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    judul?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    galeri_id?: number | null
  }

  export type em_materi_fileUpdateInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_materi1?: em_materi1UpdateOneRequiredWithoutEm_materi_fileNestedInput
  }

  export type em_materi_fileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi_fileCreateManyInput = {
    materi_id: number
    file_name: string
    file_type: number
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    judul?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    galeri_id?: number | null
  }

  export type em_materi_fileUpdateManyMutationInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi_fileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi_kategoriCreateInput = {
    kategori_nama: string
    kategori_deskripsi?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type em_materi_kategoriUncheckedCreateInput = {
    id?: number
    kategori_nama: string
    kategori_deskripsi?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type em_materi_kategoriUpdateInput = {
    kategori_nama?: StringFieldUpdateOperationsInput | string
    kategori_deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi_kategoriUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kategori_nama?: StringFieldUpdateOperationsInput | string
    kategori_deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi_kategoriCreateManyInput = {
    kategori_nama: string
    kategori_deskripsi?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type em_materi_kategoriUpdateManyMutationInput = {
    kategori_nama?: StringFieldUpdateOperationsInput | string
    kategori_deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi_kategoriUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kategori_nama?: StringFieldUpdateOperationsInput | string
    kategori_deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi_typeCreateInput = {
    materi_name: string
    deskripsi?: string | null
    status?: string | null
    created_at: Date | string
    created_by?: string | null
    lastupdate?: Date | string | null
    em_materi2?: em_materi2CreateNestedManyWithoutEm_materi_typeInput
  }

  export type em_materi_typeUncheckedCreateInput = {
    id?: number
    materi_name: string
    deskripsi?: string | null
    status?: string | null
    created_at: Date | string
    created_by?: string | null
    lastupdate?: Date | string | null
    em_materi2?: em_materi2UncheckedCreateNestedManyWithoutEm_materi_typeInput
  }

  export type em_materi_typeUpdateInput = {
    materi_name?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi2?: em_materi2UpdateManyWithoutEm_materi_typeNestedInput
  }

  export type em_materi_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_name?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi2?: em_materi2UncheckedUpdateManyWithoutEm_materi_typeNestedInput
  }

  export type em_materi_typeCreateManyInput = {
    materi_name: string
    deskripsi?: string | null
    status?: string | null
    created_at: Date | string
    created_by?: string | null
    lastupdate?: Date | string | null
  }

  export type em_materi_typeUpdateManyMutationInput = {
    materi_name?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_name?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi1CreateInput = {
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
    em_materi_file?: em_materi_fileCreateNestedManyWithoutEm_materi1Input
    em_materi2?: em_materi2CreateNestedManyWithoutEm_materi1Input
  }

  export type em_materi1UncheckedCreateInput = {
    id?: number
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
    em_materi_file?: em_materi_fileUncheckedCreateNestedManyWithoutEm_materi1Input
    em_materi2?: em_materi2UncheckedCreateNestedManyWithoutEm_materi1Input
  }

  export type em_materi1UpdateInput = {
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi_file?: em_materi_fileUpdateManyWithoutEm_materi1NestedInput
    em_materi2?: em_materi2UpdateManyWithoutEm_materi1NestedInput
  }

  export type em_materi1UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi_file?: em_materi_fileUncheckedUpdateManyWithoutEm_materi1NestedInput
    em_materi2?: em_materi2UncheckedUpdateManyWithoutEm_materi1NestedInput
  }

  export type em_materi1CreateManyInput = {
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
  }

  export type em_materi1UpdateManyMutationInput = {
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi1UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi2CreateInput = {
    em_materi_type: em_materi_typeCreateNestedOneWithoutEm_materi2Input
    em_materi1: em_materi1CreateNestedOneWithoutEm_materi2Input
  }

  export type em_materi2UncheckedCreateInput = {
    id?: number
    materi_id: number
    materi_type: number
  }

  export type em_materi2UpdateInput = {
    em_materi_type?: em_materi_typeUpdateOneRequiredWithoutEm_materi2NestedInput
    em_materi1?: em_materi1UpdateOneRequiredWithoutEm_materi2NestedInput
  }

  export type em_materi2UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_id?: IntFieldUpdateOperationsInput | number
    materi_type?: IntFieldUpdateOperationsInput | number
  }

  export type em_materi2CreateManyInput = {
    materi_id: number
    materi_type: number
  }

  export type em_materi2UpdateManyMutationInput = {

  }

  export type em_materi2UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_id?: IntFieldUpdateOperationsInput | number
    materi_type?: IntFieldUpdateOperationsInput | number
  }

  export type em_menuCreateInput = {
    id?: number
    menuid: string
    name: string
    parent_id?: string | null
    link?: string | null
    visible: boolean
    status?: string | null
    lastupdate?: Date | string | null
    icon?: string | null
    menutype?: string | null
  }

  export type em_menuUncheckedCreateInput = {
    id?: number
    menuid: string
    name: string
    parent_id?: string | null
    link?: string | null
    visible: boolean
    status?: string | null
    lastupdate?: Date | string | null
    icon?: string | null
    menutype?: string | null
  }

  export type em_menuUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    menutype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_menuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    menutype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_menuCreateManyInput = {
    menuid: string
    name: string
    parent_id?: string | null
    link?: string | null
    visible: boolean
    status?: string | null
    lastupdate?: Date | string | null
    icon?: string | null
    menutype?: string | null
  }

  export type em_menuUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    menutype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_menuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    menutype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_notifikasiCreateInput = {
    UserId?: number | null
    GroupId?: number | null
    Note?: string | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_notifikasiUncheckedCreateInput = {
    NotifyId?: number
    UserId?: number | null
    GroupId?: number | null
    Note?: string | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_notifikasiUpdateInput = {
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasiUncheckedUpdateInput = {
    NotifyId?: IntFieldUpdateOperationsInput | number
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasiCreateManyInput = {
    UserId?: number | null
    GroupId?: number | null
    Note?: string | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_notifikasiUpdateManyMutationInput = {
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasiUncheckedUpdateManyInput = {
    NotifyId?: IntFieldUpdateOperationsInput | number
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasi_readCreateInput = {
    NotifyId?: number | null
    UserId?: number | null
    ReadDate?: Date | string | null
  }

  export type em_notifikasi_readUncheckedCreateInput = {
    ReadId?: number
    NotifyId?: number | null
    UserId?: number | null
    ReadDate?: Date | string | null
  }

  export type em_notifikasi_readUpdateInput = {
    NotifyId?: NullableIntFieldUpdateOperationsInput | number | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    ReadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasi_readUncheckedUpdateInput = {
    ReadId?: IntFieldUpdateOperationsInput | number
    NotifyId?: NullableIntFieldUpdateOperationsInput | number | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    ReadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasi_readCreateManyInput = {
    NotifyId?: number | null
    UserId?: number | null
    ReadDate?: Date | string | null
  }

  export type em_notifikasi_readUpdateManyMutationInput = {
    NotifyId?: NullableIntFieldUpdateOperationsInput | number | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    ReadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_notifikasi_readUncheckedUpdateManyInput = {
    ReadId?: IntFieldUpdateOperationsInput | number
    NotifyId?: NullableIntFieldUpdateOperationsInput | number | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    ReadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_onboardingCreateInput = {
    user_id: number
    status?: string | null
    current_step?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type em_onboardingUncheckedCreateInput = {
    id?: number
    user_id: number
    status?: string | null
    current_step?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type em_onboardingUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    current_step?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_onboardingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    current_step?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_onboardingCreateManyInput = {
    user_id: number
    status?: string | null
    current_step?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type em_onboardingUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    current_step?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_onboardingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    current_step?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_pilarCreateInput = {
    pilar_name: string
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted?: boolean | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_pilarUncheckedCreateInput = {
    id?: number
    pilar_name: string
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted?: boolean | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_pilarUpdateInput = {
    pilar_name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_pilarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pilar_name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_pilarCreateManyInput = {
    pilar_name: string
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted?: boolean | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_pilarUpdateManyMutationInput = {
    pilar_name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_pilarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pilar_name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_profesiCreateInput = {
    profesi_name?: string | null
    status?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_profesiUncheckedCreateInput = {
    profesi_id?: number
    profesi_name?: string | null
    status?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_profesiUpdateInput = {
    profesi_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_profesiUncheckedUpdateInput = {
    profesi_id?: IntFieldUpdateOperationsInput | number
    profesi_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_profesiCreateManyInput = {
    profesi_name?: string | null
    status?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_profesiUpdateManyMutationInput = {
    profesi_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_profesiUncheckedUpdateManyInput = {
    profesi_id?: IntFieldUpdateOperationsInput | number
    profesi_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_questions1CreateInput = {
    question_text: string
    question_type?: number | null
    correct_answer?: string | null
    correct_answer2?: string | null
    exam_id?: number | null
    time_limit: number
    score: number
    status?: string | null
    userid?: string | null
    qdate?: Date | string | null
    lastupdate?: Date | string | null
    fileimage?: string | null
    isExams?: string | null
    isLevel?: number | null
    em_questions2?: em_questions2CreateNestedManyWithoutEm_questions1Input
  }

  export type em_questions1UncheckedCreateInput = {
    id?: number
    question_text: string
    question_type?: number | null
    correct_answer?: string | null
    correct_answer2?: string | null
    exam_id?: number | null
    time_limit: number
    score: number
    status?: string | null
    userid?: string | null
    qdate?: Date | string | null
    lastupdate?: Date | string | null
    fileimage?: string | null
    isExams?: string | null
    isLevel?: number | null
    em_questions2?: em_questions2UncheckedCreateNestedManyWithoutEm_questions1Input
  }

  export type em_questions1UpdateInput = {
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableIntFieldUpdateOperationsInput | number | null
    correct_answer?: NullableStringFieldUpdateOperationsInput | string | null
    correct_answer2?: NullableStringFieldUpdateOperationsInput | string | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    time_limit?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    qdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    isExams?: NullableStringFieldUpdateOperationsInput | string | null
    isLevel?: NullableIntFieldUpdateOperationsInput | number | null
    em_questions2?: em_questions2UpdateManyWithoutEm_questions1NestedInput
  }

  export type em_questions1UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableIntFieldUpdateOperationsInput | number | null
    correct_answer?: NullableStringFieldUpdateOperationsInput | string | null
    correct_answer2?: NullableStringFieldUpdateOperationsInput | string | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    time_limit?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    qdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    isExams?: NullableStringFieldUpdateOperationsInput | string | null
    isLevel?: NullableIntFieldUpdateOperationsInput | number | null
    em_questions2?: em_questions2UncheckedUpdateManyWithoutEm_questions1NestedInput
  }

  export type em_questions1CreateManyInput = {
    question_text: string
    question_type?: number | null
    correct_answer?: string | null
    correct_answer2?: string | null
    exam_id?: number | null
    time_limit: number
    score: number
    status?: string | null
    userid?: string | null
    qdate?: Date | string | null
    lastupdate?: Date | string | null
    fileimage?: string | null
    isExams?: string | null
    isLevel?: number | null
  }

  export type em_questions1UpdateManyMutationInput = {
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableIntFieldUpdateOperationsInput | number | null
    correct_answer?: NullableStringFieldUpdateOperationsInput | string | null
    correct_answer2?: NullableStringFieldUpdateOperationsInput | string | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    time_limit?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    qdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    isExams?: NullableStringFieldUpdateOperationsInput | string | null
    isLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_questions1UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableIntFieldUpdateOperationsInput | number | null
    correct_answer?: NullableStringFieldUpdateOperationsInput | string | null
    correct_answer2?: NullableStringFieldUpdateOperationsInput | string | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    time_limit?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    qdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    isExams?: NullableStringFieldUpdateOperationsInput | string | null
    isLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_questions2CreateInput = {
    Id?: bigint | number
    option_choices: string
    option_text: string
    em_questions1: em_questions1CreateNestedOneWithoutEm_questions2Input
  }

  export type em_questions2UncheckedCreateInput = {
    Id?: bigint | number
    question_id: number
    option_choices: string
    option_text: string
  }

  export type em_questions2UpdateInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
    em_questions1?: em_questions1UpdateOneRequiredWithoutEm_questions2NestedInput
  }

  export type em_questions2UncheckedUpdateInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: IntFieldUpdateOperationsInput | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_questions2CreateManyInput = {
    question_id: number
    option_choices: string
    option_text: string
  }

  export type em_questions2UpdateManyMutationInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_questions2UncheckedUpdateManyInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: IntFieldUpdateOperationsInput | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_questtypeCreateInput = {
    TypeName?: string | null
    Status?: string | null
  }

  export type em_questtypeUncheckedCreateInput = {
    Id?: number
    TypeName?: string | null
    Status?: string | null
  }

  export type em_questtypeUpdateInput = {
    TypeName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_questtypeUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    TypeName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_questtypeCreateManyInput = {
    TypeName?: string | null
    Status?: string | null
  }

  export type em_questtypeUpdateManyMutationInput = {
    TypeName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_questtypeUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    TypeName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_regulationsCreateInput = {
    chanceId?: number | null
    regName?: string | null
    urut?: number | null
    status?: string | null
    userid?: string | null
    createDate?: Date | string | null
    lastUpdate?: Date | string | null
  }

  export type em_regulationsUncheckedCreateInput = {
    Id?: number
    chanceId?: number | null
    regName?: string | null
    urut?: number | null
    status?: string | null
    userid?: string | null
    createDate?: Date | string | null
    lastUpdate?: Date | string | null
  }

  export type em_regulationsUpdateInput = {
    chanceId?: NullableIntFieldUpdateOperationsInput | number | null
    regName?: NullableStringFieldUpdateOperationsInput | string | null
    urut?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_regulationsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    chanceId?: NullableIntFieldUpdateOperationsInput | number | null
    regName?: NullableStringFieldUpdateOperationsInput | string | null
    urut?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_regulationsCreateManyInput = {
    chanceId?: number | null
    regName?: string | null
    urut?: number | null
    status?: string | null
    userid?: string | null
    createDate?: Date | string | null
    lastUpdate?: Date | string | null
  }

  export type em_regulationsUpdateManyMutationInput = {
    chanceId?: NullableIntFieldUpdateOperationsInput | number | null
    regName?: NullableStringFieldUpdateOperationsInput | string | null
    urut?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_regulationsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    chanceId?: NullableIntFieldUpdateOperationsInput | number | null
    regName?: NullableStringFieldUpdateOperationsInput | string | null
    urut?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_sbuCreateInput = {
    id?: number
    sbu_code: string
    sbu_name: string
    sbu_pilar?: number | null
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_sbuUncheckedCreateInput = {
    id?: number
    sbu_code: string
    sbu_name: string
    sbu_pilar?: number | null
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_sbuUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sbu_code?: StringFieldUpdateOperationsInput | string
    sbu_name?: StringFieldUpdateOperationsInput | string
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sbu_code?: StringFieldUpdateOperationsInput | string
    sbu_name?: StringFieldUpdateOperationsInput | string
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbuCreateManyInput = {
    sbu_code: string
    sbu_name: string
    sbu_pilar?: number | null
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_sbuUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    sbu_code?: StringFieldUpdateOperationsInput | string
    sbu_name?: StringFieldUpdateOperationsInput | string
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sbu_code?: StringFieldUpdateOperationsInput | string
    sbu_name?: StringFieldUpdateOperationsInput | string
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbu_subCreateInput = {
    sbu_sub_code: string
    sbu_sub_name: string
    sbu_id?: number | null
    sbu_pilar?: number | null
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_sbu_subUncheckedCreateInput = {
    id?: number
    sbu_sub_code: string
    sbu_sub_name: string
    sbu_id?: number | null
    sbu_pilar?: number | null
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_sbu_subUpdateInput = {
    sbu_sub_code?: StringFieldUpdateOperationsInput | string
    sbu_sub_name?: StringFieldUpdateOperationsInput | string
    sbu_id?: NullableIntFieldUpdateOperationsInput | number | null
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbu_subUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sbu_sub_code?: StringFieldUpdateOperationsInput | string
    sbu_sub_name?: StringFieldUpdateOperationsInput | string
    sbu_id?: NullableIntFieldUpdateOperationsInput | number | null
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbu_subCreateManyInput = {
    sbu_sub_code: string
    sbu_sub_name: string
    sbu_id?: number | null
    sbu_pilar?: number | null
    status: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    isDeleted: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    description?: string | null
    pic?: number | null
  }

  export type em_sbu_subUpdateManyMutationInput = {
    sbu_sub_code?: StringFieldUpdateOperationsInput | string
    sbu_sub_name?: StringFieldUpdateOperationsInput | string
    sbu_id?: NullableIntFieldUpdateOperationsInput | number | null
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_sbu_subUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sbu_sub_code?: StringFieldUpdateOperationsInput | string
    sbu_sub_name?: StringFieldUpdateOperationsInput | string
    sbu_id?: NullableIntFieldUpdateOperationsInput | number | null
    sbu_pilar?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule1CreateInput = {
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule2?: em_schedule2CreateNestedManyWithoutEm_schedule1Input
    em_schedule3?: em_schedule3CreateNestedManyWithoutEm_schedule1Input
    em_schedule4?: em_schedule4CreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1UncheckedCreateInput = {
    Id?: number
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule2?: em_schedule2UncheckedCreateNestedManyWithoutEm_schedule1Input
    em_schedule3?: em_schedule3UncheckedCreateNestedManyWithoutEm_schedule1Input
    em_schedule4?: em_schedule4UncheckedCreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1UpdateInput = {
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule2?: em_schedule2UpdateManyWithoutEm_schedule1NestedInput
    em_schedule3?: em_schedule3UpdateManyWithoutEm_schedule1NestedInput
    em_schedule4?: em_schedule4UpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1UncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule2?: em_schedule2UncheckedUpdateManyWithoutEm_schedule1NestedInput
    em_schedule3?: em_schedule3UncheckedUpdateManyWithoutEm_schedule1NestedInput
    em_schedule4?: em_schedule4UncheckedUpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1CreateManyInput = {
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
  }

  export type em_schedule1UpdateManyMutationInput = {
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule1UncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule2CreateInput = {
    employeeId?: number | null
    Regid?: string | null
    is_send_wa_stats?: number | null
    send_date?: Date | string | null
    is_code_send?: string | null
    em_schedule1?: em_schedule1CreateNestedOneWithoutEm_schedule2Input
  }

  export type em_schedule2UncheckedCreateInput = {
    Id?: number
    scheduleId?: number | null
    employeeId?: number | null
    Regid?: string | null
    is_send_wa_stats?: number | null
    send_date?: Date | string | null
    is_code_send?: string | null
  }

  export type em_schedule2UpdateInput = {
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
    em_schedule1?: em_schedule1UpdateOneWithoutEm_schedule2NestedInput
  }

  export type em_schedule2UncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_schedule2CreateManyInput = {
    scheduleId?: number | null
    employeeId?: number | null
    Regid?: string | null
    is_send_wa_stats?: number | null
    send_date?: Date | string | null
    is_code_send?: string | null
  }

  export type em_schedule2UpdateManyMutationInput = {
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_schedule2UncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_schedule3CreateInput = {
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
    em_schedule1: em_schedule1CreateNestedOneWithoutEm_schedule3Input
  }

  export type em_schedule3UncheckedCreateInput = {
    Id?: number
    scheduleId: number
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
  }

  export type em_schedule3UpdateInput = {
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
    em_schedule1?: em_schedule1UpdateOneRequiredWithoutEm_schedule3NestedInput
  }

  export type em_schedule3UncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
  }

  export type em_schedule3CreateManyInput = {
    scheduleId: number
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
  }

  export type em_schedule3UpdateManyMutationInput = {
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
  }

  export type em_schedule3UncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheduleId?: IntFieldUpdateOperationsInput | number
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
  }

  export type em_schedule4CreateInput = {
    tipeSoal?: number | null
    jumlahSoal?: number | null
    durasiPerTipe?: number | null
    em_schedule1?: em_schedule1CreateNestedOneWithoutEm_schedule4Input
  }

  export type em_schedule4UncheckedCreateInput = {
    Id?: number
    scheduleId?: number | null
    tipeSoal?: number | null
    jumlahSoal?: number | null
    durasiPerTipe?: number | null
  }

  export type em_schedule4UpdateInput = {
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule1?: em_schedule1UpdateOneWithoutEm_schedule4NestedInput
  }

  export type em_schedule4UncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule4CreateManyInput = {
    scheduleId?: number | null
    tipeSoal?: number | null
    jumlahSoal?: number | null
    durasiPerTipe?: number | null
  }

  export type em_schedule4UpdateManyMutationInput = {
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule4UncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    scheduleId?: NullableIntFieldUpdateOperationsInput | number | null
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_session_examsCreateInput = {
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    em_jawaban_peserta?: em_jawaban_pesertaCreateNestedManyWithoutEm_session_examsInput
  }

  export type em_session_examsUncheckedCreateInput = {
    Id?: number
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    em_jawaban_peserta?: em_jawaban_pesertaUncheckedCreateNestedManyWithoutEm_session_examsInput
  }

  export type em_session_examsUpdateInput = {
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    em_jawaban_peserta?: em_jawaban_pesertaUpdateManyWithoutEm_session_examsNestedInput
  }

  export type em_session_examsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    em_jawaban_peserta?: em_jawaban_pesertaUncheckedUpdateManyWithoutEm_session_examsNestedInput
  }

  export type em_session_examsCreateManyInput = {
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
  }

  export type em_session_examsUpdateManyMutationInput = {
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type em_session_examsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type em_session_exams_apcCreateInput = {
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcCreateNestedManyWithoutEm_session_exams_apcInput
    em_topic_selesai?: em_topic_selesaiCreateNestedManyWithoutEm_session_exams_apcInput
  }

  export type em_session_exams_apcUncheckedCreateInput = {
    Id?: number
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcUncheckedCreateNestedManyWithoutEm_session_exams_apcInput
    em_topic_selesai?: em_topic_selesaiUncheckedCreateNestedManyWithoutEm_session_exams_apcInput
  }

  export type em_session_exams_apcUpdateInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcUpdateManyWithoutEm_session_exams_apcNestedInput
    em_topic_selesai?: em_topic_selesaiUpdateManyWithoutEm_session_exams_apcNestedInput
  }

  export type em_session_exams_apcUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcUncheckedUpdateManyWithoutEm_session_exams_apcNestedInput
    em_topic_selesai?: em_topic_selesaiUncheckedUpdateManyWithoutEm_session_exams_apcNestedInput
  }

  export type em_session_exams_apcCreateManyInput = {
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
  }

  export type em_session_exams_apcUpdateManyMutationInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_session_exams_apcUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_subscribeCreateInput = {
    UserId?: string | null
    Name?: string | null
    Status?: string | null
    Endpoint?: string | null
    P256dh?: string | null
    Auth?: string | null
    Created_at?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_subscribeUncheckedCreateInput = {
    Id?: number
    UserId?: string | null
    Name?: string | null
    Status?: string | null
    Endpoint?: string | null
    P256dh?: string | null
    Auth?: string | null
    Created_at?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_subscribeUpdateInput = {
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    P256dh?: NullableStringFieldUpdateOperationsInput | string | null
    Auth?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscribeUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    P256dh?: NullableStringFieldUpdateOperationsInput | string | null
    Auth?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscribeCreateManyInput = {
    UserId?: string | null
    Name?: string | null
    Status?: string | null
    Endpoint?: string | null
    P256dh?: string | null
    Auth?: string | null
    Created_at?: Date | string | null
    LastUpdate?: Date | string | null
  }

  export type em_subscribeUpdateManyMutationInput = {
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    P256dh?: NullableStringFieldUpdateOperationsInput | string | null
    Auth?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscribeUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    P256dh?: NullableStringFieldUpdateOperationsInput | string | null
    Auth?: NullableStringFieldUpdateOperationsInput | string | null
    Created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscriptionCreateInput = {
    username: string
    subscription?: string | null
    status?: string | null
    createdat?: Date | string | null
  }

  export type em_subscriptionUncheckedCreateInput = {
    Id?: number
    username: string
    subscription?: string | null
    status?: string | null
    createdat?: Date | string | null
  }

  export type em_subscriptionUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscriptionUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscriptionCreateManyInput = {
    username: string
    subscription?: string | null
    status?: string | null
    createdat?: Date | string | null
  }

  export type em_subscriptionUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_subscriptionUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_topic_selesaiCreateInput = {
    apc_id: number
    topic_id: number
    selesai_at?: Date | string | null
    em_session_exams_apc: em_session_exams_apcCreateNestedOneWithoutEm_topic_selesaiInput
  }

  export type em_topic_selesaiUncheckedCreateInput = {
    id?: number
    session_exams_id: string
    apc_id: number
    topic_id: number
    selesai_at?: Date | string | null
  }

  export type em_topic_selesaiUpdateInput = {
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_session_exams_apc?: em_session_exams_apcUpdateOneRequiredWithoutEm_topic_selesaiNestedInput
  }

  export type em_topic_selesaiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_exams_id?: StringFieldUpdateOperationsInput | string
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_topic_selesaiCreateManyInput = {
    session_exams_id: string
    apc_id: number
    topic_id: number
    selesai_at?: Date | string | null
  }

  export type em_topic_selesaiUpdateManyMutationInput = {
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_topic_selesaiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_exams_id?: StringFieldUpdateOperationsInput | string
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_answers1CreateInput = {
    apcid: number
    topic_id: number
    status?: string | null
    startdate?: Date | string | null
  }

  export type em_user_answers1UncheckedCreateInput = {
    Id?: number
    apcid: number
    topic_id: number
    status?: string | null
    startdate?: Date | string | null
  }

  export type em_user_answers1UpdateInput = {
    apcid?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_answers1UncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    apcid?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_answers1CreateManyInput = {
    apcid: number
    topic_id: number
    status?: string | null
    startdate?: Date | string | null
  }

  export type em_user_answers1UpdateManyMutationInput = {
    apcid?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_answers1UncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    apcid?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_dashboardCreateInput = {
    Username: string
    Password: string
    FullName?: string | null
    RoleId?: number | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
    GroupId?: number | null
  }

  export type em_user_dashboardUncheckedCreateInput = {
    UserId?: number
    Username: string
    Password: string
    FullName?: string | null
    RoleId?: number | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
    GroupId?: number | null
  }

  export type em_user_dashboardUpdateInput = {
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_user_dashboardUncheckedUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_user_dashboardCreateManyInput = {
    Username: string
    Password: string
    FullName?: string | null
    RoleId?: number | null
    Status?: string | null
    CreateDate?: Date | string | null
    LastUpdate?: Date | string | null
    GroupId?: number | null
  }

  export type em_user_dashboardUpdateManyMutationInput = {
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_user_dashboardUncheckedUpdateManyInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_user_listCreateInput = {
    userid: string
    menuid?: number | null
    visible: boolean
    lastupdate?: Date | string | null
  }

  export type em_user_listUncheckedCreateInput = {
    id?: number
    userid: string
    menuid?: number | null
    visible: boolean
    lastupdate?: Date | string | null
  }

  export type em_user_listUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    menuid?: NullableIntFieldUpdateOperationsInput | number | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_listUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    menuid?: NullableIntFieldUpdateOperationsInput | number | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_listCreateManyInput = {
    userid: string
    menuid?: number | null
    visible: boolean
    lastupdate?: Date | string | null
  }

  export type em_user_listUpdateManyMutationInput = {
    userid?: StringFieldUpdateOperationsInput | string
    menuid?: NullableIntFieldUpdateOperationsInput | number | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_user_listUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    menuid?: NullableIntFieldUpdateOperationsInput | number | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_usersCreateInput = {
    Id?: number
    UserId: string
    Username: string
    Password: string
    LastUpdate?: Date | string | null
    LevelId?: number | null
    Name: string
    Status?: string | null
    imagename?: string | null
    Pass_Access_Menu?: string | null
  }

  export type em_usersUncheckedCreateInput = {
    Id?: number
    UserId: string
    Username: string
    Password: string
    LastUpdate?: Date | string | null
    LevelId?: number | null
    Name: string
    Status?: string | null
    imagename?: string | null
    Pass_Access_Menu?: string | null
  }

  export type em_usersUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LevelId?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    imagename?: NullableStringFieldUpdateOperationsInput | string | null
    Pass_Access_Menu?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_usersUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LevelId?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    imagename?: NullableStringFieldUpdateOperationsInput | string | null
    Pass_Access_Menu?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_usersCreateManyInput = {
    UserId: string
    Username: string
    Password: string
    LastUpdate?: Date | string | null
    LevelId?: number | null
    Name: string
    Status?: string | null
    imagename?: string | null
    Pass_Access_Menu?: string | null
  }

  export type em_usersUpdateManyMutationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LevelId?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    imagename?: NullableStringFieldUpdateOperationsInput | string | null
    Pass_Access_Menu?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_usersUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LevelId?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    imagename?: NullableStringFieldUpdateOperationsInput | string | null
    Pass_Access_Menu?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_verify_linksCreateInput = {
    applicant_id: number
    token?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
    status?: string | null
    useragent?: string | null
    ipaddress?: string | null
    browser?: string | null
    platform?: string | null
    device?: string | null
  }

  export type em_verify_linksUncheckedCreateInput = {
    id?: number
    applicant_id: number
    token?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
    status?: string | null
    useragent?: string | null
    ipaddress?: string | null
    browser?: string | null
    platform?: string | null
    device?: string | null
  }

  export type em_verify_linksUpdateInput = {
    applicant_id?: IntFieldUpdateOperationsInput | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    useragent?: NullableStringFieldUpdateOperationsInput | string | null
    ipaddress?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_verify_linksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: IntFieldUpdateOperationsInput | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    useragent?: NullableStringFieldUpdateOperationsInput | string | null
    ipaddress?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_verify_linksCreateManyInput = {
    applicant_id: number
    token?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
    status?: string | null
    useragent?: string | null
    ipaddress?: string | null
    browser?: string | null
    platform?: string | null
    device?: string | null
  }

  export type em_verify_linksUpdateManyMutationInput = {
    applicant_id?: IntFieldUpdateOperationsInput | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    useragent?: NullableStringFieldUpdateOperationsInput | string | null
    ipaddress?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_verify_linksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: IntFieldUpdateOperationsInput | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    useragent?: NullableStringFieldUpdateOperationsInput | string | null
    ipaddress?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_wa_templatesCreateInput = {
    template_name: string
    template_text: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    status?: string | null
    tpfor?: number | null
  }

  export type em_wa_templatesUncheckedCreateInput = {
    id?: number
    template_name: string
    template_text: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    status?: string | null
    tpfor?: number | null
  }

  export type em_wa_templatesUpdateInput = {
    template_name?: StringFieldUpdateOperationsInput | string
    template_text?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tpfor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_wa_templatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    template_name?: StringFieldUpdateOperationsInput | string
    template_text?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tpfor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_wa_templatesCreateManyInput = {
    template_name: string
    template_text: string
    add_by?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    status?: string | null
    tpfor?: number | null
  }

  export type em_wa_templatesUpdateManyMutationInput = {
    template_name?: StringFieldUpdateOperationsInput | string
    template_text?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tpfor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_wa_templatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    template_name?: StringFieldUpdateOperationsInput | string
    template_text?: StringFieldUpdateOperationsInput | string
    add_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tpfor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_worktypeCreateInput = {
    worktype_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_worktypeUncheckedCreateInput = {
    id?: number
    worktype_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_worktypeUpdateInput = {
    worktype_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_worktypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    worktype_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_worktypeCreateManyInput = {
    worktype_text: string
    status?: string | null
    lastupdate?: Date | string | null
  }

  export type em_worktypeUpdateManyMutationInput = {
    worktype_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_worktypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    worktype_text?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_xquetestCreateInput = {
    q_id: number
    question_text: string
  }

  export type em_xquetestUncheckedCreateInput = {
    ID?: number
    q_id: number
    question_text: string
  }

  export type em_xquetestUpdateInput = {
    q_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_xquetestUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    q_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_xquetestCreateManyInput = {
    q_id: number
    question_text: string
  }

  export type em_xquetestUpdateManyMutationInput = {
    q_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_xquetestUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    q_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
  }

  export type emappCreateInput = {
    AppName?: string | null
    AppPoss?: number | null
    AppWa?: string | null
    AppMail?: string | null
    AppAge?: number | null
    AppJk?: number | null
    AppAddres?: string | null
    AppFakt?: string | null
    AppFileName?: string | null
    AppLastUpdate?: Date | string | null
    AppDate?: Date | string | null
    AppStatus?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    JobsIs?: string | null
    JFStats?: string | null
    LokasiId?: number | null
    scores?: scoresCreateNestedManyWithoutEmappInput
  }

  export type emappUncheckedCreateInput = {
    AppId?: number
    AppName?: string | null
    AppPoss?: number | null
    AppWa?: string | null
    AppMail?: string | null
    AppAge?: number | null
    AppJk?: number | null
    AppAddres?: string | null
    AppFakt?: string | null
    AppFileName?: string | null
    AppLastUpdate?: Date | string | null
    AppDate?: Date | string | null
    AppStatus?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    JobsIs?: string | null
    JFStats?: string | null
    LokasiId?: number | null
    scores?: scoresUncheckedCreateNestedManyWithoutEmappInput
  }

  export type emappUpdateInput = {
    AppName?: NullableStringFieldUpdateOperationsInput | string | null
    AppPoss?: NullableIntFieldUpdateOperationsInput | number | null
    AppWa?: NullableStringFieldUpdateOperationsInput | string | null
    AppMail?: NullableStringFieldUpdateOperationsInput | string | null
    AppAge?: NullableIntFieldUpdateOperationsInput | number | null
    AppJk?: NullableIntFieldUpdateOperationsInput | number | null
    AppAddres?: NullableStringFieldUpdateOperationsInput | string | null
    AppFakt?: NullableStringFieldUpdateOperationsInput | string | null
    AppFileName?: NullableStringFieldUpdateOperationsInput | string | null
    AppLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppStatus?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobsIs?: NullableStringFieldUpdateOperationsInput | string | null
    JFStats?: NullableStringFieldUpdateOperationsInput | string | null
    LokasiId?: NullableIntFieldUpdateOperationsInput | number | null
    scores?: scoresUpdateManyWithoutEmappNestedInput
  }

  export type emappUncheckedUpdateInput = {
    AppId?: IntFieldUpdateOperationsInput | number
    AppName?: NullableStringFieldUpdateOperationsInput | string | null
    AppPoss?: NullableIntFieldUpdateOperationsInput | number | null
    AppWa?: NullableStringFieldUpdateOperationsInput | string | null
    AppMail?: NullableStringFieldUpdateOperationsInput | string | null
    AppAge?: NullableIntFieldUpdateOperationsInput | number | null
    AppJk?: NullableIntFieldUpdateOperationsInput | number | null
    AppAddres?: NullableStringFieldUpdateOperationsInput | string | null
    AppFakt?: NullableStringFieldUpdateOperationsInput | string | null
    AppFileName?: NullableStringFieldUpdateOperationsInput | string | null
    AppLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppStatus?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobsIs?: NullableStringFieldUpdateOperationsInput | string | null
    JFStats?: NullableStringFieldUpdateOperationsInput | string | null
    LokasiId?: NullableIntFieldUpdateOperationsInput | number | null
    scores?: scoresUncheckedUpdateManyWithoutEmappNestedInput
  }

  export type emappCreateManyInput = {
    AppName?: string | null
    AppPoss?: number | null
    AppWa?: string | null
    AppMail?: string | null
    AppAge?: number | null
    AppJk?: number | null
    AppAddres?: string | null
    AppFakt?: string | null
    AppFileName?: string | null
    AppLastUpdate?: Date | string | null
    AppDate?: Date | string | null
    AppStatus?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    JobsIs?: string | null
    JFStats?: string | null
    LokasiId?: number | null
  }

  export type emappUpdateManyMutationInput = {
    AppName?: NullableStringFieldUpdateOperationsInput | string | null
    AppPoss?: NullableIntFieldUpdateOperationsInput | number | null
    AppWa?: NullableStringFieldUpdateOperationsInput | string | null
    AppMail?: NullableStringFieldUpdateOperationsInput | string | null
    AppAge?: NullableIntFieldUpdateOperationsInput | number | null
    AppJk?: NullableIntFieldUpdateOperationsInput | number | null
    AppAddres?: NullableStringFieldUpdateOperationsInput | string | null
    AppFakt?: NullableStringFieldUpdateOperationsInput | string | null
    AppFileName?: NullableStringFieldUpdateOperationsInput | string | null
    AppLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppStatus?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobsIs?: NullableStringFieldUpdateOperationsInput | string | null
    JFStats?: NullableStringFieldUpdateOperationsInput | string | null
    LokasiId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type emappUncheckedUpdateManyInput = {
    AppId?: IntFieldUpdateOperationsInput | number
    AppName?: NullableStringFieldUpdateOperationsInput | string | null
    AppPoss?: NullableIntFieldUpdateOperationsInput | number | null
    AppWa?: NullableStringFieldUpdateOperationsInput | string | null
    AppMail?: NullableStringFieldUpdateOperationsInput | string | null
    AppAge?: NullableIntFieldUpdateOperationsInput | number | null
    AppJk?: NullableIntFieldUpdateOperationsInput | number | null
    AppAddres?: NullableStringFieldUpdateOperationsInput | string | null
    AppFakt?: NullableStringFieldUpdateOperationsInput | string | null
    AppFileName?: NullableStringFieldUpdateOperationsInput | string | null
    AppLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppStatus?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobsIs?: NullableStringFieldUpdateOperationsInput | string | null
    JFStats?: NullableStringFieldUpdateOperationsInput | string | null
    LokasiId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empasswCreateInput = {
    Name?: string | null
    Pass?: string | null
    Level?: number | null
  }

  export type empasswUncheckedCreateInput = {
    Id?: number
    Name?: string | null
    Pass?: string | null
    Level?: number | null
  }

  export type empasswUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Pass?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empasswUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Pass?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empasswCreateManyInput = {
    Name?: string | null
    Pass?: string | null
    Level?: number | null
  }

  export type empasswUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Pass?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empasswUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Pass?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empossCreateInput = {
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
    em_applicant_criteria?: em_applicant_criteriaCreateNestedManyWithoutEmpossInput
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEmpossInput
  }

  export type empossUncheckedCreateInput = {
    Id?: number
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
    em_applicant_criteria?: em_applicant_criteriaUncheckedCreateNestedManyWithoutEmpossInput
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEmpossInput
  }

  export type empossUpdateInput = {
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_applicant_criteria?: em_applicant_criteriaUpdateManyWithoutEmpossNestedInput
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEmpossNestedInput
  }

  export type empossUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_applicant_criteria?: em_applicant_criteriaUncheckedUpdateManyWithoutEmpossNestedInput
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEmpossNestedInput
  }

  export type empossCreateManyInput = {
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
  }

  export type empossUpdateManyMutationInput = {
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type empossUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type faceusersCreateInput = {
    name?: string | null
    fileimage?: string | null
    descriptor?: string | null
    pose?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type faceusersUncheckedCreateInput = {
    Id?: number
    name?: string | null
    fileimage?: string | null
    descriptor?: string | null
    pose?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type faceusersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
    pose?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type faceusersUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
    pose?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type faceusersCreateManyInput = {
    name?: string | null
    fileimage?: string | null
    descriptor?: string | null
    pose?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type faceusersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
    pose?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type faceusersUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
    pose?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type menuCreateInput = {
    name: string
    parent_id?: number | null
    link?: string | null
    visible: boolean
    role?: string | null
  }

  export type menuUncheckedCreateInput = {
    id?: number
    name: string
    parent_id?: number | null
    link?: string | null
    visible: boolean
    role?: string | null
  }

  export type menuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type menuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type menuCreateManyInput = {
    name: string
    parent_id?: number | null
    link?: string | null
    visible: boolean
    role?: string | null
  }

  export type menuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type menuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type scoresCreateInput = {
    total_score: number
    created_at?: Date | string | null
    em_exams: em_examsCreateNestedOneWithoutScoresInput
    emapp: emappCreateNestedOneWithoutScoresInput
  }

  export type scoresUncheckedCreateInput = {
    id?: number
    exam_id: number
    user_id: number
    total_score: number
    created_at?: Date | string | null
  }

  export type scoresUpdateInput = {
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_exams?: em_examsUpdateOneRequiredWithoutScoresNestedInput
    emapp?: emappUpdateOneRequiredWithoutScoresNestedInput
  }

  export type scoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scoresCreateManyInput = {
    exam_id: number
    user_id: number
    total_score: number
    created_at?: Date | string | null
  }

  export type scoresUpdateManyMutationInput = {
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Bytes | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Bytes | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Bytes | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type em_absensiCountOrderByAggregateInput = {
    Id?: SortOrder
    faceId?: SortOrder
    inDate?: SortOrder
    outDate?: SortOrder
    fileImage?: SortOrder
  }

  export type em_absensiAvgOrderByAggregateInput = {
    Id?: SortOrder
    faceId?: SortOrder
  }

  export type em_absensiMaxOrderByAggregateInput = {
    Id?: SortOrder
    faceId?: SortOrder
    inDate?: SortOrder
    outDate?: SortOrder
    fileImage?: SortOrder
  }

  export type em_absensiMinOrderByAggregateInput = {
    Id?: SortOrder
    faceId?: SortOrder
    inDate?: SortOrder
    outDate?: SortOrder
    fileImage?: SortOrder
  }

  export type em_absensiSumOrderByAggregateInput = {
    Id?: SortOrder
    faceId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type Em_apc_personalScalarRelationFilter = {
    is?: em_apc_personalWhereInput
    isNot?: em_apc_personalWhereInput
  }

  export type em_apc_academyCountOrderByAggregateInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    SchoolName?: SortOrder
    Province?: SortOrder
    Major?: SortOrder
    Degree?: SortOrder
    EnrollDate?: SortOrder
    GraduatDate?: SortOrder
    IPK?: SortOrder
    OrganizeExperience?: SortOrder
    Explain?: SortOrder
    GradeSchool?: SortOrder
    DailySchedule?: SortOrder
    SchoolAddress?: SortOrder
  }

  export type em_apc_academyAvgOrderByAggregateInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    IPK?: SortOrder
  }

  export type em_apc_academyMaxOrderByAggregateInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    SchoolName?: SortOrder
    Province?: SortOrder
    Major?: SortOrder
    Degree?: SortOrder
    EnrollDate?: SortOrder
    GraduatDate?: SortOrder
    IPK?: SortOrder
    OrganizeExperience?: SortOrder
    Explain?: SortOrder
    GradeSchool?: SortOrder
    DailySchedule?: SortOrder
    SchoolAddress?: SortOrder
  }

  export type em_apc_academyMinOrderByAggregateInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    SchoolName?: SortOrder
    Province?: SortOrder
    Major?: SortOrder
    Degree?: SortOrder
    EnrollDate?: SortOrder
    GraduatDate?: SortOrder
    IPK?: SortOrder
    OrganizeExperience?: SortOrder
    Explain?: SortOrder
    GradeSchool?: SortOrder
    DailySchedule?: SortOrder
    SchoolAddress?: SortOrder
  }

  export type em_apc_academySumOrderByAggregateInput = {
    AcademyId?: SortOrder
    ApcId?: SortOrder
    IPK?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Em_apc_academyListRelationFilter = {
    every?: em_apc_academyWhereInput
    some?: em_apc_academyWhereInput
    none?: em_apc_academyWhereInput
  }

  export type Em_apc_photographListRelationFilter = {
    every?: em_apc_photographWhereInput
    some?: em_apc_photographWhereInput
    none?: em_apc_photographWhereInput
  }

  export type Em_apc_regulationListRelationFilter = {
    every?: em_apc_regulationWhereInput
    some?: em_apc_regulationWhereInput
    none?: em_apc_regulationWhereInput
  }

  export type Em_apc_skill_experListRelationFilter = {
    every?: em_apc_skill_experWhereInput
    some?: em_apc_skill_experWhereInput
    none?: em_apc_skill_experWhereInput
  }

  export type Em_applicant_matchListRelationFilter = {
    every?: em_applicant_matchWhereInput
    some?: em_applicant_matchWhereInput
    none?: em_applicant_matchWhereInput
  }

  export type em_apc_academyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_apc_photographOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_apc_regulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_apc_skill_experOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_applicant_matchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_apc_personalCountOrderByAggregateInput = {
    ApcId?: SortOrder
    PossId?: SortOrder
    AboutUs?: SortOrder
    FullName?: SortOrder
    NickName?: SortOrder
    PlaceBirth?: SortOrder
    DateBirth?: SortOrder
    Age?: SortOrder
    Gender?: SortOrder
    Religion?: SortOrder
    MaritalStats?: SortOrder
    Citizenship?: SortOrder
    Province?: SortOrder
    Regency?: SortOrder
    Subdistrict?: SortOrder
    PostCode?: SortOrder
    Address?: SortOrder
    IdentityType?: SortOrder
    IdentityNumber?: SortOrder
    PhoneCode?: SortOrder
    PhoneNumber?: SortOrder
    EmailAddress?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    FatherName?: SortOrder
    FatherOccupa?: SortOrder
    MotherName?: SortOrder
    MotherOccupa?: SortOrder
    NumofSibling?: SortOrder
    SiblingNote?: SortOrder
    NikFileName?: SortOrder
    PhotoFileName?: SortOrder
    CvFileName?: SortOrder
    IsTransferPosst?: SortOrder
    Status?: SortOrder
    CreatedAt?: SortOrder
    isHobby?: SortOrder
    LokCat?: SortOrder
    isSosmedId?: SortOrder
    isSosmed?: SortOrder
    IsCall?: SortOrder
    DateCall?: SortOrder
    isLinked?: SortOrder
    PossName?: SortOrder
  }

  export type em_apc_personalAvgOrderByAggregateInput = {
    ApcId?: SortOrder
    PossId?: SortOrder
    Age?: SortOrder
    Gender?: SortOrder
    Religion?: SortOrder
    MaritalStats?: SortOrder
    Citizenship?: SortOrder
    Province?: SortOrder
    Regency?: SortOrder
    Subdistrict?: SortOrder
    PhoneCode?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    NumofSibling?: SortOrder
    LokCat?: SortOrder
    isSosmedId?: SortOrder
    IsCall?: SortOrder
  }

  export type em_apc_personalMaxOrderByAggregateInput = {
    ApcId?: SortOrder
    PossId?: SortOrder
    AboutUs?: SortOrder
    FullName?: SortOrder
    NickName?: SortOrder
    PlaceBirth?: SortOrder
    DateBirth?: SortOrder
    Age?: SortOrder
    Gender?: SortOrder
    Religion?: SortOrder
    MaritalStats?: SortOrder
    Citizenship?: SortOrder
    Province?: SortOrder
    Regency?: SortOrder
    Subdistrict?: SortOrder
    PostCode?: SortOrder
    Address?: SortOrder
    IdentityType?: SortOrder
    IdentityNumber?: SortOrder
    PhoneCode?: SortOrder
    PhoneNumber?: SortOrder
    EmailAddress?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    FatherName?: SortOrder
    FatherOccupa?: SortOrder
    MotherName?: SortOrder
    MotherOccupa?: SortOrder
    NumofSibling?: SortOrder
    SiblingNote?: SortOrder
    NikFileName?: SortOrder
    PhotoFileName?: SortOrder
    CvFileName?: SortOrder
    IsTransferPosst?: SortOrder
    Status?: SortOrder
    CreatedAt?: SortOrder
    isHobby?: SortOrder
    LokCat?: SortOrder
    isSosmedId?: SortOrder
    isSosmed?: SortOrder
    IsCall?: SortOrder
    DateCall?: SortOrder
    isLinked?: SortOrder
    PossName?: SortOrder
  }

  export type em_apc_personalMinOrderByAggregateInput = {
    ApcId?: SortOrder
    PossId?: SortOrder
    AboutUs?: SortOrder
    FullName?: SortOrder
    NickName?: SortOrder
    PlaceBirth?: SortOrder
    DateBirth?: SortOrder
    Age?: SortOrder
    Gender?: SortOrder
    Religion?: SortOrder
    MaritalStats?: SortOrder
    Citizenship?: SortOrder
    Province?: SortOrder
    Regency?: SortOrder
    Subdistrict?: SortOrder
    PostCode?: SortOrder
    Address?: SortOrder
    IdentityType?: SortOrder
    IdentityNumber?: SortOrder
    PhoneCode?: SortOrder
    PhoneNumber?: SortOrder
    EmailAddress?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    FatherName?: SortOrder
    FatherOccupa?: SortOrder
    MotherName?: SortOrder
    MotherOccupa?: SortOrder
    NumofSibling?: SortOrder
    SiblingNote?: SortOrder
    NikFileName?: SortOrder
    PhotoFileName?: SortOrder
    CvFileName?: SortOrder
    IsTransferPosst?: SortOrder
    Status?: SortOrder
    CreatedAt?: SortOrder
    isHobby?: SortOrder
    LokCat?: SortOrder
    isSosmedId?: SortOrder
    isSosmed?: SortOrder
    IsCall?: SortOrder
    DateCall?: SortOrder
    isLinked?: SortOrder
    PossName?: SortOrder
  }

  export type em_apc_personalSumOrderByAggregateInput = {
    ApcId?: SortOrder
    PossId?: SortOrder
    Age?: SortOrder
    Gender?: SortOrder
    Religion?: SortOrder
    MaritalStats?: SortOrder
    Citizenship?: SortOrder
    Province?: SortOrder
    Regency?: SortOrder
    Subdistrict?: SortOrder
    PhoneCode?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    NumofSibling?: SortOrder
    LokCat?: SortOrder
    isSosmedId?: SortOrder
    IsCall?: SortOrder
  }

  export type Em_apc_personalNullableScalarRelationFilter = {
    is?: em_apc_personalWhereInput | null
    isNot?: em_apc_personalWhereInput | null
  }

  export type em_apc_photographCountOrderByAggregateInput = {
    Id?: SortOrder
    ApcId?: SortOrder
    GenrName?: SortOrder
  }

  export type em_apc_photographAvgOrderByAggregateInput = {
    Id?: SortOrder
    ApcId?: SortOrder
  }

  export type em_apc_photographMaxOrderByAggregateInput = {
    Id?: SortOrder
    ApcId?: SortOrder
    GenrName?: SortOrder
  }

  export type em_apc_photographMinOrderByAggregateInput = {
    Id?: SortOrder
    ApcId?: SortOrder
    GenrName?: SortOrder
  }

  export type em_apc_photographSumOrderByAggregateInput = {
    Id?: SortOrder
    ApcId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type em_apc_regulationCountOrderByAggregateInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrder
    RegId?: SortOrder
    RegChoice?: SortOrder
  }

  export type em_apc_regulationAvgOrderByAggregateInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrder
    RegId?: SortOrder
  }

  export type em_apc_regulationMaxOrderByAggregateInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrder
    RegId?: SortOrder
    RegChoice?: SortOrder
  }

  export type em_apc_regulationMinOrderByAggregateInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrder
    RegId?: SortOrder
    RegChoice?: SortOrder
  }

  export type em_apc_regulationSumOrderByAggregateInput = {
    ApcRegId?: SortOrder
    ApcId?: SortOrder
    RegId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type em_apc_skill_experCountOrderByAggregateInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    CompanyName?: SortOrder
    Province?: SortOrder
    JobTitle?: SortOrder
    Salary?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Responsibilities?: SortOrder
    CareerGoals?: SortOrder
    WhyJoin?: SortOrder
    IsFriend?: SortOrder
    IsMentions?: SortOrder
    IsCompProgram?: SortOrder
    IsIllnes?: SortOrder
    HaveCriminal?: SortOrder
    WhenWork?: SortOrder
    ExpectedSalary?: SortOrder
    isContribution?: SortOrder
    isDuration?: SortOrder
    isAgency?: SortOrder
    isExprn?: SortOrder
    isGenre?: SortOrder
    isRelevan?: SortOrder
    isSpesialSkill?: SortOrder
    isShoot?: SortOrder
    isSchedl?: SortOrder
    isMotivation?: SortOrder
    isStress?: SortOrder
    isLongExpr?: SortOrder
    isPhotTools?: SortOrder
    isChalleng?: SortOrder
    isThreeYears?: SortOrder
    PersonVal?: SortOrder
  }

  export type em_apc_skill_experAvgOrderByAggregateInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    Salary?: SortOrder
    ExpectedSalary?: SortOrder
  }

  export type em_apc_skill_experMaxOrderByAggregateInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    CompanyName?: SortOrder
    Province?: SortOrder
    JobTitle?: SortOrder
    Salary?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Responsibilities?: SortOrder
    CareerGoals?: SortOrder
    WhyJoin?: SortOrder
    IsFriend?: SortOrder
    IsMentions?: SortOrder
    IsCompProgram?: SortOrder
    IsIllnes?: SortOrder
    HaveCriminal?: SortOrder
    WhenWork?: SortOrder
    ExpectedSalary?: SortOrder
    isContribution?: SortOrder
    isDuration?: SortOrder
    isAgency?: SortOrder
    isExprn?: SortOrder
    isGenre?: SortOrder
    isRelevan?: SortOrder
    isSpesialSkill?: SortOrder
    isShoot?: SortOrder
    isSchedl?: SortOrder
    isMotivation?: SortOrder
    isStress?: SortOrder
    isLongExpr?: SortOrder
    isPhotTools?: SortOrder
    isChalleng?: SortOrder
    isThreeYears?: SortOrder
    PersonVal?: SortOrder
  }

  export type em_apc_skill_experMinOrderByAggregateInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    CompanyName?: SortOrder
    Province?: SortOrder
    JobTitle?: SortOrder
    Salary?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Responsibilities?: SortOrder
    CareerGoals?: SortOrder
    WhyJoin?: SortOrder
    IsFriend?: SortOrder
    IsMentions?: SortOrder
    IsCompProgram?: SortOrder
    IsIllnes?: SortOrder
    HaveCriminal?: SortOrder
    WhenWork?: SortOrder
    ExpectedSalary?: SortOrder
    isContribution?: SortOrder
    isDuration?: SortOrder
    isAgency?: SortOrder
    isExprn?: SortOrder
    isGenre?: SortOrder
    isRelevan?: SortOrder
    isSpesialSkill?: SortOrder
    isShoot?: SortOrder
    isSchedl?: SortOrder
    isMotivation?: SortOrder
    isStress?: SortOrder
    isLongExpr?: SortOrder
    isPhotTools?: SortOrder
    isChalleng?: SortOrder
    isThreeYears?: SortOrder
    PersonVal?: SortOrder
  }

  export type em_apc_skill_experSumOrderByAggregateInput = {
    SkillId?: SortOrder
    ApcId?: SortOrder
    Salary?: SortOrder
    ExpectedSalary?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type em_api_keysCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    api_key?: SortOrder
    created_at?: SortOrder
  }

  export type em_api_keysAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_api_keysMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    api_key?: SortOrder
    created_at?: SortOrder
  }

  export type em_api_keysMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    api_key?: SortOrder
    created_at?: SortOrder
  }

  export type em_api_keysSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EmpossScalarRelationFilter = {
    is?: empossWhereInput
    isNot?: empossWhereInput
  }

  export type em_applicant_criteriaCountOrderByAggregateInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    jenis_kriteria?: SortOrder
    value?: SortOrder
    value_en?: SortOrder
    bobot?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_applicant_criteriaAvgOrderByAggregateInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    bobot?: SortOrder
  }

  export type em_applicant_criteriaMaxOrderByAggregateInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    jenis_kriteria?: SortOrder
    value?: SortOrder
    value_en?: SortOrder
    bobot?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_applicant_criteriaMinOrderByAggregateInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    jenis_kriteria?: SortOrder
    value?: SortOrder
    value_en?: SortOrder
    bobot?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_applicant_criteriaSumOrderByAggregateInput = {
    id_kriteria?: SortOrder
    id_loker?: SortOrder
    bobot?: SortOrder
  }

  export type em_applicant_matchCountOrderByAggregateInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrder
    jurusan_score?: SortOrder
    pengalaman_score?: SortOrder
    skill_score?: SortOrder
    bahasa_score?: SortOrder
    usia_score?: SortOrder
    total_score?: SortOrder
    total_kriteria?: SortOrder
    scoring_json?: SortOrder
    created_at?: SortOrder
  }

  export type em_applicant_matchAvgOrderByAggregateInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrder
    jurusan_score?: SortOrder
    pengalaman_score?: SortOrder
    skill_score?: SortOrder
    bahasa_score?: SortOrder
    usia_score?: SortOrder
    total_score?: SortOrder
    total_kriteria?: SortOrder
  }

  export type em_applicant_matchMaxOrderByAggregateInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrder
    jurusan_score?: SortOrder
    pengalaman_score?: SortOrder
    skill_score?: SortOrder
    bahasa_score?: SortOrder
    usia_score?: SortOrder
    total_score?: SortOrder
    total_kriteria?: SortOrder
    scoring_json?: SortOrder
    created_at?: SortOrder
  }

  export type em_applicant_matchMinOrderByAggregateInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrder
    jurusan_score?: SortOrder
    pengalaman_score?: SortOrder
    skill_score?: SortOrder
    bahasa_score?: SortOrder
    usia_score?: SortOrder
    total_score?: SortOrder
    total_kriteria?: SortOrder
    scoring_json?: SortOrder
    created_at?: SortOrder
  }

  export type em_applicant_matchSumOrderByAggregateInput = {
    id_match?: SortOrder
    id_applicant?: SortOrder
    id_loker?: SortOrder
    pendidikan_score?: SortOrder
    jurusan_score?: SortOrder
    pengalaman_score?: SortOrder
    skill_score?: SortOrder
    bahasa_score?: SortOrder
    usia_score?: SortOrder
    total_score?: SortOrder
    total_kriteria?: SortOrder
  }

  export type em_bannerCountOrderByAggregateInput = {
    Id?: SortOrder
    bannerName?: SortOrder
    fileName?: SortOrder
    menuName?: SortOrder
    noUrut?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    last_update?: SortOrder
    userid?: SortOrder
  }

  export type em_bannerAvgOrderByAggregateInput = {
    Id?: SortOrder
    noUrut?: SortOrder
  }

  export type em_bannerMaxOrderByAggregateInput = {
    Id?: SortOrder
    bannerName?: SortOrder
    fileName?: SortOrder
    menuName?: SortOrder
    noUrut?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    last_update?: SortOrder
    userid?: SortOrder
  }

  export type em_bannerMinOrderByAggregateInput = {
    Id?: SortOrder
    bannerName?: SortOrder
    fileName?: SortOrder
    menuName?: SortOrder
    noUrut?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    last_update?: SortOrder
    userid?: SortOrder
  }

  export type em_bannerSumOrderByAggregateInput = {
    Id?: SortOrder
    noUrut?: SortOrder
  }

  export type em_career_contactCountOrderByAggregateInput = {
    cpId?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    waNumber?: SortOrder
    fileImage?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
  }

  export type em_career_contactAvgOrderByAggregateInput = {
    cpId?: SortOrder
  }

  export type em_career_contactMaxOrderByAggregateInput = {
    cpId?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    waNumber?: SortOrder
    fileImage?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
  }

  export type em_career_contactMinOrderByAggregateInput = {
    cpId?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    waNumber?: SortOrder
    fileImage?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
  }

  export type em_career_contactSumOrderByAggregateInput = {
    cpId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Em_certificate_templatesScalarRelationFilter = {
    is?: em_certificate_templatesWhereInput
    isNot?: em_certificate_templatesWhereInput
  }

  export type em_certificate_fieldsIdCertificate_idCompoundUniqueInput = {
    id: number
    certificate_id: number
  }

  export type em_certificate_fieldsCountOrderByAggregateInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_text?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
    align?: SortOrder
    font_family?: SortOrder
    font_style?: SortOrder
    font_weight?: SortOrder
    font_color?: SortOrder
    created_date?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_certificate_fieldsAvgOrderByAggregateInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
  }

  export type em_certificate_fieldsMaxOrderByAggregateInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_text?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
    align?: SortOrder
    font_family?: SortOrder
    font_style?: SortOrder
    font_weight?: SortOrder
    font_color?: SortOrder
    created_date?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_certificate_fieldsMinOrderByAggregateInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_text?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
    align?: SortOrder
    font_family?: SortOrder
    font_style?: SortOrder
    font_weight?: SortOrder
    font_color?: SortOrder
    created_date?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_certificate_fieldsSumOrderByAggregateInput = {
    id?: SortOrder
    certificate_id?: SortOrder
    is_left?: SortOrder
    is_top?: SortOrder
    text_width?: SortOrder
    text_height?: SortOrder
    font_size?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Em_certificate_fieldsListRelationFilter = {
    every?: em_certificate_fieldsWhereInput
    some?: em_certificate_fieldsWhereInput
    none?: em_certificate_fieldsWhereInput
  }

  export type em_certificate_fieldsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_certificate_templatesCountOrderByAggregateInput = {
    certificate_id?: SortOrder
    name?: SortOrder
    background_image?: SortOrder
    created_at?: SortOrder
    certificate_name?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_certificate_templatesAvgOrderByAggregateInput = {
    certificate_id?: SortOrder
  }

  export type em_certificate_templatesMaxOrderByAggregateInput = {
    certificate_id?: SortOrder
    name?: SortOrder
    background_image?: SortOrder
    created_at?: SortOrder
    certificate_name?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_certificate_templatesMinOrderByAggregateInput = {
    certificate_id?: SortOrder
    name?: SortOrder
    background_image?: SortOrder
    created_at?: SortOrder
    certificate_name?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_certificate_templatesSumOrderByAggregateInput = {
    certificate_id?: SortOrder
  }

  export type em_certificates_resultCountOrderByAggregateInput = {
    cert_number?: SortOrder
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    cert_name?: SortOrder
    created_date?: SortOrder
    status?: SortOrder
    generated_by?: SortOrder
    schedule_id?: SortOrder
  }

  export type em_certificates_resultAvgOrderByAggregateInput = {
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    schedule_id?: SortOrder
  }

  export type em_certificates_resultMaxOrderByAggregateInput = {
    cert_number?: SortOrder
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    cert_name?: SortOrder
    created_date?: SortOrder
    status?: SortOrder
    generated_by?: SortOrder
    schedule_id?: SortOrder
  }

  export type em_certificates_resultMinOrderByAggregateInput = {
    cert_number?: SortOrder
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    cert_name?: SortOrder
    created_date?: SortOrder
    status?: SortOrder
    generated_by?: SortOrder
    schedule_id?: SortOrder
  }

  export type em_certificates_resultSumOrderByAggregateInput = {
    cert_templ_id?: SortOrder
    empl_id?: SortOrder
    schedule_id?: SortOrder
  }

  export type em_chanceCountOrderByAggregateInput = {
    chId?: SortOrder
    chName?: SortOrder
    chDesc?: SortOrder
    chStats?: SortOrder
    chFileImage?: SortOrder
    chLink?: SortOrder
    chUserid?: SortOrder
    chDate?: SortOrder
    chLastupdate?: SortOrder
  }

  export type em_chanceAvgOrderByAggregateInput = {
    chId?: SortOrder
  }

  export type em_chanceMaxOrderByAggregateInput = {
    chId?: SortOrder
    chName?: SortOrder
    chDesc?: SortOrder
    chStats?: SortOrder
    chFileImage?: SortOrder
    chLink?: SortOrder
    chUserid?: SortOrder
    chDate?: SortOrder
    chLastupdate?: SortOrder
  }

  export type em_chanceMinOrderByAggregateInput = {
    chId?: SortOrder
    chName?: SortOrder
    chDesc?: SortOrder
    chStats?: SortOrder
    chFileImage?: SortOrder
    chLink?: SortOrder
    chUserid?: SortOrder
    chDate?: SortOrder
    chLastupdate?: SortOrder
  }

  export type em_chanceSumOrderByAggregateInput = {
    chId?: SortOrder
  }

  export type em_contrctypeCountOrderByAggregateInput = {
    id?: SortOrder
    contract_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_contrctypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_contrctypeMaxOrderByAggregateInput = {
    id?: SortOrder
    contract_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_contrctypeMinOrderByAggregateInput = {
    id?: SortOrder
    contract_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_contrctypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_deptCountOrderByAggregateInput = {
    DEPTID?: SortOrder
    DEPTNAME?: SortOrder
    sbu_sub?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_deptAvgOrderByAggregateInput = {
    DEPTID?: SortOrder
    sbu_sub?: SortOrder
  }

  export type em_deptMaxOrderByAggregateInput = {
    DEPTID?: SortOrder
    DEPTNAME?: SortOrder
    sbu_sub?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_deptMinOrderByAggregateInput = {
    DEPTID?: SortOrder
    DEPTNAME?: SortOrder
    sbu_sub?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_deptSumOrderByAggregateInput = {
    DEPTID?: SortOrder
    sbu_sub?: SortOrder
  }

  export type em_employeeCountOrderByAggregateInput = {
    UserId?: SortOrder
    BadgeNum?: SortOrder
    Name?: SortOrder
    Gender?: SortOrder
    BirthDay?: SortOrder
    HireDay?: SortOrder
    Street?: SortOrder
    Religion?: SortOrder
    Tipe?: SortOrder
    isLokasi?: SortOrder
    Phone?: SortOrder
    DeptId?: SortOrder
    Password?: SortOrder
    CardNo?: SortOrder
    Shift?: SortOrder
    isMem?: SortOrder
    AddBy?: SortOrder
    Created_at?: SortOrder
    Lastupdate?: SortOrder
    isMemDate?: SortOrder
    isFirstLogin?: SortOrder
    ImgName?: SortOrder
    SbuSub?: SortOrder
    Nik?: SortOrder
    ResignDate?: SortOrder
    status?: SortOrder
  }

  export type em_employeeAvgOrderByAggregateInput = {
    UserId?: SortOrder
    DeptId?: SortOrder
    Shift?: SortOrder
    isFirstLogin?: SortOrder
    SbuSub?: SortOrder
  }

  export type em_employeeMaxOrderByAggregateInput = {
    UserId?: SortOrder
    BadgeNum?: SortOrder
    Name?: SortOrder
    Gender?: SortOrder
    BirthDay?: SortOrder
    HireDay?: SortOrder
    Street?: SortOrder
    Religion?: SortOrder
    Tipe?: SortOrder
    isLokasi?: SortOrder
    Phone?: SortOrder
    DeptId?: SortOrder
    Password?: SortOrder
    CardNo?: SortOrder
    Shift?: SortOrder
    isMem?: SortOrder
    AddBy?: SortOrder
    Created_at?: SortOrder
    Lastupdate?: SortOrder
    isMemDate?: SortOrder
    isFirstLogin?: SortOrder
    ImgName?: SortOrder
    SbuSub?: SortOrder
    Nik?: SortOrder
    ResignDate?: SortOrder
    status?: SortOrder
  }

  export type em_employeeMinOrderByAggregateInput = {
    UserId?: SortOrder
    BadgeNum?: SortOrder
    Name?: SortOrder
    Gender?: SortOrder
    BirthDay?: SortOrder
    HireDay?: SortOrder
    Street?: SortOrder
    Religion?: SortOrder
    Tipe?: SortOrder
    isLokasi?: SortOrder
    Phone?: SortOrder
    DeptId?: SortOrder
    Password?: SortOrder
    CardNo?: SortOrder
    Shift?: SortOrder
    isMem?: SortOrder
    AddBy?: SortOrder
    Created_at?: SortOrder
    Lastupdate?: SortOrder
    isMemDate?: SortOrder
    isFirstLogin?: SortOrder
    ImgName?: SortOrder
    SbuSub?: SortOrder
    Nik?: SortOrder
    ResignDate?: SortOrder
    status?: SortOrder
  }

  export type em_employeeSumOrderByAggregateInput = {
    UserId?: SortOrder
    DeptId?: SortOrder
    Shift?: SortOrder
    isFirstLogin?: SortOrder
    SbuSub?: SortOrder
  }

  export type Em_event2ListRelationFilter = {
    every?: em_event2WhereInput
    some?: em_event2WhereInput
    none?: em_event2WhereInput
  }

  export type em_event2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_eventCountOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    lokasi?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_eventAvgOrderByAggregateInput = {
    event_id?: SortOrder
  }

  export type em_eventMaxOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    lokasi?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_eventMinOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    lokasi?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_eventSumOrderByAggregateInput = {
    event_id?: SortOrder
  }

  export type em_event_regCountOrderByAggregateInput = {
    Regid?: SortOrder
    name?: SortOrder
    optic_name?: SortOrder
    password?: SortOrder
    wa_num?: SortOrder
    email?: SortOrder
    profesi_id?: SortOrder
    event_id?: SortOrder
    status?: SortOrder
    first_login?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
    image_name?: SortOrder
  }

  export type em_event_regAvgOrderByAggregateInput = {
    Regid?: SortOrder
    profesi_id?: SortOrder
    event_id?: SortOrder
  }

  export type em_event_regMaxOrderByAggregateInput = {
    Regid?: SortOrder
    name?: SortOrder
    optic_name?: SortOrder
    password?: SortOrder
    wa_num?: SortOrder
    email?: SortOrder
    profesi_id?: SortOrder
    event_id?: SortOrder
    status?: SortOrder
    first_login?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
    image_name?: SortOrder
  }

  export type em_event_regMinOrderByAggregateInput = {
    Regid?: SortOrder
    name?: SortOrder
    optic_name?: SortOrder
    password?: SortOrder
    wa_num?: SortOrder
    email?: SortOrder
    profesi_id?: SortOrder
    event_id?: SortOrder
    status?: SortOrder
    first_login?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
    image_name?: SortOrder
  }

  export type em_event_regSumOrderByAggregateInput = {
    Regid?: SortOrder
    profesi_id?: SortOrder
    event_id?: SortOrder
  }

  export type Em_eventNullableScalarRelationFilter = {
    is?: em_eventWhereInput | null
    isNot?: em_eventWhereInput | null
  }

  export type em_event2CountOrderByAggregateInput = {
    sess_id?: SortOrder
    event_id?: SortOrder
    event_name?: SortOrder
    status?: SortOrder
    qr_code?: SortOrder
  }

  export type em_event2AvgOrderByAggregateInput = {
    sess_id?: SortOrder
    event_id?: SortOrder
  }

  export type em_event2MaxOrderByAggregateInput = {
    sess_id?: SortOrder
    event_id?: SortOrder
    event_name?: SortOrder
    status?: SortOrder
    qr_code?: SortOrder
  }

  export type em_event2MinOrderByAggregateInput = {
    sess_id?: SortOrder
    event_id?: SortOrder
    event_name?: SortOrder
    status?: SortOrder
    qr_code?: SortOrder
  }

  export type em_event2SumOrderByAggregateInput = {
    sess_id?: SortOrder
    event_id?: SortOrder
  }

  export type em_exam_questionsCountOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
  }

  export type em_exam_questionsAvgOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
  }

  export type em_exam_questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
  }

  export type em_exam_questionsMinOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
  }

  export type em_exam_questionsSumOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    question_id?: SortOrder
  }

  export type Em_loktopikListRelationFilter = {
    every?: em_loktopikWhereInput
    some?: em_loktopikWhereInput
    none?: em_loktopikWhereInput
  }

  export type ScoresListRelationFilter = {
    every?: scoresWhereInput
    some?: scoresWhereInput
    none?: scoresWhereInput
  }

  export type em_loktopikOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type scoresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_examsCountOrderByAggregateInput = {
    id?: SortOrder
    exam_name?: SortOrder
    UserId?: SortOrder
    Status?: SortOrder
    LastUpdate?: SortOrder
    Deskripsi?: SortOrder
    FileImage?: SortOrder
    CatType?: SortOrder
  }

  export type em_examsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_examsMaxOrderByAggregateInput = {
    id?: SortOrder
    exam_name?: SortOrder
    UserId?: SortOrder
    Status?: SortOrder
    LastUpdate?: SortOrder
    Deskripsi?: SortOrder
    FileImage?: SortOrder
    CatType?: SortOrder
  }

  export type em_examsMinOrderByAggregateInput = {
    id?: SortOrder
    exam_name?: SortOrder
    UserId?: SortOrder
    Status?: SortOrder
    LastUpdate?: SortOrder
    Deskripsi?: SortOrder
    FileImage?: SortOrder
    CatType?: SortOrder
  }

  export type em_examsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type em_exams_monitorCountOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    tipe_soal?: SortOrder
    jumlah_soal?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type em_exams_monitorAvgOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    empl_id?: SortOrder
    jumlah_soal?: SortOrder
  }

  export type em_exams_monitorMaxOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    tipe_soal?: SortOrder
    jumlah_soal?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type em_exams_monitorMinOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    tipe_soal?: SortOrder
    jumlah_soal?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type em_exams_monitorSumOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    empl_id?: SortOrder
    jumlah_soal?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type em_exams_resultsCountOrderByAggregateInput = {
    Id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    is_changes?: SortOrder
    is_answer?: SortOrder
    is_time?: SortOrder
  }

  export type em_exams_resultsAvgOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    is_changes?: SortOrder
  }

  export type em_exams_resultsMaxOrderByAggregateInput = {
    Id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    is_changes?: SortOrder
    is_answer?: SortOrder
    is_time?: SortOrder
  }

  export type em_exams_resultsMinOrderByAggregateInput = {
    Id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    is_changes?: SortOrder
    is_answer?: SortOrder
    is_time?: SortOrder
  }

  export type em_exams_resultsSumOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    is_changes?: SortOrder
  }

  export type Em_faq_catNullableScalarRelationFilter = {
    is?: em_faq_catWhereInput | null
    isNot?: em_faq_catWhereInput | null
  }

  export type em_faqCountOrderByAggregateInput = {
    fqId?: SortOrder
    fqcatid?: SortOrder
    isquestions?: SortOrder
    isanswer?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
  }

  export type em_faqAvgOrderByAggregateInput = {
    fqId?: SortOrder
    fqcatid?: SortOrder
  }

  export type em_faqMaxOrderByAggregateInput = {
    fqId?: SortOrder
    fqcatid?: SortOrder
    isquestions?: SortOrder
    isanswer?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
  }

  export type em_faqMinOrderByAggregateInput = {
    fqId?: SortOrder
    fqcatid?: SortOrder
    isquestions?: SortOrder
    isanswer?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
  }

  export type em_faqSumOrderByAggregateInput = {
    fqId?: SortOrder
    fqcatid?: SortOrder
  }

  export type Em_faqListRelationFilter = {
    every?: em_faqWhereInput
    some?: em_faqWhereInput
    none?: em_faqWhereInput
  }

  export type em_faqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_faq_catCountOrderByAggregateInput = {
    fqcatid?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_faq_catAvgOrderByAggregateInput = {
    fqcatid?: SortOrder
  }

  export type em_faq_catMaxOrderByAggregateInput = {
    fqcatid?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_faq_catMinOrderByAggregateInput = {
    fqcatid?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_faq_catSumOrderByAggregateInput = {
    fqcatid?: SortOrder
  }

  export type em_galeri_materiCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    file_type?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    url?: SortOrder
    urutan?: SortOrder
    status?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_galeri_materiAvgOrderByAggregateInput = {
    id?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    urutan?: SortOrder
  }

  export type em_galeri_materiMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    file_type?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    url?: SortOrder
    urutan?: SortOrder
    status?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_galeri_materiMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    file_type?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    url?: SortOrder
    urutan?: SortOrder
    status?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_galeri_materiSumOrderByAggregateInput = {
    id?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    urutan?: SortOrder
  }

  export type em_groupCountOrderByAggregateInput = {
    GroupId?: SortOrder
    GroupName?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_groupAvgOrderByAggregateInput = {
    GroupId?: SortOrder
  }

  export type em_groupMaxOrderByAggregateInput = {
    GroupId?: SortOrder
    GroupName?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_groupMinOrderByAggregateInput = {
    GroupId?: SortOrder
    GroupName?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_groupSumOrderByAggregateInput = {
    GroupId?: SortOrder
  }

  export type em_hero_sectionCountOrderByAggregateInput = {
    hsId?: SortOrder
    hsName?: SortOrder
    hsDesc?: SortOrder
    hsStats?: SortOrder
    hsFileImage?: SortOrder
    hsLink?: SortOrder
    hsUserid?: SortOrder
    hsDate?: SortOrder
    hsLastupdate?: SortOrder
    Urutan?: SortOrder
  }

  export type em_hero_sectionAvgOrderByAggregateInput = {
    hsId?: SortOrder
    Urutan?: SortOrder
  }

  export type em_hero_sectionMaxOrderByAggregateInput = {
    hsId?: SortOrder
    hsName?: SortOrder
    hsDesc?: SortOrder
    hsStats?: SortOrder
    hsFileImage?: SortOrder
    hsLink?: SortOrder
    hsUserid?: SortOrder
    hsDate?: SortOrder
    hsLastupdate?: SortOrder
    Urutan?: SortOrder
  }

  export type em_hero_sectionMinOrderByAggregateInput = {
    hsId?: SortOrder
    hsName?: SortOrder
    hsDesc?: SortOrder
    hsStats?: SortOrder
    hsFileImage?: SortOrder
    hsLink?: SortOrder
    hsUserid?: SortOrder
    hsDate?: SortOrder
    hsLastupdate?: SortOrder
    Urutan?: SortOrder
  }

  export type em_hero_sectionSumOrderByAggregateInput = {
    hsId?: SortOrder
    Urutan?: SortOrder
  }

  export type Em_session_examsScalarRelationFilter = {
    is?: em_session_examsWhereInput
    isNot?: em_session_examsWhereInput
  }

  export type em_jawaban_pesertaIdEmpl_idSoal_idSession_exams_idCompoundUniqueInput = {
    Id: number
    empl_id: number
    soal_id: number
    session_exams_id: string
  }

  export type em_jawaban_pesertaCountOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban?: SortOrder
    jawaban2?: SortOrder
    waktu_jawab?: SortOrder
    Score?: SortOrder
    is_correction?: SortOrder
    is_train_jawaban?: SortOrder
  }

  export type em_jawaban_pesertaAvgOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    Score?: SortOrder
    is_correction?: SortOrder
  }

  export type em_jawaban_pesertaMaxOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban?: SortOrder
    jawaban2?: SortOrder
    waktu_jawab?: SortOrder
    Score?: SortOrder
    is_correction?: SortOrder
    is_train_jawaban?: SortOrder
  }

  export type em_jawaban_pesertaMinOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban?: SortOrder
    jawaban2?: SortOrder
    waktu_jawab?: SortOrder
    Score?: SortOrder
    is_correction?: SortOrder
    is_train_jawaban?: SortOrder
  }

  export type em_jawaban_pesertaSumOrderByAggregateInput = {
    Id?: SortOrder
    empl_id?: SortOrder
    soal_id?: SortOrder
    Score?: SortOrder
    is_correction?: SortOrder
  }

  export type Em_session_exams_apcScalarRelationFilter = {
    is?: em_session_exams_apcWhereInput
    isNot?: em_session_exams_apcWhereInput
  }

  export type em_jawaban_peserta_apcCountOrderByAggregateInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban_option?: SortOrder
    jawaban_text?: SortOrder
    waktu_jawab?: SortOrder
    score?: SortOrder
    is_correction?: SortOrder
    is_train_jawaban?: SortOrder
  }

  export type em_jawaban_peserta_apcAvgOrderByAggregateInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    score?: SortOrder
  }

  export type em_jawaban_peserta_apcMaxOrderByAggregateInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban_option?: SortOrder
    jawaban_text?: SortOrder
    waktu_jawab?: SortOrder
    score?: SortOrder
    is_correction?: SortOrder
    is_train_jawaban?: SortOrder
  }

  export type em_jawaban_peserta_apcMinOrderByAggregateInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    session_exams_id?: SortOrder
    jawaban_option?: SortOrder
    jawaban_text?: SortOrder
    waktu_jawab?: SortOrder
    score?: SortOrder
    is_correction?: SortOrder
    is_train_jawaban?: SortOrder
  }

  export type em_jawaban_peserta_apcSumOrderByAggregateInput = {
    Id?: SortOrder
    apc_id?: SortOrder
    soal_id?: SortOrder
    topic_id?: SortOrder
    score?: SortOrder
  }

  export type em_jobfairCountOrderByAggregateInput = {
    id?: SortOrder
    lokasi?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_jobfairAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_jobfairMaxOrderByAggregateInput = {
    id?: SortOrder
    lokasi?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_jobfairMinOrderByAggregateInput = {
    id?: SortOrder
    lokasi?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_jobfairSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_levelpossCountOrderByAggregateInput = {
    id?: SortOrder
    level_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_levelpossAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_levelpossMaxOrderByAggregateInput = {
    id?: SortOrder
    level_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_levelpossMinOrderByAggregateInput = {
    id?: SortOrder
    level_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_levelpossSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_logsCountOrderByAggregateInput = {
    Id?: SortOrder
    IP?: SortOrder
    Login?: SortOrder
    Logout?: SortOrder
    UserId?: SortOrder
    LogId?: SortOrder
    Notes?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_logsAvgOrderByAggregateInput = {
    Id?: SortOrder
    LogId?: SortOrder
  }

  export type em_logsMaxOrderByAggregateInput = {
    Id?: SortOrder
    IP?: SortOrder
    Login?: SortOrder
    Logout?: SortOrder
    UserId?: SortOrder
    LogId?: SortOrder
    Notes?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_logsMinOrderByAggregateInput = {
    Id?: SortOrder
    IP?: SortOrder
    Login?: SortOrder
    Logout?: SortOrder
    UserId?: SortOrder
    LogId?: SortOrder
    Notes?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_logsSumOrderByAggregateInput = {
    Id?: SortOrder
    LogId?: SortOrder
  }

  export type em_lokerCountOrderByAggregateInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    jobdesc?: SortOrder
    qualify?: SortOrder
    worktype?: SortOrder
    salary?: SortOrder
    contrtype?: SortOrder
    posslevel?: SortOrder
    status?: SortOrder
    benefit?: SortOrder
    fileimage?: SortOrder
    createdate?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
    kategori?: SortOrder
  }

  export type em_lokerAvgOrderByAggregateInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    kategori?: SortOrder
  }

  export type em_lokerMaxOrderByAggregateInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    jobdesc?: SortOrder
    qualify?: SortOrder
    worktype?: SortOrder
    salary?: SortOrder
    contrtype?: SortOrder
    posslevel?: SortOrder
    status?: SortOrder
    benefit?: SortOrder
    fileimage?: SortOrder
    createdate?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
    kategori?: SortOrder
  }

  export type em_lokerMinOrderByAggregateInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    jobdesc?: SortOrder
    qualify?: SortOrder
    worktype?: SortOrder
    salary?: SortOrder
    contrtype?: SortOrder
    posslevel?: SortOrder
    status?: SortOrder
    benefit?: SortOrder
    fileimage?: SortOrder
    createdate?: SortOrder
    lastupdate?: SortOrder
    userid?: SortOrder
    kategori?: SortOrder
  }

  export type em_lokerSumOrderByAggregateInput = {
    lokerid?: SortOrder
    possid?: SortOrder
    kategori?: SortOrder
  }

  export type Em_lokerScalarRelationFilter = {
    is?: em_lokerWhereInput
    isNot?: em_lokerWhereInput
  }

  export type Em_examsScalarRelationFilter = {
    is?: em_examsWhereInput
    isNot?: em_examsWhereInput
  }

  export type em_loktopikCountOrderByAggregateInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    created_at?: SortOrder
    possid?: SortOrder
    urutan?: SortOrder
  }

  export type em_loktopikAvgOrderByAggregateInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    possid?: SortOrder
    urutan?: SortOrder
  }

  export type em_loktopikMaxOrderByAggregateInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    created_at?: SortOrder
    possid?: SortOrder
    urutan?: SortOrder
  }

  export type em_loktopikMinOrderByAggregateInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    created_at?: SortOrder
    possid?: SortOrder
    urutan?: SortOrder
  }

  export type em_loktopikSumOrderByAggregateInput = {
    id?: SortOrder
    loker_id?: SortOrder
    topik_id?: SortOrder
    jmlh_soal?: SortOrder
    possid?: SortOrder
    urutan?: SortOrder
  }

  export type Em_materi1ScalarRelationFilter = {
    is?: em_materi1WhereInput
    isNot?: em_materi1WhereInput
  }

  export type em_materi_fileCountOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    url?: SortOrder
    urutan?: SortOrder
    judul?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    galeri_id?: SortOrder
  }

  export type em_materi_fileAvgOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    urutan?: SortOrder
    galeri_id?: SortOrder
  }

  export type em_materi_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    url?: SortOrder
    urutan?: SortOrder
    judul?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    galeri_id?: SortOrder
  }

  export type em_materi_fileMinOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    url?: SortOrder
    urutan?: SortOrder
    judul?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    galeri_id?: SortOrder
  }

  export type em_materi_fileSumOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    urutan?: SortOrder
    galeri_id?: SortOrder
  }

  export type em_materi_kategoriCountOrderByAggregateInput = {
    id?: SortOrder
    kategori_nama?: SortOrder
    kategori_deskripsi?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type em_materi_kategoriAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_materi_kategoriMaxOrderByAggregateInput = {
    id?: SortOrder
    kategori_nama?: SortOrder
    kategori_deskripsi?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type em_materi_kategoriMinOrderByAggregateInput = {
    id?: SortOrder
    kategori_nama?: SortOrder
    kategori_deskripsi?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type em_materi_kategoriSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Em_materi2ListRelationFilter = {
    every?: em_materi2WhereInput
    some?: em_materi2WhereInput
    none?: em_materi2WhereInput
  }

  export type em_materi2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_materi_typeCountOrderByAggregateInput = {
    id?: SortOrder
    materi_name?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_materi_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_materi_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    materi_name?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_materi_typeMinOrderByAggregateInput = {
    id?: SortOrder
    materi_name?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_materi_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Em_materi_fileListRelationFilter = {
    every?: em_materi_fileWhereInput
    some?: em_materi_fileWhereInput
    none?: em_materi_fileWhereInput
  }

  export type em_materi_fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_materi1CountOrderByAggregateInput = {
    id?: SortOrder
    kode_materi?: SortOrder
    judul_materi?: SortOrder
    deskripsi_materi?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    is_required?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_materi1AvgOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
  }

  export type em_materi1MaxOrderByAggregateInput = {
    id?: SortOrder
    kode_materi?: SortOrder
    judul_materi?: SortOrder
    deskripsi_materi?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    is_required?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_materi1MinOrderByAggregateInput = {
    id?: SortOrder
    kode_materi?: SortOrder
    judul_materi?: SortOrder
    deskripsi_materi?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    is_required?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_materi1SumOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Em_materi_typeScalarRelationFilter = {
    is?: em_materi_typeWhereInput
    isNot?: em_materi_typeWhereInput
  }

  export type em_materi2CountOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
  }

  export type em_materi2AvgOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
  }

  export type em_materi2MaxOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
  }

  export type em_materi2MinOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
  }

  export type em_materi2SumOrderByAggregateInput = {
    id?: SortOrder
    materi_id?: SortOrder
    materi_type?: SortOrder
  }

  export type em_menuIdMenuidCompoundUniqueInput = {
    id: number
    menuid: string
  }

  export type em_menuCountOrderByAggregateInput = {
    id?: SortOrder
    menuid?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    link?: SortOrder
    visible?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
    icon?: SortOrder
    menutype?: SortOrder
  }

  export type em_menuAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_menuMaxOrderByAggregateInput = {
    id?: SortOrder
    menuid?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    link?: SortOrder
    visible?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
    icon?: SortOrder
    menutype?: SortOrder
  }

  export type em_menuMinOrderByAggregateInput = {
    id?: SortOrder
    menuid?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    link?: SortOrder
    visible?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
    icon?: SortOrder
    menutype?: SortOrder
  }

  export type em_menuSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_notifikasiCountOrderByAggregateInput = {
    NotifyId?: SortOrder
    UserId?: SortOrder
    GroupId?: SortOrder
    Note?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_notifikasiAvgOrderByAggregateInput = {
    NotifyId?: SortOrder
    UserId?: SortOrder
    GroupId?: SortOrder
  }

  export type em_notifikasiMaxOrderByAggregateInput = {
    NotifyId?: SortOrder
    UserId?: SortOrder
    GroupId?: SortOrder
    Note?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_notifikasiMinOrderByAggregateInput = {
    NotifyId?: SortOrder
    UserId?: SortOrder
    GroupId?: SortOrder
    Note?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_notifikasiSumOrderByAggregateInput = {
    NotifyId?: SortOrder
    UserId?: SortOrder
    GroupId?: SortOrder
  }

  export type em_notifikasi_readCountOrderByAggregateInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrder
    UserId?: SortOrder
    ReadDate?: SortOrder
  }

  export type em_notifikasi_readAvgOrderByAggregateInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrder
    UserId?: SortOrder
  }

  export type em_notifikasi_readMaxOrderByAggregateInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrder
    UserId?: SortOrder
    ReadDate?: SortOrder
  }

  export type em_notifikasi_readMinOrderByAggregateInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrder
    UserId?: SortOrder
    ReadDate?: SortOrder
  }

  export type em_notifikasi_readSumOrderByAggregateInput = {
    ReadId?: SortOrder
    NotifyId?: SortOrder
    UserId?: SortOrder
  }

  export type em_onboardingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    current_step?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type em_onboardingAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    current_step?: SortOrder
  }

  export type em_onboardingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    current_step?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type em_onboardingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    current_step?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type em_onboardingSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    current_step?: SortOrder
  }

  export type em_pilarCountOrderByAggregateInput = {
    id?: SortOrder
    pilar_name?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_pilarAvgOrderByAggregateInput = {
    id?: SortOrder
    pic?: SortOrder
  }

  export type em_pilarMaxOrderByAggregateInput = {
    id?: SortOrder
    pilar_name?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_pilarMinOrderByAggregateInput = {
    id?: SortOrder
    pilar_name?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_pilarSumOrderByAggregateInput = {
    id?: SortOrder
    pic?: SortOrder
  }

  export type em_profesiCountOrderByAggregateInput = {
    profesi_id?: SortOrder
    profesi_name?: SortOrder
    status?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_profesiAvgOrderByAggregateInput = {
    profesi_id?: SortOrder
  }

  export type em_profesiMaxOrderByAggregateInput = {
    profesi_id?: SortOrder
    profesi_name?: SortOrder
    status?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_profesiMinOrderByAggregateInput = {
    profesi_id?: SortOrder
    profesi_name?: SortOrder
    status?: SortOrder
    created_date?: SortOrder
    last_update?: SortOrder
  }

  export type em_profesiSumOrderByAggregateInput = {
    profesi_id?: SortOrder
  }

  export type Em_questions2ListRelationFilter = {
    every?: em_questions2WhereInput
    some?: em_questions2WhereInput
    none?: em_questions2WhereInput
  }

  export type em_questions2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_questions1CountOrderByAggregateInput = {
    id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    correct_answer?: SortOrder
    correct_answer2?: SortOrder
    exam_id?: SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    status?: SortOrder
    userid?: SortOrder
    qdate?: SortOrder
    lastupdate?: SortOrder
    fileimage?: SortOrder
    isExams?: SortOrder
    isLevel?: SortOrder
  }

  export type em_questions1AvgOrderByAggregateInput = {
    id?: SortOrder
    question_type?: SortOrder
    exam_id?: SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    isLevel?: SortOrder
  }

  export type em_questions1MaxOrderByAggregateInput = {
    id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    correct_answer?: SortOrder
    correct_answer2?: SortOrder
    exam_id?: SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    status?: SortOrder
    userid?: SortOrder
    qdate?: SortOrder
    lastupdate?: SortOrder
    fileimage?: SortOrder
    isExams?: SortOrder
    isLevel?: SortOrder
  }

  export type em_questions1MinOrderByAggregateInput = {
    id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    correct_answer?: SortOrder
    correct_answer2?: SortOrder
    exam_id?: SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    status?: SortOrder
    userid?: SortOrder
    qdate?: SortOrder
    lastupdate?: SortOrder
    fileimage?: SortOrder
    isExams?: SortOrder
    isLevel?: SortOrder
  }

  export type em_questions1SumOrderByAggregateInput = {
    id?: SortOrder
    question_type?: SortOrder
    exam_id?: SortOrder
    time_limit?: SortOrder
    score?: SortOrder
    isLevel?: SortOrder
  }

  export type Em_questions1ScalarRelationFilter = {
    is?: em_questions1WhereInput
    isNot?: em_questions1WhereInput
  }

  export type em_questions2IdQuestion_idOption_choicesCompoundUniqueInput = {
    Id: bigint | number
    question_id: number
    option_choices: string
  }

  export type em_questions2CountOrderByAggregateInput = {
    Id?: SortOrder
    question_id?: SortOrder
    option_choices?: SortOrder
    option_text?: SortOrder
  }

  export type em_questions2AvgOrderByAggregateInput = {
    Id?: SortOrder
    question_id?: SortOrder
  }

  export type em_questions2MaxOrderByAggregateInput = {
    Id?: SortOrder
    question_id?: SortOrder
    option_choices?: SortOrder
    option_text?: SortOrder
  }

  export type em_questions2MinOrderByAggregateInput = {
    Id?: SortOrder
    question_id?: SortOrder
    option_choices?: SortOrder
    option_text?: SortOrder
  }

  export type em_questions2SumOrderByAggregateInput = {
    Id?: SortOrder
    question_id?: SortOrder
  }

  export type em_questtypeCountOrderByAggregateInput = {
    Id?: SortOrder
    TypeName?: SortOrder
    Status?: SortOrder
  }

  export type em_questtypeAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type em_questtypeMaxOrderByAggregateInput = {
    Id?: SortOrder
    TypeName?: SortOrder
    Status?: SortOrder
  }

  export type em_questtypeMinOrderByAggregateInput = {
    Id?: SortOrder
    TypeName?: SortOrder
    Status?: SortOrder
  }

  export type em_questtypeSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type em_regulationsCountOrderByAggregateInput = {
    Id?: SortOrder
    chanceId?: SortOrder
    regName?: SortOrder
    urut?: SortOrder
    status?: SortOrder
    userid?: SortOrder
    createDate?: SortOrder
    lastUpdate?: SortOrder
  }

  export type em_regulationsAvgOrderByAggregateInput = {
    Id?: SortOrder
    chanceId?: SortOrder
    urut?: SortOrder
  }

  export type em_regulationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    chanceId?: SortOrder
    regName?: SortOrder
    urut?: SortOrder
    status?: SortOrder
    userid?: SortOrder
    createDate?: SortOrder
    lastUpdate?: SortOrder
  }

  export type em_regulationsMinOrderByAggregateInput = {
    Id?: SortOrder
    chanceId?: SortOrder
    regName?: SortOrder
    urut?: SortOrder
    status?: SortOrder
    userid?: SortOrder
    createDate?: SortOrder
    lastUpdate?: SortOrder
  }

  export type em_regulationsSumOrderByAggregateInput = {
    Id?: SortOrder
    chanceId?: SortOrder
    urut?: SortOrder
  }

  export type em_sbuIdSbu_codeCompoundUniqueInput = {
    id: number
    sbu_code: string
  }

  export type em_sbuCountOrderByAggregateInput = {
    id?: SortOrder
    sbu_code?: SortOrder
    sbu_name?: SortOrder
    sbu_pilar?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_sbuAvgOrderByAggregateInput = {
    id?: SortOrder
    sbu_pilar?: SortOrder
    pic?: SortOrder
  }

  export type em_sbuMaxOrderByAggregateInput = {
    id?: SortOrder
    sbu_code?: SortOrder
    sbu_name?: SortOrder
    sbu_pilar?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_sbuMinOrderByAggregateInput = {
    id?: SortOrder
    sbu_code?: SortOrder
    sbu_name?: SortOrder
    sbu_pilar?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_sbuSumOrderByAggregateInput = {
    id?: SortOrder
    sbu_pilar?: SortOrder
    pic?: SortOrder
  }

  export type em_sbu_subCountOrderByAggregateInput = {
    id?: SortOrder
    sbu_sub_code?: SortOrder
    sbu_sub_name?: SortOrder
    sbu_id?: SortOrder
    sbu_pilar?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_sbu_subAvgOrderByAggregateInput = {
    id?: SortOrder
    sbu_id?: SortOrder
    sbu_pilar?: SortOrder
    pic?: SortOrder
  }

  export type em_sbu_subMaxOrderByAggregateInput = {
    id?: SortOrder
    sbu_sub_code?: SortOrder
    sbu_sub_name?: SortOrder
    sbu_id?: SortOrder
    sbu_pilar?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_sbu_subMinOrderByAggregateInput = {
    id?: SortOrder
    sbu_sub_code?: SortOrder
    sbu_sub_name?: SortOrder
    sbu_id?: SortOrder
    sbu_pilar?: SortOrder
    status?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    description?: SortOrder
    pic?: SortOrder
  }

  export type em_sbu_subSumOrderByAggregateInput = {
    id?: SortOrder
    sbu_id?: SortOrder
    sbu_pilar?: SortOrder
    pic?: SortOrder
  }

  export type Em_schedule2ListRelationFilter = {
    every?: em_schedule2WhereInput
    some?: em_schedule2WhereInput
    none?: em_schedule2WhereInput
  }

  export type Em_schedule3ListRelationFilter = {
    every?: em_schedule3WhereInput
    some?: em_schedule3WhereInput
    none?: em_schedule3WhereInput
  }

  export type Em_schedule4ListRelationFilter = {
    every?: em_schedule4WhereInput
    some?: em_schedule4WhereInput
    none?: em_schedule4WhereInput
  }

  export type em_schedule2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_schedule3OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_schedule4OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_schedule1CountOrderByAggregateInput = {
    Id?: SortOrder
    scheName?: SortOrder
    scheDeskripsi?: SortOrder
    isMateri?: SortOrder
    isQuota?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isLokasi?: SortOrder
    isTrainer?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    sendWA?: SortOrder
    ujian_stats?: SortOrder
    is_with_soal?: SortOrder
    usr_by?: SortOrder
    is_wa_template?: SortOrder
    is_batch?: SortOrder
    event_id?: SortOrder
  }

  export type em_schedule1AvgOrderByAggregateInput = {
    Id?: SortOrder
    isMateri?: SortOrder
    isQuota?: SortOrder
    sendWA?: SortOrder
    is_wa_template?: SortOrder
    event_id?: SortOrder
  }

  export type em_schedule1MaxOrderByAggregateInput = {
    Id?: SortOrder
    scheName?: SortOrder
    scheDeskripsi?: SortOrder
    isMateri?: SortOrder
    isQuota?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isLokasi?: SortOrder
    isTrainer?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    sendWA?: SortOrder
    ujian_stats?: SortOrder
    is_with_soal?: SortOrder
    usr_by?: SortOrder
    is_wa_template?: SortOrder
    is_batch?: SortOrder
    event_id?: SortOrder
  }

  export type em_schedule1MinOrderByAggregateInput = {
    Id?: SortOrder
    scheName?: SortOrder
    scheDeskripsi?: SortOrder
    isMateri?: SortOrder
    isQuota?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isLokasi?: SortOrder
    isTrainer?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    sendWA?: SortOrder
    ujian_stats?: SortOrder
    is_with_soal?: SortOrder
    usr_by?: SortOrder
    is_wa_template?: SortOrder
    is_batch?: SortOrder
    event_id?: SortOrder
  }

  export type em_schedule1SumOrderByAggregateInput = {
    Id?: SortOrder
    isMateri?: SortOrder
    isQuota?: SortOrder
    sendWA?: SortOrder
    is_wa_template?: SortOrder
    event_id?: SortOrder
  }

  export type Em_schedule1NullableScalarRelationFilter = {
    is?: em_schedule1WhereInput | null
    isNot?: em_schedule1WhereInput | null
  }

  export type em_schedule2CountOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    employeeId?: SortOrder
    Regid?: SortOrder
    is_send_wa_stats?: SortOrder
    send_date?: SortOrder
    is_code_send?: SortOrder
  }

  export type em_schedule2AvgOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    employeeId?: SortOrder
    is_send_wa_stats?: SortOrder
  }

  export type em_schedule2MaxOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    employeeId?: SortOrder
    Regid?: SortOrder
    is_send_wa_stats?: SortOrder
    send_date?: SortOrder
    is_code_send?: SortOrder
  }

  export type em_schedule2MinOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    employeeId?: SortOrder
    Regid?: SortOrder
    is_send_wa_stats?: SortOrder
    send_date?: SortOrder
    is_code_send?: SortOrder
  }

  export type em_schedule2SumOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    employeeId?: SortOrder
    is_send_wa_stats?: SortOrder
  }

  export type Em_schedule1ScalarRelationFilter = {
    is?: em_schedule1WhereInput
    isNot?: em_schedule1WhereInput
  }

  export type em_schedule3CountOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
  }

  export type em_schedule3AvgOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
  }

  export type em_schedule3MaxOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
  }

  export type em_schedule3MinOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
  }

  export type em_schedule3SumOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    soalId?: SortOrder
    urutanSoal?: SortOrder
    materiId?: SortOrder
    urutanTipeSoal?: SortOrder
    tipeSoal?: SortOrder
  }

  export type em_schedule4CountOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    tipeSoal?: SortOrder
    jumlahSoal?: SortOrder
    durasiPerTipe?: SortOrder
  }

  export type em_schedule4AvgOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    tipeSoal?: SortOrder
    jumlahSoal?: SortOrder
    durasiPerTipe?: SortOrder
  }

  export type em_schedule4MaxOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    tipeSoal?: SortOrder
    jumlahSoal?: SortOrder
    durasiPerTipe?: SortOrder
  }

  export type em_schedule4MinOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    tipeSoal?: SortOrder
    jumlahSoal?: SortOrder
    durasiPerTipe?: SortOrder
  }

  export type em_schedule4SumOrderByAggregateInput = {
    Id?: SortOrder
    scheduleId?: SortOrder
    tipeSoal?: SortOrder
    jumlahSoal?: SortOrder
    durasiPerTipe?: SortOrder
  }

  export type Em_jawaban_pesertaListRelationFilter = {
    every?: em_jawaban_pesertaWhereInput
    some?: em_jawaban_pesertaWhereInput
    none?: em_jawaban_pesertaWhereInput
  }

  export type em_jawaban_pesertaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_session_examsCountOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    soal_urut?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_selesai?: SortOrder
    is_token?: SortOrder
    is_token_expr?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_notes?: SortOrder
    is_score_akhir?: SortOrder
  }

  export type em_session_examsAvgOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    empl_id?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_score_akhir?: SortOrder
  }

  export type em_session_examsMaxOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    soal_urut?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_selesai?: SortOrder
    is_token?: SortOrder
    is_token_expr?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_notes?: SortOrder
    is_score_akhir?: SortOrder
  }

  export type em_session_examsMinOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    exams_id?: SortOrder
    empl_id?: SortOrder
    soal_urut?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_selesai?: SortOrder
    is_token?: SortOrder
    is_token_expr?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_notes?: SortOrder
    is_score_akhir?: SortOrder
  }

  export type em_session_examsSumOrderByAggregateInput = {
    Id?: SortOrder
    schedule_id?: SortOrder
    empl_id?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_score_akhir?: SortOrder
  }

  export type Em_jawaban_peserta_apcListRelationFilter = {
    every?: em_jawaban_peserta_apcWhereInput
    some?: em_jawaban_peserta_apcWhereInput
    none?: em_jawaban_peserta_apcWhereInput
  }

  export type Em_topic_selesaiListRelationFilter = {
    every?: em_topic_selesaiWhereInput
    some?: em_topic_selesaiWhereInput
    none?: em_topic_selesaiWhereInput
  }

  export type em_jawaban_peserta_apcOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_topic_selesaiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type em_session_exams_apcCountOrderByAggregateInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    exams_id?: SortOrder
    apcid?: SortOrder
    soal_urut?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_selesai?: SortOrder
    is_token?: SortOrder
    is_token_expr?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_notes?: SortOrder
    is_score_akhir?: SortOrder
    curr_topic_index?: SortOrder
    curr_soal_index?: SortOrder
    is_intro_topic?: SortOrder
    is_jawaban_kosong?: SortOrder
  }

  export type em_session_exams_apcAvgOrderByAggregateInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    apcid?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_score_akhir?: SortOrder
    curr_topic_index?: SortOrder
    curr_soal_index?: SortOrder
    is_jawaban_kosong?: SortOrder
  }

  export type em_session_exams_apcMaxOrderByAggregateInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    exams_id?: SortOrder
    apcid?: SortOrder
    soal_urut?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_selesai?: SortOrder
    is_token?: SortOrder
    is_token_expr?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_notes?: SortOrder
    is_score_akhir?: SortOrder
    curr_topic_index?: SortOrder
    curr_soal_index?: SortOrder
    is_intro_topic?: SortOrder
    is_jawaban_kosong?: SortOrder
  }

  export type em_session_exams_apcMinOrderByAggregateInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    exams_id?: SortOrder
    apcid?: SortOrder
    soal_urut?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_selesai?: SortOrder
    is_token?: SortOrder
    is_token_expr?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_notes?: SortOrder
    is_score_akhir?: SortOrder
    curr_topic_index?: SortOrder
    curr_soal_index?: SortOrder
    is_intro_topic?: SortOrder
    is_jawaban_kosong?: SortOrder
  }

  export type em_session_exams_apcSumOrderByAggregateInput = {
    Id?: SortOrder
    lokerid?: SortOrder
    apcid?: SortOrder
    durasi?: SortOrder
    is_correct?: SortOrder
    is_score_akhir?: SortOrder
    curr_topic_index?: SortOrder
    curr_soal_index?: SortOrder
    is_jawaban_kosong?: SortOrder
  }

  export type em_subscribeCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    Endpoint?: SortOrder
    P256dh?: SortOrder
    Auth?: SortOrder
    Created_at?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_subscribeAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type em_subscribeMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    Endpoint?: SortOrder
    P256dh?: SortOrder
    Auth?: SortOrder
    Created_at?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_subscribeMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    Endpoint?: SortOrder
    P256dh?: SortOrder
    Auth?: SortOrder
    Created_at?: SortOrder
    LastUpdate?: SortOrder
  }

  export type em_subscribeSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type em_subscriptionCountOrderByAggregateInput = {
    Id?: SortOrder
    username?: SortOrder
    subscription?: SortOrder
    status?: SortOrder
    createdat?: SortOrder
  }

  export type em_subscriptionAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type em_subscriptionMaxOrderByAggregateInput = {
    Id?: SortOrder
    username?: SortOrder
    subscription?: SortOrder
    status?: SortOrder
    createdat?: SortOrder
  }

  export type em_subscriptionMinOrderByAggregateInput = {
    Id?: SortOrder
    username?: SortOrder
    subscription?: SortOrder
    status?: SortOrder
    createdat?: SortOrder
  }

  export type em_subscriptionSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type em_topic_selesaiCountOrderByAggregateInput = {
    id?: SortOrder
    session_exams_id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
    selesai_at?: SortOrder
  }

  export type em_topic_selesaiAvgOrderByAggregateInput = {
    id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
  }

  export type em_topic_selesaiMaxOrderByAggregateInput = {
    id?: SortOrder
    session_exams_id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
    selesai_at?: SortOrder
  }

  export type em_topic_selesaiMinOrderByAggregateInput = {
    id?: SortOrder
    session_exams_id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
    selesai_at?: SortOrder
  }

  export type em_topic_selesaiSumOrderByAggregateInput = {
    id?: SortOrder
    apc_id?: SortOrder
    topic_id?: SortOrder
  }

  export type em_user_answers1CountOrderByAggregateInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
    status?: SortOrder
    startdate?: SortOrder
  }

  export type em_user_answers1AvgOrderByAggregateInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
  }

  export type em_user_answers1MaxOrderByAggregateInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
    status?: SortOrder
    startdate?: SortOrder
  }

  export type em_user_answers1MinOrderByAggregateInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
    status?: SortOrder
    startdate?: SortOrder
  }

  export type em_user_answers1SumOrderByAggregateInput = {
    Id?: SortOrder
    apcid?: SortOrder
    topic_id?: SortOrder
  }

  export type em_user_dashboardCountOrderByAggregateInput = {
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    FullName?: SortOrder
    RoleId?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
    GroupId?: SortOrder
  }

  export type em_user_dashboardAvgOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    GroupId?: SortOrder
  }

  export type em_user_dashboardMaxOrderByAggregateInput = {
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    FullName?: SortOrder
    RoleId?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
    GroupId?: SortOrder
  }

  export type em_user_dashboardMinOrderByAggregateInput = {
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    FullName?: SortOrder
    RoleId?: SortOrder
    Status?: SortOrder
    CreateDate?: SortOrder
    LastUpdate?: SortOrder
    GroupId?: SortOrder
  }

  export type em_user_dashboardSumOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    GroupId?: SortOrder
  }

  export type em_user_listCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    menuid?: SortOrder
    visible?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_user_listAvgOrderByAggregateInput = {
    id?: SortOrder
    menuid?: SortOrder
  }

  export type em_user_listMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    menuid?: SortOrder
    visible?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_user_listMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    menuid?: SortOrder
    visible?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_user_listSumOrderByAggregateInput = {
    id?: SortOrder
    menuid?: SortOrder
  }

  export type em_usersIdUserIdCompoundUniqueInput = {
    Id: number
    UserId: string
  }

  export type em_usersCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    LastUpdate?: SortOrder
    LevelId?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    imagename?: SortOrder
    Pass_Access_Menu?: SortOrder
  }

  export type em_usersAvgOrderByAggregateInput = {
    Id?: SortOrder
    LevelId?: SortOrder
  }

  export type em_usersMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    LastUpdate?: SortOrder
    LevelId?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    imagename?: SortOrder
    Pass_Access_Menu?: SortOrder
  }

  export type em_usersMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    LastUpdate?: SortOrder
    LevelId?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    imagename?: SortOrder
    Pass_Access_Menu?: SortOrder
  }

  export type em_usersSumOrderByAggregateInput = {
    Id?: SortOrder
    LevelId?: SortOrder
  }

  export type em_verify_linksCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    browser?: SortOrder
    platform?: SortOrder
    device?: SortOrder
  }

  export type em_verify_linksAvgOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
  }

  export type em_verify_linksMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    browser?: SortOrder
    platform?: SortOrder
    device?: SortOrder
  }

  export type em_verify_linksMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    browser?: SortOrder
    platform?: SortOrder
    device?: SortOrder
  }

  export type em_verify_linksSumOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
  }

  export type em_wa_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    template_name?: SortOrder
    template_text?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    status?: SortOrder
    tpfor?: SortOrder
  }

  export type em_wa_templatesAvgOrderByAggregateInput = {
    id?: SortOrder
    tpfor?: SortOrder
  }

  export type em_wa_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    template_name?: SortOrder
    template_text?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    status?: SortOrder
    tpfor?: SortOrder
  }

  export type em_wa_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    template_name?: SortOrder
    template_text?: SortOrder
    add_by?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
    status?: SortOrder
    tpfor?: SortOrder
  }

  export type em_wa_templatesSumOrderByAggregateInput = {
    id?: SortOrder
    tpfor?: SortOrder
  }

  export type em_worktypeCountOrderByAggregateInput = {
    id?: SortOrder
    worktype_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_worktypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_worktypeMaxOrderByAggregateInput = {
    id?: SortOrder
    worktype_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_worktypeMinOrderByAggregateInput = {
    id?: SortOrder
    worktype_text?: SortOrder
    status?: SortOrder
    lastupdate?: SortOrder
  }

  export type em_worktypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type em_xquetestCountOrderByAggregateInput = {
    ID?: SortOrder
    q_id?: SortOrder
    question_text?: SortOrder
  }

  export type em_xquetestAvgOrderByAggregateInput = {
    ID?: SortOrder
    q_id?: SortOrder
  }

  export type em_xquetestMaxOrderByAggregateInput = {
    ID?: SortOrder
    q_id?: SortOrder
    question_text?: SortOrder
  }

  export type em_xquetestMinOrderByAggregateInput = {
    ID?: SortOrder
    q_id?: SortOrder
    question_text?: SortOrder
  }

  export type em_xquetestSumOrderByAggregateInput = {
    ID?: SortOrder
    q_id?: SortOrder
  }

  export type emappCountOrderByAggregateInput = {
    AppId?: SortOrder
    AppName?: SortOrder
    AppPoss?: SortOrder
    AppWa?: SortOrder
    AppMail?: SortOrder
    AppAge?: SortOrder
    AppJk?: SortOrder
    AppAddres?: SortOrder
    AppFakt?: SortOrder
    AppFileName?: SortOrder
    AppLastUpdate?: SortOrder
    AppDate?: SortOrder
    AppStatus?: SortOrder
    IsCall?: SortOrder
    DateCall?: SortOrder
    JobsIs?: SortOrder
    JFStats?: SortOrder
    LokasiId?: SortOrder
  }

  export type emappAvgOrderByAggregateInput = {
    AppId?: SortOrder
    AppPoss?: SortOrder
    AppAge?: SortOrder
    AppJk?: SortOrder
    IsCall?: SortOrder
    LokasiId?: SortOrder
  }

  export type emappMaxOrderByAggregateInput = {
    AppId?: SortOrder
    AppName?: SortOrder
    AppPoss?: SortOrder
    AppWa?: SortOrder
    AppMail?: SortOrder
    AppAge?: SortOrder
    AppJk?: SortOrder
    AppAddres?: SortOrder
    AppFakt?: SortOrder
    AppFileName?: SortOrder
    AppLastUpdate?: SortOrder
    AppDate?: SortOrder
    AppStatus?: SortOrder
    IsCall?: SortOrder
    DateCall?: SortOrder
    JobsIs?: SortOrder
    JFStats?: SortOrder
    LokasiId?: SortOrder
  }

  export type emappMinOrderByAggregateInput = {
    AppId?: SortOrder
    AppName?: SortOrder
    AppPoss?: SortOrder
    AppWa?: SortOrder
    AppMail?: SortOrder
    AppAge?: SortOrder
    AppJk?: SortOrder
    AppAddres?: SortOrder
    AppFakt?: SortOrder
    AppFileName?: SortOrder
    AppLastUpdate?: SortOrder
    AppDate?: SortOrder
    AppStatus?: SortOrder
    IsCall?: SortOrder
    DateCall?: SortOrder
    JobsIs?: SortOrder
    JFStats?: SortOrder
    LokasiId?: SortOrder
  }

  export type emappSumOrderByAggregateInput = {
    AppId?: SortOrder
    AppPoss?: SortOrder
    AppAge?: SortOrder
    AppJk?: SortOrder
    IsCall?: SortOrder
    LokasiId?: SortOrder
  }

  export type empasswCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Pass?: SortOrder
    Level?: SortOrder
  }

  export type empasswAvgOrderByAggregateInput = {
    Id?: SortOrder
    Level?: SortOrder
  }

  export type empasswMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Pass?: SortOrder
    Level?: SortOrder
  }

  export type empasswMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Pass?: SortOrder
    Level?: SortOrder
  }

  export type empasswSumOrderByAggregateInput = {
    Id?: SortOrder
    Level?: SortOrder
  }

  export type Em_applicant_criteriaListRelationFilter = {
    every?: em_applicant_criteriaWhereInput
    some?: em_applicant_criteriaWhereInput
    none?: em_applicant_criteriaWhereInput
  }

  export type em_applicant_criteriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empossCountOrderByAggregateInput = {
    Id?: SortOrder
    PossName?: SortOrder
    Status?: SortOrder
    UserId?: SortOrder
    LastUpdate?: SortOrder
  }

  export type empossAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type empossMaxOrderByAggregateInput = {
    Id?: SortOrder
    PossName?: SortOrder
    Status?: SortOrder
    UserId?: SortOrder
    LastUpdate?: SortOrder
  }

  export type empossMinOrderByAggregateInput = {
    Id?: SortOrder
    PossName?: SortOrder
    Status?: SortOrder
    UserId?: SortOrder
    LastUpdate?: SortOrder
  }

  export type empossSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type faceusersCountOrderByAggregateInput = {
    Id?: SortOrder
    name?: SortOrder
    fileimage?: SortOrder
    descriptor?: SortOrder
    pose?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type faceusersAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type faceusersMaxOrderByAggregateInput = {
    Id?: SortOrder
    name?: SortOrder
    fileimage?: SortOrder
    descriptor?: SortOrder
    pose?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type faceusersMinOrderByAggregateInput = {
    Id?: SortOrder
    name?: SortOrder
    fileimage?: SortOrder
    descriptor?: SortOrder
    pose?: SortOrder
    created_at?: SortOrder
    lastupdate?: SortOrder
  }

  export type faceusersSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type menuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    link?: SortOrder
    visible?: SortOrder
    role?: SortOrder
  }

  export type menuAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
  }

  export type menuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    link?: SortOrder
    visible?: SortOrder
    role?: SortOrder
  }

  export type menuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    link?: SortOrder
    visible?: SortOrder
    role?: SortOrder
  }

  export type menuSumOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
  }

  export type EmappScalarRelationFilter = {
    is?: emappWhereInput
    isNot?: emappWhereInput
  }

  export type scoresCountOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
    created_at?: SortOrder
  }

  export type scoresAvgOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
  }

  export type scoresMaxOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
    created_at?: SortOrder
  }

  export type scoresMinOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
    created_at?: SortOrder
  }

  export type scoresSumOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    user_id?: SortOrder
    total_score?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type em_apc_personalCreateNestedOneWithoutEm_apc_academyInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_academyInput, em_apc_personalUncheckedCreateWithoutEm_apc_academyInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_academyInput
    connect?: em_apc_personalWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type em_apc_personalUpdateOneRequiredWithoutEm_apc_academyNestedInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_academyInput, em_apc_personalUncheckedCreateWithoutEm_apc_academyInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_academyInput
    upsert?: em_apc_personalUpsertWithoutEm_apc_academyInput
    connect?: em_apc_personalWhereUniqueInput
    update?: XOR<XOR<em_apc_personalUpdateToOneWithWhereWithoutEm_apc_academyInput, em_apc_personalUpdateWithoutEm_apc_academyInput>, em_apc_personalUncheckedUpdateWithoutEm_apc_academyInput>
  }

  export type em_apc_academyCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_academyCreateWithoutEm_apc_personalInput, em_apc_academyUncheckedCreateWithoutEm_apc_personalInput> | em_apc_academyCreateWithoutEm_apc_personalInput[] | em_apc_academyUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_academyCreateOrConnectWithoutEm_apc_personalInput | em_apc_academyCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_academyCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
  }

  export type em_apc_photographCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_photographCreateWithoutEm_apc_personalInput, em_apc_photographUncheckedCreateWithoutEm_apc_personalInput> | em_apc_photographCreateWithoutEm_apc_personalInput[] | em_apc_photographUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_photographCreateOrConnectWithoutEm_apc_personalInput | em_apc_photographCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_photographCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
  }

  export type em_apc_regulationCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_regulationCreateWithoutEm_apc_personalInput, em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput> | em_apc_regulationCreateWithoutEm_apc_personalInput[] | em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput | em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_regulationCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
  }

  export type em_apc_skill_experCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_skill_experCreateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput> | em_apc_skill_experCreateWithoutEm_apc_personalInput[] | em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput | em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_skill_experCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
  }

  export type em_applicant_matchCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_applicant_matchCreateWithoutEm_apc_personalInput, em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput> | em_applicant_matchCreateWithoutEm_apc_personalInput[] | em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput | em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_applicant_matchCreateManyEm_apc_personalInputEnvelope
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
  }

  export type em_apc_academyUncheckedCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_academyCreateWithoutEm_apc_personalInput, em_apc_academyUncheckedCreateWithoutEm_apc_personalInput> | em_apc_academyCreateWithoutEm_apc_personalInput[] | em_apc_academyUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_academyCreateOrConnectWithoutEm_apc_personalInput | em_apc_academyCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_academyCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
  }

  export type em_apc_photographUncheckedCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_photographCreateWithoutEm_apc_personalInput, em_apc_photographUncheckedCreateWithoutEm_apc_personalInput> | em_apc_photographCreateWithoutEm_apc_personalInput[] | em_apc_photographUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_photographCreateOrConnectWithoutEm_apc_personalInput | em_apc_photographCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_photographCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
  }

  export type em_apc_regulationUncheckedCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_regulationCreateWithoutEm_apc_personalInput, em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput> | em_apc_regulationCreateWithoutEm_apc_personalInput[] | em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput | em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_regulationCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
  }

  export type em_apc_skill_experUncheckedCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_apc_skill_experCreateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput> | em_apc_skill_experCreateWithoutEm_apc_personalInput[] | em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput | em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_apc_skill_experCreateManyEm_apc_personalInputEnvelope
    connect?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
  }

  export type em_applicant_matchUncheckedCreateNestedManyWithoutEm_apc_personalInput = {
    create?: XOR<em_applicant_matchCreateWithoutEm_apc_personalInput, em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput> | em_applicant_matchCreateWithoutEm_apc_personalInput[] | em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput | em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput[]
    createMany?: em_applicant_matchCreateManyEm_apc_personalInputEnvelope
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
  }

  export type em_apc_academyUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_academyCreateWithoutEm_apc_personalInput, em_apc_academyUncheckedCreateWithoutEm_apc_personalInput> | em_apc_academyCreateWithoutEm_apc_personalInput[] | em_apc_academyUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_academyCreateOrConnectWithoutEm_apc_personalInput | em_apc_academyCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_academyUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_academyUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_academyCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    disconnect?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    delete?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    connect?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    update?: em_apc_academyUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_academyUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_academyUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_academyUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_academyScalarWhereInput | em_apc_academyScalarWhereInput[]
  }

  export type em_apc_photographUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_photographCreateWithoutEm_apc_personalInput, em_apc_photographUncheckedCreateWithoutEm_apc_personalInput> | em_apc_photographCreateWithoutEm_apc_personalInput[] | em_apc_photographUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_photographCreateOrConnectWithoutEm_apc_personalInput | em_apc_photographCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_photographUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_photographUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_photographCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    disconnect?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    delete?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    connect?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    update?: em_apc_photographUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_photographUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_photographUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_photographUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_photographScalarWhereInput | em_apc_photographScalarWhereInput[]
  }

  export type em_apc_regulationUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_regulationCreateWithoutEm_apc_personalInput, em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput> | em_apc_regulationCreateWithoutEm_apc_personalInput[] | em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput | em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_regulationUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_regulationUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_regulationCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    disconnect?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    delete?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    connect?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    update?: em_apc_regulationUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_regulationUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_regulationUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_regulationUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_regulationScalarWhereInput | em_apc_regulationScalarWhereInput[]
  }

  export type em_apc_skill_experUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_skill_experCreateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput> | em_apc_skill_experCreateWithoutEm_apc_personalInput[] | em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput | em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_skill_experUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_skill_experUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_skill_experCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    disconnect?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    delete?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    connect?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    update?: em_apc_skill_experUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_skill_experUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_skill_experUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_skill_experUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_skill_experScalarWhereInput | em_apc_skill_experScalarWhereInput[]
  }

  export type em_applicant_matchUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_applicant_matchCreateWithoutEm_apc_personalInput, em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput> | em_applicant_matchCreateWithoutEm_apc_personalInput[] | em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput | em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_applicant_matchUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_applicant_matchUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_applicant_matchCreateManyEm_apc_personalInputEnvelope
    set?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    disconnect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    delete?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    update?: em_applicant_matchUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_applicant_matchUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_applicant_matchUpdateManyWithWhereWithoutEm_apc_personalInput | em_applicant_matchUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_applicant_matchScalarWhereInput | em_applicant_matchScalarWhereInput[]
  }

  export type em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_academyCreateWithoutEm_apc_personalInput, em_apc_academyUncheckedCreateWithoutEm_apc_personalInput> | em_apc_academyCreateWithoutEm_apc_personalInput[] | em_apc_academyUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_academyCreateOrConnectWithoutEm_apc_personalInput | em_apc_academyCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_academyUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_academyUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_academyCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    disconnect?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    delete?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    connect?: em_apc_academyWhereUniqueInput | em_apc_academyWhereUniqueInput[]
    update?: em_apc_academyUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_academyUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_academyUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_academyUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_academyScalarWhereInput | em_apc_academyScalarWhereInput[]
  }

  export type em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_photographCreateWithoutEm_apc_personalInput, em_apc_photographUncheckedCreateWithoutEm_apc_personalInput> | em_apc_photographCreateWithoutEm_apc_personalInput[] | em_apc_photographUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_photographCreateOrConnectWithoutEm_apc_personalInput | em_apc_photographCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_photographUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_photographUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_photographCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    disconnect?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    delete?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    connect?: em_apc_photographWhereUniqueInput | em_apc_photographWhereUniqueInput[]
    update?: em_apc_photographUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_photographUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_photographUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_photographUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_photographScalarWhereInput | em_apc_photographScalarWhereInput[]
  }

  export type em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_regulationCreateWithoutEm_apc_personalInput, em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput> | em_apc_regulationCreateWithoutEm_apc_personalInput[] | em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput | em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_regulationUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_regulationUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_regulationCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    disconnect?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    delete?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    connect?: em_apc_regulationWhereUniqueInput | em_apc_regulationWhereUniqueInput[]
    update?: em_apc_regulationUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_regulationUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_regulationUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_regulationUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_regulationScalarWhereInput | em_apc_regulationScalarWhereInput[]
  }

  export type em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_apc_skill_experCreateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput> | em_apc_skill_experCreateWithoutEm_apc_personalInput[] | em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput | em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_apc_skill_experUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_apc_skill_experUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_apc_skill_experCreateManyEm_apc_personalInputEnvelope
    set?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    disconnect?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    delete?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    connect?: em_apc_skill_experWhereUniqueInput | em_apc_skill_experWhereUniqueInput[]
    update?: em_apc_skill_experUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_apc_skill_experUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_apc_skill_experUpdateManyWithWhereWithoutEm_apc_personalInput | em_apc_skill_experUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_apc_skill_experScalarWhereInput | em_apc_skill_experScalarWhereInput[]
  }

  export type em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalNestedInput = {
    create?: XOR<em_applicant_matchCreateWithoutEm_apc_personalInput, em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput> | em_applicant_matchCreateWithoutEm_apc_personalInput[] | em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput | em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput[]
    upsert?: em_applicant_matchUpsertWithWhereUniqueWithoutEm_apc_personalInput | em_applicant_matchUpsertWithWhereUniqueWithoutEm_apc_personalInput[]
    createMany?: em_applicant_matchCreateManyEm_apc_personalInputEnvelope
    set?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    disconnect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    delete?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    update?: em_applicant_matchUpdateWithWhereUniqueWithoutEm_apc_personalInput | em_applicant_matchUpdateWithWhereUniqueWithoutEm_apc_personalInput[]
    updateMany?: em_applicant_matchUpdateManyWithWhereWithoutEm_apc_personalInput | em_applicant_matchUpdateManyWithWhereWithoutEm_apc_personalInput[]
    deleteMany?: em_applicant_matchScalarWhereInput | em_applicant_matchScalarWhereInput[]
  }

  export type em_apc_personalCreateNestedOneWithoutEm_apc_photographInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_photographInput, em_apc_personalUncheckedCreateWithoutEm_apc_photographInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_photographInput
    connect?: em_apc_personalWhereUniqueInput
  }

  export type em_apc_personalUpdateOneWithoutEm_apc_photographNestedInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_photographInput, em_apc_personalUncheckedCreateWithoutEm_apc_photographInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_photographInput
    upsert?: em_apc_personalUpsertWithoutEm_apc_photographInput
    disconnect?: em_apc_personalWhereInput | boolean
    delete?: em_apc_personalWhereInput | boolean
    connect?: em_apc_personalWhereUniqueInput
    update?: XOR<XOR<em_apc_personalUpdateToOneWithWhereWithoutEm_apc_photographInput, em_apc_personalUpdateWithoutEm_apc_photographInput>, em_apc_personalUncheckedUpdateWithoutEm_apc_photographInput>
  }

  export type em_apc_personalCreateNestedOneWithoutEm_apc_regulationInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_regulationInput, em_apc_personalUncheckedCreateWithoutEm_apc_regulationInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_regulationInput
    connect?: em_apc_personalWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type em_apc_personalUpdateOneWithoutEm_apc_regulationNestedInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_regulationInput, em_apc_personalUncheckedCreateWithoutEm_apc_regulationInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_regulationInput
    upsert?: em_apc_personalUpsertWithoutEm_apc_regulationInput
    disconnect?: em_apc_personalWhereInput | boolean
    delete?: em_apc_personalWhereInput | boolean
    connect?: em_apc_personalWhereUniqueInput
    update?: XOR<XOR<em_apc_personalUpdateToOneWithWhereWithoutEm_apc_regulationInput, em_apc_personalUpdateWithoutEm_apc_regulationInput>, em_apc_personalUncheckedUpdateWithoutEm_apc_regulationInput>
  }

  export type em_apc_personalCreateNestedOneWithoutEm_apc_skill_experInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_skill_experInput, em_apc_personalUncheckedCreateWithoutEm_apc_skill_experInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_skill_experInput
    connect?: em_apc_personalWhereUniqueInput
  }

  export type em_apc_personalUpdateOneRequiredWithoutEm_apc_skill_experNestedInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_apc_skill_experInput, em_apc_personalUncheckedCreateWithoutEm_apc_skill_experInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_apc_skill_experInput
    upsert?: em_apc_personalUpsertWithoutEm_apc_skill_experInput
    connect?: em_apc_personalWhereUniqueInput
    update?: XOR<XOR<em_apc_personalUpdateToOneWithWhereWithoutEm_apc_skill_experInput, em_apc_personalUpdateWithoutEm_apc_skill_experInput>, em_apc_personalUncheckedUpdateWithoutEm_apc_skill_experInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type empossCreateNestedOneWithoutEm_applicant_criteriaInput = {
    create?: XOR<empossCreateWithoutEm_applicant_criteriaInput, empossUncheckedCreateWithoutEm_applicant_criteriaInput>
    connectOrCreate?: empossCreateOrConnectWithoutEm_applicant_criteriaInput
    connect?: empossWhereUniqueInput
  }

  export type empossUpdateOneRequiredWithoutEm_applicant_criteriaNestedInput = {
    create?: XOR<empossCreateWithoutEm_applicant_criteriaInput, empossUncheckedCreateWithoutEm_applicant_criteriaInput>
    connectOrCreate?: empossCreateOrConnectWithoutEm_applicant_criteriaInput
    upsert?: empossUpsertWithoutEm_applicant_criteriaInput
    connect?: empossWhereUniqueInput
    update?: XOR<XOR<empossUpdateToOneWithWhereWithoutEm_applicant_criteriaInput, empossUpdateWithoutEm_applicant_criteriaInput>, empossUncheckedUpdateWithoutEm_applicant_criteriaInput>
  }

  export type em_apc_personalCreateNestedOneWithoutEm_applicant_matchInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_applicant_matchInput, em_apc_personalUncheckedCreateWithoutEm_applicant_matchInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_applicant_matchInput
    connect?: em_apc_personalWhereUniqueInput
  }

  export type empossCreateNestedOneWithoutEm_applicant_matchInput = {
    create?: XOR<empossCreateWithoutEm_applicant_matchInput, empossUncheckedCreateWithoutEm_applicant_matchInput>
    connectOrCreate?: empossCreateOrConnectWithoutEm_applicant_matchInput
    connect?: empossWhereUniqueInput
  }

  export type em_apc_personalUpdateOneRequiredWithoutEm_applicant_matchNestedInput = {
    create?: XOR<em_apc_personalCreateWithoutEm_applicant_matchInput, em_apc_personalUncheckedCreateWithoutEm_applicant_matchInput>
    connectOrCreate?: em_apc_personalCreateOrConnectWithoutEm_applicant_matchInput
    upsert?: em_apc_personalUpsertWithoutEm_applicant_matchInput
    connect?: em_apc_personalWhereUniqueInput
    update?: XOR<XOR<em_apc_personalUpdateToOneWithWhereWithoutEm_applicant_matchInput, em_apc_personalUpdateWithoutEm_applicant_matchInput>, em_apc_personalUncheckedUpdateWithoutEm_applicant_matchInput>
  }

  export type empossUpdateOneRequiredWithoutEm_applicant_matchNestedInput = {
    create?: XOR<empossCreateWithoutEm_applicant_matchInput, empossUncheckedCreateWithoutEm_applicant_matchInput>
    connectOrCreate?: empossCreateOrConnectWithoutEm_applicant_matchInput
    upsert?: empossUpsertWithoutEm_applicant_matchInput
    connect?: empossWhereUniqueInput
    update?: XOR<XOR<empossUpdateToOneWithWhereWithoutEm_applicant_matchInput, empossUpdateWithoutEm_applicant_matchInput>, empossUncheckedUpdateWithoutEm_applicant_matchInput>
  }

  export type em_certificate_templatesCreateNestedOneWithoutEm_certificate_fieldsInput = {
    create?: XOR<em_certificate_templatesCreateWithoutEm_certificate_fieldsInput, em_certificate_templatesUncheckedCreateWithoutEm_certificate_fieldsInput>
    connectOrCreate?: em_certificate_templatesCreateOrConnectWithoutEm_certificate_fieldsInput
    connect?: em_certificate_templatesWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type em_certificate_templatesUpdateOneRequiredWithoutEm_certificate_fieldsNestedInput = {
    create?: XOR<em_certificate_templatesCreateWithoutEm_certificate_fieldsInput, em_certificate_templatesUncheckedCreateWithoutEm_certificate_fieldsInput>
    connectOrCreate?: em_certificate_templatesCreateOrConnectWithoutEm_certificate_fieldsInput
    upsert?: em_certificate_templatesUpsertWithoutEm_certificate_fieldsInput
    connect?: em_certificate_templatesWhereUniqueInput
    update?: XOR<XOR<em_certificate_templatesUpdateToOneWithWhereWithoutEm_certificate_fieldsInput, em_certificate_templatesUpdateWithoutEm_certificate_fieldsInput>, em_certificate_templatesUncheckedUpdateWithoutEm_certificate_fieldsInput>
  }

  export type em_certificate_fieldsCreateNestedManyWithoutEm_certificate_templatesInput = {
    create?: XOR<em_certificate_fieldsCreateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput> | em_certificate_fieldsCreateWithoutEm_certificate_templatesInput[] | em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput[]
    connectOrCreate?: em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput | em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput[]
    createMany?: em_certificate_fieldsCreateManyEm_certificate_templatesInputEnvelope
    connect?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
  }

  export type em_certificate_fieldsUncheckedCreateNestedManyWithoutEm_certificate_templatesInput = {
    create?: XOR<em_certificate_fieldsCreateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput> | em_certificate_fieldsCreateWithoutEm_certificate_templatesInput[] | em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput[]
    connectOrCreate?: em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput | em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput[]
    createMany?: em_certificate_fieldsCreateManyEm_certificate_templatesInputEnvelope
    connect?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
  }

  export type em_certificate_fieldsUpdateManyWithoutEm_certificate_templatesNestedInput = {
    create?: XOR<em_certificate_fieldsCreateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput> | em_certificate_fieldsCreateWithoutEm_certificate_templatesInput[] | em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput[]
    connectOrCreate?: em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput | em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput[]
    upsert?: em_certificate_fieldsUpsertWithWhereUniqueWithoutEm_certificate_templatesInput | em_certificate_fieldsUpsertWithWhereUniqueWithoutEm_certificate_templatesInput[]
    createMany?: em_certificate_fieldsCreateManyEm_certificate_templatesInputEnvelope
    set?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    disconnect?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    delete?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    connect?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    update?: em_certificate_fieldsUpdateWithWhereUniqueWithoutEm_certificate_templatesInput | em_certificate_fieldsUpdateWithWhereUniqueWithoutEm_certificate_templatesInput[]
    updateMany?: em_certificate_fieldsUpdateManyWithWhereWithoutEm_certificate_templatesInput | em_certificate_fieldsUpdateManyWithWhereWithoutEm_certificate_templatesInput[]
    deleteMany?: em_certificate_fieldsScalarWhereInput | em_certificate_fieldsScalarWhereInput[]
  }

  export type em_certificate_fieldsUncheckedUpdateManyWithoutEm_certificate_templatesNestedInput = {
    create?: XOR<em_certificate_fieldsCreateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput> | em_certificate_fieldsCreateWithoutEm_certificate_templatesInput[] | em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput[]
    connectOrCreate?: em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput | em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput[]
    upsert?: em_certificate_fieldsUpsertWithWhereUniqueWithoutEm_certificate_templatesInput | em_certificate_fieldsUpsertWithWhereUniqueWithoutEm_certificate_templatesInput[]
    createMany?: em_certificate_fieldsCreateManyEm_certificate_templatesInputEnvelope
    set?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    disconnect?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    delete?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    connect?: em_certificate_fieldsWhereUniqueInput | em_certificate_fieldsWhereUniqueInput[]
    update?: em_certificate_fieldsUpdateWithWhereUniqueWithoutEm_certificate_templatesInput | em_certificate_fieldsUpdateWithWhereUniqueWithoutEm_certificate_templatesInput[]
    updateMany?: em_certificate_fieldsUpdateManyWithWhereWithoutEm_certificate_templatesInput | em_certificate_fieldsUpdateManyWithWhereWithoutEm_certificate_templatesInput[]
    deleteMany?: em_certificate_fieldsScalarWhereInput | em_certificate_fieldsScalarWhereInput[]
  }

  export type em_event2CreateNestedManyWithoutEm_eventInput = {
    create?: XOR<em_event2CreateWithoutEm_eventInput, em_event2UncheckedCreateWithoutEm_eventInput> | em_event2CreateWithoutEm_eventInput[] | em_event2UncheckedCreateWithoutEm_eventInput[]
    connectOrCreate?: em_event2CreateOrConnectWithoutEm_eventInput | em_event2CreateOrConnectWithoutEm_eventInput[]
    createMany?: em_event2CreateManyEm_eventInputEnvelope
    connect?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
  }

  export type em_event2UncheckedCreateNestedManyWithoutEm_eventInput = {
    create?: XOR<em_event2CreateWithoutEm_eventInput, em_event2UncheckedCreateWithoutEm_eventInput> | em_event2CreateWithoutEm_eventInput[] | em_event2UncheckedCreateWithoutEm_eventInput[]
    connectOrCreate?: em_event2CreateOrConnectWithoutEm_eventInput | em_event2CreateOrConnectWithoutEm_eventInput[]
    createMany?: em_event2CreateManyEm_eventInputEnvelope
    connect?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
  }

  export type em_event2UpdateManyWithoutEm_eventNestedInput = {
    create?: XOR<em_event2CreateWithoutEm_eventInput, em_event2UncheckedCreateWithoutEm_eventInput> | em_event2CreateWithoutEm_eventInput[] | em_event2UncheckedCreateWithoutEm_eventInput[]
    connectOrCreate?: em_event2CreateOrConnectWithoutEm_eventInput | em_event2CreateOrConnectWithoutEm_eventInput[]
    upsert?: em_event2UpsertWithWhereUniqueWithoutEm_eventInput | em_event2UpsertWithWhereUniqueWithoutEm_eventInput[]
    createMany?: em_event2CreateManyEm_eventInputEnvelope
    set?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    disconnect?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    delete?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    connect?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    update?: em_event2UpdateWithWhereUniqueWithoutEm_eventInput | em_event2UpdateWithWhereUniqueWithoutEm_eventInput[]
    updateMany?: em_event2UpdateManyWithWhereWithoutEm_eventInput | em_event2UpdateManyWithWhereWithoutEm_eventInput[]
    deleteMany?: em_event2ScalarWhereInput | em_event2ScalarWhereInput[]
  }

  export type em_event2UncheckedUpdateManyWithoutEm_eventNestedInput = {
    create?: XOR<em_event2CreateWithoutEm_eventInput, em_event2UncheckedCreateWithoutEm_eventInput> | em_event2CreateWithoutEm_eventInput[] | em_event2UncheckedCreateWithoutEm_eventInput[]
    connectOrCreate?: em_event2CreateOrConnectWithoutEm_eventInput | em_event2CreateOrConnectWithoutEm_eventInput[]
    upsert?: em_event2UpsertWithWhereUniqueWithoutEm_eventInput | em_event2UpsertWithWhereUniqueWithoutEm_eventInput[]
    createMany?: em_event2CreateManyEm_eventInputEnvelope
    set?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    disconnect?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    delete?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    connect?: em_event2WhereUniqueInput | em_event2WhereUniqueInput[]
    update?: em_event2UpdateWithWhereUniqueWithoutEm_eventInput | em_event2UpdateWithWhereUniqueWithoutEm_eventInput[]
    updateMany?: em_event2UpdateManyWithWhereWithoutEm_eventInput | em_event2UpdateManyWithWhereWithoutEm_eventInput[]
    deleteMany?: em_event2ScalarWhereInput | em_event2ScalarWhereInput[]
  }

  export type em_eventCreateNestedOneWithoutEm_event2Input = {
    create?: XOR<em_eventCreateWithoutEm_event2Input, em_eventUncheckedCreateWithoutEm_event2Input>
    connectOrCreate?: em_eventCreateOrConnectWithoutEm_event2Input
    connect?: em_eventWhereUniqueInput
  }

  export type em_eventUpdateOneWithoutEm_event2NestedInput = {
    create?: XOR<em_eventCreateWithoutEm_event2Input, em_eventUncheckedCreateWithoutEm_event2Input>
    connectOrCreate?: em_eventCreateOrConnectWithoutEm_event2Input
    upsert?: em_eventUpsertWithoutEm_event2Input
    disconnect?: em_eventWhereInput | boolean
    delete?: em_eventWhereInput | boolean
    connect?: em_eventWhereUniqueInput
    update?: XOR<XOR<em_eventUpdateToOneWithWhereWithoutEm_event2Input, em_eventUpdateWithoutEm_event2Input>, em_eventUncheckedUpdateWithoutEm_event2Input>
  }

  export type em_loktopikCreateNestedManyWithoutEm_examsInput = {
    create?: XOR<em_loktopikCreateWithoutEm_examsInput, em_loktopikUncheckedCreateWithoutEm_examsInput> | em_loktopikCreateWithoutEm_examsInput[] | em_loktopikUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_examsInput | em_loktopikCreateOrConnectWithoutEm_examsInput[]
    createMany?: em_loktopikCreateManyEm_examsInputEnvelope
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
  }

  export type scoresCreateNestedManyWithoutEm_examsInput = {
    create?: XOR<scoresCreateWithoutEm_examsInput, scoresUncheckedCreateWithoutEm_examsInput> | scoresCreateWithoutEm_examsInput[] | scoresUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEm_examsInput | scoresCreateOrConnectWithoutEm_examsInput[]
    createMany?: scoresCreateManyEm_examsInputEnvelope
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
  }

  export type em_loktopikUncheckedCreateNestedManyWithoutEm_examsInput = {
    create?: XOR<em_loktopikCreateWithoutEm_examsInput, em_loktopikUncheckedCreateWithoutEm_examsInput> | em_loktopikCreateWithoutEm_examsInput[] | em_loktopikUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_examsInput | em_loktopikCreateOrConnectWithoutEm_examsInput[]
    createMany?: em_loktopikCreateManyEm_examsInputEnvelope
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
  }

  export type scoresUncheckedCreateNestedManyWithoutEm_examsInput = {
    create?: XOR<scoresCreateWithoutEm_examsInput, scoresUncheckedCreateWithoutEm_examsInput> | scoresCreateWithoutEm_examsInput[] | scoresUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEm_examsInput | scoresCreateOrConnectWithoutEm_examsInput[]
    createMany?: scoresCreateManyEm_examsInputEnvelope
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
  }

  export type em_loktopikUpdateManyWithoutEm_examsNestedInput = {
    create?: XOR<em_loktopikCreateWithoutEm_examsInput, em_loktopikUncheckedCreateWithoutEm_examsInput> | em_loktopikCreateWithoutEm_examsInput[] | em_loktopikUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_examsInput | em_loktopikCreateOrConnectWithoutEm_examsInput[]
    upsert?: em_loktopikUpsertWithWhereUniqueWithoutEm_examsInput | em_loktopikUpsertWithWhereUniqueWithoutEm_examsInput[]
    createMany?: em_loktopikCreateManyEm_examsInputEnvelope
    set?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    disconnect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    delete?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    update?: em_loktopikUpdateWithWhereUniqueWithoutEm_examsInput | em_loktopikUpdateWithWhereUniqueWithoutEm_examsInput[]
    updateMany?: em_loktopikUpdateManyWithWhereWithoutEm_examsInput | em_loktopikUpdateManyWithWhereWithoutEm_examsInput[]
    deleteMany?: em_loktopikScalarWhereInput | em_loktopikScalarWhereInput[]
  }

  export type scoresUpdateManyWithoutEm_examsNestedInput = {
    create?: XOR<scoresCreateWithoutEm_examsInput, scoresUncheckedCreateWithoutEm_examsInput> | scoresCreateWithoutEm_examsInput[] | scoresUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEm_examsInput | scoresCreateOrConnectWithoutEm_examsInput[]
    upsert?: scoresUpsertWithWhereUniqueWithoutEm_examsInput | scoresUpsertWithWhereUniqueWithoutEm_examsInput[]
    createMany?: scoresCreateManyEm_examsInputEnvelope
    set?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    disconnect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    delete?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    update?: scoresUpdateWithWhereUniqueWithoutEm_examsInput | scoresUpdateWithWhereUniqueWithoutEm_examsInput[]
    updateMany?: scoresUpdateManyWithWhereWithoutEm_examsInput | scoresUpdateManyWithWhereWithoutEm_examsInput[]
    deleteMany?: scoresScalarWhereInput | scoresScalarWhereInput[]
  }

  export type em_loktopikUncheckedUpdateManyWithoutEm_examsNestedInput = {
    create?: XOR<em_loktopikCreateWithoutEm_examsInput, em_loktopikUncheckedCreateWithoutEm_examsInput> | em_loktopikCreateWithoutEm_examsInput[] | em_loktopikUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_examsInput | em_loktopikCreateOrConnectWithoutEm_examsInput[]
    upsert?: em_loktopikUpsertWithWhereUniqueWithoutEm_examsInput | em_loktopikUpsertWithWhereUniqueWithoutEm_examsInput[]
    createMany?: em_loktopikCreateManyEm_examsInputEnvelope
    set?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    disconnect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    delete?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    update?: em_loktopikUpdateWithWhereUniqueWithoutEm_examsInput | em_loktopikUpdateWithWhereUniqueWithoutEm_examsInput[]
    updateMany?: em_loktopikUpdateManyWithWhereWithoutEm_examsInput | em_loktopikUpdateManyWithWhereWithoutEm_examsInput[]
    deleteMany?: em_loktopikScalarWhereInput | em_loktopikScalarWhereInput[]
  }

  export type scoresUncheckedUpdateManyWithoutEm_examsNestedInput = {
    create?: XOR<scoresCreateWithoutEm_examsInput, scoresUncheckedCreateWithoutEm_examsInput> | scoresCreateWithoutEm_examsInput[] | scoresUncheckedCreateWithoutEm_examsInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEm_examsInput | scoresCreateOrConnectWithoutEm_examsInput[]
    upsert?: scoresUpsertWithWhereUniqueWithoutEm_examsInput | scoresUpsertWithWhereUniqueWithoutEm_examsInput[]
    createMany?: scoresCreateManyEm_examsInputEnvelope
    set?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    disconnect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    delete?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    update?: scoresUpdateWithWhereUniqueWithoutEm_examsInput | scoresUpdateWithWhereUniqueWithoutEm_examsInput[]
    updateMany?: scoresUpdateManyWithWhereWithoutEm_examsInput | scoresUpdateManyWithWhereWithoutEm_examsInput[]
    deleteMany?: scoresScalarWhereInput | scoresScalarWhereInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type em_faq_catCreateNestedOneWithoutEm_faqInput = {
    create?: XOR<em_faq_catCreateWithoutEm_faqInput, em_faq_catUncheckedCreateWithoutEm_faqInput>
    connectOrCreate?: em_faq_catCreateOrConnectWithoutEm_faqInput
    connect?: em_faq_catWhereUniqueInput
  }

  export type em_faq_catUpdateOneWithoutEm_faqNestedInput = {
    create?: XOR<em_faq_catCreateWithoutEm_faqInput, em_faq_catUncheckedCreateWithoutEm_faqInput>
    connectOrCreate?: em_faq_catCreateOrConnectWithoutEm_faqInput
    upsert?: em_faq_catUpsertWithoutEm_faqInput
    disconnect?: em_faq_catWhereInput | boolean
    delete?: em_faq_catWhereInput | boolean
    connect?: em_faq_catWhereUniqueInput
    update?: XOR<XOR<em_faq_catUpdateToOneWithWhereWithoutEm_faqInput, em_faq_catUpdateWithoutEm_faqInput>, em_faq_catUncheckedUpdateWithoutEm_faqInput>
  }

  export type em_faqCreateNestedManyWithoutEm_faq_catInput = {
    create?: XOR<em_faqCreateWithoutEm_faq_catInput, em_faqUncheckedCreateWithoutEm_faq_catInput> | em_faqCreateWithoutEm_faq_catInput[] | em_faqUncheckedCreateWithoutEm_faq_catInput[]
    connectOrCreate?: em_faqCreateOrConnectWithoutEm_faq_catInput | em_faqCreateOrConnectWithoutEm_faq_catInput[]
    createMany?: em_faqCreateManyEm_faq_catInputEnvelope
    connect?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
  }

  export type em_faqUncheckedCreateNestedManyWithoutEm_faq_catInput = {
    create?: XOR<em_faqCreateWithoutEm_faq_catInput, em_faqUncheckedCreateWithoutEm_faq_catInput> | em_faqCreateWithoutEm_faq_catInput[] | em_faqUncheckedCreateWithoutEm_faq_catInput[]
    connectOrCreate?: em_faqCreateOrConnectWithoutEm_faq_catInput | em_faqCreateOrConnectWithoutEm_faq_catInput[]
    createMany?: em_faqCreateManyEm_faq_catInputEnvelope
    connect?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
  }

  export type em_faqUpdateManyWithoutEm_faq_catNestedInput = {
    create?: XOR<em_faqCreateWithoutEm_faq_catInput, em_faqUncheckedCreateWithoutEm_faq_catInput> | em_faqCreateWithoutEm_faq_catInput[] | em_faqUncheckedCreateWithoutEm_faq_catInput[]
    connectOrCreate?: em_faqCreateOrConnectWithoutEm_faq_catInput | em_faqCreateOrConnectWithoutEm_faq_catInput[]
    upsert?: em_faqUpsertWithWhereUniqueWithoutEm_faq_catInput | em_faqUpsertWithWhereUniqueWithoutEm_faq_catInput[]
    createMany?: em_faqCreateManyEm_faq_catInputEnvelope
    set?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    disconnect?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    delete?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    connect?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    update?: em_faqUpdateWithWhereUniqueWithoutEm_faq_catInput | em_faqUpdateWithWhereUniqueWithoutEm_faq_catInput[]
    updateMany?: em_faqUpdateManyWithWhereWithoutEm_faq_catInput | em_faqUpdateManyWithWhereWithoutEm_faq_catInput[]
    deleteMany?: em_faqScalarWhereInput | em_faqScalarWhereInput[]
  }

  export type em_faqUncheckedUpdateManyWithoutEm_faq_catNestedInput = {
    create?: XOR<em_faqCreateWithoutEm_faq_catInput, em_faqUncheckedCreateWithoutEm_faq_catInput> | em_faqCreateWithoutEm_faq_catInput[] | em_faqUncheckedCreateWithoutEm_faq_catInput[]
    connectOrCreate?: em_faqCreateOrConnectWithoutEm_faq_catInput | em_faqCreateOrConnectWithoutEm_faq_catInput[]
    upsert?: em_faqUpsertWithWhereUniqueWithoutEm_faq_catInput | em_faqUpsertWithWhereUniqueWithoutEm_faq_catInput[]
    createMany?: em_faqCreateManyEm_faq_catInputEnvelope
    set?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    disconnect?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    delete?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    connect?: em_faqWhereUniqueInput | em_faqWhereUniqueInput[]
    update?: em_faqUpdateWithWhereUniqueWithoutEm_faq_catInput | em_faqUpdateWithWhereUniqueWithoutEm_faq_catInput[]
    updateMany?: em_faqUpdateManyWithWhereWithoutEm_faq_catInput | em_faqUpdateManyWithWhereWithoutEm_faq_catInput[]
    deleteMany?: em_faqScalarWhereInput | em_faqScalarWhereInput[]
  }

  export type em_session_examsCreateNestedOneWithoutEm_jawaban_pesertaInput = {
    create?: XOR<em_session_examsCreateWithoutEm_jawaban_pesertaInput, em_session_examsUncheckedCreateWithoutEm_jawaban_pesertaInput>
    connectOrCreate?: em_session_examsCreateOrConnectWithoutEm_jawaban_pesertaInput
    connect?: em_session_examsWhereUniqueInput
  }

  export type em_session_examsUpdateOneRequiredWithoutEm_jawaban_pesertaNestedInput = {
    create?: XOR<em_session_examsCreateWithoutEm_jawaban_pesertaInput, em_session_examsUncheckedCreateWithoutEm_jawaban_pesertaInput>
    connectOrCreate?: em_session_examsCreateOrConnectWithoutEm_jawaban_pesertaInput
    upsert?: em_session_examsUpsertWithoutEm_jawaban_pesertaInput
    connect?: em_session_examsWhereUniqueInput
    update?: XOR<XOR<em_session_examsUpdateToOneWithWhereWithoutEm_jawaban_pesertaInput, em_session_examsUpdateWithoutEm_jawaban_pesertaInput>, em_session_examsUncheckedUpdateWithoutEm_jawaban_pesertaInput>
  }

  export type em_session_exams_apcCreateNestedOneWithoutEm_jawaban_peserta_apcInput = {
    create?: XOR<em_session_exams_apcCreateWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUncheckedCreateWithoutEm_jawaban_peserta_apcInput>
    connectOrCreate?: em_session_exams_apcCreateOrConnectWithoutEm_jawaban_peserta_apcInput
    connect?: em_session_exams_apcWhereUniqueInput
  }

  export type em_session_exams_apcUpdateOneRequiredWithoutEm_jawaban_peserta_apcNestedInput = {
    create?: XOR<em_session_exams_apcCreateWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUncheckedCreateWithoutEm_jawaban_peserta_apcInput>
    connectOrCreate?: em_session_exams_apcCreateOrConnectWithoutEm_jawaban_peserta_apcInput
    upsert?: em_session_exams_apcUpsertWithoutEm_jawaban_peserta_apcInput
    connect?: em_session_exams_apcWhereUniqueInput
    update?: XOR<XOR<em_session_exams_apcUpdateToOneWithWhereWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUpdateWithoutEm_jawaban_peserta_apcInput>, em_session_exams_apcUncheckedUpdateWithoutEm_jawaban_peserta_apcInput>
  }

  export type em_loktopikCreateNestedManyWithoutEm_lokerInput = {
    create?: XOR<em_loktopikCreateWithoutEm_lokerInput, em_loktopikUncheckedCreateWithoutEm_lokerInput> | em_loktopikCreateWithoutEm_lokerInput[] | em_loktopikUncheckedCreateWithoutEm_lokerInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_lokerInput | em_loktopikCreateOrConnectWithoutEm_lokerInput[]
    createMany?: em_loktopikCreateManyEm_lokerInputEnvelope
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
  }

  export type em_loktopikUncheckedCreateNestedManyWithoutEm_lokerInput = {
    create?: XOR<em_loktopikCreateWithoutEm_lokerInput, em_loktopikUncheckedCreateWithoutEm_lokerInput> | em_loktopikCreateWithoutEm_lokerInput[] | em_loktopikUncheckedCreateWithoutEm_lokerInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_lokerInput | em_loktopikCreateOrConnectWithoutEm_lokerInput[]
    createMany?: em_loktopikCreateManyEm_lokerInputEnvelope
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
  }

  export type em_loktopikUpdateManyWithoutEm_lokerNestedInput = {
    create?: XOR<em_loktopikCreateWithoutEm_lokerInput, em_loktopikUncheckedCreateWithoutEm_lokerInput> | em_loktopikCreateWithoutEm_lokerInput[] | em_loktopikUncheckedCreateWithoutEm_lokerInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_lokerInput | em_loktopikCreateOrConnectWithoutEm_lokerInput[]
    upsert?: em_loktopikUpsertWithWhereUniqueWithoutEm_lokerInput | em_loktopikUpsertWithWhereUniqueWithoutEm_lokerInput[]
    createMany?: em_loktopikCreateManyEm_lokerInputEnvelope
    set?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    disconnect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    delete?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    update?: em_loktopikUpdateWithWhereUniqueWithoutEm_lokerInput | em_loktopikUpdateWithWhereUniqueWithoutEm_lokerInput[]
    updateMany?: em_loktopikUpdateManyWithWhereWithoutEm_lokerInput | em_loktopikUpdateManyWithWhereWithoutEm_lokerInput[]
    deleteMany?: em_loktopikScalarWhereInput | em_loktopikScalarWhereInput[]
  }

  export type em_loktopikUncheckedUpdateManyWithoutEm_lokerNestedInput = {
    create?: XOR<em_loktopikCreateWithoutEm_lokerInput, em_loktopikUncheckedCreateWithoutEm_lokerInput> | em_loktopikCreateWithoutEm_lokerInput[] | em_loktopikUncheckedCreateWithoutEm_lokerInput[]
    connectOrCreate?: em_loktopikCreateOrConnectWithoutEm_lokerInput | em_loktopikCreateOrConnectWithoutEm_lokerInput[]
    upsert?: em_loktopikUpsertWithWhereUniqueWithoutEm_lokerInput | em_loktopikUpsertWithWhereUniqueWithoutEm_lokerInput[]
    createMany?: em_loktopikCreateManyEm_lokerInputEnvelope
    set?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    disconnect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    delete?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    connect?: em_loktopikWhereUniqueInput | em_loktopikWhereUniqueInput[]
    update?: em_loktopikUpdateWithWhereUniqueWithoutEm_lokerInput | em_loktopikUpdateWithWhereUniqueWithoutEm_lokerInput[]
    updateMany?: em_loktopikUpdateManyWithWhereWithoutEm_lokerInput | em_loktopikUpdateManyWithWhereWithoutEm_lokerInput[]
    deleteMany?: em_loktopikScalarWhereInput | em_loktopikScalarWhereInput[]
  }

  export type em_lokerCreateNestedOneWithoutEm_loktopikInput = {
    create?: XOR<em_lokerCreateWithoutEm_loktopikInput, em_lokerUncheckedCreateWithoutEm_loktopikInput>
    connectOrCreate?: em_lokerCreateOrConnectWithoutEm_loktopikInput
    connect?: em_lokerWhereUniqueInput
  }

  export type em_examsCreateNestedOneWithoutEm_loktopikInput = {
    create?: XOR<em_examsCreateWithoutEm_loktopikInput, em_examsUncheckedCreateWithoutEm_loktopikInput>
    connectOrCreate?: em_examsCreateOrConnectWithoutEm_loktopikInput
    connect?: em_examsWhereUniqueInput
  }

  export type em_lokerUpdateOneRequiredWithoutEm_loktopikNestedInput = {
    create?: XOR<em_lokerCreateWithoutEm_loktopikInput, em_lokerUncheckedCreateWithoutEm_loktopikInput>
    connectOrCreate?: em_lokerCreateOrConnectWithoutEm_loktopikInput
    upsert?: em_lokerUpsertWithoutEm_loktopikInput
    connect?: em_lokerWhereUniqueInput
    update?: XOR<XOR<em_lokerUpdateToOneWithWhereWithoutEm_loktopikInput, em_lokerUpdateWithoutEm_loktopikInput>, em_lokerUncheckedUpdateWithoutEm_loktopikInput>
  }

  export type em_examsUpdateOneRequiredWithoutEm_loktopikNestedInput = {
    create?: XOR<em_examsCreateWithoutEm_loktopikInput, em_examsUncheckedCreateWithoutEm_loktopikInput>
    connectOrCreate?: em_examsCreateOrConnectWithoutEm_loktopikInput
    upsert?: em_examsUpsertWithoutEm_loktopikInput
    connect?: em_examsWhereUniqueInput
    update?: XOR<XOR<em_examsUpdateToOneWithWhereWithoutEm_loktopikInput, em_examsUpdateWithoutEm_loktopikInput>, em_examsUncheckedUpdateWithoutEm_loktopikInput>
  }

  export type em_materi1CreateNestedOneWithoutEm_materi_fileInput = {
    create?: XOR<em_materi1CreateWithoutEm_materi_fileInput, em_materi1UncheckedCreateWithoutEm_materi_fileInput>
    connectOrCreate?: em_materi1CreateOrConnectWithoutEm_materi_fileInput
    connect?: em_materi1WhereUniqueInput
  }

  export type em_materi1UpdateOneRequiredWithoutEm_materi_fileNestedInput = {
    create?: XOR<em_materi1CreateWithoutEm_materi_fileInput, em_materi1UncheckedCreateWithoutEm_materi_fileInput>
    connectOrCreate?: em_materi1CreateOrConnectWithoutEm_materi_fileInput
    upsert?: em_materi1UpsertWithoutEm_materi_fileInput
    connect?: em_materi1WhereUniqueInput
    update?: XOR<XOR<em_materi1UpdateToOneWithWhereWithoutEm_materi_fileInput, em_materi1UpdateWithoutEm_materi_fileInput>, em_materi1UncheckedUpdateWithoutEm_materi_fileInput>
  }

  export type em_materi2CreateNestedManyWithoutEm_materi_typeInput = {
    create?: XOR<em_materi2CreateWithoutEm_materi_typeInput, em_materi2UncheckedCreateWithoutEm_materi_typeInput> | em_materi2CreateWithoutEm_materi_typeInput[] | em_materi2UncheckedCreateWithoutEm_materi_typeInput[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi_typeInput | em_materi2CreateOrConnectWithoutEm_materi_typeInput[]
    createMany?: em_materi2CreateManyEm_materi_typeInputEnvelope
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
  }

  export type em_materi2UncheckedCreateNestedManyWithoutEm_materi_typeInput = {
    create?: XOR<em_materi2CreateWithoutEm_materi_typeInput, em_materi2UncheckedCreateWithoutEm_materi_typeInput> | em_materi2CreateWithoutEm_materi_typeInput[] | em_materi2UncheckedCreateWithoutEm_materi_typeInput[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi_typeInput | em_materi2CreateOrConnectWithoutEm_materi_typeInput[]
    createMany?: em_materi2CreateManyEm_materi_typeInputEnvelope
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
  }

  export type em_materi2UpdateManyWithoutEm_materi_typeNestedInput = {
    create?: XOR<em_materi2CreateWithoutEm_materi_typeInput, em_materi2UncheckedCreateWithoutEm_materi_typeInput> | em_materi2CreateWithoutEm_materi_typeInput[] | em_materi2UncheckedCreateWithoutEm_materi_typeInput[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi_typeInput | em_materi2CreateOrConnectWithoutEm_materi_typeInput[]
    upsert?: em_materi2UpsertWithWhereUniqueWithoutEm_materi_typeInput | em_materi2UpsertWithWhereUniqueWithoutEm_materi_typeInput[]
    createMany?: em_materi2CreateManyEm_materi_typeInputEnvelope
    set?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    disconnect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    delete?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    update?: em_materi2UpdateWithWhereUniqueWithoutEm_materi_typeInput | em_materi2UpdateWithWhereUniqueWithoutEm_materi_typeInput[]
    updateMany?: em_materi2UpdateManyWithWhereWithoutEm_materi_typeInput | em_materi2UpdateManyWithWhereWithoutEm_materi_typeInput[]
    deleteMany?: em_materi2ScalarWhereInput | em_materi2ScalarWhereInput[]
  }

  export type em_materi2UncheckedUpdateManyWithoutEm_materi_typeNestedInput = {
    create?: XOR<em_materi2CreateWithoutEm_materi_typeInput, em_materi2UncheckedCreateWithoutEm_materi_typeInput> | em_materi2CreateWithoutEm_materi_typeInput[] | em_materi2UncheckedCreateWithoutEm_materi_typeInput[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi_typeInput | em_materi2CreateOrConnectWithoutEm_materi_typeInput[]
    upsert?: em_materi2UpsertWithWhereUniqueWithoutEm_materi_typeInput | em_materi2UpsertWithWhereUniqueWithoutEm_materi_typeInput[]
    createMany?: em_materi2CreateManyEm_materi_typeInputEnvelope
    set?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    disconnect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    delete?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    update?: em_materi2UpdateWithWhereUniqueWithoutEm_materi_typeInput | em_materi2UpdateWithWhereUniqueWithoutEm_materi_typeInput[]
    updateMany?: em_materi2UpdateManyWithWhereWithoutEm_materi_typeInput | em_materi2UpdateManyWithWhereWithoutEm_materi_typeInput[]
    deleteMany?: em_materi2ScalarWhereInput | em_materi2ScalarWhereInput[]
  }

  export type em_materi_fileCreateNestedManyWithoutEm_materi1Input = {
    create?: XOR<em_materi_fileCreateWithoutEm_materi1Input, em_materi_fileUncheckedCreateWithoutEm_materi1Input> | em_materi_fileCreateWithoutEm_materi1Input[] | em_materi_fileUncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi_fileCreateOrConnectWithoutEm_materi1Input | em_materi_fileCreateOrConnectWithoutEm_materi1Input[]
    createMany?: em_materi_fileCreateManyEm_materi1InputEnvelope
    connect?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
  }

  export type em_materi2CreateNestedManyWithoutEm_materi1Input = {
    create?: XOR<em_materi2CreateWithoutEm_materi1Input, em_materi2UncheckedCreateWithoutEm_materi1Input> | em_materi2CreateWithoutEm_materi1Input[] | em_materi2UncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi1Input | em_materi2CreateOrConnectWithoutEm_materi1Input[]
    createMany?: em_materi2CreateManyEm_materi1InputEnvelope
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
  }

  export type em_materi_fileUncheckedCreateNestedManyWithoutEm_materi1Input = {
    create?: XOR<em_materi_fileCreateWithoutEm_materi1Input, em_materi_fileUncheckedCreateWithoutEm_materi1Input> | em_materi_fileCreateWithoutEm_materi1Input[] | em_materi_fileUncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi_fileCreateOrConnectWithoutEm_materi1Input | em_materi_fileCreateOrConnectWithoutEm_materi1Input[]
    createMany?: em_materi_fileCreateManyEm_materi1InputEnvelope
    connect?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
  }

  export type em_materi2UncheckedCreateNestedManyWithoutEm_materi1Input = {
    create?: XOR<em_materi2CreateWithoutEm_materi1Input, em_materi2UncheckedCreateWithoutEm_materi1Input> | em_materi2CreateWithoutEm_materi1Input[] | em_materi2UncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi1Input | em_materi2CreateOrConnectWithoutEm_materi1Input[]
    createMany?: em_materi2CreateManyEm_materi1InputEnvelope
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type em_materi_fileUpdateManyWithoutEm_materi1NestedInput = {
    create?: XOR<em_materi_fileCreateWithoutEm_materi1Input, em_materi_fileUncheckedCreateWithoutEm_materi1Input> | em_materi_fileCreateWithoutEm_materi1Input[] | em_materi_fileUncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi_fileCreateOrConnectWithoutEm_materi1Input | em_materi_fileCreateOrConnectWithoutEm_materi1Input[]
    upsert?: em_materi_fileUpsertWithWhereUniqueWithoutEm_materi1Input | em_materi_fileUpsertWithWhereUniqueWithoutEm_materi1Input[]
    createMany?: em_materi_fileCreateManyEm_materi1InputEnvelope
    set?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    disconnect?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    delete?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    connect?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    update?: em_materi_fileUpdateWithWhereUniqueWithoutEm_materi1Input | em_materi_fileUpdateWithWhereUniqueWithoutEm_materi1Input[]
    updateMany?: em_materi_fileUpdateManyWithWhereWithoutEm_materi1Input | em_materi_fileUpdateManyWithWhereWithoutEm_materi1Input[]
    deleteMany?: em_materi_fileScalarWhereInput | em_materi_fileScalarWhereInput[]
  }

  export type em_materi2UpdateManyWithoutEm_materi1NestedInput = {
    create?: XOR<em_materi2CreateWithoutEm_materi1Input, em_materi2UncheckedCreateWithoutEm_materi1Input> | em_materi2CreateWithoutEm_materi1Input[] | em_materi2UncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi1Input | em_materi2CreateOrConnectWithoutEm_materi1Input[]
    upsert?: em_materi2UpsertWithWhereUniqueWithoutEm_materi1Input | em_materi2UpsertWithWhereUniqueWithoutEm_materi1Input[]
    createMany?: em_materi2CreateManyEm_materi1InputEnvelope
    set?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    disconnect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    delete?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    update?: em_materi2UpdateWithWhereUniqueWithoutEm_materi1Input | em_materi2UpdateWithWhereUniqueWithoutEm_materi1Input[]
    updateMany?: em_materi2UpdateManyWithWhereWithoutEm_materi1Input | em_materi2UpdateManyWithWhereWithoutEm_materi1Input[]
    deleteMany?: em_materi2ScalarWhereInput | em_materi2ScalarWhereInput[]
  }

  export type em_materi_fileUncheckedUpdateManyWithoutEm_materi1NestedInput = {
    create?: XOR<em_materi_fileCreateWithoutEm_materi1Input, em_materi_fileUncheckedCreateWithoutEm_materi1Input> | em_materi_fileCreateWithoutEm_materi1Input[] | em_materi_fileUncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi_fileCreateOrConnectWithoutEm_materi1Input | em_materi_fileCreateOrConnectWithoutEm_materi1Input[]
    upsert?: em_materi_fileUpsertWithWhereUniqueWithoutEm_materi1Input | em_materi_fileUpsertWithWhereUniqueWithoutEm_materi1Input[]
    createMany?: em_materi_fileCreateManyEm_materi1InputEnvelope
    set?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    disconnect?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    delete?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    connect?: em_materi_fileWhereUniqueInput | em_materi_fileWhereUniqueInput[]
    update?: em_materi_fileUpdateWithWhereUniqueWithoutEm_materi1Input | em_materi_fileUpdateWithWhereUniqueWithoutEm_materi1Input[]
    updateMany?: em_materi_fileUpdateManyWithWhereWithoutEm_materi1Input | em_materi_fileUpdateManyWithWhereWithoutEm_materi1Input[]
    deleteMany?: em_materi_fileScalarWhereInput | em_materi_fileScalarWhereInput[]
  }

  export type em_materi2UncheckedUpdateManyWithoutEm_materi1NestedInput = {
    create?: XOR<em_materi2CreateWithoutEm_materi1Input, em_materi2UncheckedCreateWithoutEm_materi1Input> | em_materi2CreateWithoutEm_materi1Input[] | em_materi2UncheckedCreateWithoutEm_materi1Input[]
    connectOrCreate?: em_materi2CreateOrConnectWithoutEm_materi1Input | em_materi2CreateOrConnectWithoutEm_materi1Input[]
    upsert?: em_materi2UpsertWithWhereUniqueWithoutEm_materi1Input | em_materi2UpsertWithWhereUniqueWithoutEm_materi1Input[]
    createMany?: em_materi2CreateManyEm_materi1InputEnvelope
    set?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    disconnect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    delete?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    connect?: em_materi2WhereUniqueInput | em_materi2WhereUniqueInput[]
    update?: em_materi2UpdateWithWhereUniqueWithoutEm_materi1Input | em_materi2UpdateWithWhereUniqueWithoutEm_materi1Input[]
    updateMany?: em_materi2UpdateManyWithWhereWithoutEm_materi1Input | em_materi2UpdateManyWithWhereWithoutEm_materi1Input[]
    deleteMany?: em_materi2ScalarWhereInput | em_materi2ScalarWhereInput[]
  }

  export type em_materi_typeCreateNestedOneWithoutEm_materi2Input = {
    create?: XOR<em_materi_typeCreateWithoutEm_materi2Input, em_materi_typeUncheckedCreateWithoutEm_materi2Input>
    connectOrCreate?: em_materi_typeCreateOrConnectWithoutEm_materi2Input
    connect?: em_materi_typeWhereUniqueInput
  }

  export type em_materi1CreateNestedOneWithoutEm_materi2Input = {
    create?: XOR<em_materi1CreateWithoutEm_materi2Input, em_materi1UncheckedCreateWithoutEm_materi2Input>
    connectOrCreate?: em_materi1CreateOrConnectWithoutEm_materi2Input
    connect?: em_materi1WhereUniqueInput
  }

  export type em_materi_typeUpdateOneRequiredWithoutEm_materi2NestedInput = {
    create?: XOR<em_materi_typeCreateWithoutEm_materi2Input, em_materi_typeUncheckedCreateWithoutEm_materi2Input>
    connectOrCreate?: em_materi_typeCreateOrConnectWithoutEm_materi2Input
    upsert?: em_materi_typeUpsertWithoutEm_materi2Input
    connect?: em_materi_typeWhereUniqueInput
    update?: XOR<XOR<em_materi_typeUpdateToOneWithWhereWithoutEm_materi2Input, em_materi_typeUpdateWithoutEm_materi2Input>, em_materi_typeUncheckedUpdateWithoutEm_materi2Input>
  }

  export type em_materi1UpdateOneRequiredWithoutEm_materi2NestedInput = {
    create?: XOR<em_materi1CreateWithoutEm_materi2Input, em_materi1UncheckedCreateWithoutEm_materi2Input>
    connectOrCreate?: em_materi1CreateOrConnectWithoutEm_materi2Input
    upsert?: em_materi1UpsertWithoutEm_materi2Input
    connect?: em_materi1WhereUniqueInput
    update?: XOR<XOR<em_materi1UpdateToOneWithWhereWithoutEm_materi2Input, em_materi1UpdateWithoutEm_materi2Input>, em_materi1UncheckedUpdateWithoutEm_materi2Input>
  }

  export type em_questions2CreateNestedManyWithoutEm_questions1Input = {
    create?: XOR<em_questions2CreateWithoutEm_questions1Input, em_questions2UncheckedCreateWithoutEm_questions1Input> | em_questions2CreateWithoutEm_questions1Input[] | em_questions2UncheckedCreateWithoutEm_questions1Input[]
    connectOrCreate?: em_questions2CreateOrConnectWithoutEm_questions1Input | em_questions2CreateOrConnectWithoutEm_questions1Input[]
    createMany?: em_questions2CreateManyEm_questions1InputEnvelope
    connect?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
  }

  export type em_questions2UncheckedCreateNestedManyWithoutEm_questions1Input = {
    create?: XOR<em_questions2CreateWithoutEm_questions1Input, em_questions2UncheckedCreateWithoutEm_questions1Input> | em_questions2CreateWithoutEm_questions1Input[] | em_questions2UncheckedCreateWithoutEm_questions1Input[]
    connectOrCreate?: em_questions2CreateOrConnectWithoutEm_questions1Input | em_questions2CreateOrConnectWithoutEm_questions1Input[]
    createMany?: em_questions2CreateManyEm_questions1InputEnvelope
    connect?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
  }

  export type em_questions2UpdateManyWithoutEm_questions1NestedInput = {
    create?: XOR<em_questions2CreateWithoutEm_questions1Input, em_questions2UncheckedCreateWithoutEm_questions1Input> | em_questions2CreateWithoutEm_questions1Input[] | em_questions2UncheckedCreateWithoutEm_questions1Input[]
    connectOrCreate?: em_questions2CreateOrConnectWithoutEm_questions1Input | em_questions2CreateOrConnectWithoutEm_questions1Input[]
    upsert?: em_questions2UpsertWithWhereUniqueWithoutEm_questions1Input | em_questions2UpsertWithWhereUniqueWithoutEm_questions1Input[]
    createMany?: em_questions2CreateManyEm_questions1InputEnvelope
    set?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    disconnect?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    delete?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    connect?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    update?: em_questions2UpdateWithWhereUniqueWithoutEm_questions1Input | em_questions2UpdateWithWhereUniqueWithoutEm_questions1Input[]
    updateMany?: em_questions2UpdateManyWithWhereWithoutEm_questions1Input | em_questions2UpdateManyWithWhereWithoutEm_questions1Input[]
    deleteMany?: em_questions2ScalarWhereInput | em_questions2ScalarWhereInput[]
  }

  export type em_questions2UncheckedUpdateManyWithoutEm_questions1NestedInput = {
    create?: XOR<em_questions2CreateWithoutEm_questions1Input, em_questions2UncheckedCreateWithoutEm_questions1Input> | em_questions2CreateWithoutEm_questions1Input[] | em_questions2UncheckedCreateWithoutEm_questions1Input[]
    connectOrCreate?: em_questions2CreateOrConnectWithoutEm_questions1Input | em_questions2CreateOrConnectWithoutEm_questions1Input[]
    upsert?: em_questions2UpsertWithWhereUniqueWithoutEm_questions1Input | em_questions2UpsertWithWhereUniqueWithoutEm_questions1Input[]
    createMany?: em_questions2CreateManyEm_questions1InputEnvelope
    set?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    disconnect?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    delete?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    connect?: em_questions2WhereUniqueInput | em_questions2WhereUniqueInput[]
    update?: em_questions2UpdateWithWhereUniqueWithoutEm_questions1Input | em_questions2UpdateWithWhereUniqueWithoutEm_questions1Input[]
    updateMany?: em_questions2UpdateManyWithWhereWithoutEm_questions1Input | em_questions2UpdateManyWithWhereWithoutEm_questions1Input[]
    deleteMany?: em_questions2ScalarWhereInput | em_questions2ScalarWhereInput[]
  }

  export type em_questions1CreateNestedOneWithoutEm_questions2Input = {
    create?: XOR<em_questions1CreateWithoutEm_questions2Input, em_questions1UncheckedCreateWithoutEm_questions2Input>
    connectOrCreate?: em_questions1CreateOrConnectWithoutEm_questions2Input
    connect?: em_questions1WhereUniqueInput
  }

  export type em_questions1UpdateOneRequiredWithoutEm_questions2NestedInput = {
    create?: XOR<em_questions1CreateWithoutEm_questions2Input, em_questions1UncheckedCreateWithoutEm_questions2Input>
    connectOrCreate?: em_questions1CreateOrConnectWithoutEm_questions2Input
    upsert?: em_questions1UpsertWithoutEm_questions2Input
    connect?: em_questions1WhereUniqueInput
    update?: XOR<XOR<em_questions1UpdateToOneWithWhereWithoutEm_questions2Input, em_questions1UpdateWithoutEm_questions2Input>, em_questions1UncheckedUpdateWithoutEm_questions2Input>
  }

  export type em_schedule2CreateNestedManyWithoutEm_schedule1Input = {
    create?: XOR<em_schedule2CreateWithoutEm_schedule1Input, em_schedule2UncheckedCreateWithoutEm_schedule1Input> | em_schedule2CreateWithoutEm_schedule1Input[] | em_schedule2UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule2CreateOrConnectWithoutEm_schedule1Input | em_schedule2CreateOrConnectWithoutEm_schedule1Input[]
    createMany?: em_schedule2CreateManyEm_schedule1InputEnvelope
    connect?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
  }

  export type em_schedule3CreateNestedManyWithoutEm_schedule1Input = {
    create?: XOR<em_schedule3CreateWithoutEm_schedule1Input, em_schedule3UncheckedCreateWithoutEm_schedule1Input> | em_schedule3CreateWithoutEm_schedule1Input[] | em_schedule3UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule3CreateOrConnectWithoutEm_schedule1Input | em_schedule3CreateOrConnectWithoutEm_schedule1Input[]
    createMany?: em_schedule3CreateManyEm_schedule1InputEnvelope
    connect?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
  }

  export type em_schedule4CreateNestedManyWithoutEm_schedule1Input = {
    create?: XOR<em_schedule4CreateWithoutEm_schedule1Input, em_schedule4UncheckedCreateWithoutEm_schedule1Input> | em_schedule4CreateWithoutEm_schedule1Input[] | em_schedule4UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule4CreateOrConnectWithoutEm_schedule1Input | em_schedule4CreateOrConnectWithoutEm_schedule1Input[]
    createMany?: em_schedule4CreateManyEm_schedule1InputEnvelope
    connect?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
  }

  export type em_schedule2UncheckedCreateNestedManyWithoutEm_schedule1Input = {
    create?: XOR<em_schedule2CreateWithoutEm_schedule1Input, em_schedule2UncheckedCreateWithoutEm_schedule1Input> | em_schedule2CreateWithoutEm_schedule1Input[] | em_schedule2UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule2CreateOrConnectWithoutEm_schedule1Input | em_schedule2CreateOrConnectWithoutEm_schedule1Input[]
    createMany?: em_schedule2CreateManyEm_schedule1InputEnvelope
    connect?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
  }

  export type em_schedule3UncheckedCreateNestedManyWithoutEm_schedule1Input = {
    create?: XOR<em_schedule3CreateWithoutEm_schedule1Input, em_schedule3UncheckedCreateWithoutEm_schedule1Input> | em_schedule3CreateWithoutEm_schedule1Input[] | em_schedule3UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule3CreateOrConnectWithoutEm_schedule1Input | em_schedule3CreateOrConnectWithoutEm_schedule1Input[]
    createMany?: em_schedule3CreateManyEm_schedule1InputEnvelope
    connect?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
  }

  export type em_schedule4UncheckedCreateNestedManyWithoutEm_schedule1Input = {
    create?: XOR<em_schedule4CreateWithoutEm_schedule1Input, em_schedule4UncheckedCreateWithoutEm_schedule1Input> | em_schedule4CreateWithoutEm_schedule1Input[] | em_schedule4UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule4CreateOrConnectWithoutEm_schedule1Input | em_schedule4CreateOrConnectWithoutEm_schedule1Input[]
    createMany?: em_schedule4CreateManyEm_schedule1InputEnvelope
    connect?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
  }

  export type em_schedule2UpdateManyWithoutEm_schedule1NestedInput = {
    create?: XOR<em_schedule2CreateWithoutEm_schedule1Input, em_schedule2UncheckedCreateWithoutEm_schedule1Input> | em_schedule2CreateWithoutEm_schedule1Input[] | em_schedule2UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule2CreateOrConnectWithoutEm_schedule1Input | em_schedule2CreateOrConnectWithoutEm_schedule1Input[]
    upsert?: em_schedule2UpsertWithWhereUniqueWithoutEm_schedule1Input | em_schedule2UpsertWithWhereUniqueWithoutEm_schedule1Input[]
    createMany?: em_schedule2CreateManyEm_schedule1InputEnvelope
    set?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    disconnect?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    delete?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    connect?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    update?: em_schedule2UpdateWithWhereUniqueWithoutEm_schedule1Input | em_schedule2UpdateWithWhereUniqueWithoutEm_schedule1Input[]
    updateMany?: em_schedule2UpdateManyWithWhereWithoutEm_schedule1Input | em_schedule2UpdateManyWithWhereWithoutEm_schedule1Input[]
    deleteMany?: em_schedule2ScalarWhereInput | em_schedule2ScalarWhereInput[]
  }

  export type em_schedule3UpdateManyWithoutEm_schedule1NestedInput = {
    create?: XOR<em_schedule3CreateWithoutEm_schedule1Input, em_schedule3UncheckedCreateWithoutEm_schedule1Input> | em_schedule3CreateWithoutEm_schedule1Input[] | em_schedule3UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule3CreateOrConnectWithoutEm_schedule1Input | em_schedule3CreateOrConnectWithoutEm_schedule1Input[]
    upsert?: em_schedule3UpsertWithWhereUniqueWithoutEm_schedule1Input | em_schedule3UpsertWithWhereUniqueWithoutEm_schedule1Input[]
    createMany?: em_schedule3CreateManyEm_schedule1InputEnvelope
    set?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    disconnect?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    delete?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    connect?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    update?: em_schedule3UpdateWithWhereUniqueWithoutEm_schedule1Input | em_schedule3UpdateWithWhereUniqueWithoutEm_schedule1Input[]
    updateMany?: em_schedule3UpdateManyWithWhereWithoutEm_schedule1Input | em_schedule3UpdateManyWithWhereWithoutEm_schedule1Input[]
    deleteMany?: em_schedule3ScalarWhereInput | em_schedule3ScalarWhereInput[]
  }

  export type em_schedule4UpdateManyWithoutEm_schedule1NestedInput = {
    create?: XOR<em_schedule4CreateWithoutEm_schedule1Input, em_schedule4UncheckedCreateWithoutEm_schedule1Input> | em_schedule4CreateWithoutEm_schedule1Input[] | em_schedule4UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule4CreateOrConnectWithoutEm_schedule1Input | em_schedule4CreateOrConnectWithoutEm_schedule1Input[]
    upsert?: em_schedule4UpsertWithWhereUniqueWithoutEm_schedule1Input | em_schedule4UpsertWithWhereUniqueWithoutEm_schedule1Input[]
    createMany?: em_schedule4CreateManyEm_schedule1InputEnvelope
    set?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    disconnect?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    delete?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    connect?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    update?: em_schedule4UpdateWithWhereUniqueWithoutEm_schedule1Input | em_schedule4UpdateWithWhereUniqueWithoutEm_schedule1Input[]
    updateMany?: em_schedule4UpdateManyWithWhereWithoutEm_schedule1Input | em_schedule4UpdateManyWithWhereWithoutEm_schedule1Input[]
    deleteMany?: em_schedule4ScalarWhereInput | em_schedule4ScalarWhereInput[]
  }

  export type em_schedule2UncheckedUpdateManyWithoutEm_schedule1NestedInput = {
    create?: XOR<em_schedule2CreateWithoutEm_schedule1Input, em_schedule2UncheckedCreateWithoutEm_schedule1Input> | em_schedule2CreateWithoutEm_schedule1Input[] | em_schedule2UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule2CreateOrConnectWithoutEm_schedule1Input | em_schedule2CreateOrConnectWithoutEm_schedule1Input[]
    upsert?: em_schedule2UpsertWithWhereUniqueWithoutEm_schedule1Input | em_schedule2UpsertWithWhereUniqueWithoutEm_schedule1Input[]
    createMany?: em_schedule2CreateManyEm_schedule1InputEnvelope
    set?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    disconnect?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    delete?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    connect?: em_schedule2WhereUniqueInput | em_schedule2WhereUniqueInput[]
    update?: em_schedule2UpdateWithWhereUniqueWithoutEm_schedule1Input | em_schedule2UpdateWithWhereUniqueWithoutEm_schedule1Input[]
    updateMany?: em_schedule2UpdateManyWithWhereWithoutEm_schedule1Input | em_schedule2UpdateManyWithWhereWithoutEm_schedule1Input[]
    deleteMany?: em_schedule2ScalarWhereInput | em_schedule2ScalarWhereInput[]
  }

  export type em_schedule3UncheckedUpdateManyWithoutEm_schedule1NestedInput = {
    create?: XOR<em_schedule3CreateWithoutEm_schedule1Input, em_schedule3UncheckedCreateWithoutEm_schedule1Input> | em_schedule3CreateWithoutEm_schedule1Input[] | em_schedule3UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule3CreateOrConnectWithoutEm_schedule1Input | em_schedule3CreateOrConnectWithoutEm_schedule1Input[]
    upsert?: em_schedule3UpsertWithWhereUniqueWithoutEm_schedule1Input | em_schedule3UpsertWithWhereUniqueWithoutEm_schedule1Input[]
    createMany?: em_schedule3CreateManyEm_schedule1InputEnvelope
    set?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    disconnect?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    delete?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    connect?: em_schedule3WhereUniqueInput | em_schedule3WhereUniqueInput[]
    update?: em_schedule3UpdateWithWhereUniqueWithoutEm_schedule1Input | em_schedule3UpdateWithWhereUniqueWithoutEm_schedule1Input[]
    updateMany?: em_schedule3UpdateManyWithWhereWithoutEm_schedule1Input | em_schedule3UpdateManyWithWhereWithoutEm_schedule1Input[]
    deleteMany?: em_schedule3ScalarWhereInput | em_schedule3ScalarWhereInput[]
  }

  export type em_schedule4UncheckedUpdateManyWithoutEm_schedule1NestedInput = {
    create?: XOR<em_schedule4CreateWithoutEm_schedule1Input, em_schedule4UncheckedCreateWithoutEm_schedule1Input> | em_schedule4CreateWithoutEm_schedule1Input[] | em_schedule4UncheckedCreateWithoutEm_schedule1Input[]
    connectOrCreate?: em_schedule4CreateOrConnectWithoutEm_schedule1Input | em_schedule4CreateOrConnectWithoutEm_schedule1Input[]
    upsert?: em_schedule4UpsertWithWhereUniqueWithoutEm_schedule1Input | em_schedule4UpsertWithWhereUniqueWithoutEm_schedule1Input[]
    createMany?: em_schedule4CreateManyEm_schedule1InputEnvelope
    set?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    disconnect?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    delete?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    connect?: em_schedule4WhereUniqueInput | em_schedule4WhereUniqueInput[]
    update?: em_schedule4UpdateWithWhereUniqueWithoutEm_schedule1Input | em_schedule4UpdateWithWhereUniqueWithoutEm_schedule1Input[]
    updateMany?: em_schedule4UpdateManyWithWhereWithoutEm_schedule1Input | em_schedule4UpdateManyWithWhereWithoutEm_schedule1Input[]
    deleteMany?: em_schedule4ScalarWhereInput | em_schedule4ScalarWhereInput[]
  }

  export type em_schedule1CreateNestedOneWithoutEm_schedule2Input = {
    create?: XOR<em_schedule1CreateWithoutEm_schedule2Input, em_schedule1UncheckedCreateWithoutEm_schedule2Input>
    connectOrCreate?: em_schedule1CreateOrConnectWithoutEm_schedule2Input
    connect?: em_schedule1WhereUniqueInput
  }

  export type em_schedule1UpdateOneWithoutEm_schedule2NestedInput = {
    create?: XOR<em_schedule1CreateWithoutEm_schedule2Input, em_schedule1UncheckedCreateWithoutEm_schedule2Input>
    connectOrCreate?: em_schedule1CreateOrConnectWithoutEm_schedule2Input
    upsert?: em_schedule1UpsertWithoutEm_schedule2Input
    disconnect?: em_schedule1WhereInput | boolean
    delete?: em_schedule1WhereInput | boolean
    connect?: em_schedule1WhereUniqueInput
    update?: XOR<XOR<em_schedule1UpdateToOneWithWhereWithoutEm_schedule2Input, em_schedule1UpdateWithoutEm_schedule2Input>, em_schedule1UncheckedUpdateWithoutEm_schedule2Input>
  }

  export type em_schedule1CreateNestedOneWithoutEm_schedule3Input = {
    create?: XOR<em_schedule1CreateWithoutEm_schedule3Input, em_schedule1UncheckedCreateWithoutEm_schedule3Input>
    connectOrCreate?: em_schedule1CreateOrConnectWithoutEm_schedule3Input
    connect?: em_schedule1WhereUniqueInput
  }

  export type em_schedule1UpdateOneRequiredWithoutEm_schedule3NestedInput = {
    create?: XOR<em_schedule1CreateWithoutEm_schedule3Input, em_schedule1UncheckedCreateWithoutEm_schedule3Input>
    connectOrCreate?: em_schedule1CreateOrConnectWithoutEm_schedule3Input
    upsert?: em_schedule1UpsertWithoutEm_schedule3Input
    connect?: em_schedule1WhereUniqueInput
    update?: XOR<XOR<em_schedule1UpdateToOneWithWhereWithoutEm_schedule3Input, em_schedule1UpdateWithoutEm_schedule3Input>, em_schedule1UncheckedUpdateWithoutEm_schedule3Input>
  }

  export type em_schedule1CreateNestedOneWithoutEm_schedule4Input = {
    create?: XOR<em_schedule1CreateWithoutEm_schedule4Input, em_schedule1UncheckedCreateWithoutEm_schedule4Input>
    connectOrCreate?: em_schedule1CreateOrConnectWithoutEm_schedule4Input
    connect?: em_schedule1WhereUniqueInput
  }

  export type em_schedule1UpdateOneWithoutEm_schedule4NestedInput = {
    create?: XOR<em_schedule1CreateWithoutEm_schedule4Input, em_schedule1UncheckedCreateWithoutEm_schedule4Input>
    connectOrCreate?: em_schedule1CreateOrConnectWithoutEm_schedule4Input
    upsert?: em_schedule1UpsertWithoutEm_schedule4Input
    disconnect?: em_schedule1WhereInput | boolean
    delete?: em_schedule1WhereInput | boolean
    connect?: em_schedule1WhereUniqueInput
    update?: XOR<XOR<em_schedule1UpdateToOneWithWhereWithoutEm_schedule4Input, em_schedule1UpdateWithoutEm_schedule4Input>, em_schedule1UncheckedUpdateWithoutEm_schedule4Input>
  }

  export type em_jawaban_pesertaCreateNestedManyWithoutEm_session_examsInput = {
    create?: XOR<em_jawaban_pesertaCreateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput> | em_jawaban_pesertaCreateWithoutEm_session_examsInput[] | em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput[]
    connectOrCreate?: em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput | em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput[]
    createMany?: em_jawaban_pesertaCreateManyEm_session_examsInputEnvelope
    connect?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
  }

  export type em_jawaban_pesertaUncheckedCreateNestedManyWithoutEm_session_examsInput = {
    create?: XOR<em_jawaban_pesertaCreateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput> | em_jawaban_pesertaCreateWithoutEm_session_examsInput[] | em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput[]
    connectOrCreate?: em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput | em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput[]
    createMany?: em_jawaban_pesertaCreateManyEm_session_examsInputEnvelope
    connect?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
  }

  export type em_jawaban_pesertaUpdateManyWithoutEm_session_examsNestedInput = {
    create?: XOR<em_jawaban_pesertaCreateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput> | em_jawaban_pesertaCreateWithoutEm_session_examsInput[] | em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput[]
    connectOrCreate?: em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput | em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput[]
    upsert?: em_jawaban_pesertaUpsertWithWhereUniqueWithoutEm_session_examsInput | em_jawaban_pesertaUpsertWithWhereUniqueWithoutEm_session_examsInput[]
    createMany?: em_jawaban_pesertaCreateManyEm_session_examsInputEnvelope
    set?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    disconnect?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    delete?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    connect?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    update?: em_jawaban_pesertaUpdateWithWhereUniqueWithoutEm_session_examsInput | em_jawaban_pesertaUpdateWithWhereUniqueWithoutEm_session_examsInput[]
    updateMany?: em_jawaban_pesertaUpdateManyWithWhereWithoutEm_session_examsInput | em_jawaban_pesertaUpdateManyWithWhereWithoutEm_session_examsInput[]
    deleteMany?: em_jawaban_pesertaScalarWhereInput | em_jawaban_pesertaScalarWhereInput[]
  }

  export type em_jawaban_pesertaUncheckedUpdateManyWithoutEm_session_examsNestedInput = {
    create?: XOR<em_jawaban_pesertaCreateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput> | em_jawaban_pesertaCreateWithoutEm_session_examsInput[] | em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput[]
    connectOrCreate?: em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput | em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput[]
    upsert?: em_jawaban_pesertaUpsertWithWhereUniqueWithoutEm_session_examsInput | em_jawaban_pesertaUpsertWithWhereUniqueWithoutEm_session_examsInput[]
    createMany?: em_jawaban_pesertaCreateManyEm_session_examsInputEnvelope
    set?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    disconnect?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    delete?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    connect?: em_jawaban_pesertaWhereUniqueInput | em_jawaban_pesertaWhereUniqueInput[]
    update?: em_jawaban_pesertaUpdateWithWhereUniqueWithoutEm_session_examsInput | em_jawaban_pesertaUpdateWithWhereUniqueWithoutEm_session_examsInput[]
    updateMany?: em_jawaban_pesertaUpdateManyWithWhereWithoutEm_session_examsInput | em_jawaban_pesertaUpdateManyWithWhereWithoutEm_session_examsInput[]
    deleteMany?: em_jawaban_pesertaScalarWhereInput | em_jawaban_pesertaScalarWhereInput[]
  }

  export type em_jawaban_peserta_apcCreateNestedManyWithoutEm_session_exams_apcInput = {
    create?: XOR<em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput> | em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput[] | em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput[]
    createMany?: em_jawaban_peserta_apcCreateManyEm_session_exams_apcInputEnvelope
    connect?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
  }

  export type em_topic_selesaiCreateNestedManyWithoutEm_session_exams_apcInput = {
    create?: XOR<em_topic_selesaiCreateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput> | em_topic_selesaiCreateWithoutEm_session_exams_apcInput[] | em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput | em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput[]
    createMany?: em_topic_selesaiCreateManyEm_session_exams_apcInputEnvelope
    connect?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
  }

  export type em_jawaban_peserta_apcUncheckedCreateNestedManyWithoutEm_session_exams_apcInput = {
    create?: XOR<em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput> | em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput[] | em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput[]
    createMany?: em_jawaban_peserta_apcCreateManyEm_session_exams_apcInputEnvelope
    connect?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
  }

  export type em_topic_selesaiUncheckedCreateNestedManyWithoutEm_session_exams_apcInput = {
    create?: XOR<em_topic_selesaiCreateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput> | em_topic_selesaiCreateWithoutEm_session_exams_apcInput[] | em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput | em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput[]
    createMany?: em_topic_selesaiCreateManyEm_session_exams_apcInputEnvelope
    connect?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
  }

  export type em_jawaban_peserta_apcUpdateManyWithoutEm_session_exams_apcNestedInput = {
    create?: XOR<em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput> | em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput[] | em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput[]
    upsert?: em_jawaban_peserta_apcUpsertWithWhereUniqueWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcUpsertWithWhereUniqueWithoutEm_session_exams_apcInput[]
    createMany?: em_jawaban_peserta_apcCreateManyEm_session_exams_apcInputEnvelope
    set?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    disconnect?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    delete?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    connect?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    update?: em_jawaban_peserta_apcUpdateWithWhereUniqueWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcUpdateWithWhereUniqueWithoutEm_session_exams_apcInput[]
    updateMany?: em_jawaban_peserta_apcUpdateManyWithWhereWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcUpdateManyWithWhereWithoutEm_session_exams_apcInput[]
    deleteMany?: em_jawaban_peserta_apcScalarWhereInput | em_jawaban_peserta_apcScalarWhereInput[]
  }

  export type em_topic_selesaiUpdateManyWithoutEm_session_exams_apcNestedInput = {
    create?: XOR<em_topic_selesaiCreateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput> | em_topic_selesaiCreateWithoutEm_session_exams_apcInput[] | em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput | em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput[]
    upsert?: em_topic_selesaiUpsertWithWhereUniqueWithoutEm_session_exams_apcInput | em_topic_selesaiUpsertWithWhereUniqueWithoutEm_session_exams_apcInput[]
    createMany?: em_topic_selesaiCreateManyEm_session_exams_apcInputEnvelope
    set?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    disconnect?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    delete?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    connect?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    update?: em_topic_selesaiUpdateWithWhereUniqueWithoutEm_session_exams_apcInput | em_topic_selesaiUpdateWithWhereUniqueWithoutEm_session_exams_apcInput[]
    updateMany?: em_topic_selesaiUpdateManyWithWhereWithoutEm_session_exams_apcInput | em_topic_selesaiUpdateManyWithWhereWithoutEm_session_exams_apcInput[]
    deleteMany?: em_topic_selesaiScalarWhereInput | em_topic_selesaiScalarWhereInput[]
  }

  export type em_jawaban_peserta_apcUncheckedUpdateManyWithoutEm_session_exams_apcNestedInput = {
    create?: XOR<em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput> | em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput[] | em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput[]
    upsert?: em_jawaban_peserta_apcUpsertWithWhereUniqueWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcUpsertWithWhereUniqueWithoutEm_session_exams_apcInput[]
    createMany?: em_jawaban_peserta_apcCreateManyEm_session_exams_apcInputEnvelope
    set?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    disconnect?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    delete?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    connect?: em_jawaban_peserta_apcWhereUniqueInput | em_jawaban_peserta_apcWhereUniqueInput[]
    update?: em_jawaban_peserta_apcUpdateWithWhereUniqueWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcUpdateWithWhereUniqueWithoutEm_session_exams_apcInput[]
    updateMany?: em_jawaban_peserta_apcUpdateManyWithWhereWithoutEm_session_exams_apcInput | em_jawaban_peserta_apcUpdateManyWithWhereWithoutEm_session_exams_apcInput[]
    deleteMany?: em_jawaban_peserta_apcScalarWhereInput | em_jawaban_peserta_apcScalarWhereInput[]
  }

  export type em_topic_selesaiUncheckedUpdateManyWithoutEm_session_exams_apcNestedInput = {
    create?: XOR<em_topic_selesaiCreateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput> | em_topic_selesaiCreateWithoutEm_session_exams_apcInput[] | em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput[]
    connectOrCreate?: em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput | em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput[]
    upsert?: em_topic_selesaiUpsertWithWhereUniqueWithoutEm_session_exams_apcInput | em_topic_selesaiUpsertWithWhereUniqueWithoutEm_session_exams_apcInput[]
    createMany?: em_topic_selesaiCreateManyEm_session_exams_apcInputEnvelope
    set?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    disconnect?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    delete?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    connect?: em_topic_selesaiWhereUniqueInput | em_topic_selesaiWhereUniqueInput[]
    update?: em_topic_selesaiUpdateWithWhereUniqueWithoutEm_session_exams_apcInput | em_topic_selesaiUpdateWithWhereUniqueWithoutEm_session_exams_apcInput[]
    updateMany?: em_topic_selesaiUpdateManyWithWhereWithoutEm_session_exams_apcInput | em_topic_selesaiUpdateManyWithWhereWithoutEm_session_exams_apcInput[]
    deleteMany?: em_topic_selesaiScalarWhereInput | em_topic_selesaiScalarWhereInput[]
  }

  export type em_session_exams_apcCreateNestedOneWithoutEm_topic_selesaiInput = {
    create?: XOR<em_session_exams_apcCreateWithoutEm_topic_selesaiInput, em_session_exams_apcUncheckedCreateWithoutEm_topic_selesaiInput>
    connectOrCreate?: em_session_exams_apcCreateOrConnectWithoutEm_topic_selesaiInput
    connect?: em_session_exams_apcWhereUniqueInput
  }

  export type em_session_exams_apcUpdateOneRequiredWithoutEm_topic_selesaiNestedInput = {
    create?: XOR<em_session_exams_apcCreateWithoutEm_topic_selesaiInput, em_session_exams_apcUncheckedCreateWithoutEm_topic_selesaiInput>
    connectOrCreate?: em_session_exams_apcCreateOrConnectWithoutEm_topic_selesaiInput
    upsert?: em_session_exams_apcUpsertWithoutEm_topic_selesaiInput
    connect?: em_session_exams_apcWhereUniqueInput
    update?: XOR<XOR<em_session_exams_apcUpdateToOneWithWhereWithoutEm_topic_selesaiInput, em_session_exams_apcUpdateWithoutEm_topic_selesaiInput>, em_session_exams_apcUncheckedUpdateWithoutEm_topic_selesaiInput>
  }

  export type scoresCreateNestedManyWithoutEmappInput = {
    create?: XOR<scoresCreateWithoutEmappInput, scoresUncheckedCreateWithoutEmappInput> | scoresCreateWithoutEmappInput[] | scoresUncheckedCreateWithoutEmappInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEmappInput | scoresCreateOrConnectWithoutEmappInput[]
    createMany?: scoresCreateManyEmappInputEnvelope
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
  }

  export type scoresUncheckedCreateNestedManyWithoutEmappInput = {
    create?: XOR<scoresCreateWithoutEmappInput, scoresUncheckedCreateWithoutEmappInput> | scoresCreateWithoutEmappInput[] | scoresUncheckedCreateWithoutEmappInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEmappInput | scoresCreateOrConnectWithoutEmappInput[]
    createMany?: scoresCreateManyEmappInputEnvelope
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
  }

  export type scoresUpdateManyWithoutEmappNestedInput = {
    create?: XOR<scoresCreateWithoutEmappInput, scoresUncheckedCreateWithoutEmappInput> | scoresCreateWithoutEmappInput[] | scoresUncheckedCreateWithoutEmappInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEmappInput | scoresCreateOrConnectWithoutEmappInput[]
    upsert?: scoresUpsertWithWhereUniqueWithoutEmappInput | scoresUpsertWithWhereUniqueWithoutEmappInput[]
    createMany?: scoresCreateManyEmappInputEnvelope
    set?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    disconnect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    delete?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    update?: scoresUpdateWithWhereUniqueWithoutEmappInput | scoresUpdateWithWhereUniqueWithoutEmappInput[]
    updateMany?: scoresUpdateManyWithWhereWithoutEmappInput | scoresUpdateManyWithWhereWithoutEmappInput[]
    deleteMany?: scoresScalarWhereInput | scoresScalarWhereInput[]
  }

  export type scoresUncheckedUpdateManyWithoutEmappNestedInput = {
    create?: XOR<scoresCreateWithoutEmappInput, scoresUncheckedCreateWithoutEmappInput> | scoresCreateWithoutEmappInput[] | scoresUncheckedCreateWithoutEmappInput[]
    connectOrCreate?: scoresCreateOrConnectWithoutEmappInput | scoresCreateOrConnectWithoutEmappInput[]
    upsert?: scoresUpsertWithWhereUniqueWithoutEmappInput | scoresUpsertWithWhereUniqueWithoutEmappInput[]
    createMany?: scoresCreateManyEmappInputEnvelope
    set?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    disconnect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    delete?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    connect?: scoresWhereUniqueInput | scoresWhereUniqueInput[]
    update?: scoresUpdateWithWhereUniqueWithoutEmappInput | scoresUpdateWithWhereUniqueWithoutEmappInput[]
    updateMany?: scoresUpdateManyWithWhereWithoutEmappInput | scoresUpdateManyWithWhereWithoutEmappInput[]
    deleteMany?: scoresScalarWhereInput | scoresScalarWhereInput[]
  }

  export type em_applicant_criteriaCreateNestedManyWithoutEmpossInput = {
    create?: XOR<em_applicant_criteriaCreateWithoutEmpossInput, em_applicant_criteriaUncheckedCreateWithoutEmpossInput> | em_applicant_criteriaCreateWithoutEmpossInput[] | em_applicant_criteriaUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_criteriaCreateOrConnectWithoutEmpossInput | em_applicant_criteriaCreateOrConnectWithoutEmpossInput[]
    createMany?: em_applicant_criteriaCreateManyEmpossInputEnvelope
    connect?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
  }

  export type em_applicant_matchCreateNestedManyWithoutEmpossInput = {
    create?: XOR<em_applicant_matchCreateWithoutEmpossInput, em_applicant_matchUncheckedCreateWithoutEmpossInput> | em_applicant_matchCreateWithoutEmpossInput[] | em_applicant_matchUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEmpossInput | em_applicant_matchCreateOrConnectWithoutEmpossInput[]
    createMany?: em_applicant_matchCreateManyEmpossInputEnvelope
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
  }

  export type em_applicant_criteriaUncheckedCreateNestedManyWithoutEmpossInput = {
    create?: XOR<em_applicant_criteriaCreateWithoutEmpossInput, em_applicant_criteriaUncheckedCreateWithoutEmpossInput> | em_applicant_criteriaCreateWithoutEmpossInput[] | em_applicant_criteriaUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_criteriaCreateOrConnectWithoutEmpossInput | em_applicant_criteriaCreateOrConnectWithoutEmpossInput[]
    createMany?: em_applicant_criteriaCreateManyEmpossInputEnvelope
    connect?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
  }

  export type em_applicant_matchUncheckedCreateNestedManyWithoutEmpossInput = {
    create?: XOR<em_applicant_matchCreateWithoutEmpossInput, em_applicant_matchUncheckedCreateWithoutEmpossInput> | em_applicant_matchCreateWithoutEmpossInput[] | em_applicant_matchUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEmpossInput | em_applicant_matchCreateOrConnectWithoutEmpossInput[]
    createMany?: em_applicant_matchCreateManyEmpossInputEnvelope
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
  }

  export type em_applicant_criteriaUpdateManyWithoutEmpossNestedInput = {
    create?: XOR<em_applicant_criteriaCreateWithoutEmpossInput, em_applicant_criteriaUncheckedCreateWithoutEmpossInput> | em_applicant_criteriaCreateWithoutEmpossInput[] | em_applicant_criteriaUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_criteriaCreateOrConnectWithoutEmpossInput | em_applicant_criteriaCreateOrConnectWithoutEmpossInput[]
    upsert?: em_applicant_criteriaUpsertWithWhereUniqueWithoutEmpossInput | em_applicant_criteriaUpsertWithWhereUniqueWithoutEmpossInput[]
    createMany?: em_applicant_criteriaCreateManyEmpossInputEnvelope
    set?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    disconnect?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    delete?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    connect?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    update?: em_applicant_criteriaUpdateWithWhereUniqueWithoutEmpossInput | em_applicant_criteriaUpdateWithWhereUniqueWithoutEmpossInput[]
    updateMany?: em_applicant_criteriaUpdateManyWithWhereWithoutEmpossInput | em_applicant_criteriaUpdateManyWithWhereWithoutEmpossInput[]
    deleteMany?: em_applicant_criteriaScalarWhereInput | em_applicant_criteriaScalarWhereInput[]
  }

  export type em_applicant_matchUpdateManyWithoutEmpossNestedInput = {
    create?: XOR<em_applicant_matchCreateWithoutEmpossInput, em_applicant_matchUncheckedCreateWithoutEmpossInput> | em_applicant_matchCreateWithoutEmpossInput[] | em_applicant_matchUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEmpossInput | em_applicant_matchCreateOrConnectWithoutEmpossInput[]
    upsert?: em_applicant_matchUpsertWithWhereUniqueWithoutEmpossInput | em_applicant_matchUpsertWithWhereUniqueWithoutEmpossInput[]
    createMany?: em_applicant_matchCreateManyEmpossInputEnvelope
    set?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    disconnect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    delete?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    update?: em_applicant_matchUpdateWithWhereUniqueWithoutEmpossInput | em_applicant_matchUpdateWithWhereUniqueWithoutEmpossInput[]
    updateMany?: em_applicant_matchUpdateManyWithWhereWithoutEmpossInput | em_applicant_matchUpdateManyWithWhereWithoutEmpossInput[]
    deleteMany?: em_applicant_matchScalarWhereInput | em_applicant_matchScalarWhereInput[]
  }

  export type em_applicant_criteriaUncheckedUpdateManyWithoutEmpossNestedInput = {
    create?: XOR<em_applicant_criteriaCreateWithoutEmpossInput, em_applicant_criteriaUncheckedCreateWithoutEmpossInput> | em_applicant_criteriaCreateWithoutEmpossInput[] | em_applicant_criteriaUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_criteriaCreateOrConnectWithoutEmpossInput | em_applicant_criteriaCreateOrConnectWithoutEmpossInput[]
    upsert?: em_applicant_criteriaUpsertWithWhereUniqueWithoutEmpossInput | em_applicant_criteriaUpsertWithWhereUniqueWithoutEmpossInput[]
    createMany?: em_applicant_criteriaCreateManyEmpossInputEnvelope
    set?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    disconnect?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    delete?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    connect?: em_applicant_criteriaWhereUniqueInput | em_applicant_criteriaWhereUniqueInput[]
    update?: em_applicant_criteriaUpdateWithWhereUniqueWithoutEmpossInput | em_applicant_criteriaUpdateWithWhereUniqueWithoutEmpossInput[]
    updateMany?: em_applicant_criteriaUpdateManyWithWhereWithoutEmpossInput | em_applicant_criteriaUpdateManyWithWhereWithoutEmpossInput[]
    deleteMany?: em_applicant_criteriaScalarWhereInput | em_applicant_criteriaScalarWhereInput[]
  }

  export type em_applicant_matchUncheckedUpdateManyWithoutEmpossNestedInput = {
    create?: XOR<em_applicant_matchCreateWithoutEmpossInput, em_applicant_matchUncheckedCreateWithoutEmpossInput> | em_applicant_matchCreateWithoutEmpossInput[] | em_applicant_matchUncheckedCreateWithoutEmpossInput[]
    connectOrCreate?: em_applicant_matchCreateOrConnectWithoutEmpossInput | em_applicant_matchCreateOrConnectWithoutEmpossInput[]
    upsert?: em_applicant_matchUpsertWithWhereUniqueWithoutEmpossInput | em_applicant_matchUpsertWithWhereUniqueWithoutEmpossInput[]
    createMany?: em_applicant_matchCreateManyEmpossInputEnvelope
    set?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    disconnect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    delete?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    connect?: em_applicant_matchWhereUniqueInput | em_applicant_matchWhereUniqueInput[]
    update?: em_applicant_matchUpdateWithWhereUniqueWithoutEmpossInput | em_applicant_matchUpdateWithWhereUniqueWithoutEmpossInput[]
    updateMany?: em_applicant_matchUpdateManyWithWhereWithoutEmpossInput | em_applicant_matchUpdateManyWithWhereWithoutEmpossInput[]
    deleteMany?: em_applicant_matchScalarWhereInput | em_applicant_matchScalarWhereInput[]
  }

  export type em_examsCreateNestedOneWithoutScoresInput = {
    create?: XOR<em_examsCreateWithoutScoresInput, em_examsUncheckedCreateWithoutScoresInput>
    connectOrCreate?: em_examsCreateOrConnectWithoutScoresInput
    connect?: em_examsWhereUniqueInput
  }

  export type emappCreateNestedOneWithoutScoresInput = {
    create?: XOR<emappCreateWithoutScoresInput, emappUncheckedCreateWithoutScoresInput>
    connectOrCreate?: emappCreateOrConnectWithoutScoresInput
    connect?: emappWhereUniqueInput
  }

  export type em_examsUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<em_examsCreateWithoutScoresInput, em_examsUncheckedCreateWithoutScoresInput>
    connectOrCreate?: em_examsCreateOrConnectWithoutScoresInput
    upsert?: em_examsUpsertWithoutScoresInput
    connect?: em_examsWhereUniqueInput
    update?: XOR<XOR<em_examsUpdateToOneWithWhereWithoutScoresInput, em_examsUpdateWithoutScoresInput>, em_examsUncheckedUpdateWithoutScoresInput>
  }

  export type emappUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<emappCreateWithoutScoresInput, emappUncheckedCreateWithoutScoresInput>
    connectOrCreate?: emappCreateOrConnectWithoutScoresInput
    upsert?: emappUpsertWithoutScoresInput
    connect?: emappWhereUniqueInput
    update?: XOR<XOR<emappUpdateToOneWithWhereWithoutScoresInput, emappUpdateWithoutScoresInput>, emappUncheckedUpdateWithoutScoresInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type em_apc_personalCreateWithoutEm_apc_academyInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_photograph?: em_apc_photographCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUncheckedCreateWithoutEm_apc_academyInput = {
    ApcId?: number
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_photograph?: em_apc_photographUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalCreateOrConnectWithoutEm_apc_academyInput = {
    where: em_apc_personalWhereUniqueInput
    create: XOR<em_apc_personalCreateWithoutEm_apc_academyInput, em_apc_personalUncheckedCreateWithoutEm_apc_academyInput>
  }

  export type em_apc_personalUpsertWithoutEm_apc_academyInput = {
    update: XOR<em_apc_personalUpdateWithoutEm_apc_academyInput, em_apc_personalUncheckedUpdateWithoutEm_apc_academyInput>
    create: XOR<em_apc_personalCreateWithoutEm_apc_academyInput, em_apc_personalUncheckedCreateWithoutEm_apc_academyInput>
    where?: em_apc_personalWhereInput
  }

  export type em_apc_personalUpdateToOneWithWhereWithoutEm_apc_academyInput = {
    where?: em_apc_personalWhereInput
    data: XOR<em_apc_personalUpdateWithoutEm_apc_academyInput, em_apc_personalUncheckedUpdateWithoutEm_apc_academyInput>
  }

  export type em_apc_personalUpdateWithoutEm_apc_academyInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_photograph?: em_apc_photographUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalUncheckedUpdateWithoutEm_apc_academyInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_photograph?: em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_academyCreateWithoutEm_apc_personalInput = {
    SchoolName?: string | null
    Province?: string | null
    Major?: string | null
    Degree?: string | null
    EnrollDate?: Date | string | null
    GraduatDate?: Date | string | null
    IPK?: number | null
    OrganizeExperience?: string | null
    Explain?: string | null
    GradeSchool?: string | null
    DailySchedule?: string | null
    SchoolAddress?: string | null
  }

  export type em_apc_academyUncheckedCreateWithoutEm_apc_personalInput = {
    AcademyId?: number
    SchoolName?: string | null
    Province?: string | null
    Major?: string | null
    Degree?: string | null
    EnrollDate?: Date | string | null
    GraduatDate?: Date | string | null
    IPK?: number | null
    OrganizeExperience?: string | null
    Explain?: string | null
    GradeSchool?: string | null
    DailySchedule?: string | null
    SchoolAddress?: string | null
  }

  export type em_apc_academyCreateOrConnectWithoutEm_apc_personalInput = {
    where: em_apc_academyWhereUniqueInput
    create: XOR<em_apc_academyCreateWithoutEm_apc_personalInput, em_apc_academyUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_academyCreateManyEm_apc_personalInputEnvelope = {
    data: em_apc_academyCreateManyEm_apc_personalInput | em_apc_academyCreateManyEm_apc_personalInput[]
  }

  export type em_apc_photographCreateWithoutEm_apc_personalInput = {
    GenrName?: string | null
  }

  export type em_apc_photographUncheckedCreateWithoutEm_apc_personalInput = {
    Id?: number
    GenrName?: string | null
  }

  export type em_apc_photographCreateOrConnectWithoutEm_apc_personalInput = {
    where: em_apc_photographWhereUniqueInput
    create: XOR<em_apc_photographCreateWithoutEm_apc_personalInput, em_apc_photographUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_photographCreateManyEm_apc_personalInputEnvelope = {
    data: em_apc_photographCreateManyEm_apc_personalInput | em_apc_photographCreateManyEm_apc_personalInput[]
  }

  export type em_apc_regulationCreateWithoutEm_apc_personalInput = {
    RegId?: number | null
    RegChoice?: boolean | null
  }

  export type em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput = {
    ApcRegId?: number
    RegId?: number | null
    RegChoice?: boolean | null
  }

  export type em_apc_regulationCreateOrConnectWithoutEm_apc_personalInput = {
    where: em_apc_regulationWhereUniqueInput
    create: XOR<em_apc_regulationCreateWithoutEm_apc_personalInput, em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_regulationCreateManyEm_apc_personalInputEnvelope = {
    data: em_apc_regulationCreateManyEm_apc_personalInput | em_apc_regulationCreateManyEm_apc_personalInput[]
  }

  export type em_apc_skill_experCreateWithoutEm_apc_personalInput = {
    CompanyName?: string | null
    Province?: string | null
    JobTitle?: string | null
    Salary?: number | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Responsibilities?: string | null
    CareerGoals?: string | null
    WhyJoin?: string | null
    IsFriend?: string | null
    IsMentions?: string | null
    IsCompProgram?: string | null
    IsIllnes?: string | null
    HaveCriminal?: string | null
    WhenWork?: string | null
    ExpectedSalary?: number | null
    isContribution?: string | null
    isDuration?: string | null
    isAgency?: string | null
    isExprn?: string | null
    isGenre?: string | null
    isRelevan?: string | null
    isSpesialSkill?: string | null
    isShoot?: string | null
    isSchedl?: string | null
    isMotivation?: string | null
    isStress?: string | null
    isLongExpr?: string | null
    isPhotTools?: string | null
    isChalleng?: string | null
    isThreeYears?: string | null
    PersonVal?: string | null
  }

  export type em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput = {
    SkillId?: number
    CompanyName?: string | null
    Province?: string | null
    JobTitle?: string | null
    Salary?: number | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Responsibilities?: string | null
    CareerGoals?: string | null
    WhyJoin?: string | null
    IsFriend?: string | null
    IsMentions?: string | null
    IsCompProgram?: string | null
    IsIllnes?: string | null
    HaveCriminal?: string | null
    WhenWork?: string | null
    ExpectedSalary?: number | null
    isContribution?: string | null
    isDuration?: string | null
    isAgency?: string | null
    isExprn?: string | null
    isGenre?: string | null
    isRelevan?: string | null
    isSpesialSkill?: string | null
    isShoot?: string | null
    isSchedl?: string | null
    isMotivation?: string | null
    isStress?: string | null
    isLongExpr?: string | null
    isPhotTools?: string | null
    isChalleng?: string | null
    isThreeYears?: string | null
    PersonVal?: string | null
  }

  export type em_apc_skill_experCreateOrConnectWithoutEm_apc_personalInput = {
    where: em_apc_skill_experWhereUniqueInput
    create: XOR<em_apc_skill_experCreateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_skill_experCreateManyEm_apc_personalInputEnvelope = {
    data: em_apc_skill_experCreateManyEm_apc_personalInput | em_apc_skill_experCreateManyEm_apc_personalInput[]
  }

  export type em_applicant_matchCreateWithoutEm_apc_personalInput = {
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
    emposs: empossCreateNestedOneWithoutEm_applicant_matchInput
  }

  export type em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput = {
    id_match?: number
    id_loker: number
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
  }

  export type em_applicant_matchCreateOrConnectWithoutEm_apc_personalInput = {
    where: em_applicant_matchWhereUniqueInput
    create: XOR<em_applicant_matchCreateWithoutEm_apc_personalInput, em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_applicant_matchCreateManyEm_apc_personalInputEnvelope = {
    data: em_applicant_matchCreateManyEm_apc_personalInput | em_applicant_matchCreateManyEm_apc_personalInput[]
  }

  export type em_apc_academyUpsertWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_academyWhereUniqueInput
    update: XOR<em_apc_academyUpdateWithoutEm_apc_personalInput, em_apc_academyUncheckedUpdateWithoutEm_apc_personalInput>
    create: XOR<em_apc_academyCreateWithoutEm_apc_personalInput, em_apc_academyUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_academyUpdateWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_academyWhereUniqueInput
    data: XOR<em_apc_academyUpdateWithoutEm_apc_personalInput, em_apc_academyUncheckedUpdateWithoutEm_apc_personalInput>
  }

  export type em_apc_academyUpdateManyWithWhereWithoutEm_apc_personalInput = {
    where: em_apc_academyScalarWhereInput
    data: XOR<em_apc_academyUpdateManyMutationInput, em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalInput>
  }

  export type em_apc_academyScalarWhereInput = {
    AND?: em_apc_academyScalarWhereInput | em_apc_academyScalarWhereInput[]
    OR?: em_apc_academyScalarWhereInput[]
    NOT?: em_apc_academyScalarWhereInput | em_apc_academyScalarWhereInput[]
    AcademyId?: IntFilter<"em_apc_academy"> | number
    ApcId?: IntFilter<"em_apc_academy"> | number
    SchoolName?: StringNullableFilter<"em_apc_academy"> | string | null
    Province?: StringNullableFilter<"em_apc_academy"> | string | null
    Major?: StringNullableFilter<"em_apc_academy"> | string | null
    Degree?: StringNullableFilter<"em_apc_academy"> | string | null
    EnrollDate?: DateTimeNullableFilter<"em_apc_academy"> | Date | string | null
    GraduatDate?: DateTimeNullableFilter<"em_apc_academy"> | Date | string | null
    IPK?: FloatNullableFilter<"em_apc_academy"> | number | null
    OrganizeExperience?: StringNullableFilter<"em_apc_academy"> | string | null
    Explain?: StringNullableFilter<"em_apc_academy"> | string | null
    GradeSchool?: StringNullableFilter<"em_apc_academy"> | string | null
    DailySchedule?: StringNullableFilter<"em_apc_academy"> | string | null
    SchoolAddress?: StringNullableFilter<"em_apc_academy"> | string | null
  }

  export type em_apc_photographUpsertWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_photographWhereUniqueInput
    update: XOR<em_apc_photographUpdateWithoutEm_apc_personalInput, em_apc_photographUncheckedUpdateWithoutEm_apc_personalInput>
    create: XOR<em_apc_photographCreateWithoutEm_apc_personalInput, em_apc_photographUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_photographUpdateWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_photographWhereUniqueInput
    data: XOR<em_apc_photographUpdateWithoutEm_apc_personalInput, em_apc_photographUncheckedUpdateWithoutEm_apc_personalInput>
  }

  export type em_apc_photographUpdateManyWithWhereWithoutEm_apc_personalInput = {
    where: em_apc_photographScalarWhereInput
    data: XOR<em_apc_photographUpdateManyMutationInput, em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalInput>
  }

  export type em_apc_photographScalarWhereInput = {
    AND?: em_apc_photographScalarWhereInput | em_apc_photographScalarWhereInput[]
    OR?: em_apc_photographScalarWhereInput[]
    NOT?: em_apc_photographScalarWhereInput | em_apc_photographScalarWhereInput[]
    Id?: IntFilter<"em_apc_photograph"> | number
    ApcId?: IntNullableFilter<"em_apc_photograph"> | number | null
    GenrName?: StringNullableFilter<"em_apc_photograph"> | string | null
  }

  export type em_apc_regulationUpsertWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_regulationWhereUniqueInput
    update: XOR<em_apc_regulationUpdateWithoutEm_apc_personalInput, em_apc_regulationUncheckedUpdateWithoutEm_apc_personalInput>
    create: XOR<em_apc_regulationCreateWithoutEm_apc_personalInput, em_apc_regulationUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_regulationUpdateWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_regulationWhereUniqueInput
    data: XOR<em_apc_regulationUpdateWithoutEm_apc_personalInput, em_apc_regulationUncheckedUpdateWithoutEm_apc_personalInput>
  }

  export type em_apc_regulationUpdateManyWithWhereWithoutEm_apc_personalInput = {
    where: em_apc_regulationScalarWhereInput
    data: XOR<em_apc_regulationUpdateManyMutationInput, em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalInput>
  }

  export type em_apc_regulationScalarWhereInput = {
    AND?: em_apc_regulationScalarWhereInput | em_apc_regulationScalarWhereInput[]
    OR?: em_apc_regulationScalarWhereInput[]
    NOT?: em_apc_regulationScalarWhereInput | em_apc_regulationScalarWhereInput[]
    ApcRegId?: IntFilter<"em_apc_regulation"> | number
    ApcId?: IntNullableFilter<"em_apc_regulation"> | number | null
    RegId?: IntNullableFilter<"em_apc_regulation"> | number | null
    RegChoice?: BoolNullableFilter<"em_apc_regulation"> | boolean | null
  }

  export type em_apc_skill_experUpsertWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_skill_experWhereUniqueInput
    update: XOR<em_apc_skill_experUpdateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedUpdateWithoutEm_apc_personalInput>
    create: XOR<em_apc_skill_experCreateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_apc_skill_experUpdateWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_apc_skill_experWhereUniqueInput
    data: XOR<em_apc_skill_experUpdateWithoutEm_apc_personalInput, em_apc_skill_experUncheckedUpdateWithoutEm_apc_personalInput>
  }

  export type em_apc_skill_experUpdateManyWithWhereWithoutEm_apc_personalInput = {
    where: em_apc_skill_experScalarWhereInput
    data: XOR<em_apc_skill_experUpdateManyMutationInput, em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalInput>
  }

  export type em_apc_skill_experScalarWhereInput = {
    AND?: em_apc_skill_experScalarWhereInput | em_apc_skill_experScalarWhereInput[]
    OR?: em_apc_skill_experScalarWhereInput[]
    NOT?: em_apc_skill_experScalarWhereInput | em_apc_skill_experScalarWhereInput[]
    SkillId?: IntFilter<"em_apc_skill_exper"> | number
    ApcId?: IntFilter<"em_apc_skill_exper"> | number
    CompanyName?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    Province?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    JobTitle?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    Salary?: FloatNullableFilter<"em_apc_skill_exper"> | number | null
    StartDate?: DateTimeNullableFilter<"em_apc_skill_exper"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"em_apc_skill_exper"> | Date | string | null
    Responsibilities?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    CareerGoals?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    WhyJoin?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsFriend?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsMentions?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsCompProgram?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    IsIllnes?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    HaveCriminal?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    WhenWork?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    ExpectedSalary?: FloatNullableFilter<"em_apc_skill_exper"> | number | null
    isContribution?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isDuration?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isAgency?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isExprn?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isGenre?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isRelevan?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isSpesialSkill?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isShoot?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isSchedl?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isMotivation?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isStress?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isLongExpr?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isPhotTools?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isChalleng?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    isThreeYears?: StringNullableFilter<"em_apc_skill_exper"> | string | null
    PersonVal?: StringNullableFilter<"em_apc_skill_exper"> | string | null
  }

  export type em_applicant_matchUpsertWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_applicant_matchWhereUniqueInput
    update: XOR<em_applicant_matchUpdateWithoutEm_apc_personalInput, em_applicant_matchUncheckedUpdateWithoutEm_apc_personalInput>
    create: XOR<em_applicant_matchCreateWithoutEm_apc_personalInput, em_applicant_matchUncheckedCreateWithoutEm_apc_personalInput>
  }

  export type em_applicant_matchUpdateWithWhereUniqueWithoutEm_apc_personalInput = {
    where: em_applicant_matchWhereUniqueInput
    data: XOR<em_applicant_matchUpdateWithoutEm_apc_personalInput, em_applicant_matchUncheckedUpdateWithoutEm_apc_personalInput>
  }

  export type em_applicant_matchUpdateManyWithWhereWithoutEm_apc_personalInput = {
    where: em_applicant_matchScalarWhereInput
    data: XOR<em_applicant_matchUpdateManyMutationInput, em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalInput>
  }

  export type em_applicant_matchScalarWhereInput = {
    AND?: em_applicant_matchScalarWhereInput | em_applicant_matchScalarWhereInput[]
    OR?: em_applicant_matchScalarWhereInput[]
    NOT?: em_applicant_matchScalarWhereInput | em_applicant_matchScalarWhereInput[]
    id_match?: IntFilter<"em_applicant_match"> | number
    id_applicant?: IntFilter<"em_applicant_match"> | number
    id_loker?: IntFilter<"em_applicant_match"> | number
    pendidikan_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    jurusan_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    pengalaman_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    skill_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    bahasa_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    usia_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    total_score?: FloatNullableFilter<"em_applicant_match"> | number | null
    total_kriteria?: IntNullableFilter<"em_applicant_match"> | number | null
    scoring_json?: StringNullableFilter<"em_applicant_match"> | string | null
    created_at?: DateTimeNullableFilter<"em_applicant_match"> | Date | string | null
  }

  export type em_apc_personalCreateWithoutEm_apc_photographInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUncheckedCreateWithoutEm_apc_photographInput = {
    ApcId?: number
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalCreateOrConnectWithoutEm_apc_photographInput = {
    where: em_apc_personalWhereUniqueInput
    create: XOR<em_apc_personalCreateWithoutEm_apc_photographInput, em_apc_personalUncheckedCreateWithoutEm_apc_photographInput>
  }

  export type em_apc_personalUpsertWithoutEm_apc_photographInput = {
    update: XOR<em_apc_personalUpdateWithoutEm_apc_photographInput, em_apc_personalUncheckedUpdateWithoutEm_apc_photographInput>
    create: XOR<em_apc_personalCreateWithoutEm_apc_photographInput, em_apc_personalUncheckedCreateWithoutEm_apc_photographInput>
    where?: em_apc_personalWhereInput
  }

  export type em_apc_personalUpdateToOneWithWhereWithoutEm_apc_photographInput = {
    where?: em_apc_personalWhereInput
    data: XOR<em_apc_personalUpdateWithoutEm_apc_photographInput, em_apc_personalUncheckedUpdateWithoutEm_apc_photographInput>
  }

  export type em_apc_personalUpdateWithoutEm_apc_photographInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalUncheckedUpdateWithoutEm_apc_photographInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalCreateWithoutEm_apc_regulationInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUncheckedCreateWithoutEm_apc_regulationInput = {
    ApcId?: number
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalCreateOrConnectWithoutEm_apc_regulationInput = {
    where: em_apc_personalWhereUniqueInput
    create: XOR<em_apc_personalCreateWithoutEm_apc_regulationInput, em_apc_personalUncheckedCreateWithoutEm_apc_regulationInput>
  }

  export type em_apc_personalUpsertWithoutEm_apc_regulationInput = {
    update: XOR<em_apc_personalUpdateWithoutEm_apc_regulationInput, em_apc_personalUncheckedUpdateWithoutEm_apc_regulationInput>
    create: XOR<em_apc_personalCreateWithoutEm_apc_regulationInput, em_apc_personalUncheckedCreateWithoutEm_apc_regulationInput>
    where?: em_apc_personalWhereInput
  }

  export type em_apc_personalUpdateToOneWithWhereWithoutEm_apc_regulationInput = {
    where?: em_apc_personalWhereInput
    data: XOR<em_apc_personalUpdateWithoutEm_apc_regulationInput, em_apc_personalUncheckedUpdateWithoutEm_apc_regulationInput>
  }

  export type em_apc_personalUpdateWithoutEm_apc_regulationInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalUncheckedUpdateWithoutEm_apc_regulationInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalCreateWithoutEm_apc_skill_experInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUncheckedCreateWithoutEm_apc_skill_experInput = {
    ApcId?: number
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalCreateOrConnectWithoutEm_apc_skill_experInput = {
    where: em_apc_personalWhereUniqueInput
    create: XOR<em_apc_personalCreateWithoutEm_apc_skill_experInput, em_apc_personalUncheckedCreateWithoutEm_apc_skill_experInput>
  }

  export type em_apc_personalUpsertWithoutEm_apc_skill_experInput = {
    update: XOR<em_apc_personalUpdateWithoutEm_apc_skill_experInput, em_apc_personalUncheckedUpdateWithoutEm_apc_skill_experInput>
    create: XOR<em_apc_personalCreateWithoutEm_apc_skill_experInput, em_apc_personalUncheckedCreateWithoutEm_apc_skill_experInput>
    where?: em_apc_personalWhereInput
  }

  export type em_apc_personalUpdateToOneWithWhereWithoutEm_apc_skill_experInput = {
    where?: em_apc_personalWhereInput
    data: XOR<em_apc_personalUpdateWithoutEm_apc_skill_experInput, em_apc_personalUncheckedUpdateWithoutEm_apc_skill_experInput>
  }

  export type em_apc_personalUpdateWithoutEm_apc_skill_experInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalUncheckedUpdateWithoutEm_apc_skill_experInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type empossCreateWithoutEm_applicant_criteriaInput = {
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
    em_applicant_match?: em_applicant_matchCreateNestedManyWithoutEmpossInput
  }

  export type empossUncheckedCreateWithoutEm_applicant_criteriaInput = {
    Id?: number
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
    em_applicant_match?: em_applicant_matchUncheckedCreateNestedManyWithoutEmpossInput
  }

  export type empossCreateOrConnectWithoutEm_applicant_criteriaInput = {
    where: empossWhereUniqueInput
    create: XOR<empossCreateWithoutEm_applicant_criteriaInput, empossUncheckedCreateWithoutEm_applicant_criteriaInput>
  }

  export type empossUpsertWithoutEm_applicant_criteriaInput = {
    update: XOR<empossUpdateWithoutEm_applicant_criteriaInput, empossUncheckedUpdateWithoutEm_applicant_criteriaInput>
    create: XOR<empossCreateWithoutEm_applicant_criteriaInput, empossUncheckedCreateWithoutEm_applicant_criteriaInput>
    where?: empossWhereInput
  }

  export type empossUpdateToOneWithWhereWithoutEm_applicant_criteriaInput = {
    where?: empossWhereInput
    data: XOR<empossUpdateWithoutEm_applicant_criteriaInput, empossUncheckedUpdateWithoutEm_applicant_criteriaInput>
  }

  export type empossUpdateWithoutEm_applicant_criteriaInput = {
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_applicant_match?: em_applicant_matchUpdateManyWithoutEmpossNestedInput
  }

  export type empossUncheckedUpdateWithoutEm_applicant_criteriaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_applicant_match?: em_applicant_matchUncheckedUpdateManyWithoutEmpossNestedInput
  }

  export type em_apc_personalCreateWithoutEm_applicant_matchInput = {
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalUncheckedCreateWithoutEm_applicant_matchInput = {
    ApcId?: number
    PossId?: number | null
    AboutUs?: string | null
    FullName?: string | null
    NickName?: string | null
    PlaceBirth?: string | null
    DateBirth?: Date | string | null
    Age?: number | null
    Gender?: number | null
    Religion?: number | null
    MaritalStats?: number | null
    Citizenship?: number | null
    Province?: number | null
    Regency?: number | null
    Subdistrict?: number | null
    PostCode?: string | null
    Address?: string | null
    IdentityType?: string | null
    IdentityNumber?: string | null
    PhoneCode?: number | null
    PhoneNumber?: string | null
    EmailAddress?: string | null
    Height?: number | null
    Weight?: number | null
    FatherName?: string | null
    FatherOccupa?: string | null
    MotherName?: string | null
    MotherOccupa?: string | null
    NumofSibling?: number | null
    SiblingNote?: string | null
    NikFileName?: string | null
    PhotoFileName?: string | null
    CvFileName?: string | null
    IsTransferPosst?: string | null
    Status?: string | null
    CreatedAt?: Date | string | null
    isHobby?: string | null
    LokCat?: number | null
    isSosmedId?: number | null
    isSosmed?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    isLinked?: string | null
    PossName?: string | null
    em_apc_academy?: em_apc_academyUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_photograph?: em_apc_photographUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_regulation?: em_apc_regulationUncheckedCreateNestedManyWithoutEm_apc_personalInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedCreateNestedManyWithoutEm_apc_personalInput
  }

  export type em_apc_personalCreateOrConnectWithoutEm_applicant_matchInput = {
    where: em_apc_personalWhereUniqueInput
    create: XOR<em_apc_personalCreateWithoutEm_applicant_matchInput, em_apc_personalUncheckedCreateWithoutEm_applicant_matchInput>
  }

  export type empossCreateWithoutEm_applicant_matchInput = {
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
    em_applicant_criteria?: em_applicant_criteriaCreateNestedManyWithoutEmpossInput
  }

  export type empossUncheckedCreateWithoutEm_applicant_matchInput = {
    Id?: number
    PossName?: string | null
    Status?: string | null
    UserId?: string | null
    LastUpdate?: Date | string | null
    em_applicant_criteria?: em_applicant_criteriaUncheckedCreateNestedManyWithoutEmpossInput
  }

  export type empossCreateOrConnectWithoutEm_applicant_matchInput = {
    where: empossWhereUniqueInput
    create: XOR<empossCreateWithoutEm_applicant_matchInput, empossUncheckedCreateWithoutEm_applicant_matchInput>
  }

  export type em_apc_personalUpsertWithoutEm_applicant_matchInput = {
    update: XOR<em_apc_personalUpdateWithoutEm_applicant_matchInput, em_apc_personalUncheckedUpdateWithoutEm_applicant_matchInput>
    create: XOR<em_apc_personalCreateWithoutEm_applicant_matchInput, em_apc_personalUncheckedCreateWithoutEm_applicant_matchInput>
    where?: em_apc_personalWhereInput
  }

  export type em_apc_personalUpdateToOneWithWhereWithoutEm_applicant_matchInput = {
    where?: em_apc_personalWhereInput
    data: XOR<em_apc_personalUpdateWithoutEm_applicant_matchInput, em_apc_personalUncheckedUpdateWithoutEm_applicant_matchInput>
  }

  export type em_apc_personalUpdateWithoutEm_applicant_matchInput = {
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type em_apc_personalUncheckedUpdateWithoutEm_applicant_matchInput = {
    ApcId?: IntFieldUpdateOperationsInput | number
    PossId?: NullableIntFieldUpdateOperationsInput | number | null
    AboutUs?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NickName?: NullableStringFieldUpdateOperationsInput | string | null
    PlaceBirth?: NullableStringFieldUpdateOperationsInput | string | null
    DateBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Gender?: NullableIntFieldUpdateOperationsInput | number | null
    Religion?: NullableIntFieldUpdateOperationsInput | number | null
    MaritalStats?: NullableIntFieldUpdateOperationsInput | number | null
    Citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    Province?: NullableIntFieldUpdateOperationsInput | number | null
    Regency?: NullableIntFieldUpdateOperationsInput | number | null
    Subdistrict?: NullableIntFieldUpdateOperationsInput | number | null
    PostCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityType?: NullableStringFieldUpdateOperationsInput | string | null
    IdentityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneCode?: NullableIntFieldUpdateOperationsInput | number | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Height?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableIntFieldUpdateOperationsInput | number | null
    FatherName?: NullableStringFieldUpdateOperationsInput | string | null
    FatherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    MotherName?: NullableStringFieldUpdateOperationsInput | string | null
    MotherOccupa?: NullableStringFieldUpdateOperationsInput | string | null
    NumofSibling?: NullableIntFieldUpdateOperationsInput | number | null
    SiblingNote?: NullableStringFieldUpdateOperationsInput | string | null
    NikFileName?: NullableStringFieldUpdateOperationsInput | string | null
    PhotoFileName?: NullableStringFieldUpdateOperationsInput | string | null
    CvFileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsTransferPosst?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHobby?: NullableStringFieldUpdateOperationsInput | string | null
    LokCat?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmedId?: NullableIntFieldUpdateOperationsInput | number | null
    isSosmed?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLinked?: NullableStringFieldUpdateOperationsInput | string | null
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    em_apc_academy?: em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_photograph?: em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_regulation?: em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalNestedInput
    em_apc_skill_exper?: em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalNestedInput
  }

  export type empossUpsertWithoutEm_applicant_matchInput = {
    update: XOR<empossUpdateWithoutEm_applicant_matchInput, empossUncheckedUpdateWithoutEm_applicant_matchInput>
    create: XOR<empossCreateWithoutEm_applicant_matchInput, empossUncheckedCreateWithoutEm_applicant_matchInput>
    where?: empossWhereInput
  }

  export type empossUpdateToOneWithWhereWithoutEm_applicant_matchInput = {
    where?: empossWhereInput
    data: XOR<empossUpdateWithoutEm_applicant_matchInput, empossUncheckedUpdateWithoutEm_applicant_matchInput>
  }

  export type empossUpdateWithoutEm_applicant_matchInput = {
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_applicant_criteria?: em_applicant_criteriaUpdateManyWithoutEmpossNestedInput
  }

  export type empossUncheckedUpdateWithoutEm_applicant_matchInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PossName?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_applicant_criteria?: em_applicant_criteriaUncheckedUpdateManyWithoutEmpossNestedInput
  }

  export type em_certificate_templatesCreateWithoutEm_certificate_fieldsInput = {
    name?: string | null
    background_image?: string | null
    created_at?: Date | string | null
    certificate_name?: string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_templatesUncheckedCreateWithoutEm_certificate_fieldsInput = {
    certificate_id?: number
    name?: string | null
    background_image?: string | null
    created_at?: Date | string | null
    certificate_name?: string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_templatesCreateOrConnectWithoutEm_certificate_fieldsInput = {
    where: em_certificate_templatesWhereUniqueInput
    create: XOR<em_certificate_templatesCreateWithoutEm_certificate_fieldsInput, em_certificate_templatesUncheckedCreateWithoutEm_certificate_fieldsInput>
  }

  export type em_certificate_templatesUpsertWithoutEm_certificate_fieldsInput = {
    update: XOR<em_certificate_templatesUpdateWithoutEm_certificate_fieldsInput, em_certificate_templatesUncheckedUpdateWithoutEm_certificate_fieldsInput>
    create: XOR<em_certificate_templatesCreateWithoutEm_certificate_fieldsInput, em_certificate_templatesUncheckedCreateWithoutEm_certificate_fieldsInput>
    where?: em_certificate_templatesWhereInput
  }

  export type em_certificate_templatesUpdateToOneWithWhereWithoutEm_certificate_fieldsInput = {
    where?: em_certificate_templatesWhereInput
    data: XOR<em_certificate_templatesUpdateWithoutEm_certificate_fieldsInput, em_certificate_templatesUncheckedUpdateWithoutEm_certificate_fieldsInput>
  }

  export type em_certificate_templatesUpdateWithoutEm_certificate_fieldsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    background_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_name?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_templatesUncheckedUpdateWithoutEm_certificate_fieldsInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    background_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_name?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_fieldsCreateWithoutEm_certificate_templatesInput = {
    id?: number
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style?: string | null
    font_weight?: string | null
    font_color?: string | null
    created_date?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput = {
    id?: number
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style?: string | null
    font_weight?: string | null
    font_color?: string | null
    created_date?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_fieldsCreateOrConnectWithoutEm_certificate_templatesInput = {
    where: em_certificate_fieldsWhereUniqueInput
    create: XOR<em_certificate_fieldsCreateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput>
  }

  export type em_certificate_fieldsCreateManyEm_certificate_templatesInputEnvelope = {
    data: em_certificate_fieldsCreateManyEm_certificate_templatesInput | em_certificate_fieldsCreateManyEm_certificate_templatesInput[]
  }

  export type em_certificate_fieldsUpsertWithWhereUniqueWithoutEm_certificate_templatesInput = {
    where: em_certificate_fieldsWhereUniqueInput
    update: XOR<em_certificate_fieldsUpdateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedUpdateWithoutEm_certificate_templatesInput>
    create: XOR<em_certificate_fieldsCreateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedCreateWithoutEm_certificate_templatesInput>
  }

  export type em_certificate_fieldsUpdateWithWhereUniqueWithoutEm_certificate_templatesInput = {
    where: em_certificate_fieldsWhereUniqueInput
    data: XOR<em_certificate_fieldsUpdateWithoutEm_certificate_templatesInput, em_certificate_fieldsUncheckedUpdateWithoutEm_certificate_templatesInput>
  }

  export type em_certificate_fieldsUpdateManyWithWhereWithoutEm_certificate_templatesInput = {
    where: em_certificate_fieldsScalarWhereInput
    data: XOR<em_certificate_fieldsUpdateManyMutationInput, em_certificate_fieldsUncheckedUpdateManyWithoutEm_certificate_templatesInput>
  }

  export type em_certificate_fieldsScalarWhereInput = {
    AND?: em_certificate_fieldsScalarWhereInput | em_certificate_fieldsScalarWhereInput[]
    OR?: em_certificate_fieldsScalarWhereInput[]
    NOT?: em_certificate_fieldsScalarWhereInput | em_certificate_fieldsScalarWhereInput[]
    id?: IntFilter<"em_certificate_fields"> | number
    certificate_id?: IntFilter<"em_certificate_fields"> | number
    is_text?: StringFilter<"em_certificate_fields"> | string
    is_left?: FloatFilter<"em_certificate_fields"> | number
    is_top?: FloatFilter<"em_certificate_fields"> | number
    text_width?: FloatFilter<"em_certificate_fields"> | number
    text_height?: FloatFilter<"em_certificate_fields"> | number
    font_size?: IntFilter<"em_certificate_fields"> | number
    align?: StringFilter<"em_certificate_fields"> | string
    font_family?: StringFilter<"em_certificate_fields"> | string
    font_style?: StringNullableFilter<"em_certificate_fields"> | string | null
    font_weight?: StringNullableFilter<"em_certificate_fields"> | string | null
    font_color?: StringNullableFilter<"em_certificate_fields"> | string | null
    created_date?: DateTimeNullableFilter<"em_certificate_fields"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_certificate_fields"> | Date | string | null
  }

  export type em_event2CreateWithoutEm_eventInput = {
    event_name?: string | null
    status?: string | null
    qr_code?: string | null
  }

  export type em_event2UncheckedCreateWithoutEm_eventInput = {
    sess_id?: number
    event_name?: string | null
    status?: string | null
    qr_code?: string | null
  }

  export type em_event2CreateOrConnectWithoutEm_eventInput = {
    where: em_event2WhereUniqueInput
    create: XOR<em_event2CreateWithoutEm_eventInput, em_event2UncheckedCreateWithoutEm_eventInput>
  }

  export type em_event2CreateManyEm_eventInputEnvelope = {
    data: em_event2CreateManyEm_eventInput | em_event2CreateManyEm_eventInput[]
  }

  export type em_event2UpsertWithWhereUniqueWithoutEm_eventInput = {
    where: em_event2WhereUniqueInput
    update: XOR<em_event2UpdateWithoutEm_eventInput, em_event2UncheckedUpdateWithoutEm_eventInput>
    create: XOR<em_event2CreateWithoutEm_eventInput, em_event2UncheckedCreateWithoutEm_eventInput>
  }

  export type em_event2UpdateWithWhereUniqueWithoutEm_eventInput = {
    where: em_event2WhereUniqueInput
    data: XOR<em_event2UpdateWithoutEm_eventInput, em_event2UncheckedUpdateWithoutEm_eventInput>
  }

  export type em_event2UpdateManyWithWhereWithoutEm_eventInput = {
    where: em_event2ScalarWhereInput
    data: XOR<em_event2UpdateManyMutationInput, em_event2UncheckedUpdateManyWithoutEm_eventInput>
  }

  export type em_event2ScalarWhereInput = {
    AND?: em_event2ScalarWhereInput | em_event2ScalarWhereInput[]
    OR?: em_event2ScalarWhereInput[]
    NOT?: em_event2ScalarWhereInput | em_event2ScalarWhereInput[]
    sess_id?: IntFilter<"em_event2"> | number
    event_id?: IntNullableFilter<"em_event2"> | number | null
    event_name?: StringNullableFilter<"em_event2"> | string | null
    status?: StringNullableFilter<"em_event2"> | string | null
    qr_code?: StringNullableFilter<"em_event2"> | string | null
  }

  export type em_eventCreateWithoutEm_event2Input = {
    event_name?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    lokasi?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_eventUncheckedCreateWithoutEm_event2Input = {
    event_id?: number
    event_name?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    lokasi?: string | null
    created_date?: Date | string | null
    last_update?: Date | string | null
  }

  export type em_eventCreateOrConnectWithoutEm_event2Input = {
    where: em_eventWhereUniqueInput
    create: XOR<em_eventCreateWithoutEm_event2Input, em_eventUncheckedCreateWithoutEm_event2Input>
  }

  export type em_eventUpsertWithoutEm_event2Input = {
    update: XOR<em_eventUpdateWithoutEm_event2Input, em_eventUncheckedUpdateWithoutEm_event2Input>
    create: XOR<em_eventCreateWithoutEm_event2Input, em_eventUncheckedCreateWithoutEm_event2Input>
    where?: em_eventWhereInput
  }

  export type em_eventUpdateToOneWithWhereWithoutEm_event2Input = {
    where?: em_eventWhereInput
    data: XOR<em_eventUpdateWithoutEm_event2Input, em_eventUncheckedUpdateWithoutEm_event2Input>
  }

  export type em_eventUpdateWithoutEm_event2Input = {
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_eventUncheckedUpdateWithoutEm_event2Input = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_loktopikCreateWithoutEm_examsInput = {
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
    em_loker: em_lokerCreateNestedOneWithoutEm_loktopikInput
  }

  export type em_loktopikUncheckedCreateWithoutEm_examsInput = {
    id?: number
    loker_id: number
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
  }

  export type em_loktopikCreateOrConnectWithoutEm_examsInput = {
    where: em_loktopikWhereUniqueInput
    create: XOR<em_loktopikCreateWithoutEm_examsInput, em_loktopikUncheckedCreateWithoutEm_examsInput>
  }

  export type em_loktopikCreateManyEm_examsInputEnvelope = {
    data: em_loktopikCreateManyEm_examsInput | em_loktopikCreateManyEm_examsInput[]
  }

  export type scoresCreateWithoutEm_examsInput = {
    total_score: number
    created_at?: Date | string | null
    emapp: emappCreateNestedOneWithoutScoresInput
  }

  export type scoresUncheckedCreateWithoutEm_examsInput = {
    id?: number
    user_id: number
    total_score: number
    created_at?: Date | string | null
  }

  export type scoresCreateOrConnectWithoutEm_examsInput = {
    where: scoresWhereUniqueInput
    create: XOR<scoresCreateWithoutEm_examsInput, scoresUncheckedCreateWithoutEm_examsInput>
  }

  export type scoresCreateManyEm_examsInputEnvelope = {
    data: scoresCreateManyEm_examsInput | scoresCreateManyEm_examsInput[]
  }

  export type em_loktopikUpsertWithWhereUniqueWithoutEm_examsInput = {
    where: em_loktopikWhereUniqueInput
    update: XOR<em_loktopikUpdateWithoutEm_examsInput, em_loktopikUncheckedUpdateWithoutEm_examsInput>
    create: XOR<em_loktopikCreateWithoutEm_examsInput, em_loktopikUncheckedCreateWithoutEm_examsInput>
  }

  export type em_loktopikUpdateWithWhereUniqueWithoutEm_examsInput = {
    where: em_loktopikWhereUniqueInput
    data: XOR<em_loktopikUpdateWithoutEm_examsInput, em_loktopikUncheckedUpdateWithoutEm_examsInput>
  }

  export type em_loktopikUpdateManyWithWhereWithoutEm_examsInput = {
    where: em_loktopikScalarWhereInput
    data: XOR<em_loktopikUpdateManyMutationInput, em_loktopikUncheckedUpdateManyWithoutEm_examsInput>
  }

  export type em_loktopikScalarWhereInput = {
    AND?: em_loktopikScalarWhereInput | em_loktopikScalarWhereInput[]
    OR?: em_loktopikScalarWhereInput[]
    NOT?: em_loktopikScalarWhereInput | em_loktopikScalarWhereInput[]
    id?: IntFilter<"em_loktopik"> | number
    loker_id?: IntFilter<"em_loktopik"> | number
    topik_id?: IntFilter<"em_loktopik"> | number
    jmlh_soal?: IntFilter<"em_loktopik"> | number
    created_at?: DateTimeNullableFilter<"em_loktopik"> | Date | string | null
    possid?: IntNullableFilter<"em_loktopik"> | number | null
    urutan?: IntNullableFilter<"em_loktopik"> | number | null
  }

  export type scoresUpsertWithWhereUniqueWithoutEm_examsInput = {
    where: scoresWhereUniqueInput
    update: XOR<scoresUpdateWithoutEm_examsInput, scoresUncheckedUpdateWithoutEm_examsInput>
    create: XOR<scoresCreateWithoutEm_examsInput, scoresUncheckedCreateWithoutEm_examsInput>
  }

  export type scoresUpdateWithWhereUniqueWithoutEm_examsInput = {
    where: scoresWhereUniqueInput
    data: XOR<scoresUpdateWithoutEm_examsInput, scoresUncheckedUpdateWithoutEm_examsInput>
  }

  export type scoresUpdateManyWithWhereWithoutEm_examsInput = {
    where: scoresScalarWhereInput
    data: XOR<scoresUpdateManyMutationInput, scoresUncheckedUpdateManyWithoutEm_examsInput>
  }

  export type scoresScalarWhereInput = {
    AND?: scoresScalarWhereInput | scoresScalarWhereInput[]
    OR?: scoresScalarWhereInput[]
    NOT?: scoresScalarWhereInput | scoresScalarWhereInput[]
    id?: IntFilter<"scores"> | number
    exam_id?: IntFilter<"scores"> | number
    user_id?: IntFilter<"scores"> | number
    total_score?: IntFilter<"scores"> | number
    created_at?: DateTimeNullableFilter<"scores"> | Date | string | null
  }

  export type em_faq_catCreateWithoutEm_faqInput = {
    name?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_faq_catUncheckedCreateWithoutEm_faqInput = {
    fqcatid?: number
    name?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_faq_catCreateOrConnectWithoutEm_faqInput = {
    where: em_faq_catWhereUniqueInput
    create: XOR<em_faq_catCreateWithoutEm_faqInput, em_faq_catUncheckedCreateWithoutEm_faqInput>
  }

  export type em_faq_catUpsertWithoutEm_faqInput = {
    update: XOR<em_faq_catUpdateWithoutEm_faqInput, em_faq_catUncheckedUpdateWithoutEm_faqInput>
    create: XOR<em_faq_catCreateWithoutEm_faqInput, em_faq_catUncheckedCreateWithoutEm_faqInput>
    where?: em_faq_catWhereInput
  }

  export type em_faq_catUpdateToOneWithWhereWithoutEm_faqInput = {
    where?: em_faq_catWhereInput
    data: XOR<em_faq_catUpdateWithoutEm_faqInput, em_faq_catUncheckedUpdateWithoutEm_faqInput>
  }

  export type em_faq_catUpdateWithoutEm_faqInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_faq_catUncheckedUpdateWithoutEm_faqInput = {
    fqcatid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_faqCreateWithoutEm_faq_catInput = {
    isquestions?: string | null
    isanswer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_faqUncheckedCreateWithoutEm_faq_catInput = {
    fqId?: number
    isquestions?: string | null
    isanswer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_faqCreateOrConnectWithoutEm_faq_catInput = {
    where: em_faqWhereUniqueInput
    create: XOR<em_faqCreateWithoutEm_faq_catInput, em_faqUncheckedCreateWithoutEm_faq_catInput>
  }

  export type em_faqCreateManyEm_faq_catInputEnvelope = {
    data: em_faqCreateManyEm_faq_catInput | em_faqCreateManyEm_faq_catInput[]
  }

  export type em_faqUpsertWithWhereUniqueWithoutEm_faq_catInput = {
    where: em_faqWhereUniqueInput
    update: XOR<em_faqUpdateWithoutEm_faq_catInput, em_faqUncheckedUpdateWithoutEm_faq_catInput>
    create: XOR<em_faqCreateWithoutEm_faq_catInput, em_faqUncheckedCreateWithoutEm_faq_catInput>
  }

  export type em_faqUpdateWithWhereUniqueWithoutEm_faq_catInput = {
    where: em_faqWhereUniqueInput
    data: XOR<em_faqUpdateWithoutEm_faq_catInput, em_faqUncheckedUpdateWithoutEm_faq_catInput>
  }

  export type em_faqUpdateManyWithWhereWithoutEm_faq_catInput = {
    where: em_faqScalarWhereInput
    data: XOR<em_faqUpdateManyMutationInput, em_faqUncheckedUpdateManyWithoutEm_faq_catInput>
  }

  export type em_faqScalarWhereInput = {
    AND?: em_faqScalarWhereInput | em_faqScalarWhereInput[]
    OR?: em_faqScalarWhereInput[]
    NOT?: em_faqScalarWhereInput | em_faqScalarWhereInput[]
    fqId?: IntFilter<"em_faq"> | number
    fqcatid?: IntNullableFilter<"em_faq"> | number | null
    isquestions?: StringNullableFilter<"em_faq"> | string | null
    isanswer?: StringNullableFilter<"em_faq"> | string | null
    status?: StringNullableFilter<"em_faq"> | string | null
    created_at?: DateTimeNullableFilter<"em_faq"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_faq"> | Date | string | null
    userid?: StringNullableFilter<"em_faq"> | string | null
  }

  export type em_session_examsCreateWithoutEm_jawaban_pesertaInput = {
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
  }

  export type em_session_examsUncheckedCreateWithoutEm_jawaban_pesertaInput = {
    Id?: number
    schedule_id?: number | null
    exams_id?: string | null
    empl_id?: number | null
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
  }

  export type em_session_examsCreateOrConnectWithoutEm_jawaban_pesertaInput = {
    where: em_session_examsWhereUniqueInput
    create: XOR<em_session_examsCreateWithoutEm_jawaban_pesertaInput, em_session_examsUncheckedCreateWithoutEm_jawaban_pesertaInput>
  }

  export type em_session_examsUpsertWithoutEm_jawaban_pesertaInput = {
    update: XOR<em_session_examsUpdateWithoutEm_jawaban_pesertaInput, em_session_examsUncheckedUpdateWithoutEm_jawaban_pesertaInput>
    create: XOR<em_session_examsCreateWithoutEm_jawaban_pesertaInput, em_session_examsUncheckedCreateWithoutEm_jawaban_pesertaInput>
    where?: em_session_examsWhereInput
  }

  export type em_session_examsUpdateToOneWithWhereWithoutEm_jawaban_pesertaInput = {
    where?: em_session_examsWhereInput
    data: XOR<em_session_examsUpdateWithoutEm_jawaban_pesertaInput, em_session_examsUncheckedUpdateWithoutEm_jawaban_pesertaInput>
  }

  export type em_session_examsUpdateWithoutEm_jawaban_pesertaInput = {
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type em_session_examsUncheckedUpdateWithoutEm_jawaban_pesertaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    schedule_id?: NullableIntFieldUpdateOperationsInput | number | null
    exams_id?: NullableStringFieldUpdateOperationsInput | string | null
    empl_id?: NullableIntFieldUpdateOperationsInput | number | null
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type em_session_exams_apcCreateWithoutEm_jawaban_peserta_apcInput = {
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
    em_topic_selesai?: em_topic_selesaiCreateNestedManyWithoutEm_session_exams_apcInput
  }

  export type em_session_exams_apcUncheckedCreateWithoutEm_jawaban_peserta_apcInput = {
    Id?: number
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
    em_topic_selesai?: em_topic_selesaiUncheckedCreateNestedManyWithoutEm_session_exams_apcInput
  }

  export type em_session_exams_apcCreateOrConnectWithoutEm_jawaban_peserta_apcInput = {
    where: em_session_exams_apcWhereUniqueInput
    create: XOR<em_session_exams_apcCreateWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUncheckedCreateWithoutEm_jawaban_peserta_apcInput>
  }

  export type em_session_exams_apcUpsertWithoutEm_jawaban_peserta_apcInput = {
    update: XOR<em_session_exams_apcUpdateWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUncheckedUpdateWithoutEm_jawaban_peserta_apcInput>
    create: XOR<em_session_exams_apcCreateWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUncheckedCreateWithoutEm_jawaban_peserta_apcInput>
    where?: em_session_exams_apcWhereInput
  }

  export type em_session_exams_apcUpdateToOneWithWhereWithoutEm_jawaban_peserta_apcInput = {
    where?: em_session_exams_apcWhereInput
    data: XOR<em_session_exams_apcUpdateWithoutEm_jawaban_peserta_apcInput, em_session_exams_apcUncheckedUpdateWithoutEm_jawaban_peserta_apcInput>
  }

  export type em_session_exams_apcUpdateWithoutEm_jawaban_peserta_apcInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
    em_topic_selesai?: em_topic_selesaiUpdateManyWithoutEm_session_exams_apcNestedInput
  }

  export type em_session_exams_apcUncheckedUpdateWithoutEm_jawaban_peserta_apcInput = {
    Id?: IntFieldUpdateOperationsInput | number
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
    em_topic_selesai?: em_topic_selesaiUncheckedUpdateManyWithoutEm_session_exams_apcNestedInput
  }

  export type em_loktopikCreateWithoutEm_lokerInput = {
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
    em_exams: em_examsCreateNestedOneWithoutEm_loktopikInput
  }

  export type em_loktopikUncheckedCreateWithoutEm_lokerInput = {
    id?: number
    topik_id: number
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
  }

  export type em_loktopikCreateOrConnectWithoutEm_lokerInput = {
    where: em_loktopikWhereUniqueInput
    create: XOR<em_loktopikCreateWithoutEm_lokerInput, em_loktopikUncheckedCreateWithoutEm_lokerInput>
  }

  export type em_loktopikCreateManyEm_lokerInputEnvelope = {
    data: em_loktopikCreateManyEm_lokerInput | em_loktopikCreateManyEm_lokerInput[]
  }

  export type em_loktopikUpsertWithWhereUniqueWithoutEm_lokerInput = {
    where: em_loktopikWhereUniqueInput
    update: XOR<em_loktopikUpdateWithoutEm_lokerInput, em_loktopikUncheckedUpdateWithoutEm_lokerInput>
    create: XOR<em_loktopikCreateWithoutEm_lokerInput, em_loktopikUncheckedCreateWithoutEm_lokerInput>
  }

  export type em_loktopikUpdateWithWhereUniqueWithoutEm_lokerInput = {
    where: em_loktopikWhereUniqueInput
    data: XOR<em_loktopikUpdateWithoutEm_lokerInput, em_loktopikUncheckedUpdateWithoutEm_lokerInput>
  }

  export type em_loktopikUpdateManyWithWhereWithoutEm_lokerInput = {
    where: em_loktopikScalarWhereInput
    data: XOR<em_loktopikUpdateManyMutationInput, em_loktopikUncheckedUpdateManyWithoutEm_lokerInput>
  }

  export type em_lokerCreateWithoutEm_loktopikInput = {
    possid: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    jobdesc?: string | null
    qualify?: string | null
    worktype?: string | null
    salary?: string | null
    contrtype?: string | null
    posslevel?: string | null
    status?: string | null
    benefit?: string | null
    fileimage?: string | null
    createdate?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
    kategori?: number | null
  }

  export type em_lokerUncheckedCreateWithoutEm_loktopikInput = {
    lokerid?: number
    possid: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    jobdesc?: string | null
    qualify?: string | null
    worktype?: string | null
    salary?: string | null
    contrtype?: string | null
    posslevel?: string | null
    status?: string | null
    benefit?: string | null
    fileimage?: string | null
    createdate?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
    kategori?: number | null
  }

  export type em_lokerCreateOrConnectWithoutEm_loktopikInput = {
    where: em_lokerWhereUniqueInput
    create: XOR<em_lokerCreateWithoutEm_loktopikInput, em_lokerUncheckedCreateWithoutEm_loktopikInput>
  }

  export type em_examsCreateWithoutEm_loktopikInput = {
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
    scores?: scoresCreateNestedManyWithoutEm_examsInput
  }

  export type em_examsUncheckedCreateWithoutEm_loktopikInput = {
    id?: number
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
    scores?: scoresUncheckedCreateNestedManyWithoutEm_examsInput
  }

  export type em_examsCreateOrConnectWithoutEm_loktopikInput = {
    where: em_examsWhereUniqueInput
    create: XOR<em_examsCreateWithoutEm_loktopikInput, em_examsUncheckedCreateWithoutEm_loktopikInput>
  }

  export type em_lokerUpsertWithoutEm_loktopikInput = {
    update: XOR<em_lokerUpdateWithoutEm_loktopikInput, em_lokerUncheckedUpdateWithoutEm_loktopikInput>
    create: XOR<em_lokerCreateWithoutEm_loktopikInput, em_lokerUncheckedCreateWithoutEm_loktopikInput>
    where?: em_lokerWhereInput
  }

  export type em_lokerUpdateToOneWithWhereWithoutEm_loktopikInput = {
    where?: em_lokerWhereInput
    data: XOR<em_lokerUpdateWithoutEm_loktopikInput, em_lokerUncheckedUpdateWithoutEm_loktopikInput>
  }

  export type em_lokerUpdateWithoutEm_loktopikInput = {
    possid?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobdesc?: NullableStringFieldUpdateOperationsInput | string | null
    qualify?: NullableStringFieldUpdateOperationsInput | string | null
    worktype?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    contrtype?: NullableStringFieldUpdateOperationsInput | string | null
    posslevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_lokerUncheckedUpdateWithoutEm_loktopikInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    possid?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobdesc?: NullableStringFieldUpdateOperationsInput | string | null
    qualify?: NullableStringFieldUpdateOperationsInput | string | null
    worktype?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    contrtype?: NullableStringFieldUpdateOperationsInput | string | null
    posslevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_examsUpsertWithoutEm_loktopikInput = {
    update: XOR<em_examsUpdateWithoutEm_loktopikInput, em_examsUncheckedUpdateWithoutEm_loktopikInput>
    create: XOR<em_examsCreateWithoutEm_loktopikInput, em_examsUncheckedCreateWithoutEm_loktopikInput>
    where?: em_examsWhereInput
  }

  export type em_examsUpdateToOneWithWhereWithoutEm_loktopikInput = {
    where?: em_examsWhereInput
    data: XOR<em_examsUpdateWithoutEm_loktopikInput, em_examsUncheckedUpdateWithoutEm_loktopikInput>
  }

  export type em_examsUpdateWithoutEm_loktopikInput = {
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
    scores?: scoresUpdateManyWithoutEm_examsNestedInput
  }

  export type em_examsUncheckedUpdateWithoutEm_loktopikInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
    scores?: scoresUncheckedUpdateManyWithoutEm_examsNestedInput
  }

  export type em_materi1CreateWithoutEm_materi_fileInput = {
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
    em_materi2?: em_materi2CreateNestedManyWithoutEm_materi1Input
  }

  export type em_materi1UncheckedCreateWithoutEm_materi_fileInput = {
    id?: number
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
    em_materi2?: em_materi2UncheckedCreateNestedManyWithoutEm_materi1Input
  }

  export type em_materi1CreateOrConnectWithoutEm_materi_fileInput = {
    where: em_materi1WhereUniqueInput
    create: XOR<em_materi1CreateWithoutEm_materi_fileInput, em_materi1UncheckedCreateWithoutEm_materi_fileInput>
  }

  export type em_materi1UpsertWithoutEm_materi_fileInput = {
    update: XOR<em_materi1UpdateWithoutEm_materi_fileInput, em_materi1UncheckedUpdateWithoutEm_materi_fileInput>
    create: XOR<em_materi1CreateWithoutEm_materi_fileInput, em_materi1UncheckedCreateWithoutEm_materi_fileInput>
    where?: em_materi1WhereInput
  }

  export type em_materi1UpdateToOneWithWhereWithoutEm_materi_fileInput = {
    where?: em_materi1WhereInput
    data: XOR<em_materi1UpdateWithoutEm_materi_fileInput, em_materi1UncheckedUpdateWithoutEm_materi_fileInput>
  }

  export type em_materi1UpdateWithoutEm_materi_fileInput = {
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi2?: em_materi2UpdateManyWithoutEm_materi1NestedInput
  }

  export type em_materi1UncheckedUpdateWithoutEm_materi_fileInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi2?: em_materi2UncheckedUpdateManyWithoutEm_materi1NestedInput
  }

  export type em_materi2CreateWithoutEm_materi_typeInput = {
    em_materi1: em_materi1CreateNestedOneWithoutEm_materi2Input
  }

  export type em_materi2UncheckedCreateWithoutEm_materi_typeInput = {
    id?: number
    materi_id: number
  }

  export type em_materi2CreateOrConnectWithoutEm_materi_typeInput = {
    where: em_materi2WhereUniqueInput
    create: XOR<em_materi2CreateWithoutEm_materi_typeInput, em_materi2UncheckedCreateWithoutEm_materi_typeInput>
  }

  export type em_materi2CreateManyEm_materi_typeInputEnvelope = {
    data: em_materi2CreateManyEm_materi_typeInput | em_materi2CreateManyEm_materi_typeInput[]
  }

  export type em_materi2UpsertWithWhereUniqueWithoutEm_materi_typeInput = {
    where: em_materi2WhereUniqueInput
    update: XOR<em_materi2UpdateWithoutEm_materi_typeInput, em_materi2UncheckedUpdateWithoutEm_materi_typeInput>
    create: XOR<em_materi2CreateWithoutEm_materi_typeInput, em_materi2UncheckedCreateWithoutEm_materi_typeInput>
  }

  export type em_materi2UpdateWithWhereUniqueWithoutEm_materi_typeInput = {
    where: em_materi2WhereUniqueInput
    data: XOR<em_materi2UpdateWithoutEm_materi_typeInput, em_materi2UncheckedUpdateWithoutEm_materi_typeInput>
  }

  export type em_materi2UpdateManyWithWhereWithoutEm_materi_typeInput = {
    where: em_materi2ScalarWhereInput
    data: XOR<em_materi2UpdateManyMutationInput, em_materi2UncheckedUpdateManyWithoutEm_materi_typeInput>
  }

  export type em_materi2ScalarWhereInput = {
    AND?: em_materi2ScalarWhereInput | em_materi2ScalarWhereInput[]
    OR?: em_materi2ScalarWhereInput[]
    NOT?: em_materi2ScalarWhereInput | em_materi2ScalarWhereInput[]
    id?: IntFilter<"em_materi2"> | number
    materi_id?: IntFilter<"em_materi2"> | number
    materi_type?: IntFilter<"em_materi2"> | number
  }

  export type em_materi_fileCreateWithoutEm_materi1Input = {
    file_name: string
    file_type: number
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    judul?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    galeri_id?: number | null
  }

  export type em_materi_fileUncheckedCreateWithoutEm_materi1Input = {
    id?: number
    file_name: string
    file_type: number
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    judul?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    galeri_id?: number | null
  }

  export type em_materi_fileCreateOrConnectWithoutEm_materi1Input = {
    where: em_materi_fileWhereUniqueInput
    create: XOR<em_materi_fileCreateWithoutEm_materi1Input, em_materi_fileUncheckedCreateWithoutEm_materi1Input>
  }

  export type em_materi_fileCreateManyEm_materi1InputEnvelope = {
    data: em_materi_fileCreateManyEm_materi1Input | em_materi_fileCreateManyEm_materi1Input[]
  }

  export type em_materi2CreateWithoutEm_materi1Input = {
    em_materi_type: em_materi_typeCreateNestedOneWithoutEm_materi2Input
  }

  export type em_materi2UncheckedCreateWithoutEm_materi1Input = {
    id?: number
    materi_type: number
  }

  export type em_materi2CreateOrConnectWithoutEm_materi1Input = {
    where: em_materi2WhereUniqueInput
    create: XOR<em_materi2CreateWithoutEm_materi1Input, em_materi2UncheckedCreateWithoutEm_materi1Input>
  }

  export type em_materi2CreateManyEm_materi1InputEnvelope = {
    data: em_materi2CreateManyEm_materi1Input | em_materi2CreateManyEm_materi1Input[]
  }

  export type em_materi_fileUpsertWithWhereUniqueWithoutEm_materi1Input = {
    where: em_materi_fileWhereUniqueInput
    update: XOR<em_materi_fileUpdateWithoutEm_materi1Input, em_materi_fileUncheckedUpdateWithoutEm_materi1Input>
    create: XOR<em_materi_fileCreateWithoutEm_materi1Input, em_materi_fileUncheckedCreateWithoutEm_materi1Input>
  }

  export type em_materi_fileUpdateWithWhereUniqueWithoutEm_materi1Input = {
    where: em_materi_fileWhereUniqueInput
    data: XOR<em_materi_fileUpdateWithoutEm_materi1Input, em_materi_fileUncheckedUpdateWithoutEm_materi1Input>
  }

  export type em_materi_fileUpdateManyWithWhereWithoutEm_materi1Input = {
    where: em_materi_fileScalarWhereInput
    data: XOR<em_materi_fileUpdateManyMutationInput, em_materi_fileUncheckedUpdateManyWithoutEm_materi1Input>
  }

  export type em_materi_fileScalarWhereInput = {
    AND?: em_materi_fileScalarWhereInput | em_materi_fileScalarWhereInput[]
    OR?: em_materi_fileScalarWhereInput[]
    NOT?: em_materi_fileScalarWhereInput | em_materi_fileScalarWhereInput[]
    id?: IntFilter<"em_materi_file"> | number
    materi_id?: IntFilter<"em_materi_file"> | number
    file_name?: StringFilter<"em_materi_file"> | string
    file_type?: IntFilter<"em_materi_file"> | number
    file_size?: FloatNullableFilter<"em_materi_file"> | number | null
    url?: StringNullableFilter<"em_materi_file"> | string | null
    urutan?: IntNullableFilter<"em_materi_file"> | number | null
    judul?: StringNullableFilter<"em_materi_file"> | string | null
    created_at?: DateTimeNullableFilter<"em_materi_file"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"em_materi_file"> | Date | string | null
    galeri_id?: IntNullableFilter<"em_materi_file"> | number | null
  }

  export type em_materi2UpsertWithWhereUniqueWithoutEm_materi1Input = {
    where: em_materi2WhereUniqueInput
    update: XOR<em_materi2UpdateWithoutEm_materi1Input, em_materi2UncheckedUpdateWithoutEm_materi1Input>
    create: XOR<em_materi2CreateWithoutEm_materi1Input, em_materi2UncheckedCreateWithoutEm_materi1Input>
  }

  export type em_materi2UpdateWithWhereUniqueWithoutEm_materi1Input = {
    where: em_materi2WhereUniqueInput
    data: XOR<em_materi2UpdateWithoutEm_materi1Input, em_materi2UncheckedUpdateWithoutEm_materi1Input>
  }

  export type em_materi2UpdateManyWithWhereWithoutEm_materi1Input = {
    where: em_materi2ScalarWhereInput
    data: XOR<em_materi2UpdateManyMutationInput, em_materi2UncheckedUpdateManyWithoutEm_materi1Input>
  }

  export type em_materi_typeCreateWithoutEm_materi2Input = {
    materi_name: string
    deskripsi?: string | null
    status?: string | null
    created_at: Date | string
    created_by?: string | null
    lastupdate?: Date | string | null
  }

  export type em_materi_typeUncheckedCreateWithoutEm_materi2Input = {
    id?: number
    materi_name: string
    deskripsi?: string | null
    status?: string | null
    created_at: Date | string
    created_by?: string | null
    lastupdate?: Date | string | null
  }

  export type em_materi_typeCreateOrConnectWithoutEm_materi2Input = {
    where: em_materi_typeWhereUniqueInput
    create: XOR<em_materi_typeCreateWithoutEm_materi2Input, em_materi_typeUncheckedCreateWithoutEm_materi2Input>
  }

  export type em_materi1CreateWithoutEm_materi2Input = {
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
    em_materi_file?: em_materi_fileCreateNestedManyWithoutEm_materi1Input
  }

  export type em_materi1UncheckedCreateWithoutEm_materi2Input = {
    id?: number
    kode_materi: string
    judul_materi: string
    deskripsi_materi?: string | null
    kategori?: number | null
    urutan: number
    is_required: boolean
    status?: string | null
    created_by?: string | null
    created_at: Date | string
    lastupdate?: Date | string | null
    em_materi_file?: em_materi_fileUncheckedCreateNestedManyWithoutEm_materi1Input
  }

  export type em_materi1CreateOrConnectWithoutEm_materi2Input = {
    where: em_materi1WhereUniqueInput
    create: XOR<em_materi1CreateWithoutEm_materi2Input, em_materi1UncheckedCreateWithoutEm_materi2Input>
  }

  export type em_materi_typeUpsertWithoutEm_materi2Input = {
    update: XOR<em_materi_typeUpdateWithoutEm_materi2Input, em_materi_typeUncheckedUpdateWithoutEm_materi2Input>
    create: XOR<em_materi_typeCreateWithoutEm_materi2Input, em_materi_typeUncheckedCreateWithoutEm_materi2Input>
    where?: em_materi_typeWhereInput
  }

  export type em_materi_typeUpdateToOneWithWhereWithoutEm_materi2Input = {
    where?: em_materi_typeWhereInput
    data: XOR<em_materi_typeUpdateWithoutEm_materi2Input, em_materi_typeUncheckedUpdateWithoutEm_materi2Input>
  }

  export type em_materi_typeUpdateWithoutEm_materi2Input = {
    materi_name?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi_typeUncheckedUpdateWithoutEm_materi2Input = {
    id?: IntFieldUpdateOperationsInput | number
    materi_name?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_materi1UpsertWithoutEm_materi2Input = {
    update: XOR<em_materi1UpdateWithoutEm_materi2Input, em_materi1UncheckedUpdateWithoutEm_materi2Input>
    create: XOR<em_materi1CreateWithoutEm_materi2Input, em_materi1UncheckedCreateWithoutEm_materi2Input>
    where?: em_materi1WhereInput
  }

  export type em_materi1UpdateToOneWithWhereWithoutEm_materi2Input = {
    where?: em_materi1WhereInput
    data: XOR<em_materi1UpdateWithoutEm_materi2Input, em_materi1UncheckedUpdateWithoutEm_materi2Input>
  }

  export type em_materi1UpdateWithoutEm_materi2Input = {
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi_file?: em_materi_fileUpdateManyWithoutEm_materi1NestedInput
  }

  export type em_materi1UncheckedUpdateWithoutEm_materi2Input = {
    id?: IntFieldUpdateOperationsInput | number
    kode_materi?: StringFieldUpdateOperationsInput | string
    judul_materi?: StringFieldUpdateOperationsInput | string
    deskripsi_materi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_materi_file?: em_materi_fileUncheckedUpdateManyWithoutEm_materi1NestedInput
  }

  export type em_questions2CreateWithoutEm_questions1Input = {
    Id?: bigint | number
    option_choices: string
    option_text: string
  }

  export type em_questions2UncheckedCreateWithoutEm_questions1Input = {
    Id?: bigint | number
    option_choices: string
    option_text: string
  }

  export type em_questions2CreateOrConnectWithoutEm_questions1Input = {
    where: em_questions2WhereUniqueInput
    create: XOR<em_questions2CreateWithoutEm_questions1Input, em_questions2UncheckedCreateWithoutEm_questions1Input>
  }

  export type em_questions2CreateManyEm_questions1InputEnvelope = {
    data: em_questions2CreateManyEm_questions1Input | em_questions2CreateManyEm_questions1Input[]
  }

  export type em_questions2UpsertWithWhereUniqueWithoutEm_questions1Input = {
    where: em_questions2WhereUniqueInput
    update: XOR<em_questions2UpdateWithoutEm_questions1Input, em_questions2UncheckedUpdateWithoutEm_questions1Input>
    create: XOR<em_questions2CreateWithoutEm_questions1Input, em_questions2UncheckedCreateWithoutEm_questions1Input>
  }

  export type em_questions2UpdateWithWhereUniqueWithoutEm_questions1Input = {
    where: em_questions2WhereUniqueInput
    data: XOR<em_questions2UpdateWithoutEm_questions1Input, em_questions2UncheckedUpdateWithoutEm_questions1Input>
  }

  export type em_questions2UpdateManyWithWhereWithoutEm_questions1Input = {
    where: em_questions2ScalarWhereInput
    data: XOR<em_questions2UpdateManyMutationInput, em_questions2UncheckedUpdateManyWithoutEm_questions1Input>
  }

  export type em_questions2ScalarWhereInput = {
    AND?: em_questions2ScalarWhereInput | em_questions2ScalarWhereInput[]
    OR?: em_questions2ScalarWhereInput[]
    NOT?: em_questions2ScalarWhereInput | em_questions2ScalarWhereInput[]
    Id?: BigIntFilter<"em_questions2"> | bigint | number
    question_id?: IntFilter<"em_questions2"> | number
    option_choices?: StringFilter<"em_questions2"> | string
    option_text?: StringFilter<"em_questions2"> | string
  }

  export type em_questions1CreateWithoutEm_questions2Input = {
    question_text: string
    question_type?: number | null
    correct_answer?: string | null
    correct_answer2?: string | null
    exam_id?: number | null
    time_limit: number
    score: number
    status?: string | null
    userid?: string | null
    qdate?: Date | string | null
    lastupdate?: Date | string | null
    fileimage?: string | null
    isExams?: string | null
    isLevel?: number | null
  }

  export type em_questions1UncheckedCreateWithoutEm_questions2Input = {
    id?: number
    question_text: string
    question_type?: number | null
    correct_answer?: string | null
    correct_answer2?: string | null
    exam_id?: number | null
    time_limit: number
    score: number
    status?: string | null
    userid?: string | null
    qdate?: Date | string | null
    lastupdate?: Date | string | null
    fileimage?: string | null
    isExams?: string | null
    isLevel?: number | null
  }

  export type em_questions1CreateOrConnectWithoutEm_questions2Input = {
    where: em_questions1WhereUniqueInput
    create: XOR<em_questions1CreateWithoutEm_questions2Input, em_questions1UncheckedCreateWithoutEm_questions2Input>
  }

  export type em_questions1UpsertWithoutEm_questions2Input = {
    update: XOR<em_questions1UpdateWithoutEm_questions2Input, em_questions1UncheckedUpdateWithoutEm_questions2Input>
    create: XOR<em_questions1CreateWithoutEm_questions2Input, em_questions1UncheckedCreateWithoutEm_questions2Input>
    where?: em_questions1WhereInput
  }

  export type em_questions1UpdateToOneWithWhereWithoutEm_questions2Input = {
    where?: em_questions1WhereInput
    data: XOR<em_questions1UpdateWithoutEm_questions2Input, em_questions1UncheckedUpdateWithoutEm_questions2Input>
  }

  export type em_questions1UpdateWithoutEm_questions2Input = {
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableIntFieldUpdateOperationsInput | number | null
    correct_answer?: NullableStringFieldUpdateOperationsInput | string | null
    correct_answer2?: NullableStringFieldUpdateOperationsInput | string | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    time_limit?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    qdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    isExams?: NullableStringFieldUpdateOperationsInput | string | null
    isLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_questions1UncheckedUpdateWithoutEm_questions2Input = {
    id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableIntFieldUpdateOperationsInput | number | null
    correct_answer?: NullableStringFieldUpdateOperationsInput | string | null
    correct_answer2?: NullableStringFieldUpdateOperationsInput | string | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    time_limit?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    qdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileimage?: NullableStringFieldUpdateOperationsInput | string | null
    isExams?: NullableStringFieldUpdateOperationsInput | string | null
    isLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule2CreateWithoutEm_schedule1Input = {
    employeeId?: number | null
    Regid?: string | null
    is_send_wa_stats?: number | null
    send_date?: Date | string | null
    is_code_send?: string | null
  }

  export type em_schedule2UncheckedCreateWithoutEm_schedule1Input = {
    Id?: number
    employeeId?: number | null
    Regid?: string | null
    is_send_wa_stats?: number | null
    send_date?: Date | string | null
    is_code_send?: string | null
  }

  export type em_schedule2CreateOrConnectWithoutEm_schedule1Input = {
    where: em_schedule2WhereUniqueInput
    create: XOR<em_schedule2CreateWithoutEm_schedule1Input, em_schedule2UncheckedCreateWithoutEm_schedule1Input>
  }

  export type em_schedule2CreateManyEm_schedule1InputEnvelope = {
    data: em_schedule2CreateManyEm_schedule1Input | em_schedule2CreateManyEm_schedule1Input[]
  }

  export type em_schedule3CreateWithoutEm_schedule1Input = {
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
  }

  export type em_schedule3UncheckedCreateWithoutEm_schedule1Input = {
    Id?: number
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
  }

  export type em_schedule3CreateOrConnectWithoutEm_schedule1Input = {
    where: em_schedule3WhereUniqueInput
    create: XOR<em_schedule3CreateWithoutEm_schedule1Input, em_schedule3UncheckedCreateWithoutEm_schedule1Input>
  }

  export type em_schedule3CreateManyEm_schedule1InputEnvelope = {
    data: em_schedule3CreateManyEm_schedule1Input | em_schedule3CreateManyEm_schedule1Input[]
  }

  export type em_schedule4CreateWithoutEm_schedule1Input = {
    tipeSoal?: number | null
    jumlahSoal?: number | null
    durasiPerTipe?: number | null
  }

  export type em_schedule4UncheckedCreateWithoutEm_schedule1Input = {
    Id?: number
    tipeSoal?: number | null
    jumlahSoal?: number | null
    durasiPerTipe?: number | null
  }

  export type em_schedule4CreateOrConnectWithoutEm_schedule1Input = {
    where: em_schedule4WhereUniqueInput
    create: XOR<em_schedule4CreateWithoutEm_schedule1Input, em_schedule4UncheckedCreateWithoutEm_schedule1Input>
  }

  export type em_schedule4CreateManyEm_schedule1InputEnvelope = {
    data: em_schedule4CreateManyEm_schedule1Input | em_schedule4CreateManyEm_schedule1Input[]
  }

  export type em_schedule2UpsertWithWhereUniqueWithoutEm_schedule1Input = {
    where: em_schedule2WhereUniqueInput
    update: XOR<em_schedule2UpdateWithoutEm_schedule1Input, em_schedule2UncheckedUpdateWithoutEm_schedule1Input>
    create: XOR<em_schedule2CreateWithoutEm_schedule1Input, em_schedule2UncheckedCreateWithoutEm_schedule1Input>
  }

  export type em_schedule2UpdateWithWhereUniqueWithoutEm_schedule1Input = {
    where: em_schedule2WhereUniqueInput
    data: XOR<em_schedule2UpdateWithoutEm_schedule1Input, em_schedule2UncheckedUpdateWithoutEm_schedule1Input>
  }

  export type em_schedule2UpdateManyWithWhereWithoutEm_schedule1Input = {
    where: em_schedule2ScalarWhereInput
    data: XOR<em_schedule2UpdateManyMutationInput, em_schedule2UncheckedUpdateManyWithoutEm_schedule1Input>
  }

  export type em_schedule2ScalarWhereInput = {
    AND?: em_schedule2ScalarWhereInput | em_schedule2ScalarWhereInput[]
    OR?: em_schedule2ScalarWhereInput[]
    NOT?: em_schedule2ScalarWhereInput | em_schedule2ScalarWhereInput[]
    Id?: IntFilter<"em_schedule2"> | number
    scheduleId?: IntNullableFilter<"em_schedule2"> | number | null
    employeeId?: IntNullableFilter<"em_schedule2"> | number | null
    Regid?: StringNullableFilter<"em_schedule2"> | string | null
    is_send_wa_stats?: IntNullableFilter<"em_schedule2"> | number | null
    send_date?: DateTimeNullableFilter<"em_schedule2"> | Date | string | null
    is_code_send?: StringNullableFilter<"em_schedule2"> | string | null
  }

  export type em_schedule3UpsertWithWhereUniqueWithoutEm_schedule1Input = {
    where: em_schedule3WhereUniqueInput
    update: XOR<em_schedule3UpdateWithoutEm_schedule1Input, em_schedule3UncheckedUpdateWithoutEm_schedule1Input>
    create: XOR<em_schedule3CreateWithoutEm_schedule1Input, em_schedule3UncheckedCreateWithoutEm_schedule1Input>
  }

  export type em_schedule3UpdateWithWhereUniqueWithoutEm_schedule1Input = {
    where: em_schedule3WhereUniqueInput
    data: XOR<em_schedule3UpdateWithoutEm_schedule1Input, em_schedule3UncheckedUpdateWithoutEm_schedule1Input>
  }

  export type em_schedule3UpdateManyWithWhereWithoutEm_schedule1Input = {
    where: em_schedule3ScalarWhereInput
    data: XOR<em_schedule3UpdateManyMutationInput, em_schedule3UncheckedUpdateManyWithoutEm_schedule1Input>
  }

  export type em_schedule3ScalarWhereInput = {
    AND?: em_schedule3ScalarWhereInput | em_schedule3ScalarWhereInput[]
    OR?: em_schedule3ScalarWhereInput[]
    NOT?: em_schedule3ScalarWhereInput | em_schedule3ScalarWhereInput[]
    Id?: IntFilter<"em_schedule3"> | number
    scheduleId?: IntFilter<"em_schedule3"> | number
    soalId?: IntFilter<"em_schedule3"> | number
    urutanSoal?: IntFilter<"em_schedule3"> | number
    materiId?: IntFilter<"em_schedule3"> | number
    urutanTipeSoal?: IntFilter<"em_schedule3"> | number
    tipeSoal?: IntFilter<"em_schedule3"> | number
  }

  export type em_schedule4UpsertWithWhereUniqueWithoutEm_schedule1Input = {
    where: em_schedule4WhereUniqueInput
    update: XOR<em_schedule4UpdateWithoutEm_schedule1Input, em_schedule4UncheckedUpdateWithoutEm_schedule1Input>
    create: XOR<em_schedule4CreateWithoutEm_schedule1Input, em_schedule4UncheckedCreateWithoutEm_schedule1Input>
  }

  export type em_schedule4UpdateWithWhereUniqueWithoutEm_schedule1Input = {
    where: em_schedule4WhereUniqueInput
    data: XOR<em_schedule4UpdateWithoutEm_schedule1Input, em_schedule4UncheckedUpdateWithoutEm_schedule1Input>
  }

  export type em_schedule4UpdateManyWithWhereWithoutEm_schedule1Input = {
    where: em_schedule4ScalarWhereInput
    data: XOR<em_schedule4UpdateManyMutationInput, em_schedule4UncheckedUpdateManyWithoutEm_schedule1Input>
  }

  export type em_schedule4ScalarWhereInput = {
    AND?: em_schedule4ScalarWhereInput | em_schedule4ScalarWhereInput[]
    OR?: em_schedule4ScalarWhereInput[]
    NOT?: em_schedule4ScalarWhereInput | em_schedule4ScalarWhereInput[]
    Id?: IntFilter<"em_schedule4"> | number
    scheduleId?: IntNullableFilter<"em_schedule4"> | number | null
    tipeSoal?: IntNullableFilter<"em_schedule4"> | number | null
    jumlahSoal?: FloatNullableFilter<"em_schedule4"> | number | null
    durasiPerTipe?: IntNullableFilter<"em_schedule4"> | number | null
  }

  export type em_schedule1CreateWithoutEm_schedule2Input = {
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule3?: em_schedule3CreateNestedManyWithoutEm_schedule1Input
    em_schedule4?: em_schedule4CreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1UncheckedCreateWithoutEm_schedule2Input = {
    Id?: number
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule3?: em_schedule3UncheckedCreateNestedManyWithoutEm_schedule1Input
    em_schedule4?: em_schedule4UncheckedCreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1CreateOrConnectWithoutEm_schedule2Input = {
    where: em_schedule1WhereUniqueInput
    create: XOR<em_schedule1CreateWithoutEm_schedule2Input, em_schedule1UncheckedCreateWithoutEm_schedule2Input>
  }

  export type em_schedule1UpsertWithoutEm_schedule2Input = {
    update: XOR<em_schedule1UpdateWithoutEm_schedule2Input, em_schedule1UncheckedUpdateWithoutEm_schedule2Input>
    create: XOR<em_schedule1CreateWithoutEm_schedule2Input, em_schedule1UncheckedCreateWithoutEm_schedule2Input>
    where?: em_schedule1WhereInput
  }

  export type em_schedule1UpdateToOneWithWhereWithoutEm_schedule2Input = {
    where?: em_schedule1WhereInput
    data: XOR<em_schedule1UpdateWithoutEm_schedule2Input, em_schedule1UncheckedUpdateWithoutEm_schedule2Input>
  }

  export type em_schedule1UpdateWithoutEm_schedule2Input = {
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule3?: em_schedule3UpdateManyWithoutEm_schedule1NestedInput
    em_schedule4?: em_schedule4UpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1UncheckedUpdateWithoutEm_schedule2Input = {
    Id?: IntFieldUpdateOperationsInput | number
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule3?: em_schedule3UncheckedUpdateManyWithoutEm_schedule1NestedInput
    em_schedule4?: em_schedule4UncheckedUpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1CreateWithoutEm_schedule3Input = {
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule2?: em_schedule2CreateNestedManyWithoutEm_schedule1Input
    em_schedule4?: em_schedule4CreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1UncheckedCreateWithoutEm_schedule3Input = {
    Id?: number
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule2?: em_schedule2UncheckedCreateNestedManyWithoutEm_schedule1Input
    em_schedule4?: em_schedule4UncheckedCreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1CreateOrConnectWithoutEm_schedule3Input = {
    where: em_schedule1WhereUniqueInput
    create: XOR<em_schedule1CreateWithoutEm_schedule3Input, em_schedule1UncheckedCreateWithoutEm_schedule3Input>
  }

  export type em_schedule1UpsertWithoutEm_schedule3Input = {
    update: XOR<em_schedule1UpdateWithoutEm_schedule3Input, em_schedule1UncheckedUpdateWithoutEm_schedule3Input>
    create: XOR<em_schedule1CreateWithoutEm_schedule3Input, em_schedule1UncheckedCreateWithoutEm_schedule3Input>
    where?: em_schedule1WhereInput
  }

  export type em_schedule1UpdateToOneWithWhereWithoutEm_schedule3Input = {
    where?: em_schedule1WhereInput
    data: XOR<em_schedule1UpdateWithoutEm_schedule3Input, em_schedule1UncheckedUpdateWithoutEm_schedule3Input>
  }

  export type em_schedule1UpdateWithoutEm_schedule3Input = {
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule2?: em_schedule2UpdateManyWithoutEm_schedule1NestedInput
    em_schedule4?: em_schedule4UpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1UncheckedUpdateWithoutEm_schedule3Input = {
    Id?: IntFieldUpdateOperationsInput | number
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule2?: em_schedule2UncheckedUpdateManyWithoutEm_schedule1NestedInput
    em_schedule4?: em_schedule4UncheckedUpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1CreateWithoutEm_schedule4Input = {
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule2?: em_schedule2CreateNestedManyWithoutEm_schedule1Input
    em_schedule3?: em_schedule3CreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1UncheckedCreateWithoutEm_schedule4Input = {
    Id?: number
    scheName?: string | null
    scheDeskripsi?: string | null
    isMateri?: number | null
    isQuota?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    isLokasi?: string | null
    isTrainer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    sendWA?: number | null
    ujian_stats?: string | null
    is_with_soal?: string | null
    usr_by?: string | null
    is_wa_template?: number | null
    is_batch?: string | null
    event_id?: number | null
    em_schedule2?: em_schedule2UncheckedCreateNestedManyWithoutEm_schedule1Input
    em_schedule3?: em_schedule3UncheckedCreateNestedManyWithoutEm_schedule1Input
  }

  export type em_schedule1CreateOrConnectWithoutEm_schedule4Input = {
    where: em_schedule1WhereUniqueInput
    create: XOR<em_schedule1CreateWithoutEm_schedule4Input, em_schedule1UncheckedCreateWithoutEm_schedule4Input>
  }

  export type em_schedule1UpsertWithoutEm_schedule4Input = {
    update: XOR<em_schedule1UpdateWithoutEm_schedule4Input, em_schedule1UncheckedUpdateWithoutEm_schedule4Input>
    create: XOR<em_schedule1CreateWithoutEm_schedule4Input, em_schedule1UncheckedCreateWithoutEm_schedule4Input>
    where?: em_schedule1WhereInput
  }

  export type em_schedule1UpdateToOneWithWhereWithoutEm_schedule4Input = {
    where?: em_schedule1WhereInput
    data: XOR<em_schedule1UpdateWithoutEm_schedule4Input, em_schedule1UncheckedUpdateWithoutEm_schedule4Input>
  }

  export type em_schedule1UpdateWithoutEm_schedule4Input = {
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule2?: em_schedule2UpdateManyWithoutEm_schedule1NestedInput
    em_schedule3?: em_schedule3UpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_schedule1UncheckedUpdateWithoutEm_schedule4Input = {
    Id?: IntFieldUpdateOperationsInput | number
    scheName?: NullableStringFieldUpdateOperationsInput | string | null
    scheDeskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    isMateri?: NullableIntFieldUpdateOperationsInput | number | null
    isQuota?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isLokasi?: NullableStringFieldUpdateOperationsInput | string | null
    isTrainer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendWA?: NullableIntFieldUpdateOperationsInput | number | null
    ujian_stats?: NullableStringFieldUpdateOperationsInput | string | null
    is_with_soal?: NullableStringFieldUpdateOperationsInput | string | null
    usr_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_wa_template?: NullableIntFieldUpdateOperationsInput | number | null
    is_batch?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: NullableIntFieldUpdateOperationsInput | number | null
    em_schedule2?: em_schedule2UncheckedUpdateManyWithoutEm_schedule1NestedInput
    em_schedule3?: em_schedule3UncheckedUpdateManyWithoutEm_schedule1NestedInput
  }

  export type em_jawaban_pesertaCreateWithoutEm_session_examsInput = {
    Id?: number
    empl_id: number
    soal_id: number
    jawaban?: string | null
    jawaban2?: string | null
    waktu_jawab?: Date | string | null
    Score?: number | null
    is_correction?: number | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput = {
    Id?: number
    empl_id: number
    soal_id: number
    jawaban?: string | null
    jawaban2?: string | null
    waktu_jawab?: Date | string | null
    Score?: number | null
    is_correction?: number | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_pesertaCreateOrConnectWithoutEm_session_examsInput = {
    where: em_jawaban_pesertaWhereUniqueInput
    create: XOR<em_jawaban_pesertaCreateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput>
  }

  export type em_jawaban_pesertaCreateManyEm_session_examsInputEnvelope = {
    data: em_jawaban_pesertaCreateManyEm_session_examsInput | em_jawaban_pesertaCreateManyEm_session_examsInput[]
  }

  export type em_jawaban_pesertaUpsertWithWhereUniqueWithoutEm_session_examsInput = {
    where: em_jawaban_pesertaWhereUniqueInput
    update: XOR<em_jawaban_pesertaUpdateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedUpdateWithoutEm_session_examsInput>
    create: XOR<em_jawaban_pesertaCreateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedCreateWithoutEm_session_examsInput>
  }

  export type em_jawaban_pesertaUpdateWithWhereUniqueWithoutEm_session_examsInput = {
    where: em_jawaban_pesertaWhereUniqueInput
    data: XOR<em_jawaban_pesertaUpdateWithoutEm_session_examsInput, em_jawaban_pesertaUncheckedUpdateWithoutEm_session_examsInput>
  }

  export type em_jawaban_pesertaUpdateManyWithWhereWithoutEm_session_examsInput = {
    where: em_jawaban_pesertaScalarWhereInput
    data: XOR<em_jawaban_pesertaUpdateManyMutationInput, em_jawaban_pesertaUncheckedUpdateManyWithoutEm_session_examsInput>
  }

  export type em_jawaban_pesertaScalarWhereInput = {
    AND?: em_jawaban_pesertaScalarWhereInput | em_jawaban_pesertaScalarWhereInput[]
    OR?: em_jawaban_pesertaScalarWhereInput[]
    NOT?: em_jawaban_pesertaScalarWhereInput | em_jawaban_pesertaScalarWhereInput[]
    Id?: IntFilter<"em_jawaban_peserta"> | number
    empl_id?: IntFilter<"em_jawaban_peserta"> | number
    soal_id?: IntFilter<"em_jawaban_peserta"> | number
    session_exams_id?: StringFilter<"em_jawaban_peserta"> | string
    jawaban?: StringNullableFilter<"em_jawaban_peserta"> | string | null
    jawaban2?: StringNullableFilter<"em_jawaban_peserta"> | string | null
    waktu_jawab?: DateTimeNullableFilter<"em_jawaban_peserta"> | Date | string | null
    Score?: FloatNullableFilter<"em_jawaban_peserta"> | number | null
    is_correction?: IntNullableFilter<"em_jawaban_peserta"> | number | null
    is_train_jawaban?: BoolNullableFilter<"em_jawaban_peserta"> | boolean | null
  }

  export type em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput = {
    apc_id: number
    soal_id: number
    topic_id: number
    jawaban_option?: string | null
    jawaban_text?: string | null
    waktu_jawab?: Date | string | null
    score?: number | null
    is_correction?: boolean | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput = {
    Id?: number
    apc_id: number
    soal_id: number
    topic_id: number
    jawaban_option?: string | null
    jawaban_text?: string | null
    waktu_jawab?: Date | string | null
    score?: number | null
    is_correction?: boolean | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_peserta_apcCreateOrConnectWithoutEm_session_exams_apcInput = {
    where: em_jawaban_peserta_apcWhereUniqueInput
    create: XOR<em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput>
  }

  export type em_jawaban_peserta_apcCreateManyEm_session_exams_apcInputEnvelope = {
    data: em_jawaban_peserta_apcCreateManyEm_session_exams_apcInput | em_jawaban_peserta_apcCreateManyEm_session_exams_apcInput[]
  }

  export type em_topic_selesaiCreateWithoutEm_session_exams_apcInput = {
    apc_id: number
    topic_id: number
    selesai_at?: Date | string | null
  }

  export type em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput = {
    id?: number
    apc_id: number
    topic_id: number
    selesai_at?: Date | string | null
  }

  export type em_topic_selesaiCreateOrConnectWithoutEm_session_exams_apcInput = {
    where: em_topic_selesaiWhereUniqueInput
    create: XOR<em_topic_selesaiCreateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput>
  }

  export type em_topic_selesaiCreateManyEm_session_exams_apcInputEnvelope = {
    data: em_topic_selesaiCreateManyEm_session_exams_apcInput | em_topic_selesaiCreateManyEm_session_exams_apcInput[]
  }

  export type em_jawaban_peserta_apcUpsertWithWhereUniqueWithoutEm_session_exams_apcInput = {
    where: em_jawaban_peserta_apcWhereUniqueInput
    update: XOR<em_jawaban_peserta_apcUpdateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedUpdateWithoutEm_session_exams_apcInput>
    create: XOR<em_jawaban_peserta_apcCreateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedCreateWithoutEm_session_exams_apcInput>
  }

  export type em_jawaban_peserta_apcUpdateWithWhereUniqueWithoutEm_session_exams_apcInput = {
    where: em_jawaban_peserta_apcWhereUniqueInput
    data: XOR<em_jawaban_peserta_apcUpdateWithoutEm_session_exams_apcInput, em_jawaban_peserta_apcUncheckedUpdateWithoutEm_session_exams_apcInput>
  }

  export type em_jawaban_peserta_apcUpdateManyWithWhereWithoutEm_session_exams_apcInput = {
    where: em_jawaban_peserta_apcScalarWhereInput
    data: XOR<em_jawaban_peserta_apcUpdateManyMutationInput, em_jawaban_peserta_apcUncheckedUpdateManyWithoutEm_session_exams_apcInput>
  }

  export type em_jawaban_peserta_apcScalarWhereInput = {
    AND?: em_jawaban_peserta_apcScalarWhereInput | em_jawaban_peserta_apcScalarWhereInput[]
    OR?: em_jawaban_peserta_apcScalarWhereInput[]
    NOT?: em_jawaban_peserta_apcScalarWhereInput | em_jawaban_peserta_apcScalarWhereInput[]
    Id?: IntFilter<"em_jawaban_peserta_apc"> | number
    apc_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    soal_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    topic_id?: IntFilter<"em_jawaban_peserta_apc"> | number
    session_exams_id?: StringFilter<"em_jawaban_peserta_apc"> | string
    jawaban_option?: StringNullableFilter<"em_jawaban_peserta_apc"> | string | null
    jawaban_text?: StringNullableFilter<"em_jawaban_peserta_apc"> | string | null
    waktu_jawab?: DateTimeNullableFilter<"em_jawaban_peserta_apc"> | Date | string | null
    score?: FloatNullableFilter<"em_jawaban_peserta_apc"> | number | null
    is_correction?: BoolNullableFilter<"em_jawaban_peserta_apc"> | boolean | null
    is_train_jawaban?: BoolNullableFilter<"em_jawaban_peserta_apc"> | boolean | null
  }

  export type em_topic_selesaiUpsertWithWhereUniqueWithoutEm_session_exams_apcInput = {
    where: em_topic_selesaiWhereUniqueInput
    update: XOR<em_topic_selesaiUpdateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedUpdateWithoutEm_session_exams_apcInput>
    create: XOR<em_topic_selesaiCreateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedCreateWithoutEm_session_exams_apcInput>
  }

  export type em_topic_selesaiUpdateWithWhereUniqueWithoutEm_session_exams_apcInput = {
    where: em_topic_selesaiWhereUniqueInput
    data: XOR<em_topic_selesaiUpdateWithoutEm_session_exams_apcInput, em_topic_selesaiUncheckedUpdateWithoutEm_session_exams_apcInput>
  }

  export type em_topic_selesaiUpdateManyWithWhereWithoutEm_session_exams_apcInput = {
    where: em_topic_selesaiScalarWhereInput
    data: XOR<em_topic_selesaiUpdateManyMutationInput, em_topic_selesaiUncheckedUpdateManyWithoutEm_session_exams_apcInput>
  }

  export type em_topic_selesaiScalarWhereInput = {
    AND?: em_topic_selesaiScalarWhereInput | em_topic_selesaiScalarWhereInput[]
    OR?: em_topic_selesaiScalarWhereInput[]
    NOT?: em_topic_selesaiScalarWhereInput | em_topic_selesaiScalarWhereInput[]
    id?: IntFilter<"em_topic_selesai"> | number
    session_exams_id?: StringFilter<"em_topic_selesai"> | string
    apc_id?: IntFilter<"em_topic_selesai"> | number
    topic_id?: IntFilter<"em_topic_selesai"> | number
    selesai_at?: DateTimeNullableFilter<"em_topic_selesai"> | Date | string | null
  }

  export type em_session_exams_apcCreateWithoutEm_topic_selesaiInput = {
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcCreateNestedManyWithoutEm_session_exams_apcInput
  }

  export type em_session_exams_apcUncheckedCreateWithoutEm_topic_selesaiInput = {
    Id?: number
    lokerid: number
    exams_id: string
    apcid: number
    soal_urut?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_selesai?: string | null
    is_token?: string | null
    is_token_expr?: Date | string | null
    durasi?: number | null
    is_correct?: number | null
    is_notes?: string | null
    is_score_akhir?: number | null
    curr_topic_index?: number | null
    curr_soal_index?: number | null
    is_intro_topic?: boolean | null
    is_jawaban_kosong?: number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcUncheckedCreateNestedManyWithoutEm_session_exams_apcInput
  }

  export type em_session_exams_apcCreateOrConnectWithoutEm_topic_selesaiInput = {
    where: em_session_exams_apcWhereUniqueInput
    create: XOR<em_session_exams_apcCreateWithoutEm_topic_selesaiInput, em_session_exams_apcUncheckedCreateWithoutEm_topic_selesaiInput>
  }

  export type em_session_exams_apcUpsertWithoutEm_topic_selesaiInput = {
    update: XOR<em_session_exams_apcUpdateWithoutEm_topic_selesaiInput, em_session_exams_apcUncheckedUpdateWithoutEm_topic_selesaiInput>
    create: XOR<em_session_exams_apcCreateWithoutEm_topic_selesaiInput, em_session_exams_apcUncheckedCreateWithoutEm_topic_selesaiInput>
    where?: em_session_exams_apcWhereInput
  }

  export type em_session_exams_apcUpdateToOneWithWhereWithoutEm_topic_selesaiInput = {
    where?: em_session_exams_apcWhereInput
    data: XOR<em_session_exams_apcUpdateWithoutEm_topic_selesaiInput, em_session_exams_apcUncheckedUpdateWithoutEm_topic_selesaiInput>
  }

  export type em_session_exams_apcUpdateWithoutEm_topic_selesaiInput = {
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcUpdateManyWithoutEm_session_exams_apcNestedInput
  }

  export type em_session_exams_apcUncheckedUpdateWithoutEm_topic_selesaiInput = {
    Id?: IntFieldUpdateOperationsInput | number
    lokerid?: IntFieldUpdateOperationsInput | number
    exams_id?: StringFieldUpdateOperationsInput | string
    apcid?: IntFieldUpdateOperationsInput | number
    soal_urut?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_selesai?: NullableStringFieldUpdateOperationsInput | string | null
    is_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_token_expr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durasi?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: NullableIntFieldUpdateOperationsInput | number | null
    is_notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_score_akhir?: NullableFloatFieldUpdateOperationsInput | number | null
    curr_topic_index?: NullableIntFieldUpdateOperationsInput | number | null
    curr_soal_index?: NullableIntFieldUpdateOperationsInput | number | null
    is_intro_topic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_jawaban_kosong?: NullableIntFieldUpdateOperationsInput | number | null
    em_jawaban_peserta_apc?: em_jawaban_peserta_apcUncheckedUpdateManyWithoutEm_session_exams_apcNestedInput
  }

  export type scoresCreateWithoutEmappInput = {
    total_score: number
    created_at?: Date | string | null
    em_exams: em_examsCreateNestedOneWithoutScoresInput
  }

  export type scoresUncheckedCreateWithoutEmappInput = {
    id?: number
    exam_id: number
    total_score: number
    created_at?: Date | string | null
  }

  export type scoresCreateOrConnectWithoutEmappInput = {
    where: scoresWhereUniqueInput
    create: XOR<scoresCreateWithoutEmappInput, scoresUncheckedCreateWithoutEmappInput>
  }

  export type scoresCreateManyEmappInputEnvelope = {
    data: scoresCreateManyEmappInput | scoresCreateManyEmappInput[]
  }

  export type scoresUpsertWithWhereUniqueWithoutEmappInput = {
    where: scoresWhereUniqueInput
    update: XOR<scoresUpdateWithoutEmappInput, scoresUncheckedUpdateWithoutEmappInput>
    create: XOR<scoresCreateWithoutEmappInput, scoresUncheckedCreateWithoutEmappInput>
  }

  export type scoresUpdateWithWhereUniqueWithoutEmappInput = {
    where: scoresWhereUniqueInput
    data: XOR<scoresUpdateWithoutEmappInput, scoresUncheckedUpdateWithoutEmappInput>
  }

  export type scoresUpdateManyWithWhereWithoutEmappInput = {
    where: scoresScalarWhereInput
    data: XOR<scoresUpdateManyMutationInput, scoresUncheckedUpdateManyWithoutEmappInput>
  }

  export type em_applicant_criteriaCreateWithoutEmpossInput = {
    jenis_kriteria?: string | null
    value?: string | null
    value_en?: string | null
    bobot?: number | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_applicant_criteriaUncheckedCreateWithoutEmpossInput = {
    id_kriteria?: number
    jenis_kriteria?: string | null
    value?: string | null
    value_en?: string | null
    bobot?: number | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_applicant_criteriaCreateOrConnectWithoutEmpossInput = {
    where: em_applicant_criteriaWhereUniqueInput
    create: XOR<em_applicant_criteriaCreateWithoutEmpossInput, em_applicant_criteriaUncheckedCreateWithoutEmpossInput>
  }

  export type em_applicant_criteriaCreateManyEmpossInputEnvelope = {
    data: em_applicant_criteriaCreateManyEmpossInput | em_applicant_criteriaCreateManyEmpossInput[]
  }

  export type em_applicant_matchCreateWithoutEmpossInput = {
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
    em_apc_personal: em_apc_personalCreateNestedOneWithoutEm_applicant_matchInput
  }

  export type em_applicant_matchUncheckedCreateWithoutEmpossInput = {
    id_match?: number
    id_applicant: number
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
  }

  export type em_applicant_matchCreateOrConnectWithoutEmpossInput = {
    where: em_applicant_matchWhereUniqueInput
    create: XOR<em_applicant_matchCreateWithoutEmpossInput, em_applicant_matchUncheckedCreateWithoutEmpossInput>
  }

  export type em_applicant_matchCreateManyEmpossInputEnvelope = {
    data: em_applicant_matchCreateManyEmpossInput | em_applicant_matchCreateManyEmpossInput[]
  }

  export type em_applicant_criteriaUpsertWithWhereUniqueWithoutEmpossInput = {
    where: em_applicant_criteriaWhereUniqueInput
    update: XOR<em_applicant_criteriaUpdateWithoutEmpossInput, em_applicant_criteriaUncheckedUpdateWithoutEmpossInput>
    create: XOR<em_applicant_criteriaCreateWithoutEmpossInput, em_applicant_criteriaUncheckedCreateWithoutEmpossInput>
  }

  export type em_applicant_criteriaUpdateWithWhereUniqueWithoutEmpossInput = {
    where: em_applicant_criteriaWhereUniqueInput
    data: XOR<em_applicant_criteriaUpdateWithoutEmpossInput, em_applicant_criteriaUncheckedUpdateWithoutEmpossInput>
  }

  export type em_applicant_criteriaUpdateManyWithWhereWithoutEmpossInput = {
    where: em_applicant_criteriaScalarWhereInput
    data: XOR<em_applicant_criteriaUpdateManyMutationInput, em_applicant_criteriaUncheckedUpdateManyWithoutEmpossInput>
  }

  export type em_applicant_criteriaScalarWhereInput = {
    AND?: em_applicant_criteriaScalarWhereInput | em_applicant_criteriaScalarWhereInput[]
    OR?: em_applicant_criteriaScalarWhereInput[]
    NOT?: em_applicant_criteriaScalarWhereInput | em_applicant_criteriaScalarWhereInput[]
    id_kriteria?: IntFilter<"em_applicant_criteria"> | number
    id_loker?: IntFilter<"em_applicant_criteria"> | number
    jenis_kriteria?: StringNullableFilter<"em_applicant_criteria"> | string | null
    value?: StringNullableFilter<"em_applicant_criteria"> | string | null
    value_en?: StringNullableFilter<"em_applicant_criteria"> | string | null
    bobot?: FloatNullableFilter<"em_applicant_criteria"> | number | null
    created_at?: DateTimeNullableFilter<"em_applicant_criteria"> | Date | string | null
    lastupdate?: DateTimeNullableFilter<"em_applicant_criteria"> | Date | string | null
  }

  export type em_applicant_matchUpsertWithWhereUniqueWithoutEmpossInput = {
    where: em_applicant_matchWhereUniqueInput
    update: XOR<em_applicant_matchUpdateWithoutEmpossInput, em_applicant_matchUncheckedUpdateWithoutEmpossInput>
    create: XOR<em_applicant_matchCreateWithoutEmpossInput, em_applicant_matchUncheckedCreateWithoutEmpossInput>
  }

  export type em_applicant_matchUpdateWithWhereUniqueWithoutEmpossInput = {
    where: em_applicant_matchWhereUniqueInput
    data: XOR<em_applicant_matchUpdateWithoutEmpossInput, em_applicant_matchUncheckedUpdateWithoutEmpossInput>
  }

  export type em_applicant_matchUpdateManyWithWhereWithoutEmpossInput = {
    where: em_applicant_matchScalarWhereInput
    data: XOR<em_applicant_matchUpdateManyMutationInput, em_applicant_matchUncheckedUpdateManyWithoutEmpossInput>
  }

  export type em_examsCreateWithoutScoresInput = {
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
    em_loktopik?: em_loktopikCreateNestedManyWithoutEm_examsInput
  }

  export type em_examsUncheckedCreateWithoutScoresInput = {
    id?: number
    exam_name: string
    UserId?: string | null
    Status?: string | null
    LastUpdate?: Date | string | null
    Deskripsi?: string | null
    FileImage?: string | null
    CatType?: string | null
    em_loktopik?: em_loktopikUncheckedCreateNestedManyWithoutEm_examsInput
  }

  export type em_examsCreateOrConnectWithoutScoresInput = {
    where: em_examsWhereUniqueInput
    create: XOR<em_examsCreateWithoutScoresInput, em_examsUncheckedCreateWithoutScoresInput>
  }

  export type emappCreateWithoutScoresInput = {
    AppName?: string | null
    AppPoss?: number | null
    AppWa?: string | null
    AppMail?: string | null
    AppAge?: number | null
    AppJk?: number | null
    AppAddres?: string | null
    AppFakt?: string | null
    AppFileName?: string | null
    AppLastUpdate?: Date | string | null
    AppDate?: Date | string | null
    AppStatus?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    JobsIs?: string | null
    JFStats?: string | null
    LokasiId?: number | null
  }

  export type emappUncheckedCreateWithoutScoresInput = {
    AppId?: number
    AppName?: string | null
    AppPoss?: number | null
    AppWa?: string | null
    AppMail?: string | null
    AppAge?: number | null
    AppJk?: number | null
    AppAddres?: string | null
    AppFakt?: string | null
    AppFileName?: string | null
    AppLastUpdate?: Date | string | null
    AppDate?: Date | string | null
    AppStatus?: string | null
    IsCall?: number | null
    DateCall?: Date | string | null
    JobsIs?: string | null
    JFStats?: string | null
    LokasiId?: number | null
  }

  export type emappCreateOrConnectWithoutScoresInput = {
    where: emappWhereUniqueInput
    create: XOR<emappCreateWithoutScoresInput, emappUncheckedCreateWithoutScoresInput>
  }

  export type em_examsUpsertWithoutScoresInput = {
    update: XOR<em_examsUpdateWithoutScoresInput, em_examsUncheckedUpdateWithoutScoresInput>
    create: XOR<em_examsCreateWithoutScoresInput, em_examsUncheckedCreateWithoutScoresInput>
    where?: em_examsWhereInput
  }

  export type em_examsUpdateToOneWithWhereWithoutScoresInput = {
    where?: em_examsWhereInput
    data: XOR<em_examsUpdateWithoutScoresInput, em_examsUncheckedUpdateWithoutScoresInput>
  }

  export type em_examsUpdateWithoutScoresInput = {
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
    em_loktopik?: em_loktopikUpdateManyWithoutEm_examsNestedInput
  }

  export type em_examsUncheckedUpdateWithoutScoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_name?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    LastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    FileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CatType?: NullableStringFieldUpdateOperationsInput | string | null
    em_loktopik?: em_loktopikUncheckedUpdateManyWithoutEm_examsNestedInput
  }

  export type emappUpsertWithoutScoresInput = {
    update: XOR<emappUpdateWithoutScoresInput, emappUncheckedUpdateWithoutScoresInput>
    create: XOR<emappCreateWithoutScoresInput, emappUncheckedCreateWithoutScoresInput>
    where?: emappWhereInput
  }

  export type emappUpdateToOneWithWhereWithoutScoresInput = {
    where?: emappWhereInput
    data: XOR<emappUpdateWithoutScoresInput, emappUncheckedUpdateWithoutScoresInput>
  }

  export type emappUpdateWithoutScoresInput = {
    AppName?: NullableStringFieldUpdateOperationsInput | string | null
    AppPoss?: NullableIntFieldUpdateOperationsInput | number | null
    AppWa?: NullableStringFieldUpdateOperationsInput | string | null
    AppMail?: NullableStringFieldUpdateOperationsInput | string | null
    AppAge?: NullableIntFieldUpdateOperationsInput | number | null
    AppJk?: NullableIntFieldUpdateOperationsInput | number | null
    AppAddres?: NullableStringFieldUpdateOperationsInput | string | null
    AppFakt?: NullableStringFieldUpdateOperationsInput | string | null
    AppFileName?: NullableStringFieldUpdateOperationsInput | string | null
    AppLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppStatus?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobsIs?: NullableStringFieldUpdateOperationsInput | string | null
    JFStats?: NullableStringFieldUpdateOperationsInput | string | null
    LokasiId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type emappUncheckedUpdateWithoutScoresInput = {
    AppId?: IntFieldUpdateOperationsInput | number
    AppName?: NullableStringFieldUpdateOperationsInput | string | null
    AppPoss?: NullableIntFieldUpdateOperationsInput | number | null
    AppWa?: NullableStringFieldUpdateOperationsInput | string | null
    AppMail?: NullableStringFieldUpdateOperationsInput | string | null
    AppAge?: NullableIntFieldUpdateOperationsInput | number | null
    AppJk?: NullableIntFieldUpdateOperationsInput | number | null
    AppAddres?: NullableStringFieldUpdateOperationsInput | string | null
    AppFakt?: NullableStringFieldUpdateOperationsInput | string | null
    AppFileName?: NullableStringFieldUpdateOperationsInput | string | null
    AppLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AppStatus?: NullableStringFieldUpdateOperationsInput | string | null
    IsCall?: NullableIntFieldUpdateOperationsInput | number | null
    DateCall?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobsIs?: NullableStringFieldUpdateOperationsInput | string | null
    JFStats?: NullableStringFieldUpdateOperationsInput | string | null
    LokasiId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_apc_academyCreateManyEm_apc_personalInput = {
    SchoolName?: string | null
    Province?: string | null
    Major?: string | null
    Degree?: string | null
    EnrollDate?: Date | string | null
    GraduatDate?: Date | string | null
    IPK?: number | null
    OrganizeExperience?: string | null
    Explain?: string | null
    GradeSchool?: string | null
    DailySchedule?: string | null
    SchoolAddress?: string | null
  }

  export type em_apc_photographCreateManyEm_apc_personalInput = {
    GenrName?: string | null
  }

  export type em_apc_regulationCreateManyEm_apc_personalInput = {
    RegId?: number | null
    RegChoice?: boolean | null
  }

  export type em_apc_skill_experCreateManyEm_apc_personalInput = {
    CompanyName?: string | null
    Province?: string | null
    JobTitle?: string | null
    Salary?: number | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Responsibilities?: string | null
    CareerGoals?: string | null
    WhyJoin?: string | null
    IsFriend?: string | null
    IsMentions?: string | null
    IsCompProgram?: string | null
    IsIllnes?: string | null
    HaveCriminal?: string | null
    WhenWork?: string | null
    ExpectedSalary?: number | null
    isContribution?: string | null
    isDuration?: string | null
    isAgency?: string | null
    isExprn?: string | null
    isGenre?: string | null
    isRelevan?: string | null
    isSpesialSkill?: string | null
    isShoot?: string | null
    isSchedl?: string | null
    isMotivation?: string | null
    isStress?: string | null
    isLongExpr?: string | null
    isPhotTools?: string | null
    isChalleng?: string | null
    isThreeYears?: string | null
    PersonVal?: string | null
  }

  export type em_applicant_matchCreateManyEm_apc_personalInput = {
    id_loker: number
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
  }

  export type em_apc_academyUpdateWithoutEm_apc_personalInput = {
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_academyUncheckedUpdateWithoutEm_apc_personalInput = {
    AcademyId?: IntFieldUpdateOperationsInput | number
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_academyUncheckedUpdateManyWithoutEm_apc_personalInput = {
    AcademyId?: IntFieldUpdateOperationsInput | number
    SchoolName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Major?: NullableStringFieldUpdateOperationsInput | string | null
    Degree?: NullableStringFieldUpdateOperationsInput | string | null
    EnrollDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GraduatDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IPK?: NullableFloatFieldUpdateOperationsInput | number | null
    OrganizeExperience?: NullableStringFieldUpdateOperationsInput | string | null
    Explain?: NullableStringFieldUpdateOperationsInput | string | null
    GradeSchool?: NullableStringFieldUpdateOperationsInput | string | null
    DailySchedule?: NullableStringFieldUpdateOperationsInput | string | null
    SchoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_photographUpdateWithoutEm_apc_personalInput = {
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_photographUncheckedUpdateWithoutEm_apc_personalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_photographUncheckedUpdateManyWithoutEm_apc_personalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    GenrName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_regulationUpdateWithoutEm_apc_personalInput = {
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_apc_regulationUncheckedUpdateWithoutEm_apc_personalInput = {
    ApcRegId?: IntFieldUpdateOperationsInput | number
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_apc_regulationUncheckedUpdateManyWithoutEm_apc_personalInput = {
    ApcRegId?: IntFieldUpdateOperationsInput | number
    RegId?: NullableIntFieldUpdateOperationsInput | number | null
    RegChoice?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_apc_skill_experUpdateWithoutEm_apc_personalInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_skill_experUncheckedUpdateWithoutEm_apc_personalInput = {
    SkillId?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_apc_skill_experUncheckedUpdateManyWithoutEm_apc_personalInput = {
    SkillId?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    CareerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    WhyJoin?: NullableStringFieldUpdateOperationsInput | string | null
    IsFriend?: NullableStringFieldUpdateOperationsInput | string | null
    IsMentions?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompProgram?: NullableStringFieldUpdateOperationsInput | string | null
    IsIllnes?: NullableStringFieldUpdateOperationsInput | string | null
    HaveCriminal?: NullableStringFieldUpdateOperationsInput | string | null
    WhenWork?: NullableStringFieldUpdateOperationsInput | string | null
    ExpectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isDuration?: NullableStringFieldUpdateOperationsInput | string | null
    isAgency?: NullableStringFieldUpdateOperationsInput | string | null
    isExprn?: NullableStringFieldUpdateOperationsInput | string | null
    isGenre?: NullableStringFieldUpdateOperationsInput | string | null
    isRelevan?: NullableStringFieldUpdateOperationsInput | string | null
    isSpesialSkill?: NullableStringFieldUpdateOperationsInput | string | null
    isShoot?: NullableStringFieldUpdateOperationsInput | string | null
    isSchedl?: NullableStringFieldUpdateOperationsInput | string | null
    isMotivation?: NullableStringFieldUpdateOperationsInput | string | null
    isStress?: NullableStringFieldUpdateOperationsInput | string | null
    isLongExpr?: NullableStringFieldUpdateOperationsInput | string | null
    isPhotTools?: NullableStringFieldUpdateOperationsInput | string | null
    isChalleng?: NullableStringFieldUpdateOperationsInput | string | null
    isThreeYears?: NullableStringFieldUpdateOperationsInput | string | null
    PersonVal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_applicant_matchUpdateWithoutEm_apc_personalInput = {
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emposs?: empossUpdateOneRequiredWithoutEm_applicant_matchNestedInput
  }

  export type em_applicant_matchUncheckedUpdateWithoutEm_apc_personalInput = {
    id_match?: IntFieldUpdateOperationsInput | number
    id_loker?: IntFieldUpdateOperationsInput | number
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_matchUncheckedUpdateManyWithoutEm_apc_personalInput = {
    id_match?: IntFieldUpdateOperationsInput | number
    id_loker?: IntFieldUpdateOperationsInput | number
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_fieldsCreateManyEm_certificate_templatesInput = {
    is_text: string
    is_left: number
    is_top: number
    text_width: number
    text_height: number
    font_size: number
    align: string
    font_family: string
    font_style?: string | null
    font_weight?: string | null
    font_color?: string | null
    created_date?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_certificate_fieldsUpdateWithoutEm_certificate_templatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_fieldsUncheckedUpdateWithoutEm_certificate_templatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_certificate_fieldsUncheckedUpdateManyWithoutEm_certificate_templatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_text?: StringFieldUpdateOperationsInput | string
    is_left?: FloatFieldUpdateOperationsInput | number
    is_top?: FloatFieldUpdateOperationsInput | number
    text_width?: FloatFieldUpdateOperationsInput | number
    text_height?: FloatFieldUpdateOperationsInput | number
    font_size?: IntFieldUpdateOperationsInput | number
    align?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    font_style?: NullableStringFieldUpdateOperationsInput | string | null
    font_weight?: NullableStringFieldUpdateOperationsInput | string | null
    font_color?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_event2CreateManyEm_eventInput = {
    event_name?: string | null
    status?: string | null
    qr_code?: string | null
  }

  export type em_event2UpdateWithoutEm_eventInput = {
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event2UncheckedUpdateWithoutEm_eventInput = {
    sess_id?: IntFieldUpdateOperationsInput | number
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_event2UncheckedUpdateManyWithoutEm_eventInput = {
    sess_id?: IntFieldUpdateOperationsInput | number
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_loktopikCreateManyEm_examsInput = {
    loker_id: number
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
  }

  export type scoresCreateManyEm_examsInput = {
    user_id: number
    total_score: number
    created_at?: Date | string | null
  }

  export type em_loktopikUpdateWithoutEm_examsInput = {
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    em_loker?: em_lokerUpdateOneRequiredWithoutEm_loktopikNestedInput
  }

  export type em_loktopikUncheckedUpdateWithoutEm_examsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loker_id?: IntFieldUpdateOperationsInput | number
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_loktopikUncheckedUpdateManyWithoutEm_examsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loker_id?: IntFieldUpdateOperationsInput | number
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scoresUpdateWithoutEm_examsInput = {
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emapp?: emappUpdateOneRequiredWithoutScoresNestedInput
  }

  export type scoresUncheckedUpdateWithoutEm_examsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scoresUncheckedUpdateManyWithoutEm_examsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_faqCreateManyEm_faq_catInput = {
    isquestions?: string | null
    isanswer?: string | null
    status?: string | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
    userid?: string | null
  }

  export type em_faqUpdateWithoutEm_faq_catInput = {
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_faqUncheckedUpdateWithoutEm_faq_catInput = {
    fqId?: IntFieldUpdateOperationsInput | number
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_faqUncheckedUpdateManyWithoutEm_faq_catInput = {
    fqId?: IntFieldUpdateOperationsInput | number
    isquestions?: NullableStringFieldUpdateOperationsInput | string | null
    isanswer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_loktopikCreateManyEm_lokerInput = {
    topik_id: number
    jmlh_soal: number
    created_at?: Date | string | null
    possid?: number | null
    urutan?: number | null
  }

  export type em_loktopikUpdateWithoutEm_lokerInput = {
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    em_exams?: em_examsUpdateOneRequiredWithoutEm_loktopikNestedInput
  }

  export type em_loktopikUncheckedUpdateWithoutEm_lokerInput = {
    id?: IntFieldUpdateOperationsInput | number
    topik_id?: IntFieldUpdateOperationsInput | number
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_loktopikUncheckedUpdateManyWithoutEm_lokerInput = {
    id?: IntFieldUpdateOperationsInput | number
    topik_id?: IntFieldUpdateOperationsInput | number
    jmlh_soal?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    possid?: NullableIntFieldUpdateOperationsInput | number | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi2CreateManyEm_materi_typeInput = {
    materi_id: number
  }

  export type em_materi2UpdateWithoutEm_materi_typeInput = {
    em_materi1?: em_materi1UpdateOneRequiredWithoutEm_materi2NestedInput
  }

  export type em_materi2UncheckedUpdateWithoutEm_materi_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_id?: IntFieldUpdateOperationsInput | number
  }

  export type em_materi2UncheckedUpdateManyWithoutEm_materi_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    materi_id?: IntFieldUpdateOperationsInput | number
  }

  export type em_materi_fileCreateManyEm_materi1Input = {
    file_name: string
    file_type: number
    file_size?: number | null
    url?: string | null
    urutan?: number | null
    judul?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    galeri_id?: number | null
  }

  export type em_materi2CreateManyEm_materi1Input = {
    materi_type: number
  }

  export type em_materi_fileUpdateWithoutEm_materi1Input = {
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi_fileUncheckedUpdateWithoutEm_materi1Input = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi_fileUncheckedUpdateManyWithoutEm_materi1Input = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: IntFieldUpdateOperationsInput | number
    file_size?: NullableFloatFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    urutan?: NullableIntFieldUpdateOperationsInput | number | null
    judul?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    galeri_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_materi2UpdateWithoutEm_materi1Input = {
    em_materi_type?: em_materi_typeUpdateOneRequiredWithoutEm_materi2NestedInput
  }

  export type em_materi2UncheckedUpdateWithoutEm_materi1Input = {
    id?: IntFieldUpdateOperationsInput | number
    materi_type?: IntFieldUpdateOperationsInput | number
  }

  export type em_materi2UncheckedUpdateManyWithoutEm_materi1Input = {
    id?: IntFieldUpdateOperationsInput | number
    materi_type?: IntFieldUpdateOperationsInput | number
  }

  export type em_questions2CreateManyEm_questions1Input = {
    option_choices: string
    option_text: string
  }

  export type em_questions2UpdateWithoutEm_questions1Input = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_questions2UncheckedUpdateWithoutEm_questions1Input = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_questions2UncheckedUpdateManyWithoutEm_questions1Input = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_choices?: StringFieldUpdateOperationsInput | string
    option_text?: StringFieldUpdateOperationsInput | string
  }

  export type em_schedule2CreateManyEm_schedule1Input = {
    employeeId?: number | null
    Regid?: string | null
    is_send_wa_stats?: number | null
    send_date?: Date | string | null
    is_code_send?: string | null
  }

  export type em_schedule3CreateManyEm_schedule1Input = {
    soalId: number
    urutanSoal: number
    materiId: number
    urutanTipeSoal: number
    tipeSoal: number
  }

  export type em_schedule4CreateManyEm_schedule1Input = {
    tipeSoal?: number | null
    jumlahSoal?: number | null
    durasiPerTipe?: number | null
  }

  export type em_schedule2UpdateWithoutEm_schedule1Input = {
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_schedule2UncheckedUpdateWithoutEm_schedule1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_schedule2UncheckedUpdateManyWithoutEm_schedule1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    Regid?: NullableStringFieldUpdateOperationsInput | string | null
    is_send_wa_stats?: NullableIntFieldUpdateOperationsInput | number | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_code_send?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type em_schedule3UpdateWithoutEm_schedule1Input = {
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
  }

  export type em_schedule3UncheckedUpdateWithoutEm_schedule1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
  }

  export type em_schedule3UncheckedUpdateManyWithoutEm_schedule1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    soalId?: IntFieldUpdateOperationsInput | number
    urutanSoal?: IntFieldUpdateOperationsInput | number
    materiId?: IntFieldUpdateOperationsInput | number
    urutanTipeSoal?: IntFieldUpdateOperationsInput | number
    tipeSoal?: IntFieldUpdateOperationsInput | number
  }

  export type em_schedule4UpdateWithoutEm_schedule1Input = {
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule4UncheckedUpdateWithoutEm_schedule1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_schedule4UncheckedUpdateManyWithoutEm_schedule1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    tipeSoal?: NullableIntFieldUpdateOperationsInput | number | null
    jumlahSoal?: NullableFloatFieldUpdateOperationsInput | number | null
    durasiPerTipe?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type em_jawaban_pesertaCreateManyEm_session_examsInput = {
    empl_id: number
    soal_id: number
    jawaban?: string | null
    jawaban2?: string | null
    waktu_jawab?: Date | string | null
    Score?: number | null
    is_correction?: number | null
    is_train_jawaban?: boolean | null
  }

  export type em_jawaban_pesertaUpdateWithoutEm_session_examsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_pesertaUncheckedUpdateWithoutEm_session_examsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_pesertaUncheckedUpdateManyWithoutEm_session_examsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    empl_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    jawaban?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban2?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableIntFieldUpdateOperationsInput | number | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_peserta_apcCreateManyEm_session_exams_apcInput = {
    apc_id: number
    soal_id: number
    topic_id: number
    jawaban_option?: string | null
    jawaban_text?: string | null
    waktu_jawab?: Date | string | null
    score?: number | null
    is_correction?: boolean | null
    is_train_jawaban?: boolean | null
  }

  export type em_topic_selesaiCreateManyEm_session_exams_apcInput = {
    apc_id: number
    topic_id: number
    selesai_at?: Date | string | null
  }

  export type em_jawaban_peserta_apcUpdateWithoutEm_session_exams_apcInput = {
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_peserta_apcUncheckedUpdateWithoutEm_session_exams_apcInput = {
    Id?: IntFieldUpdateOperationsInput | number
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_jawaban_peserta_apcUncheckedUpdateManyWithoutEm_session_exams_apcInput = {
    Id?: IntFieldUpdateOperationsInput | number
    apc_id?: IntFieldUpdateOperationsInput | number
    soal_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    jawaban_option?: NullableStringFieldUpdateOperationsInput | string | null
    jawaban_text?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_jawab?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    is_correction?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_train_jawaban?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type em_topic_selesaiUpdateWithoutEm_session_exams_apcInput = {
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_topic_selesaiUncheckedUpdateWithoutEm_session_exams_apcInput = {
    id?: IntFieldUpdateOperationsInput | number
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_topic_selesaiUncheckedUpdateManyWithoutEm_session_exams_apcInput = {
    id?: IntFieldUpdateOperationsInput | number
    apc_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    selesai_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scoresCreateManyEmappInput = {
    exam_id: number
    total_score: number
    created_at?: Date | string | null
  }

  export type scoresUpdateWithoutEmappInput = {
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_exams?: em_examsUpdateOneRequiredWithoutScoresNestedInput
  }

  export type scoresUncheckedUpdateWithoutEmappInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: IntFieldUpdateOperationsInput | number
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scoresUncheckedUpdateManyWithoutEmappInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: IntFieldUpdateOperationsInput | number
    total_score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_criteriaCreateManyEmpossInput = {
    jenis_kriteria?: string | null
    value?: string | null
    value_en?: string | null
    bobot?: number | null
    created_at?: Date | string | null
    lastupdate?: Date | string | null
  }

  export type em_applicant_matchCreateManyEmpossInput = {
    id_applicant: number
    pendidikan_score?: number | null
    jurusan_score?: number | null
    pengalaman_score?: number | null
    skill_score?: number | null
    bahasa_score?: number | null
    usia_score?: number | null
    total_score?: number | null
    total_kriteria?: number | null
    scoring_json?: string | null
    created_at?: Date | string | null
  }

  export type em_applicant_criteriaUpdateWithoutEmpossInput = {
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_criteriaUncheckedUpdateWithoutEmpossInput = {
    id_kriteria?: IntFieldUpdateOperationsInput | number
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_criteriaUncheckedUpdateManyWithoutEmpossInput = {
    id_kriteria?: IntFieldUpdateOperationsInput | number
    jenis_kriteria?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    value_en?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastupdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_matchUpdateWithoutEmpossInput = {
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    em_apc_personal?: em_apc_personalUpdateOneRequiredWithoutEm_applicant_matchNestedInput
  }

  export type em_applicant_matchUncheckedUpdateWithoutEmpossInput = {
    id_match?: IntFieldUpdateOperationsInput | number
    id_applicant?: IntFieldUpdateOperationsInput | number
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type em_applicant_matchUncheckedUpdateManyWithoutEmpossInput = {
    id_match?: IntFieldUpdateOperationsInput | number
    id_applicant?: IntFieldUpdateOperationsInput | number
    pendidikan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    jurusan_score?: NullableFloatFieldUpdateOperationsInput | number | null
    pengalaman_score?: NullableFloatFieldUpdateOperationsInput | number | null
    skill_score?: NullableFloatFieldUpdateOperationsInput | number | null
    bahasa_score?: NullableFloatFieldUpdateOperationsInput | number | null
    usia_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_score?: NullableFloatFieldUpdateOperationsInput | number | null
    total_kriteria?: NullableIntFieldUpdateOperationsInput | number | null
    scoring_json?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}